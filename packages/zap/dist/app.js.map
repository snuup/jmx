{"version":3,"file":"app.js","sources":["../../jmx/jmx.ts","../lab.tsx"],"sourcesContent":["/// <reference path=\"./h.ts\" />\r\nimport { rebind } from './base'\r\nimport { Expr, FComponent, H, HComp, HCompClass, HElement, HFragment, IClassComponent, Props, UpdateContext } from 'h'\r\n\r\nconst enum NodeType { // vaporizes (but for that must be in this file, otherwise not)\r\n    TextNode = 3,\r\n}\r\n\r\nlet evaluate = <T>(expr: Expr<T>): T => expr instanceof Function ? expr() : expr\r\nlet removeexcesschildren = (n: Element, i: number) => { let c: ChildNode; while ((c = n.childNodes[i])) { c.remove() } }\r\nlet iswebcomponent = (h: HElement) => (h.tag as string).includes('-')\r\nlet isclasscomponent = (h: HComp): h is HCompClass => (h.tag as any)?.prototype?.view\r\nlet iselement = (h: any): h is HElement => typeof h.tag == \"string\"\r\nlet isfragment = (h: any): h is HFragment => { return h.tag == undefined && h.cn != undefined }\r\nlet isobject = (o: any): o is object => typeof o === \"object\"\r\n\r\nlet isproperty = (name: string, value: any) => (\r\n    ['value', 'checked', 'disabled', 'className', 'style', 'href', 'src', 'selected', 'readOnly', 'tabIndex',].includes(name)\r\n    || value instanceof Object\r\n    || value instanceof Function\r\n)\r\n\r\nlet setprops = (e: Element, newprops: Props = {}) => {\r\n    let oldprops = evaluate(e.h?.p) ?? {}\r\n    for (let p in oldprops) (!(p in newprops)) && isproperty(p, oldprops[p]) ? (e as any)[p] = null : e.removeAttribute(p)\r\n    for (let p in newprops) isproperty(p, newprops[p]) ? (e as any)[p] = newprops[p] : e.setAttribute(p, newprops[p])\r\n}\r\n\r\n/** syncs at position i of p. returns the number of the element past the last added element.\r\n * if no element was added (eg when h=null) then it returns i\r\n * if a fragment with 5 nodes was added, it returns i + 5\r\n * when a single element or component is added, it is i+1 since they always create exactly 1 node\r\n*/\r\nfunction sync(p: Element, i: number, h: Expr<H | undefined>, uc: UpdateContext): number {\r\n\r\n    // console.log('%csync', \"background:orange\", p.tagName, i, h, 'html = ' + document.body.outerHTML)\r\n\r\n    h = evaluate(h)\r\n    if (h === null || h === undefined) return i // skip this element. not that !!h would forbid to render the number 0 or the boolean value false\r\n\r\n    let c = p.childNodes[i] // is often null, eg during fresh creation\r\n\r\n    function synctextnode(text: string) {\r\n        if (c && c.nodeType == NodeType.TextNode) {\r\n            if (c.textContent != text) c.textContent = text// firefox updates even equal text, loosing an existing text selection\r\n        } else {\r\n            let tn = document.createTextNode(text)\r\n            c ? c.replaceWith(tn) : p.appendChild(tn)\r\n        }\r\n    }\r\n\r\n    if (isobject(h)) {\r\n\r\n        // element nodes\r\n\r\n        /** synchronizes children starting at the i-th element. returns the index of the last child synchronized */\r\n        function syncchildren(p: Element, h: HElement | HComp | HFragment, i: number): number {\r\n            evaluate(h.cn)?.flat().forEach(hc => i = sync(p, i, hc, uc))\r\n            return i\r\n        }\r\n\r\n        if (isfragment(h)) return syncchildren(p, h, i)\r\n\r\n        const props = evaluate(h.p)\r\n\r\n        if (iselement(h)) {\r\n\r\n            let n: Element\r\n\r\n            if ((<Element>c)?.tagName != h.tag) {\r\n                n = document.createElement(h.tag)\r\n                c ? c.replaceWith(n) : p.appendChild(n)\r\n                setprops(n, props)\r\n                props?.mounted?.(n)\r\n            } else {\r\n                n = c as Element\r\n                setprops(n, props)\r\n                if (props?.update?.(c, uc)) return i + 1\r\n            }\r\n            n.h = h\r\n\r\n            if (!uc.patchElementOnly && !iswebcomponent(h as HElement)) { // tbd: make \"island\" attribute\r\n                const j = syncchildren(n, h, 0)\r\n                removeexcesschildren(n, j)\r\n            }\r\n            return i + 1\r\n        }\r\n\r\n        switch (typeof h.tag) {\r\n\r\n            case 'function':\r\n\r\n                let isupdate = c?.h?.tag == h.tag\r\n\r\n                let ci: IClassComponent | undefined\r\n\r\n                if (isclasscomponent(h)) {\r\n                    h.i = ci = (c?.h as HCompClass)?.i ?? rebind(new h.tag(props))\r\n                    ci.props = props\r\n\r\n                    // if component instance returns truthy for update(), then syncing is susbstituted by the component\r\n                    if (isupdate && ci.update(uc)) return i + 1\r\n                }\r\n\r\n                // materialize the component\r\n                // we run compoents view() and fun code often, we do not compare properties to avoid their computation\r\n                // this means that the inner hr (h resolved) is run often\r\n                let hr = ci?.view() ?? (h.tag as FComponent)(props, evaluate(h.cn))\r\n\r\n                // a component can return undefined or null if it has no elements to show\r\n                if (hr === undefined || hr == null) return i\r\n\r\n                let j = sync(p, i, hr, uc)\r\n\r\n                let cn = p.childNodes[i]!\r\n                cn.h = h    // attach h onto the materialized component node\r\n\r\n                if (ci) ci.element = cn\r\n                if (!isupdate) ci?.mounted()\r\n\r\n                return j\r\n\r\n            case 'object':\r\n                return sync(p, i, h.tag, uc) // tbd: type of h is not correct, h.tag == never\r\n        }\r\n    }\r\n    // text nodes\r\n    synctextnode(h as string)\r\n    return i + 1\r\n}\r\n\r\nexport function patch(e: Node | null, h: Expr<H>, uc: UpdateContext = {}) {\r\n    if (!e) return\r\n    if (uc.replace) (e as HTMLElement).replaceChildren()\r\n    const p = e.parentElement as HTMLElement\r\n    const i = [].indexOf.call<any, any, any>(p.childNodes, e)\r\n    // always called deferred, because removing elements can trigger events and their handlers (like blur)\r\n    requestAnimationFrame(() => sync(p, i, h, uc))\r\n}\r\n\r\n\r\n// Overload signatures\r\ntype Selector = string | Node | undefined | null\r\ntype Selectors = Selector[]\r\n\r\nexport function updateview(uc: UpdateContext, ...selectors: Selectors): void;\r\nexport function updateview(...selectors: Selectors): void;\r\n\r\n// Implementation\r\nexport function updateview(...ucOrSelectors: (UpdateContext | Selector)[]): void {\r\n    {\r\n        let uc: UpdateContext\r\n\r\n        ucOrSelectors\r\n        .flatMap(x => (typeof x == 'string') ? [...document.querySelectorAll(x)] : (x instanceof Node) ? [x] : (uc = x!, []))\r\n        .forEach(e => {\r\n            if (!e?.h) throw 'jmx: no h exists on the node';\r\n            patch(e, e.h, uc)\r\n        })\r\n    }\r\n}\r\n\r\nexport function jsx(): HElement { throw 'jmx plugin not configured' } // dumy function for app code - jmx-plugin removes calls to this function, minifyer then removes it\r\nexport function jsxf(): HElement { throw 'jmx plugin not configured' } // dumy function for app code - jmx-plugin removes calls to this function, minifyer then removes it\r\n","import { jsx, jsxf } from \"jmx\"\r\n\r\nlet x = <>{1}{2}{3}</>\r\n// let x = jsx(jsxf, null, 1, 2, 3);\r\n\r\nconsole.log(x);\r\n"],"names":[],"mappings":"AAkKO,SAAS,GAAgB,GAAA;AAAE,EAAM,MAAA,2BAAA;AAA4B;;AChKpE,IAAI,CAAI,GAAA,GAAA,CAAW,CAAA;AAGnB,OAAA,CAAQ,IAAI,CAAC,CAAA"}