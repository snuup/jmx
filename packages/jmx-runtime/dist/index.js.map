{"version":3,"file":"index.js","sources":["../base.ts","../jmx.ts","../lib.ts","../h.ts"],"sourcesContent":["export function hopsi() {}\r\n\r\nexport function rebind(o: Record<string, any>, proto = Object.getPrototypeOf(o)) {\r\n    Object.entries(Object.getOwnPropertyDescriptors(proto))\r\n        .filter(([name, p]) => name != 'constructor' && p.value instanceof Function)\r\n        .forEach(([name]) => o[name] = o[name].bind(o))\r\n    return o\r\n}\r\n\r\nexport function mount(o: Record<string, any>) { Object.assign(globalThis, o) }\r\n\r\nexport const loggedmethodsex = <T extends Record<string, any>>(o: T, logger: (name: string, args: any[], result: any) => void) => new Proxy(o, {\r\n    get(target, name: string, receiver) {\r\n        if (typeof target[name] === \"function\") {\r\n            return function (this: T, ...args: any[]) {\r\n\r\n                logger(name, args, undefined)\r\n                let r = target[name].apply(this, args)\r\n                return r\r\n            }\r\n        }\r\n        return Reflect.get(target, name, receiver)\r\n    },\r\n})\r\n\r\nexport const loggedmethods = <T extends Record<string, any>>(o: T ): T => loggedmethodsex(o, (name, args, result) => console.log(\"%c\" + name, \"background:#585059;color:white;padding:2px;font-weight:bold\", args))\r\nexport const loggedmethodscolored = <T extends Record<string, any>>(bgcolor: string, o: T ): T => loggedmethodsex(o, (name, args, result) => console.log(\"%c\" + name, `background:${bgcolor};color:white;padding:2px;font-weight:bold`, args))\r\n","import { rebind } from './base'\r\nimport { Expr, FComponent, H, HComp, HCompClass, HElement, HFragment, IClassComponent, Props } from './h'\r\n\r\n// config\r\nexport function createElement(tag: string) {\r\n    let ns = window.jmx?.getnamespace?.(tag)\r\n    return ns ? document.createElementNS(ns, tag) : document.createElement(tag)\r\n}\r\n\r\nconst enum NodeType { // vaporizes (but for that must be in this file, otherwise not)\r\n    TextNode = 3,\r\n}\r\n\r\nlet evaluate = <T>(expr: Expr<T>): T => (expr instanceof Function ? expr() : expr)\r\nlet removeexcesschildren = (n: Element, i: number) => {\r\n    let c: ChildNode\r\n    while ((c = n.childNodes[i])) {\r\n        c.remove()\r\n    }\r\n}\r\nlet iswebcomponent = (h: HElement) => (h.tag as string).includes('-')\r\nlet isclasscomponent = (h: HComp): h is HCompClass => (h.tag as any)?.prototype?.view\r\nlet iselement = (h: any): h is HElement => typeof h.tag == 'string'\r\nlet isfragment = (h: any): h is HFragment => {\r\n    return h.tag == undefined && h.cn != undefined\r\n}\r\nlet isobject = (o: any): o is object => typeof o === 'object'\r\n\r\nlet isproperty = (name: string, value: any) =>\r\n    ['value', 'checked', 'disabled', 'className', 'style', 'href', 'src', 'selected', 'readOnly', 'tabIndex'].includes(\r\n        name\r\n    ) ||\r\n    value instanceof Object ||\r\n    value instanceof Function\r\n\r\nlet setprops = (e: Element, newprops: Props = {}) => {\r\n    let oldprops = evaluate(e.h?.p) ?? {}\r\n    for (let p in oldprops)\r\n        !(p in newprops) && isproperty(p, oldprops[p]) ? ((e as any)[p] = null) : e.removeAttribute(p)\r\n    for (let p in newprops) isproperty(p, newprops[p]) ? ((e as any)[p] = newprops[p]) : e.setAttribute(p, newprops[p])\r\n}\r\n\r\n/** syncs at position i of p. returns the number of the element past the last added element.\r\n * if no element was added (eg when h=null) then it returns i\r\n * if a fragment with 5 nodes was added, it returns i + 5\r\n * when a single element or component is added, it is i+1 since they always create exactly 1 node\r\n */\r\nfunction sync(p: Element, i: number, h: Expr<H | undefined>): number {\r\n    // console.log('%csync', \"background:orange\", p.tagName, i, h)\r\n\r\n    h = evaluate(h)\r\n    if (h === null || h === undefined) return i // skip this element. not that !!h would forbid to render the number 0 or the boolean value false\r\n\r\n    let c = p.childNodes[i] // is often null, eg during fresh creation\r\n\r\n    function synctextnode(text: string) {\r\n        if (c && c.nodeType == NodeType.TextNode) {\r\n            if (c.textContent != text) c.textContent = text // firefox updates even equal text, loosing an existing text selection\r\n        } else {\r\n            let tn = document.createTextNode(text)\r\n            c ? c.replaceWith(tn) : p.appendChild(tn)\r\n        }\r\n    }\r\n\r\n    if (isobject(h)) {\r\n        // element nodes\r\n\r\n        /** synchronizes children starting at the i-th element. returns the index of the last child synchronized */\r\n        function syncchildren(p: Element, h: HElement | HComp | HFragment, i: number): number {\r\n            evaluate(h.cn)\r\n                ?.flat()\r\n                .forEach(hc => (i = sync(p, i, hc)))\r\n            return i\r\n        }\r\n\r\n        if (isfragment(h)) return syncchildren(p, h, i)\r\n\r\n        const props = evaluate(h.p)\r\n\r\n        if (iselement(h)) {\r\n            let n: Element\r\n\r\n            if ((<Element>c)?.tagName?.toLowerCase() != h.tag.toLowerCase()) {\r\n                n = createElement(h.tag)\r\n                c ? c.replaceWith(n) : p.appendChild(n)\r\n                setprops(n, props)\r\n                props?.mounted?.(n)\r\n            } else {\r\n                n = c as Element\r\n                setprops(n, props)\r\n                if (props?.update?.(c, globaluc)) return i + 1\r\n            }\r\n\r\n            // if only components shall be updateable (advantage: close variables inside component functions are always fresh materialized, avoids surprises), comment this out\r\n            n.h = h\r\n\r\n            if (!globaluc.patchElementOnly && !iswebcomponent(h as HElement)) {\r\n                // tbd: make \"island\" attribute\r\n                const j = syncchildren(n, h, 0)\r\n                removeexcesschildren(n, j)\r\n            }\r\n            return i + 1\r\n        }\r\n\r\n        switch (typeof h.tag) {\r\n            case 'function':\r\n                let isupdate = c?.h?.tag == h.tag\r\n\r\n                let ci: IClassComponent | undefined\r\n\r\n                if (isclasscomponent(h)) {\r\n                    h.i = ci = (c?.h as HCompClass)?.i ?? rebind(new h.tag(props))\r\n                    ci.props = props\r\n\r\n                    // if component instance returns truthy for update(), then syncing is susbstituted by the component\r\n                    if (isupdate && ci.update(globaluc)) return i + 1\r\n                }\r\n\r\n                // materialize the component\r\n                // we run compoents view() and fun code often, we do not compare properties to avoid their computation\r\n                // this means that the inner hr (h resolved) is run often\r\n                //\r\n                // if ci has a view, return ci.view() even if it is falsy, this is perfectly valid\r\n                let hr = ci?.view ? ci?.view() : (h.tag as FComponent)(props, evaluate(h.cn))\r\n\r\n                // a component can return undefined or null if it has no elements to show\r\n                if (hr === undefined || hr == null) return i\r\n\r\n                let j = sync(p, i, hr)\r\n\r\n                let cn = p.childNodes[i]!\r\n                cn.h = h // attach h onto the materialized component node\r\n                // ;(cn as HTMLElement).setAttribute?.('comp', '')\r\n\r\n                if (ci) ci.element = cn\r\n                if (!isupdate) ci?.mounted?.()\r\n\r\n                return j\r\n\r\n            case 'object':\r\n                return sync(p, i, h.tag) // tbd: type of h is not correct, h.tag == never\r\n        }\r\n    }\r\n    // text nodes\r\n    synctextnode(h as string)\r\n    return i + 1\r\n}\r\n\r\nlet globaluc: IUpdateContext = {}\r\n\r\nexport function patch(e: Node | null, h: Expr<H>) {\r\n    if (!e) return\r\n    if (globaluc.replace) (e as HTMLElement).replaceChildren()\r\n    const p = e.parentElement as HTMLElement\r\n    const i = [].indexOf.call<any, any, any>(p.childNodes, e)\r\n    // always called deferred, because removing elements can trigger events and their handlers (like blur)\r\n    sync(p, i, h)\r\n}\r\n\r\n// Overload signatures\r\ntype Selector = string | Node | undefined | null\r\ntype Selectors = Selector[]\r\n\r\nexport function updateviewuc(uc: IUpdateContext, ...sels: Selectors): void {\r\n    {\r\n        globaluc = uc\r\n        updateviewinternal(...sels)\r\n    }\r\n}\r\nexport function updateview(...sels: Selectors): void {\r\n    {\r\n        globaluc = {}\r\n        updateviewinternal(...sels)\r\n    }\r\n}\r\n\r\nfunction updateviewinternal(...sels: Selector[]): void {\r\n    if (!sels.length) sels.push('body')\r\n    sels.flatMap(s => (typeof s == 'string' ? [...document.querySelectorAll(s)] : s ? [s] : [])).forEach(e => {\r\n        if (!e?.h) throw 'jmx: no h exists on the node'\r\n        patch(e, e.h)\r\n    })\r\n}\r\n","import { Props, IClassComponent, H, FComponentT, Children } from 'h'\r\nimport { updateview } from './jmx'\r\n\r\nexport type DeepReadonly<T> = { readonly [K in keyof T]: T[K] extends Record<string, unknown> ? DeepReadonly<T[K]> : T[K]; }\r\n\r\nexport const When = ({ cond }: { cond: boolean }, cn: Children) => cond ? { cn } : void 0;\r\n\r\nexport abstract class JMXComp<P extends Props = {}> implements IClassComponent {\r\n\r\n    // assigned by jmx framework\r\n    element!: HTMLElement\r\n\r\n    // we provide this ctor for jsx which uses ctor arguments as properties of class components.\r\n    // at runtime, we pass the props directly\r\n    constructor(public props: P) { }\r\n\r\n    // overrides\r\n    mounted() { }\r\n    update(uc?: IUpdateContext): boolean | void { }\r\n    abstract view(): H\r\n\r\n    // utility: updates the component's view\r\n    updateview() { updateview(this.element) }\r\n    get ismounted():boolean { return this.element as any }\r\n}\r\n\r\nexport function cc(...namesOrObjects: (string | any)[]): string {\r\n    return namesOrObjects.flatMap(n => (n.trim ? n : Object.keys(n).filter(k => n[k]))).join(' ') // n.trim distinguishes strings from objects\r\n}","// jmx internal types - hopst\r\n// the following types describe the js expression we get from tsx after conversion be our jmx plugin\r\n// they can be useful for users as well, components might return them.\r\n\r\ntype Func<T> = () => T\r\nexport type Expr<T> = T | Func<T>\r\n\r\nexport type Props = Record<string, any>\r\n\r\nexport type FComponent = (props: Props | undefined, children?: ChildrenH) => HElement // show an example for usage of children\r\n\r\nexport type FComponentT<P> = (pcn: P, cn?: Children) => H | void\r\n\r\nexport interface IClassComponent {\r\n    element: Node\r\n    props?: Record<string, any>\r\n    view(): H\r\n    update(uc: IUpdateContext): boolean | void\r\n    mounted?(): void\r\n}\r\n\r\ninterface CComponent {\r\n    new (props: any): IClassComponent // while a real component expresses its interface via props pass to the ctor, internally we assign props after construction with new()\r\n}\r\n\r\nexport type ChildrenH = (H | undefined)[]\r\nexport type Children = Expr<ChildrenH>\r\n\r\ntype HText =\r\n    | string // text node\r\n    | number // text node\r\n    | boolean // do not allow boolean, that\r\n\r\nexport type HFragment = {\r\n    cn: Children\r\n}\r\n\r\nexport type HElement = {\r\n    tag: string\r\n    p?: Expr<Props>\r\n    cn: Children\r\n    i?: any\r\n}\r\n\r\ntype HCompFun = {\r\n    tag: FComponent\r\n    p?: Expr<Props>\r\n    cn?: Children\r\n}\r\n\r\nexport type HCompClass = {\r\n    tag: CComponent\r\n    p?: Expr<Props>\r\n    cn: Children\r\n    i: IClassComponent\r\n}\r\n\r\nexport type HComp = HCompFun | HCompClass\r\n\r\nexport type H = // a hyperscript atom that describes a ...\r\n\r\n        | HText\r\n        | HElement // a tag, like p, div with attributes and children\r\n        | HComp // a dynamic component computing any other HNode\r\n        | HFragment\r\n\r\ndeclare global {\r\n    interface Node {\r\n        h?: HElement | HCompFun | HCompClass\r\n    }\r\n    export interface IUpdateContext {\r\n        patchElementOnly?: boolean\r\n        replace?: boolean\r\n    }\r\n\r\n    export interface Window {\r\n        jmx?: {\r\n            getnamespace: (tag: string) => string | undefined\r\n        }\r\n    }\r\n}\r\n\r\nexport function jsx(): HElement {\r\n    throw 'jmx plugin not configured'\r\n} // dumy function for app code - jmx-plugin removes calls to this function, minifyer then removes it\r\nexport function jsxf(): HElement {\r\n    throw 'jmx plugin not configured'\r\n} // dumy function for app code - jmx-plugin removes calls to this function, minifyer then removes it\r\n"],"names":[],"mappings":"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"}