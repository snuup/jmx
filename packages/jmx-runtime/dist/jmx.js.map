{"version":3,"file":"jmx.js","sourceRoot":"./","sources":["jmx.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,MAAM,EAAE,MAAM,QAAQ,CAAA;AAI/B,MAAM,UAAU,aAAa,CAAC,GAAW;IACrC,IAAI,EAAE,GAAG,MAAM,CAAC,GAAG,EAAE,YAAY,EAAE,CAAC,GAAG,CAAC,CAAA;IACxC,OAAO,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,eAAe,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,aAAa,CAAC,GAAG,CAAC,CAAA;AAC/E,CAAC;AAMD,IAAI,QAAQ,GAAG,CAAI,IAAa,EAAK,EAAE,CAAC,CAAC,IAAI,YAAY,QAAQ,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAA;AAClF,IAAI,oBAAoB,GAAG,CAAC,CAAU,EAAE,CAAS,EAAE,EAAE;IACjD,IAAI,CAAY,CAAA;IAChB,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;QAC3B,CAAC,CAAC,MAAM,EAAE,CAAA;IACd,CAAC;AACL,CAAC,CAAA;AACD,IAAI,cAAc,GAAG,CAAC,CAAW,EAAE,EAAE,CAAE,CAAC,CAAC,GAAc,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAA;AACrE,IAAI,gBAAgB,GAAG,CAAC,CAAQ,EAAmB,EAAE,CAAE,CAAC,CAAC,GAAW,EAAE,SAAS,EAAE,IAAI,CAAA;AACrF,IAAI,SAAS,GAAG,CAAC,CAAM,EAAiB,EAAE,CAAC,OAAO,CAAC,CAAC,GAAG,IAAI,QAAQ,CAAA;AACnE,IAAI,UAAU,GAAG,CAAC,CAAM,EAAkB,EAAE;IACxC,OAAO,CAAC,CAAC,GAAG,IAAI,SAAS,IAAI,CAAC,CAAC,EAAE,IAAI,SAAS,CAAA;AAClD,CAAC,CAAA;AACD,IAAI,QAAQ,GAAG,CAAC,CAAM,EAAe,EAAE,CAAC,OAAO,CAAC,KAAK,QAAQ,CAAA;AAE7D,IAAI,UAAU,GAAG,CAAC,IAAY,EAAE,KAAU,EAAE,EAAE,CAC1C,CAAC,OAAO,EAAE,SAAS,EAAE,UAAU,EAAE,WAAW,EAAE,OAAO,EAAE,MAAM,EAAE,KAAK,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,CAAC,CAAC,QAAQ,CAC9G,IAAI,CACP;IACD,KAAK,YAAY,MAAM;IACvB,KAAK,YAAY,QAAQ,CAAA;AAE7B,IAAI,QAAQ,GAAG,CAAC,CAAU,EAAE,WAAkB,EAAE,EAAE,EAAE;IAChD,IAAI,QAAQ,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE,CAAA;IACrC,KAAK,IAAI,CAAC,IAAI,QAAQ;QAClB,CAAC,CAAC,CAAC,IAAI,QAAQ,CAAC,IAAI,UAAU,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAE,CAAS,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,CAAA;IAClG,KAAK,IAAI,CAAC,IAAI,QAAQ;QAAE,UAAU,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAE,CAAS,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAA;AACvH,CAAC,CAAA;AAOD,SAAS,IAAI,CAAC,CAAU,EAAE,CAAS,EAAE,CAAsB;IAGvD,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAA;IACf,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,SAAS;QAAE,OAAO,CAAC,CAAA;IAE3C,IAAI,CAAC,GAAG,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA;IAEvB,SAAS,YAAY,CAAC,IAAY;QAC9B,IAAI,CAAC,IAAI,CAAC,CAAC,QAAQ,KAAqB,EAAE,CAAC;YACvC,IAAI,CAAC,CAAC,WAAW,IAAI,IAAI;gBAAE,CAAC,CAAC,WAAW,GAAG,IAAI,CAAA;QACnD,CAAC;aAAM,CAAC;YACJ,IAAI,EAAE,GAAG,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC,CAAA;YACtC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,EAAE,CAAC,CAAA;QAC7C,CAAC;IACL,CAAC;IAED,IAAI,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC;QAId,SAAS,YAAY,CAAC,CAAU,EAAE,CAA+B,EAAE,CAAS;YACxE,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC;gBACV,EAAE,IAAI,EAAE;iBACP,OAAO,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAA;YACxC,OAAO,CAAC,CAAA;QACZ,CAAC;QAED,IAAI,UAAU,CAAC,CAAC,CAAC;YAAE,OAAO,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAA;QAE/C,MAAM,KAAK,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAA;QAE3B,IAAI,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC;YACf,IAAI,CAAU,CAAA;YAEd,IAAc,CAAE,EAAE,OAAO,EAAE,WAAW,EAAE,IAAI,CAAC,CAAC,GAAG,CAAC,WAAW,EAAE,EAAE,CAAC;gBAC9D,CAAC,GAAG,aAAa,CAAC,CAAC,CAAC,GAAG,CAAC,CAAA;gBACxB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,CAAA;gBACvC,QAAQ,CAAC,CAAC,EAAE,KAAK,CAAC,CAAA;gBAClB,KAAK,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC,CAAA;YACvB,CAAC;iBAAM,CAAC;gBACJ,CAAC,GAAG,CAAY,CAAA;gBAChB,QAAQ,CAAC,CAAC,EAAE,KAAK,CAAC,CAAA;gBAClB,IAAI,KAAK,EAAE,MAAM,EAAE,CAAC,CAAC,EAAE,QAAQ,CAAC;oBAAE,OAAO,CAAC,GAAG,CAAC,CAAA;YAClD,CAAC;YAGD,CAAC,CAAC,CAAC,GAAG,CAAC,CAAA;YAEP,IAAI,CAAC,QAAQ,CAAC,gBAAgB,IAAI,CAAC,cAAc,CAAC,CAAa,CAAC,EAAE,CAAC;gBAE/D,MAAM,CAAC,GAAG,YAAY,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAA;gBAC/B,oBAAoB,CAAC,CAAC,EAAE,CAAC,CAAC,CAAA;YAC9B,CAAC;YACD,OAAO,CAAC,GAAG,CAAC,CAAA;QAChB,CAAC;QAED,QAAQ,OAAO,CAAC,CAAC,GAAG,EAAE,CAAC;YACnB,KAAK,UAAU;gBACX,IAAI,QAAQ,GAAG,CAAC,EAAE,CAAC,EAAE,GAAG,IAAI,CAAC,CAAC,GAAG,CAAA;gBAEjC,IAAI,EAA+B,CAAA;gBAEnC,IAAI,gBAAgB,CAAC,CAAC,CAAC,EAAE,CAAC;oBACtB,CAAC,CAAC,CAAC,GAAG,EAAE,GAAI,CAAC,EAAE,CAAgB,EAAE,CAAC,IAAI,MAAM,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAA;oBAC9D,EAAE,CAAC,KAAK,GAAG,KAAK,CAAA;oBAGhB,IAAI,QAAQ,IAAI,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC;wBAAE,OAAO,CAAC,GAAG,CAAC,CAAA;gBACrD,CAAC;gBAOD,IAAI,EAAE,GAAG,EAAE,EAAE,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,IAAI,EAAE,CAAC,CAAC,CAAE,CAAC,CAAC,GAAkB,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAA;gBAG7E,IAAI,EAAE,KAAK,SAAS,IAAI,EAAE,IAAI,IAAI;oBAAE,OAAO,CAAC,CAAA;gBAE5C,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAA;gBAEtB,IAAI,EAAE,GAAG,CAAC,CAAC,UAAU,CAAC,CAAC,CAAE,CAAA;gBACzB,EAAE,CAAC,CAAC,GAAG,CAAC,CAAA;gBAGR,IAAI,EAAE;oBAAE,EAAE,CAAC,OAAO,GAAG,EAAE,CAAA;gBACvB,IAAI,CAAC,QAAQ;oBAAE,EAAE,EAAE,OAAO,EAAE,EAAE,CAAA;gBAE9B,OAAO,CAAC,CAAA;YAEZ,KAAK,QAAQ;gBACT,OAAO,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAA;QAChC,CAAC;IACL,CAAC;IAED,YAAY,CAAC,CAAW,CAAC,CAAA;IACzB,OAAO,CAAC,GAAG,CAAC,CAAA;AAChB,CAAC;AAED,IAAI,QAAQ,GAAmB,EAAE,CAAA;AAEjC,MAAM,UAAU,KAAK,CAAC,CAAc,EAAE,CAAU;IAC5C,IAAI,CAAC,CAAC;QAAE,OAAM;IACd,IAAI,QAAQ,CAAC,OAAO;QAAG,CAAiB,CAAC,eAAe,EAAE,CAAA;IAC1D,MAAM,CAAC,GAAG,CAAC,CAAC,aAA4B,CAAA;IACxC,MAAM,CAAC,GAAG,EAAE,CAAC,OAAO,CAAC,IAAI,CAAgB,CAAC,CAAC,UAAU,EAAE,CAAC,CAAC,CAAA;IAEzD,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAA;AACjB,CAAC;AAMD,MAAM,UAAU,YAAY,CAAC,EAAkB,EAAE,GAAG,IAAe;IAC/D,CAAC;QACG,QAAQ,GAAG,EAAE,CAAA;QACb,kBAAkB,CAAC,GAAG,IAAI,CAAC,CAAA;IAC/B,CAAC;AACL,CAAC;AACD,MAAM,UAAU,UAAU,CAAC,GAAG,IAAe;IACzC,CAAC;QACG,QAAQ,GAAG,EAAE,CAAA;QACb,kBAAkB,CAAC,GAAG,IAAI,CAAC,CAAA;IAC/B,CAAC;AACL,CAAC;AAED,SAAS,kBAAkB,CAAC,GAAG,IAAgB;IAC3C,IAAI,CAAC,IAAI,CAAC,MAAM;QAAE,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;IACnC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,IAAI,QAAQ,CAAC,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;QACrG,IAAI,CAAC,CAAC,EAAE,CAAC;YAAE,MAAM,8BAA8B,CAAA;QAC/C,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAA;IACjB,CAAC,CAAC,CAAA;AACN,CAAC","sourcesContent":["import { rebind } from './base'\nimport { Expr, FComponent, H, HComp, HCompClass, HElement, HFragment, IClassComponent, Props } from './h'\n\n// config\nexport function createElement(tag: string) {\n    let ns = window.jmx?.getnamespace?.(tag)\n    return ns ? document.createElementNS(ns, tag) : document.createElement(tag)\n}\n\nconst enum NodeType { // vaporizes (but for that must be in this file, otherwise not)\n    TextNode = 3,\n}\n\nlet evaluate = <T>(expr: Expr<T>): T => (expr instanceof Function ? expr() : expr)\nlet removeexcesschildren = (n: Element, i: number) => {\n    let c: ChildNode\n    while ((c = n.childNodes[i])) {\n        c.remove()\n    }\n}\nlet iswebcomponent = (h: HElement) => (h.tag as string).includes('-')\nlet isclasscomponent = (h: HComp): h is HCompClass => (h.tag as any)?.prototype?.view\nlet iselement = (h: any): h is HElement => typeof h.tag == 'string'\nlet isfragment = (h: any): h is HFragment => {\n    return h.tag == undefined && h.cn != undefined\n}\nlet isobject = (o: any): o is object => typeof o === 'object'\n\nlet isproperty = (name: string, value: any) =>\n    ['value', 'checked', 'disabled', 'className', 'style', 'href', 'src', 'selected', 'readOnly', 'tabIndex'].includes(\n        name\n    ) ||\n    value instanceof Object ||\n    value instanceof Function\n\nlet setprops = (e: Element, newprops: Props = {}) => {\n    let oldprops = evaluate(e.h?.p) ?? {}\n    for (let p in oldprops)\n        !(p in newprops) && isproperty(p, oldprops[p]) ? ((e as any)[p] = null) : e.removeAttribute(p)\n    for (let p in newprops) isproperty(p, newprops[p]) ? ((e as any)[p] = newprops[p]) : e.setAttribute(p, newprops[p])\n}\n\n/** syncs at position i of p. returns the number of the element past the last added element.\n * if no element was added (eg when h=null) then it returns i\n * if a fragment with 5 nodes was added, it returns i + 5\n * when a single element or component is added, it is i+1 since they always create exactly 1 node\n */\nfunction sync(p: Element, i: number, h: Expr<H | undefined>): number {\n    // console.log('%csync', \"background:orange\", p.tagName, i, h)\n\n    h = evaluate(h)\n    if (h === null || h === undefined) return i // skip this element. not that !!h would forbid to render the number 0 or the boolean value false\n\n    let c = p.childNodes[i] // is often null, eg during fresh creation\n\n    function synctextnode(text: string) {\n        if (c && c.nodeType == NodeType.TextNode) {\n            if (c.textContent != text) c.textContent = text // firefox updates even equal text, loosing an existing text selection\n        } else {\n            let tn = document.createTextNode(text)\n            c ? c.replaceWith(tn) : p.appendChild(tn)\n        }\n    }\n\n    if (isobject(h)) {\n        // element nodes\n\n        /** synchronizes children starting at the i-th element. returns the index of the last child synchronized */\n        function syncchildren(p: Element, h: HElement | HComp | HFragment, i: number): number {\n            evaluate(h.cn)\n                ?.flat()\n                .forEach(hc => (i = sync(p, i, hc)))\n            return i\n        }\n\n        if (isfragment(h)) return syncchildren(p, h, i)\n\n        const props = evaluate(h.p)\n\n        if (iselement(h)) {\n            let n: Element\n\n            if ((<Element>c)?.tagName?.toLowerCase() != h.tag.toLowerCase()) {\n                n = createElement(h.tag)\n                c ? c.replaceWith(n) : p.appendChild(n)\n                setprops(n, props)\n                props?.mounted?.(n)\n            } else {\n                n = c as Element\n                setprops(n, props)\n                if (props?.update?.(c, globaluc)) return i + 1\n            }\n\n            // if only components shall be updateable (advantage: close variables inside component functions are always fresh materialized, avoids surprises), comment this out\n            n.h = h\n\n            if (!globaluc.patchElementOnly && !iswebcomponent(h as HElement)) {\n                // tbd: make \"island\" attribute\n                const j = syncchildren(n, h, 0)\n                removeexcesschildren(n, j)\n            }\n            return i + 1\n        }\n\n        switch (typeof h.tag) {\n            case 'function':\n                let isupdate = c?.h?.tag == h.tag\n\n                let ci: IClassComponent | undefined\n\n                if (isclasscomponent(h)) {\n                    h.i = ci = (c?.h as HCompClass)?.i ?? rebind(new h.tag(props))\n                    ci.props = props\n\n                    // if component instance returns truthy for update(), then syncing is susbstituted by the component\n                    if (isupdate && ci.update(globaluc)) return i + 1\n                }\n\n                // materialize the component\n                // we run compoents view() and fun code often, we do not compare properties to avoid their computation\n                // this means that the inner hr (h resolved) is run often\n                //\n                // if ci has a view, return ci.view() even if it is falsy, this is perfectly valid\n                let hr = ci?.view ? ci?.view() : (h.tag as FComponent)(props, evaluate(h.cn))\n\n                // a component can return undefined or null if it has no elements to show\n                if (hr === undefined || hr == null) return i\n\n                let j = sync(p, i, hr)\n\n                let cn = p.childNodes[i]!\n                cn.h = h // attach h onto the materialized component node\n                // ;(cn as HTMLElement).setAttribute?.('comp', '')\n\n                if (ci) ci.element = cn\n                if (!isupdate) ci?.mounted?.()\n\n                return j\n\n            case 'object':\n                return sync(p, i, h.tag) // tbd: type of h is not correct, h.tag == never\n        }\n    }\n    // text nodes\n    synctextnode(h as string)\n    return i + 1\n}\n\nlet globaluc: IUpdateContext = {}\n\nexport function patch(e: Node | null, h: Expr<H>) {\n    if (!e) return\n    if (globaluc.replace) (e as HTMLElement).replaceChildren()\n    const p = e.parentElement as HTMLElement\n    const i = [].indexOf.call<any, any, any>(p.childNodes, e)\n    // always called deferred, because removing elements can trigger events and their handlers (like blur)\n    sync(p, i, h)\n}\n\n// Overload signatures\ntype Selector = string | Node | undefined | null\ntype Selectors = Selector[]\n\nexport function updateviewuc(uc: IUpdateContext, ...sels: Selectors): void {\n    {\n        globaluc = uc\n        updateviewinternal(...sels)\n    }\n}\nexport function updateview(...sels: Selectors): void {\n    {\n        globaluc = {}\n        updateviewinternal(...sels)\n    }\n}\n\nfunction updateviewinternal(...sels: Selector[]): void {\n    if (!sels.length) sels.push('body')\n    sels.flatMap(s => (typeof s == 'string' ? [...document.querySelectorAll(s)] : s ? [s] : [])).forEach(e => {\n        if (!e?.h) throw 'jmx: no h exists on the node'\n        patch(e, e.h)\n    })\n}\n"]}