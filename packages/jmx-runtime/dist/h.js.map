{"version":3,"file":"h.js","sourceRoot":"./","sources":["h.ts"],"names":[],"mappings":"AAkFA,MAAM,UAAU,GAAG;IACf,MAAM,2BAA2B,CAAA;AACrC,CAAC;AACD,MAAM,UAAU,IAAI;IAChB,MAAM,2BAA2B,CAAA;AACrC,CAAC","sourcesContent":["// jmx internal types - hopst\n// the following types describe the js expression we get from tsx after conversion be our jmx plugin\n// they can be useful for users as well, components might return them.\n\ntype Func<T> = () => T\nexport type Expr<T> = T | Func<T>\n\nexport type Props = Record<string, any>\n\nexport type FComponent = (props: Props | undefined, children?: ChildrenH) => HElement // show an example for usage of children\n\nexport type FComponentT<P> = (pcn: P, cn?: Children) => H | void\n\nexport interface IClassComponent {\n    element: Node\n    props?: Record<string, any>\n    view(): H\n    update(uc: IUpdateContext): boolean | void\n    mounted?(): void\n}\n\ninterface CComponent {\n    new (props: any): IClassComponent // while a real component expresses its interface via props pass to the ctor, internally we assign props after construction with new()\n}\n\nexport type ChildrenH = (H | undefined)[]\nexport type Children = Expr<ChildrenH>\n\ntype HText =\n    | string // text node\n    | number // text node\n    | boolean // do not allow boolean, that\n\nexport type HFragment = {\n    cn: Children\n}\n\nexport type HElement = {\n    tag: string\n    p?: Expr<Props>\n    cn: Children\n    i?: any\n}\n\ntype HCompFun = {\n    tag: FComponent\n    p?: Expr<Props>\n    cn?: Children\n}\n\nexport type HCompClass = {\n    tag: CComponent\n    p?: Expr<Props>\n    cn: Children\n    i: IClassComponent\n}\n\nexport type HComp = HCompFun | HCompClass\n\nexport type H = // a hyperscript atom that describes a ...\n\n        | HText\n        | HElement // a tag, like p, div with attributes and children\n        | HComp // a dynamic component computing any other HNode\n        | HFragment\n\ndeclare global {\n    interface Node {\n        h?: HElement | HCompFun | HCompClass\n    }\n    export interface IUpdateContext {\n        patchElementOnly?: boolean\n        replace?: boolean\n    }\n\n    export interface Window {\n        jmx?: {\n            getnamespace: (tag: string) => string | undefined\n        }\n    }\n}\n\nexport function jsx(): HElement {\n    throw 'jmx plugin not configured'\n} // dumy function for app code - jmx-plugin removes calls to this function, minifyer then removes it\nexport function jsxf(): HElement {\n    throw 'jmx plugin not configured'\n} // dumy function for app code - jmx-plugin removes calls to this function, minifyer then removes it\n"]}