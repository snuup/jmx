import require$$0$1 from 'tty';
import require$$1 from 'util';
import * as fs from 'fs';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return _arrayLikeToArray(r);
}
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}
function _createForOfIteratorHelper(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) {
      t && (r = t);
      var n = 0,
        F = function () {};
      return {
        s: F,
        n: function () {
          return n >= r.length ? {
            done: true
          } : {
            done: false,
            value: r[n++]
          };
        },
        e: function (r) {
          throw r;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o,
    a = true,
    u = false;
  return {
    s: function () {
      t = t.call(r);
    },
    n: function () {
      var r = t.next();
      return a = r.done, r;
    },
    e: function (r) {
      u = true, o = r;
    },
    f: function () {
      try {
        a || null == t.return || t.return();
      } finally {
        if (u) throw o;
      }
    }
  };
}
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}
function _get() {
  return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) {
    var p = _superPropBase(e, t);
    if (p) {
      var n = Object.getOwnPropertyDescriptor(p, t);
      return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
    }
  }, _get.apply(null, arguments);
}
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _getPrototypeOf(t);
}
function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t, "prototype", {
    writable: false
  }), e && _setPrototypeOf(t, e);
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function () {
    return !!t;
  })();
}
function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = true,
      o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = true, n = r;
    } finally {
      try {
        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == typeof e || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}
function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: true,
      configurable: true,
      writable: true
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function (t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function (t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: true
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = false, next;
            return next.value = t, next.done = true, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(typeof e + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function (e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function () {
      this.done = true;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function (e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, true);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, true);
          } else {
            if (!u) throw Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function (t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function (t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function (t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    catch: function (t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function (e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}
function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}
function _superPropBase(t, o) {
  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)););
  return t;
}
function _superPropGet(t, o, e, r) {
  var p = _get(_getPrototypeOf(t.prototype ), o, e);
  return 2 & r && "function" == typeof p ? function (t) {
    return p.apply(e, t);
  } : p;
}
function _taggedTemplateLiteral(e, t) {
  return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, {
    raw: {
      value: Object.freeze(t)
    }
  }));
}
function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}

var lib$7 = {};

var _templateObject$1,_templateObject2,_templateObject3,_templateObject4,_templateObject5;var hasRequiredLib$7;function requireLib$7(){if(hasRequiredLib$7)return lib$7;hasRequiredLib$7=1;Object.defineProperty(lib$7,'__esModule',{value:true});function _objectWithoutPropertiesLoose(r,e){if(null==r)return {};var t={};for(var n in r)if({}.hasOwnProperty.call(r,n)){if(e.includes(n))continue;t[n]=r[n];}return t;}var Position=/*#__PURE__*/_createClass(function Position(line,col,index){_classCallCheck(this,Position);this.line=void 0;this.column=void 0;this.index=void 0;this.line=line;this.column=col;this.index=index;});var SourceLocation=/*#__PURE__*/_createClass(function SourceLocation(start,end){_classCallCheck(this,SourceLocation);this.start=void 0;this.end=void 0;this.filename=void 0;this.identifierName=void 0;this.start=start;this.end=end;});function createPositionWithColumnOffset(position,columnOffset){var line=position.line,column=position.column,index=position.index;return new Position(line,column+columnOffset,index+columnOffset);}var code="BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";var ModuleErrors={ImportMetaOutsideModule:{message:"import.meta may appear only with 'sourceType: \"module\"'",code:code},ImportOutsideModule:{message:"'import' and 'export' may appear only with 'sourceType: \"module\"'",code:code}};var NodeDescriptions={ArrayPattern:"array destructuring pattern",AssignmentExpression:"assignment expression",AssignmentPattern:"assignment expression",ArrowFunctionExpression:"arrow function expression",ConditionalExpression:"conditional expression",CatchClause:"catch clause",ForOfStatement:"for-of statement",ForInStatement:"for-in statement",ForStatement:"for-loop",FormalParameters:"function parameter list",Identifier:"identifier",ImportSpecifier:"import specifier",ImportDefaultSpecifier:"import default specifier",ImportNamespaceSpecifier:"import namespace specifier",ObjectPattern:"object destructuring pattern",ParenthesizedExpression:"parenthesized expression",RestElement:"rest element",UpdateExpression:{"true":"prefix operation","false":"postfix operation"},VariableDeclarator:"variable declaration",YieldExpression:"yield expression"};var toNodeDescription=function toNodeDescription(node){return node.type==="UpdateExpression"?NodeDescriptions.UpdateExpression["".concat(node.prefix)]:NodeDescriptions[node.type];};var StandardErrors={AccessorIsGenerator:function AccessorIsGenerator(_ref3){var kind=_ref3.kind;return "A ".concat(kind,"ter cannot be a generator.");},ArgumentsInClass:"'arguments' is only allowed in functions and class methods.",AsyncFunctionInSingleStatementContext:"Async functions can only be declared at the top level or inside a block.",AwaitBindingIdentifier:"Can not use 'await' as identifier inside an async function.",AwaitBindingIdentifierInStaticBlock:"Can not use 'await' as identifier inside a static block.",AwaitExpressionFormalParameter:"'await' is not allowed in async function parameters.",AwaitUsingNotInAsyncContext:"'await using' is only allowed within async functions and at the top levels of modules.",AwaitNotInAsyncContext:"'await' is only allowed within async functions and at the top levels of modules.",AwaitNotInAsyncFunction:"'await' is only allowed within async functions.",BadGetterArity:"A 'get' accessor must not have any formal parameters.",BadSetterArity:"A 'set' accessor must have exactly one formal parameter.",BadSetterRestParameter:"A 'set' accessor function argument must not be a rest parameter.",ConstructorClassField:"Classes may not have a field named 'constructor'.",ConstructorClassPrivateField:"Classes may not have a private field named '#constructor'.",ConstructorIsAccessor:"Class constructor may not be an accessor.",ConstructorIsAsync:"Constructor can't be an async function.",ConstructorIsGenerator:"Constructor can't be a generator.",DeclarationMissingInitializer:function DeclarationMissingInitializer(_ref4){var kind=_ref4.kind;return "Missing initializer in ".concat(kind," declaration.");},DecoratorArgumentsOutsideParentheses:"Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",DecoratorBeforeExport:"Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",DecoratorsBeforeAfterExport:"Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",DecoratorConstructor:"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",DecoratorExportClass:"Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",DecoratorSemicolon:"Decorators must not be followed by a semicolon.",DecoratorStaticBlock:"Decorators can't be used with a static block.",DeferImportRequiresNamespace:'Only `import defer * as x from "./module"` is valid.',DeletePrivateField:"Deleting a private field is not allowed.",DestructureNamedImport:"ES2015 named imports do not destructure. Use another statement for destructuring after the import.",DuplicateConstructor:"Duplicate constructor in the same class.",DuplicateDefaultExport:"Only one default export allowed per module.",DuplicateExport:function DuplicateExport(_ref5){var exportName=_ref5.exportName;return "`".concat(exportName,"` has already been exported. Exported identifiers must be unique.");},DuplicateProto:"Redefinition of __proto__ property.",DuplicateRegExpFlags:"Duplicate regular expression flag.",DynamicImportPhaseRequiresImportExpressions:function DynamicImportPhaseRequiresImportExpressions(_ref6){var phase=_ref6.phase;return "'import.".concat(phase,"(...)' can only be parsed when using the 'createImportExpressions' option.");},ElementAfterRest:"Rest element must be last element.",EscapedCharNotAnIdentifier:"Invalid Unicode escape.",ExportBindingIsString:function ExportBindingIsString(_ref7){var localName=_ref7.localName,exportName=_ref7.exportName;return "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '".concat(localName,"' as '").concat(exportName,"' } from 'some-module'`?");},ExportDefaultFromAsIdentifier:"'from' is not allowed as an identifier after 'export default'.",ForInOfLoopInitializer:function ForInOfLoopInitializer(_ref8){var type=_ref8.type;return "'".concat(type==="ForInStatement"?"for-in":"for-of","' loop variable declaration may not have an initializer.");},ForInUsing:"For-in loop may not start with 'using' declaration.",ForOfAsync:"The left-hand side of a for-of loop may not be 'async'.",ForOfLet:"The left-hand side of a for-of loop may not start with 'let'.",GeneratorInSingleStatementContext:"Generators can only be declared at the top level or inside a block.",IllegalBreakContinue:function IllegalBreakContinue(_ref9){var type=_ref9.type;return "Unsyntactic ".concat(type==="BreakStatement"?"break":"continue",".");},IllegalLanguageModeDirective:"Illegal 'use strict' directive in function with non-simple parameter list.",IllegalReturn:"'return' outside of function.",ImportAttributesUseAssert:"The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.",ImportBindingIsString:function ImportBindingIsString(_ref10){var importName=_ref10.importName;return "A string literal cannot be used as an imported binding.\n- Did you mean `import { \"".concat(importName,"\" as foo }`?");},ImportCallArity:"`import()` requires exactly one or two arguments.",ImportCallNotNewExpression:"Cannot use new with import(...).",ImportCallSpreadArgument:"`...` is not allowed in `import()`.",ImportJSONBindingNotDefault:"A JSON module can only be imported with `default`.",ImportReflectionHasAssertion:"`import module x` cannot have assertions.",ImportReflectionNotBinding:'Only `import module x from "./module"` is valid.',IncompatibleRegExpUVFlags:"The 'u' and 'v' regular expression flags cannot be enabled at the same time.",InvalidBigIntLiteral:"Invalid BigIntLiteral.",InvalidCodePoint:"Code point out of bounds.",InvalidCoverInitializedName:"Invalid shorthand property initializer.",InvalidDecimal:"Invalid decimal.",InvalidDigit:function InvalidDigit(_ref11){var radix=_ref11.radix;return "Expected number in radix ".concat(radix,".");},InvalidEscapeSequence:"Bad character escape sequence.",InvalidEscapeSequenceTemplate:"Invalid escape sequence in template.",InvalidEscapedReservedWord:function InvalidEscapedReservedWord(_ref12){var reservedWord=_ref12.reservedWord;return "Escape sequence in keyword ".concat(reservedWord,".");},InvalidIdentifier:function InvalidIdentifier(_ref13){var identifierName=_ref13.identifierName;return "Invalid identifier ".concat(identifierName,".");},InvalidLhs:function InvalidLhs(_ref14){var ancestor=_ref14.ancestor;return "Invalid left-hand side in ".concat(toNodeDescription(ancestor),".");},InvalidLhsBinding:function InvalidLhsBinding(_ref15){var ancestor=_ref15.ancestor;return "Binding invalid left-hand side in ".concat(toNodeDescription(ancestor),".");},InvalidLhsOptionalChaining:function InvalidLhsOptionalChaining(_ref16){var ancestor=_ref16.ancestor;return "Invalid optional chaining in the left-hand side of ".concat(toNodeDescription(ancestor),".");},InvalidNumber:"Invalid number.",InvalidOrMissingExponent:"Floating-point numbers require a valid exponent after the 'e'.",InvalidOrUnexpectedToken:function InvalidOrUnexpectedToken(_ref17){var unexpected=_ref17.unexpected;return "Unexpected character '".concat(unexpected,"'.");},InvalidParenthesizedAssignment:"Invalid parenthesized assignment pattern.",InvalidPrivateFieldResolution:function InvalidPrivateFieldResolution(_ref18){var identifierName=_ref18.identifierName;return "Private name #".concat(identifierName," is not defined.");},InvalidPropertyBindingPattern:"Binding member expression.",InvalidRecordProperty:"Only properties and spread elements are allowed in record definitions.",InvalidRestAssignmentPattern:"Invalid rest operator's argument.",LabelRedeclaration:function LabelRedeclaration(_ref19){var labelName=_ref19.labelName;return "Label '".concat(labelName,"' is already declared.");},LetInLexicalBinding:"'let' is disallowed as a lexically bound name.",LineTerminatorBeforeArrow:"No line break is allowed before '=>'.",MalformedRegExpFlags:"Invalid regular expression flag.",MissingClassName:"A class name is required.",MissingEqInAssignment:"Only '=' operator can be used for specifying default value.",MissingSemicolon:"Missing semicolon.",MissingPlugin:function MissingPlugin(_ref20){var missingPlugin=_ref20.missingPlugin;return "This experimental syntax requires enabling the parser plugin: ".concat(missingPlugin.map(function(name){return JSON.stringify(name);}).join(", "),".");},MissingOneOfPlugins:function MissingOneOfPlugins(_ref21){var missingPlugin=_ref21.missingPlugin;return "This experimental syntax requires enabling one of the following parser plugin(s): ".concat(missingPlugin.map(function(name){return JSON.stringify(name);}).join(", "),".");},MissingUnicodeEscape:"Expecting Unicode escape sequence \\uXXXX.",MixingCoalesceWithLogical:"Nullish coalescing operator(??) requires parens when mixing with logical operators.",ModuleAttributeDifferentFromType:"The only accepted module attribute is `type`.",ModuleAttributeInvalidValue:"Only string literals are allowed as module attribute values.",ModuleAttributesWithDuplicateKeys:function ModuleAttributesWithDuplicateKeys(_ref22){var key=_ref22.key;return "Duplicate key \"".concat(key,"\" is not allowed in module attributes.");},ModuleExportNameHasLoneSurrogate:function ModuleExportNameHasLoneSurrogate(_ref23){var surrogateCharCode=_ref23.surrogateCharCode;return "An export name cannot include a lone surrogate, found '\\u".concat(surrogateCharCode.toString(16),"'.");},ModuleExportUndefined:function ModuleExportUndefined(_ref24){var localName=_ref24.localName;return "Export '".concat(localName,"' is not defined.");},MultipleDefaultsInSwitch:"Multiple default clauses.",NewlineAfterThrow:"Illegal newline after throw.",NoCatchOrFinally:"Missing catch or finally clause.",NumberIdentifier:"Identifier directly after number.",NumericSeparatorInEscapeSequence:"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",ObsoleteAwaitStar:"'await*' has been removed from the async functions proposal. Use Promise.all() instead.",OptionalChainingNoNew:"Constructors in/after an Optional Chain are not allowed.",OptionalChainingNoTemplate:"Tagged Template Literals are not allowed in optionalChain.",OverrideOnConstructor:"'override' modifier cannot appear on a constructor declaration.",ParamDupe:"Argument name clash.",PatternHasAccessor:"Object pattern can't contain getter or setter.",PatternHasMethod:"Object pattern can't contain methods.",PrivateInExpectedIn:function PrivateInExpectedIn(_ref25){var identifierName=_ref25.identifierName;return "Private names are only allowed in property accesses (`obj.#".concat(identifierName,"`) or in `in` expressions (`#").concat(identifierName," in obj`).");},PrivateNameRedeclaration:function PrivateNameRedeclaration(_ref26){var identifierName=_ref26.identifierName;return "Duplicate private name #".concat(identifierName,".");},RecordExpressionBarIncorrectEndSyntaxType:"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",RecordExpressionBarIncorrectStartSyntaxType:"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",RecordExpressionHashIncorrectStartSyntaxType:"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",RecordNoProto:"'__proto__' is not allowed in Record expressions.",RestTrailingComma:"Unexpected trailing comma after rest element.",SloppyFunction:"In non-strict mode code, functions can only be declared at top level or inside a block.",SloppyFunctionAnnexB:"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",SourcePhaseImportRequiresDefault:'Only `import source x from "./module"` is valid.',StaticPrototype:"Classes may not have static property named prototype.",SuperNotAllowed:"`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",SuperPrivateField:"Private fields can't be accessed on super.",TrailingDecorator:"Decorators must be attached to a class element.",TupleExpressionBarIncorrectEndSyntaxType:"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",TupleExpressionBarIncorrectStartSyntaxType:"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",TupleExpressionHashIncorrectStartSyntaxType:"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",UnexpectedArgumentPlaceholder:"Unexpected argument placeholder.",UnexpectedAwaitAfterPipelineBody:'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',UnexpectedDigitAfterHash:"Unexpected digit after hash token.",UnexpectedImportExport:"'import' and 'export' may only appear at the top level.",UnexpectedKeyword:function UnexpectedKeyword(_ref27){var keyword=_ref27.keyword;return "Unexpected keyword '".concat(keyword,"'.");},UnexpectedLeadingDecorator:"Leading decorators must be attached to a class declaration.",UnexpectedLexicalDeclaration:"Lexical declaration cannot appear in a single-statement context.",UnexpectedNewTarget:"`new.target` can only be used in functions or class properties.",UnexpectedNumericSeparator:"A numeric separator is only allowed between two digits.",UnexpectedPrivateField:"Unexpected private name.",UnexpectedReservedWord:function UnexpectedReservedWord(_ref28){var reservedWord=_ref28.reservedWord;return "Unexpected reserved word '".concat(reservedWord,"'.");},UnexpectedSuper:"'super' is only allowed in object methods and classes.",UnexpectedToken:function UnexpectedToken(_ref29){var expected=_ref29.expected,unexpected=_ref29.unexpected;return "Unexpected token".concat(unexpected?" '".concat(unexpected,"'."):"").concat(expected?", expected \"".concat(expected,"\""):"");},UnexpectedTokenUnaryExponentiation:"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",UnexpectedUsingDeclaration:"Using declaration cannot appear in the top level when source type is `script`.",UnsupportedBind:"Binding should be performed on object property.",UnsupportedDecoratorExport:"A decorated export must export a class declaration.",UnsupportedDefaultExport:"Only expressions, functions or classes are allowed as the `default` export.",UnsupportedImport:"`import` can only be used in `import()` or `import.meta`.",UnsupportedMetaProperty:function UnsupportedMetaProperty(_ref30){var target=_ref30.target,onlyValidPropertyName=_ref30.onlyValidPropertyName;return "The only valid meta property for ".concat(target," is ").concat(target,".").concat(onlyValidPropertyName,".");},UnsupportedParameterDecorator:"Decorators cannot be used to decorate parameters.",UnsupportedPropertyDecorator:"Decorators cannot be used to decorate object literal properties.",UnsupportedSuper:"'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",UnterminatedComment:"Unterminated comment.",UnterminatedRegExp:"Unterminated regular expression.",UnterminatedString:"Unterminated string constant.",UnterminatedTemplate:"Unterminated template.",UsingDeclarationExport:"Using declaration cannot be exported.",UsingDeclarationHasBindingPattern:"Using declaration cannot have destructuring patterns.",VarRedeclaration:function VarRedeclaration(_ref31){var identifierName=_ref31.identifierName;return "Identifier '".concat(identifierName,"' has already been declared.");},YieldBindingIdentifier:"Can not use 'yield' as identifier inside a generator.",YieldInParameter:"Yield expression is not allowed in formal parameters.",ZeroDigitNumericSeparator:"Numeric separator can not be used after leading 0."};var StrictModeErrors={StrictDelete:"Deleting local variable in strict mode.",StrictEvalArguments:function StrictEvalArguments(_ref32){var referenceName=_ref32.referenceName;return "Assigning to '".concat(referenceName,"' in strict mode.");},StrictEvalArgumentsBinding:function StrictEvalArgumentsBinding(_ref33){var bindingName=_ref33.bindingName;return "Binding '".concat(bindingName,"' in strict mode.");},StrictFunction:"In strict mode code, functions can only be declared at top level or inside a block.",StrictNumericEscape:"The only valid numeric escape in strict mode is '\\0'.",StrictOctalLiteral:"Legacy octal literals are not allowed in strict mode.",StrictWith:"'with' in strict mode."};var UnparenthesizedPipeBodyDescriptions=new Set(["ArrowFunctionExpression","AssignmentExpression","ConditionalExpression","YieldExpression"]);var PipelineOperatorErrors=Object.assign({PipeBodyIsTighter:"Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",PipeTopicRequiresHackPipes:'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',PipeTopicUnbound:"Topic reference is unbound; it must be inside a pipe body.",PipeTopicUnconfiguredToken:function PipeTopicUnconfiguredToken(_ref34){var token=_ref34.token;return "Invalid topic token ".concat(token,". In order to use ").concat(token," as a topic reference, the pipelineOperator plugin must be configured with { \"proposal\": \"hack\", \"topicToken\": \"").concat(token,"\" }.");},PipeTopicUnused:"Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",PipeUnparenthesizedBody:function PipeUnparenthesizedBody(_ref35){var type=_ref35.type;return "Hack-style pipe body cannot be an unparenthesized ".concat(toNodeDescription({type:type}),"; please wrap it in parentheses.");}},{PipelineBodyNoArrow:'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',PipelineBodySequenceExpression:"Pipeline body may not be a comma-separated sequence expression.",PipelineHeadSequenceExpression:"Pipeline head should not be a comma-separated sequence expression.",PipelineTopicUnused:"Pipeline is in topic style but does not use topic reference.",PrimaryTopicNotAllowed:"Topic reference was used in a lexical context without topic binding.",PrimaryTopicRequiresSmartPipeline:'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'});var _excluded=["message"];function defineHidden(obj,key,value){Object.defineProperty(obj,key,{enumerable:false,configurable:true,value:value});}function toParseErrorConstructor(_ref36){var toMessage=_ref36.toMessage,code=_ref36.code,reasonCode=_ref36.reasonCode,syntaxPlugin=_ref36.syntaxPlugin;var hasMissingPlugin=reasonCode==="MissingPlugin"||reasonCode==="MissingOneOfPlugins";{var oldReasonCodes={AccessorCannotDeclareThisParameter:"AccesorCannotDeclareThisParameter",AccessorCannotHaveTypeParameters:"AccesorCannotHaveTypeParameters",ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference:"ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference",SetAccessorCannotHaveOptionalParameter:"SetAccesorCannotHaveOptionalParameter",SetAccessorCannotHaveRestParameter:"SetAccesorCannotHaveRestParameter",SetAccessorCannotHaveReturnType:"SetAccesorCannotHaveReturnType"};if(oldReasonCodes[reasonCode]){reasonCode=oldReasonCodes[reasonCode];}}return function constructor(loc,details){var error=new SyntaxError();error.code=code;error.reasonCode=reasonCode;error.loc=loc;error.pos=loc.index;error.syntaxPlugin=syntaxPlugin;if(hasMissingPlugin){error.missingPlugin=details.missingPlugin;}defineHidden(error,"clone",function clone(){var overrides=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var _overrides$loc;var _ref37=(_overrides$loc=overrides.loc)!=null?_overrides$loc:loc,line=_ref37.line,column=_ref37.column,index=_ref37.index;return constructor(new Position(line,column,index),Object.assign({},details,overrides.details));});defineHidden(error,"details",details);Object.defineProperty(error,"message",{configurable:true,get:function get(){var message="".concat(toMessage(details)," (").concat(loc.line,":").concat(loc.column,")");this.message=message;return message;},set:function set(value){Object.defineProperty(this,"message",{value:value,writable:true});}});return error;};}function ParseErrorEnum(argument,syntaxPlugin){if(Array.isArray(argument)){return function(parseErrorTemplates){return ParseErrorEnum(parseErrorTemplates,argument[0]);};}var ParseErrorConstructors={};var _loop=function _loop(){var reasonCode=_Object$keys[_i];var template=argument[reasonCode];var _ref=typeof template==="string"?{message:function message(){return template;}}:typeof template==="function"?{message:template}:template,message=_ref.message,rest=_objectWithoutPropertiesLoose(_ref,_excluded);var toMessage=typeof message==="string"?function(){return message;}:message;ParseErrorConstructors[reasonCode]=toParseErrorConstructor(Object.assign({code:"BABEL_PARSER_SYNTAX_ERROR",reasonCode:reasonCode,toMessage:toMessage},syntaxPlugin?{syntaxPlugin:syntaxPlugin}:{},rest));};for(var _i=0,_Object$keys=Object.keys(argument);_i<_Object$keys.length;_i++){_loop();}return ParseErrorConstructors;}var Errors=Object.assign({},ParseErrorEnum(ModuleErrors),ParseErrorEnum(StandardErrors),ParseErrorEnum(StrictModeErrors),ParseErrorEnum(_templateObject$1||(_templateObject$1=_taggedTemplateLiteral(["pipelineOperator"])))(PipelineOperatorErrors));function createDefaultOptions(){return {sourceType:"script",sourceFilename:undefined,startIndex:0,startColumn:0,startLine:1,allowAwaitOutsideFunction:false,allowReturnOutsideFunction:false,allowNewTargetOutsideFunction:false,allowImportExportEverywhere:false,allowSuperOutsideMethod:false,allowUndeclaredExports:false,plugins:[],strictMode:null,ranges:false,tokens:false,createImportExpressions:false,createParenthesizedExpressions:false,errorRecovery:false,attachComment:true,annexB:true};}function getOptions(opts){var options=createDefaultOptions();if(opts==null){return options;}if(opts.annexB!=null&&opts.annexB!==false){throw new Error("The `annexB` option can only be set to `false`.");}for(var _i2=0,_Object$keys2=Object.keys(options);_i2<_Object$keys2.length;_i2++){var key=_Object$keys2[_i2];if(opts[key]!=null)options[key]=opts[key];}if(options.startLine===1){if(opts.startIndex==null&&options.startColumn>0){options.startIndex=options.startColumn;}else if(opts.startColumn==null&&options.startIndex>0){options.startColumn=options.startIndex;}}else if(opts.startColumn==null||opts.startIndex==null){if(opts.startIndex!=null){throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");}}return options;}var defineProperty=Object.defineProperty;var toUnenumerable=function toUnenumerable(object,key){if(object){defineProperty(object,key,{enumerable:false,value:object[key]});}};function toESTreeLocation(node){toUnenumerable(node.loc.start,"index");toUnenumerable(node.loc.end,"index");return node;}var estree=function estree(superClass){return/*#__PURE__*/function(_superClass){function ESTreeParserMixin(){_classCallCheck(this,ESTreeParserMixin);return _callSuper(this,ESTreeParserMixin,arguments);}_inherits(ESTreeParserMixin,_superClass);return _createClass(ESTreeParserMixin,[{key:"parse",value:function parse(){var file=toESTreeLocation(_superPropGet(ESTreeParserMixin,"parse",this,3)([]));if(this.optionFlags&128){file.tokens=file.tokens.map(toESTreeLocation);}return file;}},{key:"parseRegExpLiteral",value:function parseRegExpLiteral(_ref38){var pattern=_ref38.pattern,flags=_ref38.flags;var regex=null;try{regex=new RegExp(pattern,flags);}catch(_){}var node=this.estreeParseLiteral(regex);node.regex={pattern:pattern,flags:flags};return node;}},{key:"parseBigIntLiteral",value:function parseBigIntLiteral(value){var bigInt;try{bigInt=BigInt(value);}catch(_unused){bigInt=null;}var node=this.estreeParseLiteral(bigInt);node.bigint=String(node.value||value);return node;}},{key:"parseDecimalLiteral",value:function parseDecimalLiteral(value){var decimal=null;var node=this.estreeParseLiteral(decimal);node.decimal=String(node.value||value);return node;}},{key:"estreeParseLiteral",value:function estreeParseLiteral(value){return this.parseLiteral(value,"Literal");}},{key:"parseStringLiteral",value:function parseStringLiteral(value){return this.estreeParseLiteral(value);}},{key:"parseNumericLiteral",value:function parseNumericLiteral(value){return this.estreeParseLiteral(value);}},{key:"parseNullLiteral",value:function parseNullLiteral(){return this.estreeParseLiteral(null);}},{key:"parseBooleanLiteral",value:function parseBooleanLiteral(value){return this.estreeParseLiteral(value);}},{key:"directiveToStmt",value:function directiveToStmt(directive){var expression=directive.value;delete directive.value;expression.type="Literal";expression.raw=expression.extra.raw;expression.value=expression.extra.expressionValue;var stmt=directive;stmt.type="ExpressionStatement";stmt.expression=expression;stmt.directive=expression.extra.rawValue;delete expression.extra;return stmt;}},{key:"initFunction",value:function initFunction(node,isAsync){_superPropGet(ESTreeParserMixin,"initFunction",this,3)([node,isAsync]);node.expression=false;}},{key:"checkDeclaration",value:function checkDeclaration(node){if(node!=null&&this.isObjectProperty(node)){this.checkDeclaration(node.value);}else {_superPropGet(ESTreeParserMixin,"checkDeclaration",this,3)([node]);}}},{key:"getObjectOrClassMethodParams",value:function getObjectOrClassMethodParams(method){return method.value.params;}},{key:"isValidDirective",value:function isValidDirective(stmt){var _stmt$expression$extr;return stmt.type==="ExpressionStatement"&&stmt.expression.type==="Literal"&&typeof stmt.expression.value==="string"&&!((_stmt$expression$extr=stmt.expression.extra)!=null&&_stmt$expression$extr.parenthesized);}},{key:"parseBlockBody",value:function parseBlockBody(node,allowDirectives,topLevel,end,afterBlockParse){var _this2=this;_superPropGet(ESTreeParserMixin,"parseBlockBody",this,3)([node,allowDirectives,topLevel,end,afterBlockParse]);var directiveStatements=node.directives.map(function(d){return _this2.directiveToStmt(d);});node.body=directiveStatements.concat(node.body);delete node.directives;}},{key:"parsePrivateName",value:function parsePrivateName(){var node=_superPropGet(ESTreeParserMixin,"parsePrivateName",this,3)([]);{if(!this.getPluginOption("estree","classFeatures")){return node;}}return this.convertPrivateNameToPrivateIdentifier(node);}},{key:"convertPrivateNameToPrivateIdentifier",value:function convertPrivateNameToPrivateIdentifier(node){var name=_superPropGet(ESTreeParserMixin,"getPrivateNameSV",this,3)([node]);node=node;delete node.id;node.name=name;node.type="PrivateIdentifier";return node;}},{key:"isPrivateName",value:function isPrivateName(node){{if(!this.getPluginOption("estree","classFeatures")){return _superPropGet(ESTreeParserMixin,"isPrivateName",this,3)([node]);}}return node.type==="PrivateIdentifier";}},{key:"getPrivateNameSV",value:function getPrivateNameSV(node){{if(!this.getPluginOption("estree","classFeatures")){return _superPropGet(ESTreeParserMixin,"getPrivateNameSV",this,3)([node]);}}return node.name;}},{key:"parseLiteral",value:function parseLiteral(value,type){var node=_superPropGet(ESTreeParserMixin,"parseLiteral",this,3)([value,type]);node.raw=node.extra.raw;delete node.extra;return node;}},{key:"parseFunctionBody",value:function parseFunctionBody(node,allowExpression){var isMethod=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;_superPropGet(ESTreeParserMixin,"parseFunctionBody",this,3)([node,allowExpression,isMethod]);node.expression=node.body.type!=="BlockStatement";}},{key:"parseMethod",value:function parseMethod(node,isGenerator,isAsync,isConstructor,allowDirectSuper,type){var inClassScope=arguments.length>6&&arguments[6]!==undefined?arguments[6]:false;var funcNode=this.startNode();funcNode.kind=node.kind;funcNode=_superPropGet(ESTreeParserMixin,"parseMethod",this,3)([funcNode,isGenerator,isAsync,isConstructor,allowDirectSuper,type,inClassScope]);funcNode.type="FunctionExpression";delete funcNode.kind;node.value=funcNode;var typeParameters=node.typeParameters;if(typeParameters){delete node.typeParameters;funcNode.typeParameters=typeParameters;this.resetStartLocationFromNode(funcNode,typeParameters);}if(type==="ClassPrivateMethod"){node.computed=false;}return this.finishNode(node,"MethodDefinition");}},{key:"nameIsConstructor",value:function nameIsConstructor(key){if(key.type==="Literal")return key.value==="constructor";return _superPropGet(ESTreeParserMixin,"nameIsConstructor",this,3)([key]);}},{key:"parseClassProperty",value:function parseClassProperty(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}var propertyNode=_superPropGet(ESTreeParserMixin,"parseClassProperty",this,3)(args);{if(!this.getPluginOption("estree","classFeatures")){return propertyNode;}}{propertyNode.type="PropertyDefinition";}return propertyNode;}},{key:"parseClassPrivateProperty",value:function parseClassPrivateProperty(){for(var _len2=arguments.length,args=new Array(_len2),_key2=0;_key2<_len2;_key2++){args[_key2]=arguments[_key2];}var propertyNode=_superPropGet(ESTreeParserMixin,"parseClassPrivateProperty",this,3)(args);{if(!this.getPluginOption("estree","classFeatures")){return propertyNode;}}{propertyNode.type="PropertyDefinition";}propertyNode.computed=false;return propertyNode;}},{key:"parseObjectMethod",value:function parseObjectMethod(prop,isGenerator,isAsync,isPattern,isAccessor){var node=_superPropGet(ESTreeParserMixin,"parseObjectMethod",this,3)([prop,isGenerator,isAsync,isPattern,isAccessor]);if(node){node.type="Property";if(node.kind==="method"){node.kind="init";}node.shorthand=false;}return node;}},{key:"parseObjectProperty",value:function parseObjectProperty(prop,startLoc,isPattern,refExpressionErrors){var node=_superPropGet(ESTreeParserMixin,"parseObjectProperty",this,3)([prop,startLoc,isPattern,refExpressionErrors]);if(node){node.kind="init";node.type="Property";}return node;}},{key:"isValidLVal",value:function isValidLVal(type,isUnparenthesizedInAssign,binding){return type==="Property"?"value":_superPropGet(ESTreeParserMixin,"isValidLVal",this,3)([type,isUnparenthesizedInAssign,binding]);}},{key:"isAssignable",value:function isAssignable(node,isBinding){if(node!=null&&this.isObjectProperty(node)){return this.isAssignable(node.value,isBinding);}return _superPropGet(ESTreeParserMixin,"isAssignable",this,3)([node,isBinding]);}},{key:"toAssignable",value:function toAssignable(node){var isLHS=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;if(node!=null&&this.isObjectProperty(node)){var key=node.key,value=node.value;if(this.isPrivateName(key)){this.classScope.usePrivateName(this.getPrivateNameSV(key),key.loc.start);}this.toAssignable(value,isLHS);}else {_superPropGet(ESTreeParserMixin,"toAssignable",this,3)([node,isLHS]);}}},{key:"toAssignableObjectExpressionProp",value:function toAssignableObjectExpressionProp(prop,isLast,isLHS){if(prop.type==="Property"&&(prop.kind==="get"||prop.kind==="set")){this.raise(Errors.PatternHasAccessor,prop.key);}else if(prop.type==="Property"&&prop.method){this.raise(Errors.PatternHasMethod,prop.key);}else {_superPropGet(ESTreeParserMixin,"toAssignableObjectExpressionProp",this,3)([prop,isLast,isLHS]);}}},{key:"finishCallExpression",value:function finishCallExpression(unfinished,optional){var node=_superPropGet(ESTreeParserMixin,"finishCallExpression",this,3)([unfinished,optional]);if(node.callee.type==="Import"){var _ref,_ref2;node.type="ImportExpression";node.source=node.arguments[0];node.options=(_ref=node.arguments[1])!=null?_ref:null;node.attributes=(_ref2=node.arguments[1])!=null?_ref2:null;delete node.arguments;delete node.callee;}return node;}},{key:"toReferencedArguments",value:function toReferencedArguments(node){if(node.type==="ImportExpression"){return;}_superPropGet(ESTreeParserMixin,"toReferencedArguments",this,3)([node]);}},{key:"parseExport",value:function parseExport(unfinished,decorators){var exportStartLoc=this.state.lastTokStartLoc;var node=_superPropGet(ESTreeParserMixin,"parseExport",this,3)([unfinished,decorators]);switch(node.type){case "ExportAllDeclaration":node.exported=null;break;case "ExportNamedDeclaration":if(node.specifiers.length===1&&node.specifiers[0].type==="ExportNamespaceSpecifier"){node.type="ExportAllDeclaration";node.exported=node.specifiers[0].exported;delete node.specifiers;}case "ExportDefaultDeclaration":{var _declaration$decorato;var declaration=node.declaration;if((declaration==null?void 0:declaration.type)==="ClassDeclaration"&&((_declaration$decorato=declaration.decorators)==null?void 0:_declaration$decorato.length)>0&&declaration.start===node.start){this.resetStartLocation(node,exportStartLoc);}}break;}return node;}},{key:"parseSubscript",value:function parseSubscript(base,startLoc,noCalls,state){var node=_superPropGet(ESTreeParserMixin,"parseSubscript",this,3)([base,startLoc,noCalls,state]);if(state.optionalChainMember){if(node.type==="OptionalMemberExpression"||node.type==="OptionalCallExpression"){node.type=node.type.substring(8);}if(state.stop){var chain=this.startNodeAtNode(node);chain.expression=node;return this.finishNode(chain,"ChainExpression");}}else if(node.type==="MemberExpression"||node.type==="CallExpression"){node.optional=false;}return node;}},{key:"isOptionalMemberExpression",value:function isOptionalMemberExpression(node){if(node.type==="ChainExpression"){return node.expression.type==="MemberExpression";}return _superPropGet(ESTreeParserMixin,"isOptionalMemberExpression",this,3)([node]);}},{key:"hasPropertyAsPrivateName",value:function hasPropertyAsPrivateName(node){if(node.type==="ChainExpression"){node=node.expression;}return _superPropGet(ESTreeParserMixin,"hasPropertyAsPrivateName",this,3)([node]);}},{key:"isObjectProperty",value:function isObjectProperty(node){return node.type==="Property"&&node.kind==="init"&&!node.method;}},{key:"isObjectMethod",value:function isObjectMethod(node){return node.type==="Property"&&(node.method||node.kind==="get"||node.kind==="set");}},{key:"finishNodeAt",value:function finishNodeAt(node,type,endLoc){return toESTreeLocation(_superPropGet(ESTreeParserMixin,"finishNodeAt",this,3)([node,type,endLoc]));}},{key:"resetStartLocation",value:function resetStartLocation(node,startLoc){_superPropGet(ESTreeParserMixin,"resetStartLocation",this,3)([node,startLoc]);toESTreeLocation(node);}},{key:"resetEndLocation",value:function resetEndLocation(node){var endLoc=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.state.lastTokEndLoc;_superPropGet(ESTreeParserMixin,"resetEndLocation",this,3)([node,endLoc]);toESTreeLocation(node);}}]);}(superClass);};var TokContext=/*#__PURE__*/_createClass(function TokContext(token,preserveSpace){_classCallCheck(this,TokContext);this.token=void 0;this.preserveSpace=void 0;this.token=token;this.preserveSpace=!!preserveSpace;});var types={brace:new TokContext("{"),j_oTag:new TokContext("<tag"),j_cTag:new TokContext("</tag"),j_expr:new TokContext("<tag>...</tag>",true)};{types.template=new TokContext("`",true);}var beforeExpr=true;var startsExpr=true;var isLoop=true;var isAssign=true;var prefix=true;var postfix=true;var ExportedTokenType=/*#__PURE__*/_createClass(function ExportedTokenType(label){var conf=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,ExportedTokenType);this.label=void 0;this.keyword=void 0;this.beforeExpr=void 0;this.startsExpr=void 0;this.rightAssociative=void 0;this.isLoop=void 0;this.isAssign=void 0;this.prefix=void 0;this.postfix=void 0;this.binop=void 0;this.label=label;this.keyword=conf.keyword;this.beforeExpr=!!conf.beforeExpr;this.startsExpr=!!conf.startsExpr;this.rightAssociative=!!conf.rightAssociative;this.isLoop=!!conf.isLoop;this.isAssign=!!conf.isAssign;this.prefix=!!conf.prefix;this.postfix=!!conf.postfix;this.binop=conf.binop!=null?conf.binop:null;{this.updateContext=null;}});var keywords$1=new Map();function createKeyword(name){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};options.keyword=name;var token=createToken(name,options);keywords$1.set(name,token);return token;}function createBinop(name,binop){return createToken(name,{beforeExpr:beforeExpr,binop:binop});}var tokenTypeCounter=-1;var tokenTypes=[];var tokenLabels=[];var tokenBinops=[];var tokenBeforeExprs=[];var tokenStartsExprs=[];var tokenPrefixes=[];function createToken(name){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var _options$binop,_options$beforeExpr,_options$startsExpr,_options$prefix;++tokenTypeCounter;tokenLabels.push(name);tokenBinops.push((_options$binop=options.binop)!=null?_options$binop:-1);tokenBeforeExprs.push((_options$beforeExpr=options.beforeExpr)!=null?_options$beforeExpr:false);tokenStartsExprs.push((_options$startsExpr=options.startsExpr)!=null?_options$startsExpr:false);tokenPrefixes.push((_options$prefix=options.prefix)!=null?_options$prefix:false);tokenTypes.push(new ExportedTokenType(name,options));return tokenTypeCounter;}function createKeywordLike(name){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var _options$binop2,_options$beforeExpr2,_options$startsExpr2,_options$prefix2;++tokenTypeCounter;keywords$1.set(name,tokenTypeCounter);tokenLabels.push(name);tokenBinops.push((_options$binop2=options.binop)!=null?_options$binop2:-1);tokenBeforeExprs.push((_options$beforeExpr2=options.beforeExpr)!=null?_options$beforeExpr2:false);tokenStartsExprs.push((_options$startsExpr2=options.startsExpr)!=null?_options$startsExpr2:false);tokenPrefixes.push((_options$prefix2=options.prefix)!=null?_options$prefix2:false);tokenTypes.push(new ExportedTokenType("name",options));return tokenTypeCounter;}var tt={bracketL:createToken("[",{beforeExpr:beforeExpr,startsExpr:startsExpr}),bracketHashL:createToken("#[",{beforeExpr:beforeExpr,startsExpr:startsExpr}),bracketBarL:createToken("[|",{beforeExpr:beforeExpr,startsExpr:startsExpr}),bracketR:createToken("]"),bracketBarR:createToken("|]"),braceL:createToken("{",{beforeExpr:beforeExpr,startsExpr:startsExpr}),braceBarL:createToken("{|",{beforeExpr:beforeExpr,startsExpr:startsExpr}),braceHashL:createToken("#{",{beforeExpr:beforeExpr,startsExpr:startsExpr}),braceR:createToken("}"),braceBarR:createToken("|}"),parenL:createToken("(",{beforeExpr:beforeExpr,startsExpr:startsExpr}),parenR:createToken(")"),comma:createToken(",",{beforeExpr:beforeExpr}),semi:createToken(";",{beforeExpr:beforeExpr}),colon:createToken(":",{beforeExpr:beforeExpr}),doubleColon:createToken("::",{beforeExpr:beforeExpr}),dot:createToken("."),question:createToken("?",{beforeExpr:beforeExpr}),questionDot:createToken("?."),arrow:createToken("=>",{beforeExpr:beforeExpr}),template:createToken("template"),ellipsis:createToken("...",{beforeExpr:beforeExpr}),backQuote:createToken("`",{startsExpr:startsExpr}),dollarBraceL:createToken("${",{beforeExpr:beforeExpr,startsExpr:startsExpr}),templateTail:createToken("...`",{startsExpr:startsExpr}),templateNonTail:createToken("...${",{beforeExpr:beforeExpr,startsExpr:startsExpr}),at:createToken("@"),hash:createToken("#",{startsExpr:startsExpr}),interpreterDirective:createToken("#!..."),eq:createToken("=",{beforeExpr:beforeExpr,isAssign:isAssign}),assign:createToken("_=",{beforeExpr:beforeExpr,isAssign:isAssign}),slashAssign:createToken("_=",{beforeExpr:beforeExpr,isAssign:isAssign}),xorAssign:createToken("_=",{beforeExpr:beforeExpr,isAssign:isAssign}),moduloAssign:createToken("_=",{beforeExpr:beforeExpr,isAssign:isAssign}),incDec:createToken("++/--",{prefix:prefix,postfix:postfix,startsExpr:startsExpr}),bang:createToken("!",{beforeExpr:beforeExpr,prefix:prefix,startsExpr:startsExpr}),tilde:createToken("~",{beforeExpr:beforeExpr,prefix:prefix,startsExpr:startsExpr}),doubleCaret:createToken("^^",{startsExpr:startsExpr}),doubleAt:createToken("@@",{startsExpr:startsExpr}),pipeline:createBinop("|>",0),nullishCoalescing:createBinop("??",1),logicalOR:createBinop("||",1),logicalAND:createBinop("&&",2),bitwiseOR:createBinop("|",3),bitwiseXOR:createBinop("^",4),bitwiseAND:createBinop("&",5),equality:createBinop("==/!=/===/!==",6),lt:createBinop("</>/<=/>=",7),gt:createBinop("</>/<=/>=",7),relational:createBinop("</>/<=/>=",7),bitShift:createBinop("<</>>/>>>",8),bitShiftL:createBinop("<</>>/>>>",8),bitShiftR:createBinop("<</>>/>>>",8),plusMin:createToken("+/-",{beforeExpr:beforeExpr,binop:9,prefix:prefix,startsExpr:startsExpr}),modulo:createToken("%",{binop:10,startsExpr:startsExpr}),star:createToken("*",{binop:10}),slash:createBinop("/",10),exponent:createToken("**",{beforeExpr:beforeExpr,binop:11,rightAssociative:true}),_in:createKeyword("in",{beforeExpr:beforeExpr,binop:7}),_instanceof:createKeyword("instanceof",{beforeExpr:beforeExpr,binop:7}),_break:createKeyword("break"),_case:createKeyword("case",{beforeExpr:beforeExpr}),_catch:createKeyword("catch"),_continue:createKeyword("continue"),_debugger:createKeyword("debugger"),_default:createKeyword("default",{beforeExpr:beforeExpr}),_else:createKeyword("else",{beforeExpr:beforeExpr}),_finally:createKeyword("finally"),_function:createKeyword("function",{startsExpr:startsExpr}),_if:createKeyword("if"),_return:createKeyword("return",{beforeExpr:beforeExpr}),_switch:createKeyword("switch"),_throw:createKeyword("throw",{beforeExpr:beforeExpr,prefix:prefix,startsExpr:startsExpr}),_try:createKeyword("try"),_var:createKeyword("var"),_const:createKeyword("const"),_with:createKeyword("with"),_new:createKeyword("new",{beforeExpr:beforeExpr,startsExpr:startsExpr}),_this:createKeyword("this",{startsExpr:startsExpr}),_super:createKeyword("super",{startsExpr:startsExpr}),_class:createKeyword("class",{startsExpr:startsExpr}),_extends:createKeyword("extends",{beforeExpr:beforeExpr}),_export:createKeyword("export"),_import:createKeyword("import",{startsExpr:startsExpr}),_null:createKeyword("null",{startsExpr:startsExpr}),_true:createKeyword("true",{startsExpr:startsExpr}),_false:createKeyword("false",{startsExpr:startsExpr}),_typeof:createKeyword("typeof",{beforeExpr:beforeExpr,prefix:prefix,startsExpr:startsExpr}),_void:createKeyword("void",{beforeExpr:beforeExpr,prefix:prefix,startsExpr:startsExpr}),_delete:createKeyword("delete",{beforeExpr:beforeExpr,prefix:prefix,startsExpr:startsExpr}),_do:createKeyword("do",{isLoop:isLoop,beforeExpr:beforeExpr}),_for:createKeyword("for",{isLoop:isLoop}),_while:createKeyword("while",{isLoop:isLoop}),_as:createKeywordLike("as",{startsExpr:startsExpr}),_assert:createKeywordLike("assert",{startsExpr:startsExpr}),_async:createKeywordLike("async",{startsExpr:startsExpr}),_await:createKeywordLike("await",{startsExpr:startsExpr}),_defer:createKeywordLike("defer",{startsExpr:startsExpr}),_from:createKeywordLike("from",{startsExpr:startsExpr}),_get:createKeywordLike("get",{startsExpr:startsExpr}),_let:createKeywordLike("let",{startsExpr:startsExpr}),_meta:createKeywordLike("meta",{startsExpr:startsExpr}),_of:createKeywordLike("of",{startsExpr:startsExpr}),_sent:createKeywordLike("sent",{startsExpr:startsExpr}),_set:createKeywordLike("set",{startsExpr:startsExpr}),_source:createKeywordLike("source",{startsExpr:startsExpr}),_static:createKeywordLike("static",{startsExpr:startsExpr}),_using:createKeywordLike("using",{startsExpr:startsExpr}),_yield:createKeywordLike("yield",{startsExpr:startsExpr}),_asserts:createKeywordLike("asserts",{startsExpr:startsExpr}),_checks:createKeywordLike("checks",{startsExpr:startsExpr}),_exports:createKeywordLike("exports",{startsExpr:startsExpr}),_global:createKeywordLike("global",{startsExpr:startsExpr}),_implements:createKeywordLike("implements",{startsExpr:startsExpr}),_intrinsic:createKeywordLike("intrinsic",{startsExpr:startsExpr}),_infer:createKeywordLike("infer",{startsExpr:startsExpr}),_is:createKeywordLike("is",{startsExpr:startsExpr}),_mixins:createKeywordLike("mixins",{startsExpr:startsExpr}),_proto:createKeywordLike("proto",{startsExpr:startsExpr}),_require:createKeywordLike("require",{startsExpr:startsExpr}),_satisfies:createKeywordLike("satisfies",{startsExpr:startsExpr}),_keyof:createKeywordLike("keyof",{startsExpr:startsExpr}),_readonly:createKeywordLike("readonly",{startsExpr:startsExpr}),_unique:createKeywordLike("unique",{startsExpr:startsExpr}),_abstract:createKeywordLike("abstract",{startsExpr:startsExpr}),_declare:createKeywordLike("declare",{startsExpr:startsExpr}),_enum:createKeywordLike("enum",{startsExpr:startsExpr}),_module:createKeywordLike("module",{startsExpr:startsExpr}),_namespace:createKeywordLike("namespace",{startsExpr:startsExpr}),_interface:createKeywordLike("interface",{startsExpr:startsExpr}),_type:createKeywordLike("type",{startsExpr:startsExpr}),_opaque:createKeywordLike("opaque",{startsExpr:startsExpr}),name:createToken("name",{startsExpr:startsExpr}),placeholder:createToken("%%",{startsExpr:true}),string:createToken("string",{startsExpr:startsExpr}),num:createToken("num",{startsExpr:startsExpr}),bigint:createToken("bigint",{startsExpr:startsExpr}),decimal:createToken("decimal",{startsExpr:startsExpr}),regexp:createToken("regexp",{startsExpr:startsExpr}),privateName:createToken("#name",{startsExpr:startsExpr}),eof:createToken("eof"),jsxName:createToken("jsxName"),jsxText:createToken("jsxText",{beforeExpr:true}),jsxTagStart:createToken("jsxTagStart",{startsExpr:true}),jsxTagEnd:createToken("jsxTagEnd")};function tokenIsIdentifier(token){return token>=93&&token<=133;}function tokenKeywordOrIdentifierIsKeyword(token){return token<=92;}function tokenIsKeywordOrIdentifier(token){return token>=58&&token<=133;}function tokenIsLiteralPropertyName(token){return token>=58&&token<=137;}function tokenComesBeforeExpression(token){return tokenBeforeExprs[token];}function tokenCanStartExpression(token){return tokenStartsExprs[token];}function tokenIsAssignment(token){return token>=29&&token<=33;}function tokenIsFlowInterfaceOrTypeOrOpaque(token){return token>=129&&token<=131;}function tokenIsLoop(token){return token>=90&&token<=92;}function tokenIsKeyword(token){return token>=58&&token<=92;}function tokenIsOperator(token){return token>=39&&token<=59;}function tokenIsPostfix(token){return token===34;}function tokenIsPrefix(token){return tokenPrefixes[token];}function tokenIsTSTypeOperator(token){return token>=121&&token<=123;}function tokenIsTSDeclarationStart(token){return token>=124&&token<=130;}function tokenLabelName(token){return tokenLabels[token];}function tokenOperatorPrecedence(token){return tokenBinops[token];}function tokenIsRightAssociative(token){return token===57;}function tokenIsTemplate(token){return token>=24&&token<=25;}function getExportedToken(token){return tokenTypes[token];}{tokenTypes[8].updateContext=function(context){context.pop();};tokenTypes[5].updateContext=tokenTypes[7].updateContext=tokenTypes[23].updateContext=function(context){context.push(types.brace);};tokenTypes[22].updateContext=function(context){if(context[context.length-1]===types.template){context.pop();}else {context.push(types.template);}};tokenTypes[143].updateContext=function(context){context.push(types.j_expr,types.j_oTag);};}var nonASCIIidentifierStartChars="\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";var nonASCIIidentifierChars="\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";var nonASCIIidentifierStart=new RegExp("["+nonASCIIidentifierStartChars+"]");var nonASCIIidentifier=new RegExp("["+nonASCIIidentifierStartChars+nonASCIIidentifierChars+"]");nonASCIIidentifierStartChars=nonASCIIidentifierChars=null;var astralIdentifierStartCodes=[0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,13,10,2,14,2,6,2,1,2,10,2,14,2,6,2,1,4,51,13,310,10,21,11,7,25,5,2,41,2,8,70,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,39,27,10,22,251,41,7,1,17,2,60,28,11,0,9,21,43,17,47,20,28,22,13,52,58,1,3,0,14,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,20,1,64,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,31,9,2,0,3,0,2,37,2,0,26,0,2,0,45,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,38,6,186,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,19,72,200,32,32,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,16,0,2,12,2,33,125,0,80,921,103,110,18,195,2637,96,16,1071,18,5,26,3994,6,582,6842,29,1763,568,8,30,18,78,18,29,19,47,17,3,32,20,6,18,433,44,212,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,42,9,8936,3,2,6,2,1,2,290,16,0,30,2,3,0,15,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,1845,30,7,5,262,61,147,44,11,6,17,0,322,29,19,43,485,27,229,29,3,0,496,6,2,3,2,1,2,14,2,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42719,33,4153,7,221,3,5761,15,7472,16,621,2467,541,1507,4938,6,4191];var astralIdentifierCodes=[509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,7,9,32,4,318,1,80,3,71,10,50,3,123,2,54,14,32,10,3,1,11,3,46,10,8,0,46,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,3,0,158,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,68,8,2,0,3,0,2,3,2,4,2,0,15,1,83,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,7,19,58,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,343,9,54,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,10,1,2,0,49,6,4,4,14,10,5350,0,7,14,11465,27,2343,9,87,9,39,4,60,6,26,9,535,9,470,0,2,54,8,3,82,0,12,1,19628,1,4178,9,519,45,3,22,543,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,101,0,161,6,10,9,357,0,62,13,499,13,245,1,2,9,726,6,110,6,6,9,4759,9,787719,239];function isInAstralSet(code,set){var pos=0x10000;for(var i=0,length=set.length;i<length;i+=2){pos+=set[i];if(pos>code)return false;pos+=set[i+1];if(pos>=code)return true;}return false;}function isIdentifierStart(code){if(code<65)return code===36;if(code<=90)return true;if(code<97)return code===95;if(code<=122)return true;if(code<=0xffff){return code>=0xaa&&nonASCIIidentifierStart.test(String.fromCharCode(code));}return isInAstralSet(code,astralIdentifierStartCodes);}function isIdentifierChar(code){if(code<48)return code===36;if(code<58)return true;if(code<65)return false;if(code<=90)return true;if(code<97)return code===95;if(code<=122)return true;if(code<=0xffff){return code>=0xaa&&nonASCIIidentifier.test(String.fromCharCode(code));}return isInAstralSet(code,astralIdentifierStartCodes)||isInAstralSet(code,astralIdentifierCodes);}var reservedWords={keyword:["break","case","catch","continue","debugger","default","do","else","finally","for","function","if","return","switch","throw","try","var","const","while","with","new","this","super","class","extends","export","import","null","true","false","in","instanceof","typeof","void","delete"],strict:["implements","interface","let","package","private","protected","public","static","yield"],strictBind:["eval","arguments"]};var keywords=new Set(reservedWords.keyword);var reservedWordsStrictSet=new Set(reservedWords.strict);var reservedWordsStrictBindSet=new Set(reservedWords.strictBind);function isReservedWord(word,inModule){return inModule&&word==="await"||word==="enum";}function isStrictReservedWord(word,inModule){return isReservedWord(word,inModule)||reservedWordsStrictSet.has(word);}function isStrictBindOnlyReservedWord(word){return reservedWordsStrictBindSet.has(word);}function isStrictBindReservedWord(word,inModule){return isStrictReservedWord(word,inModule)||isStrictBindOnlyReservedWord(word);}function isKeyword(word){return keywords.has(word);}function isIteratorStart(current,next,next2){return current===64&&next===64&&isIdentifierStart(next2);}var reservedWordLikeSet=new Set(["break","case","catch","continue","debugger","default","do","else","finally","for","function","if","return","switch","throw","try","var","const","while","with","new","this","super","class","extends","export","import","null","true","false","in","instanceof","typeof","void","delete","implements","interface","let","package","private","protected","public","static","yield","eval","arguments","enum","await"]);function canBeReservedWord(word){return reservedWordLikeSet.has(word);}var Scope=/*#__PURE__*/_createClass(function Scope(flags){_classCallCheck(this,Scope);this.flags=0;this.names=new Map();this.firstLexicalName="";this.flags=flags;});var ScopeHandler=/*#__PURE__*/function(){function ScopeHandler(parser,inModule){_classCallCheck(this,ScopeHandler);this.parser=void 0;this.scopeStack=[];this.inModule=void 0;this.undefinedExports=new Map();this.parser=parser;this.inModule=inModule;}return _createClass(ScopeHandler,[{key:"inTopLevel",get:function get(){return (this.currentScope().flags&1)>0;}},{key:"inFunction",get:function get(){return (this.currentVarScopeFlags()&2)>0;}},{key:"allowSuper",get:function get(){return (this.currentThisScopeFlags()&16)>0;}},{key:"allowDirectSuper",get:function get(){return (this.currentThisScopeFlags()&32)>0;}},{key:"inClass",get:function get(){return (this.currentThisScopeFlags()&64)>0;}},{key:"inClassAndNotInNonArrowFunction",get:function get(){var flags=this.currentThisScopeFlags();return (flags&64)>0&&(flags&2)===0;}},{key:"inStaticBlock",get:function get(){for(var i=this.scopeStack.length-1;;i--){var flags=this.scopeStack[i].flags;if(flags&128){return true;}if(flags&(387|64)){return false;}}}},{key:"inNonArrowFunction",get:function get(){return (this.currentThisScopeFlags()&2)>0;}},{key:"treatFunctionsAsVar",get:function get(){return this.treatFunctionsAsVarInScope(this.currentScope());}},{key:"createScope",value:function createScope(flags){return new Scope(flags);}},{key:"enter",value:function enter(flags){this.scopeStack.push(this.createScope(flags));}},{key:"exit",value:function exit(){var scope=this.scopeStack.pop();return scope.flags;}},{key:"treatFunctionsAsVarInScope",value:function treatFunctionsAsVarInScope(scope){return !!(scope.flags&(2|128)||!this.parser.inModule&&scope.flags&1);}},{key:"declareName",value:function declareName(name,bindingType,loc){var scope=this.currentScope();if(bindingType&8||bindingType&16){this.checkRedeclarationInScope(scope,name,bindingType,loc);var type=scope.names.get(name)||0;if(bindingType&16){type=type|4;}else {if(!scope.firstLexicalName){scope.firstLexicalName=name;}type=type|2;}scope.names.set(name,type);if(bindingType&8){this.maybeExportDefined(scope,name);}}else if(bindingType&4){for(var i=this.scopeStack.length-1;i>=0;--i){scope=this.scopeStack[i];this.checkRedeclarationInScope(scope,name,bindingType,loc);scope.names.set(name,(scope.names.get(name)||0)|1);this.maybeExportDefined(scope,name);if(scope.flags&387)break;}}if(this.parser.inModule&&scope.flags&1){this.undefinedExports["delete"](name);}}},{key:"maybeExportDefined",value:function maybeExportDefined(scope,name){if(this.parser.inModule&&scope.flags&1){this.undefinedExports["delete"](name);}}},{key:"checkRedeclarationInScope",value:function checkRedeclarationInScope(scope,name,bindingType,loc){if(this.isRedeclaredInScope(scope,name,bindingType)){this.parser.raise(Errors.VarRedeclaration,loc,{identifierName:name});}}},{key:"isRedeclaredInScope",value:function isRedeclaredInScope(scope,name,bindingType){if(!(bindingType&1))return false;if(bindingType&8){return scope.names.has(name);}var type=scope.names.get(name);if(bindingType&16){return (type&2)>0||!this.treatFunctionsAsVarInScope(scope)&&(type&1)>0;}return (type&2)>0&&!(scope.flags&8&&scope.firstLexicalName===name)||!this.treatFunctionsAsVarInScope(scope)&&(type&4)>0;}},{key:"checkLocalExport",value:function checkLocalExport(id){var name=id.name;var topLevelScope=this.scopeStack[0];if(!topLevelScope.names.has(name)){this.undefinedExports.set(name,id.loc.start);}}},{key:"currentScope",value:function currentScope(){return this.scopeStack[this.scopeStack.length-1];}},{key:"currentVarScopeFlags",value:function currentVarScopeFlags(){for(var i=this.scopeStack.length-1;;i--){var flags=this.scopeStack[i].flags;if(flags&387){return flags;}}}},{key:"currentThisScopeFlags",value:function currentThisScopeFlags(){for(var i=this.scopeStack.length-1;;i--){var flags=this.scopeStack[i].flags;if(flags&(387|64)&&!(flags&4)){return flags;}}}}]);}();var FlowScope=/*#__PURE__*/function(_Scope){function FlowScope(){var _this3;_classCallCheck(this,FlowScope);for(var _len3=arguments.length,args=new Array(_len3),_key3=0;_key3<_len3;_key3++){args[_key3]=arguments[_key3];}_this3=_callSuper(this,FlowScope,[].concat(args));_this3.declareFunctions=new Set();return _this3;}_inherits(FlowScope,_Scope);return _createClass(FlowScope);}(Scope);var FlowScopeHandler=/*#__PURE__*/function(_ScopeHandler){function FlowScopeHandler(){_classCallCheck(this,FlowScopeHandler);return _callSuper(this,FlowScopeHandler,arguments);}_inherits(FlowScopeHandler,_ScopeHandler);return _createClass(FlowScopeHandler,[{key:"createScope",value:function createScope(flags){return new FlowScope(flags);}},{key:"declareName",value:function declareName(name,bindingType,loc){var scope=this.currentScope();if(bindingType&2048){this.checkRedeclarationInScope(scope,name,bindingType,loc);this.maybeExportDefined(scope,name);scope.declareFunctions.add(name);return;}_superPropGet(FlowScopeHandler,"declareName",this,3)([name,bindingType,loc]);}},{key:"isRedeclaredInScope",value:function isRedeclaredInScope(scope,name,bindingType){if(_superPropGet(FlowScopeHandler,"isRedeclaredInScope",this,3)([scope,name,bindingType]))return true;if(bindingType&2048&&!scope.declareFunctions.has(name)){var type=scope.names.get(name);return (type&4)>0||(type&2)>0;}return false;}},{key:"checkLocalExport",value:function checkLocalExport(id){if(!this.scopeStack[0].declareFunctions.has(id.name)){_superPropGet(FlowScopeHandler,"checkLocalExport",this,3)([id]);}}}]);}(ScopeHandler);var BaseParser=/*#__PURE__*/function(){function BaseParser(){_classCallCheck(this,BaseParser);this.sawUnambiguousESM=false;this.ambiguousScriptDifferentAst=false;}return _createClass(BaseParser,[{key:"sourceToOffsetPos",value:function sourceToOffsetPos(sourcePos){return sourcePos+this.startIndex;}},{key:"offsetToSourcePos",value:function offsetToSourcePos(offsetPos){return offsetPos-this.startIndex;}},{key:"hasPlugin",value:function hasPlugin(pluginConfig){if(typeof pluginConfig==="string"){return this.plugins.has(pluginConfig);}else {var _pluginConfig=_slicedToArray(pluginConfig,2),pluginName=_pluginConfig[0],pluginOptions=_pluginConfig[1];if(!this.hasPlugin(pluginName)){return false;}var actualOptions=this.plugins.get(pluginName);for(var _i3=0,_Object$keys3=Object.keys(pluginOptions);_i3<_Object$keys3.length;_i3++){var key=_Object$keys3[_i3];if((actualOptions==null?void 0:actualOptions[key])!==pluginOptions[key]){return false;}}return true;}}},{key:"getPluginOption",value:function getPluginOption(plugin,name){var _this$plugins$get;return (_this$plugins$get=this.plugins.get(plugin))==null?void 0:_this$plugins$get[name];}}]);}();function setTrailingComments(node,comments){if(node.trailingComments===undefined){node.trailingComments=comments;}else {var _node$trailingComment;(_node$trailingComment=node.trailingComments).unshift.apply(_node$trailingComment,_toConsumableArray(comments));}}function setLeadingComments(node,comments){if(node.leadingComments===undefined){node.leadingComments=comments;}else {var _node$leadingComments;(_node$leadingComments=node.leadingComments).unshift.apply(_node$leadingComments,_toConsumableArray(comments));}}function setInnerComments(node,comments){if(node.innerComments===undefined){node.innerComments=comments;}else {var _node$innerComments;(_node$innerComments=node.innerComments).unshift.apply(_node$innerComments,_toConsumableArray(comments));}}function adjustInnerComments(node,elements,commentWS){var lastElement=null;var i=elements.length;while(lastElement===null&&i>0){lastElement=elements[--i];}if(lastElement===null||lastElement.start>commentWS.start){setInnerComments(node,commentWS.comments);}else {setTrailingComments(lastElement,commentWS.comments);}}var CommentsParser=/*#__PURE__*/function(_BaseParser){function CommentsParser(){_classCallCheck(this,CommentsParser);return _callSuper(this,CommentsParser,arguments);}_inherits(CommentsParser,_BaseParser);return _createClass(CommentsParser,[{key:"addComment",value:function addComment(comment){if(this.filename)comment.loc.filename=this.filename;var commentsLen=this.state.commentsLen;if(this.comments.length!==commentsLen){this.comments.length=commentsLen;}this.comments.push(comment);this.state.commentsLen++;}},{key:"processComment",value:function processComment(node){var commentStack=this.state.commentStack;var commentStackLength=commentStack.length;if(commentStackLength===0)return;var i=commentStackLength-1;var lastCommentWS=commentStack[i];if(lastCommentWS.start===node.end){lastCommentWS.leadingNode=node;i--;}var nodeStart=node.start;for(;i>=0;i--){var commentWS=commentStack[i];var commentEnd=commentWS.end;if(commentEnd>nodeStart){commentWS.containingNode=node;this.finalizeComment(commentWS);commentStack.splice(i,1);}else {if(commentEnd===nodeStart){commentWS.trailingNode=node;}break;}}}},{key:"finalizeComment",value:function finalizeComment(commentWS){var comments=commentWS.comments;if(commentWS.leadingNode!==null||commentWS.trailingNode!==null){if(commentWS.leadingNode!==null){setTrailingComments(commentWS.leadingNode,comments);}if(commentWS.trailingNode!==null){setLeadingComments(commentWS.trailingNode,comments);}}else {var node=commentWS.containingNode,commentStart=commentWS.start;if(this.input.charCodeAt(this.offsetToSourcePos(commentStart)-1)===44){switch(node.type){case "ObjectExpression":case "ObjectPattern":case "RecordExpression":adjustInnerComments(node,node.properties,commentWS);break;case "CallExpression":case "OptionalCallExpression":adjustInnerComments(node,node.arguments,commentWS);break;case "FunctionDeclaration":case "FunctionExpression":case "ArrowFunctionExpression":case "ObjectMethod":case "ClassMethod":case "ClassPrivateMethod":adjustInnerComments(node,node.params,commentWS);break;case "ArrayExpression":case "ArrayPattern":case "TupleExpression":adjustInnerComments(node,node.elements,commentWS);break;case "ExportNamedDeclaration":case "ImportDeclaration":adjustInnerComments(node,node.specifiers,commentWS);break;case "TSEnumDeclaration":{adjustInnerComments(node,node.members,commentWS);}break;case "TSEnumBody":adjustInnerComments(node,node.members,commentWS);break;default:{setInnerComments(node,comments);}}}else {setInnerComments(node,comments);}}}},{key:"finalizeRemainingComments",value:function finalizeRemainingComments(){var commentStack=this.state.commentStack;for(var i=commentStack.length-1;i>=0;i--){this.finalizeComment(commentStack[i]);}this.state.commentStack=[];}},{key:"resetPreviousNodeTrailingComments",value:function resetPreviousNodeTrailingComments(node){var commentStack=this.state.commentStack;var length=commentStack.length;if(length===0)return;var commentWS=commentStack[length-1];if(commentWS.leadingNode===node){commentWS.leadingNode=null;}}},{key:"resetPreviousIdentifierLeadingComments",value:function resetPreviousIdentifierLeadingComments(node){var commentStack=this.state.commentStack;var length=commentStack.length;if(length===0)return;if(commentStack[length-1].trailingNode===node){commentStack[length-1].trailingNode=null;}else if(length>=2&&commentStack[length-2].trailingNode===node){commentStack[length-2].trailingNode=null;}}},{key:"takeSurroundingComments",value:function takeSurroundingComments(node,start,end){var commentStack=this.state.commentStack;var commentStackLength=commentStack.length;if(commentStackLength===0)return;var i=commentStackLength-1;for(;i>=0;i--){var commentWS=commentStack[i];var commentEnd=commentWS.end;var commentStart=commentWS.start;if(commentStart===end){commentWS.leadingNode=node;}else if(commentEnd===start){commentWS.trailingNode=node;}else if(commentEnd<start){break;}}}}]);}(BaseParser);var lineBreak=/\r\n|[\r\n\u2028\u2029]/;var lineBreakG=new RegExp(lineBreak.source,"g");function isNewLine(code){switch(code){case 10:case 13:case 8232:case 8233:return true;default:return false;}}function hasNewLine(input,start,end){for(var i=start;i<end;i++){if(isNewLine(input.charCodeAt(i))){return true;}}return false;}var skipWhiteSpace=/(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;var skipWhiteSpaceInLine=/(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;function isWhitespace(code){switch(code){case 0x0009:case 0x000b:case 0x000c:case 32:case 160:case 5760:case 0x2000:case 0x2001:case 0x2002:case 0x2003:case 0x2004:case 0x2005:case 0x2006:case 0x2007:case 0x2008:case 0x2009:case 0x200a:case 0x202f:case 0x205f:case 0x3000:case 0xfeff:return true;default:return false;}}var State=/*#__PURE__*/function(){function State(){_classCallCheck(this,State);this.flags=1024;this.startIndex=void 0;this.curLine=void 0;this.lineStart=void 0;this.startLoc=void 0;this.endLoc=void 0;this.errors=[];this.potentialArrowAt=-1;this.noArrowAt=[];this.noArrowParamsConversionAt=[];this.topicContext={maxNumOfResolvableTopics:0,maxTopicIndex:null};this.labels=[];this.commentsLen=0;this.commentStack=[];this.pos=0;this.type=140;this.value=null;this.start=0;this.end=0;this.lastTokEndLoc=null;this.lastTokStartLoc=null;this.context=[types.brace];this.firstInvalidTemplateEscapePos=null;this.strictErrors=new Map();this.tokensLength=0;}return _createClass(State,[{key:"strict",get:function get(){return (this.flags&1)>0;},set:function set(v){if(v)this.flags|=1;else this.flags&=-2;}},{key:"init",value:function init(_ref39){var strictMode=_ref39.strictMode,sourceType=_ref39.sourceType,startIndex=_ref39.startIndex,startLine=_ref39.startLine,startColumn=_ref39.startColumn;this.strict=strictMode===false?false:strictMode===true?true:sourceType==="module";this.startIndex=startIndex;this.curLine=startLine;this.lineStart=-startColumn;this.startLoc=this.endLoc=new Position(startLine,startColumn,startIndex);}},{key:"maybeInArrowParameters",get:function get(){return (this.flags&2)>0;},set:function set(v){if(v)this.flags|=2;else this.flags&=-3;}},{key:"inType",get:function get(){return (this.flags&4)>0;},set:function set(v){if(v)this.flags|=4;else this.flags&=-5;}},{key:"noAnonFunctionType",get:function get(){return (this.flags&8)>0;},set:function set(v){if(v)this.flags|=8;else this.flags&=-9;}},{key:"hasFlowComment",get:function get(){return (this.flags&16)>0;},set:function set(v){if(v)this.flags|=16;else this.flags&=-17;}},{key:"isAmbientContext",get:function get(){return (this.flags&32)>0;},set:function set(v){if(v)this.flags|=32;else this.flags&=-33;}},{key:"inAbstractClass",get:function get(){return (this.flags&64)>0;},set:function set(v){if(v)this.flags|=64;else this.flags&=-65;}},{key:"inDisallowConditionalTypesContext",get:function get(){return (this.flags&128)>0;},set:function set(v){if(v)this.flags|=128;else this.flags&=-129;}},{key:"soloAwait",get:function get(){return (this.flags&256)>0;},set:function set(v){if(v)this.flags|=256;else this.flags&=-257;}},{key:"inFSharpPipelineDirectBody",get:function get(){return (this.flags&512)>0;},set:function set(v){if(v)this.flags|=512;else this.flags&=-513;}},{key:"canStartJSXElement",get:function get(){return (this.flags&1024)>0;},set:function set(v){if(v)this.flags|=1024;else this.flags&=-1025;}},{key:"containsEsc",get:function get(){return (this.flags&2048)>0;},set:function set(v){if(v)this.flags|=2048;else this.flags&=-2049;}},{key:"hasTopLevelAwait",get:function get(){return (this.flags&4096)>0;},set:function set(v){if(v)this.flags|=4096;else this.flags&=-4097;}},{key:"curPosition",value:function curPosition(){return new Position(this.curLine,this.pos-this.lineStart,this.pos+this.startIndex);}},{key:"clone",value:function clone(){var state=new State();state.flags=this.flags;state.startIndex=this.startIndex;state.curLine=this.curLine;state.lineStart=this.lineStart;state.startLoc=this.startLoc;state.endLoc=this.endLoc;state.errors=this.errors.slice();state.potentialArrowAt=this.potentialArrowAt;state.noArrowAt=this.noArrowAt.slice();state.noArrowParamsConversionAt=this.noArrowParamsConversionAt.slice();state.topicContext=this.topicContext;state.labels=this.labels.slice();state.commentsLen=this.commentsLen;state.commentStack=this.commentStack.slice();state.pos=this.pos;state.type=this.type;state.value=this.value;state.start=this.start;state.end=this.end;state.lastTokEndLoc=this.lastTokEndLoc;state.lastTokStartLoc=this.lastTokStartLoc;state.context=this.context.slice();state.firstInvalidTemplateEscapePos=this.firstInvalidTemplateEscapePos;state.strictErrors=this.strictErrors;state.tokensLength=this.tokensLength;return state;}}]);}();var _isDigit=function isDigit(code){return code>=48&&code<=57;};var forbiddenNumericSeparatorSiblings={decBinOct:new Set([46,66,69,79,95,98,101,111]),hex:new Set([46,88,95,120])};var isAllowedNumericSeparatorSibling={bin:function bin(ch){return ch===48||ch===49;},oct:function oct(ch){return ch>=48&&ch<=55;},dec:function dec(ch){return ch>=48&&ch<=57;},hex:function hex(ch){return ch>=48&&ch<=57||ch>=65&&ch<=70||ch>=97&&ch<=102;}};function readStringContents(type,input,pos,lineStart,curLine,errors){var initialPos=pos;var initialLineStart=lineStart;var initialCurLine=curLine;var out="";var firstInvalidLoc=null;var chunkStart=pos;var length=input.length;for(;;){if(pos>=length){errors.unterminated(initialPos,initialLineStart,initialCurLine);out+=input.slice(chunkStart,pos);break;}var ch=input.charCodeAt(pos);if(isStringEnd(type,ch,input,pos)){out+=input.slice(chunkStart,pos);break;}if(ch===92){out+=input.slice(chunkStart,pos);var res=readEscapedChar(input,pos,lineStart,curLine,type==="template",errors);if(res.ch===null&&!firstInvalidLoc){firstInvalidLoc={pos:pos,lineStart:lineStart,curLine:curLine};}else {out+=res.ch;}pos=res.pos;lineStart=res.lineStart;curLine=res.curLine;chunkStart=pos;}else if(ch===8232||ch===8233){++pos;++curLine;lineStart=pos;}else if(ch===10||ch===13){if(type==="template"){out+=input.slice(chunkStart,pos)+"\n";++pos;if(ch===13&&input.charCodeAt(pos)===10){++pos;}++curLine;chunkStart=lineStart=pos;}else {errors.unterminated(initialPos,initialLineStart,initialCurLine);}}else {++pos;}}return {pos:pos,str:out,firstInvalidLoc:firstInvalidLoc,lineStart:lineStart,curLine:curLine,containsInvalid:!!firstInvalidLoc};}function isStringEnd(type,ch,input,pos){if(type==="template"){return ch===96||ch===36&&input.charCodeAt(pos+1)===123;}return ch===(type==="double"?34:39);}function readEscapedChar(input,pos,lineStart,curLine,inTemplate,errors){var throwOnInvalid=!inTemplate;pos++;var res=function res(ch){return {pos:pos,ch:ch,lineStart:lineStart,curLine:curLine};};var ch=input.charCodeAt(pos++);switch(ch){case 110:return res("\n");case 114:return res("\r");case 120:{var _code;var _readHexChar=readHexChar(input,pos,lineStart,curLine,2,false,throwOnInvalid,errors);_code=_readHexChar.code;pos=_readHexChar.pos;return res(_code===null?null:String.fromCharCode(_code));}case 117:{var _code2;var _readCodePoint=_readCodePoint2(input,pos,lineStart,curLine,throwOnInvalid,errors);_code2=_readCodePoint.code;pos=_readCodePoint.pos;return res(_code2===null?null:String.fromCodePoint(_code2));}case 116:return res("\t");case 98:return res("\b");case 118:return res("\x0B");case 102:return res("\f");case 13:if(input.charCodeAt(pos)===10){++pos;}case 10:lineStart=pos;++curLine;case 8232:case 8233:return res("");case 56:case 57:if(inTemplate){return res(null);}else {errors.strictNumericEscape(pos-1,lineStart,curLine);}default:if(ch>=48&&ch<=55){var startPos=pos-1;var match=/^[0-7]+/.exec(input.slice(startPos,pos+2));var octalStr=match[0];var octal=parseInt(octalStr,8);if(octal>255){octalStr=octalStr.slice(0,-1);octal=parseInt(octalStr,8);}pos+=octalStr.length-1;var next=input.charCodeAt(pos);if(octalStr!=="0"||next===56||next===57){if(inTemplate){return res(null);}else {errors.strictNumericEscape(startPos,lineStart,curLine);}}return res(String.fromCharCode(octal));}return res(String.fromCharCode(ch));}}function readHexChar(input,pos,lineStart,curLine,len,forceLen,throwOnInvalid,errors){var initialPos=pos;var n;var _readInt=_readInt2(input,pos,lineStart,curLine,16,len,forceLen,false,errors,!throwOnInvalid);n=_readInt.n;pos=_readInt.pos;if(n===null){if(throwOnInvalid){errors.invalidEscapeSequence(initialPos,lineStart,curLine);}else {pos=initialPos-1;}}return {code:n,pos:pos};}function _readInt2(input,pos,lineStart,curLine,radix,len,forceLen,allowNumSeparator,errors,bailOnError){var start=pos;var forbiddenSiblings=radix===16?forbiddenNumericSeparatorSiblings.hex:forbiddenNumericSeparatorSiblings.decBinOct;var isAllowedSibling=radix===16?isAllowedNumericSeparatorSibling.hex:radix===10?isAllowedNumericSeparatorSibling.dec:radix===8?isAllowedNumericSeparatorSibling.oct:isAllowedNumericSeparatorSibling.bin;var invalid=false;var total=0;for(var i=0,e=len==null?Infinity:len;i<e;++i){var _code3=input.charCodeAt(pos);var val=void 0;if(_code3===95&&allowNumSeparator!=="bail"){var prev=input.charCodeAt(pos-1);var next=input.charCodeAt(pos+1);if(!allowNumSeparator){if(bailOnError)return {n:null,pos:pos};errors.numericSeparatorInEscapeSequence(pos,lineStart,curLine);}else if(Number.isNaN(next)||!isAllowedSibling(next)||forbiddenSiblings.has(prev)||forbiddenSiblings.has(next)){if(bailOnError)return {n:null,pos:pos};errors.unexpectedNumericSeparator(pos,lineStart,curLine);}++pos;continue;}if(_code3>=97){val=_code3-97+10;}else if(_code3>=65){val=_code3-65+10;}else if(_isDigit(_code3)){val=_code3-48;}else {val=Infinity;}if(val>=radix){if(val<=9&&bailOnError){return {n:null,pos:pos};}else if(val<=9&&errors.invalidDigit(pos,lineStart,curLine,radix)){val=0;}else if(forceLen){val=0;invalid=true;}else {break;}}++pos;total=total*radix+val;}if(pos===start||len!=null&&pos-start!==len||invalid){return {n:null,pos:pos};}return {n:total,pos:pos};}function _readCodePoint2(input,pos,lineStart,curLine,throwOnInvalid,errors){var ch=input.charCodeAt(pos);var code;if(ch===123){++pos;var _readHexChar2=readHexChar(input,pos,lineStart,curLine,input.indexOf("}",pos)-pos,true,throwOnInvalid,errors);code=_readHexChar2.code;pos=_readHexChar2.pos;++pos;if(code!==null&&code>0x10ffff){if(throwOnInvalid){errors.invalidCodePoint(pos,lineStart,curLine);}else {return {code:null,pos:pos};}}}else {var _readHexChar3=readHexChar(input,pos,lineStart,curLine,4,false,throwOnInvalid,errors);code=_readHexChar3.code;pos=_readHexChar3.pos;}return {code:code,pos:pos};}function buildPosition(pos,lineStart,curLine){return new Position(curLine,pos-lineStart,pos);}var VALID_REGEX_FLAGS=new Set([103,109,115,105,121,117,100,118]);var Token=/*#__PURE__*/_createClass(function Token(state){_classCallCheck(this,Token);var startIndex=state.startIndex||0;this.type=state.type;this.value=state.value;this.start=startIndex+state.start;this.end=startIndex+state.end;this.loc=new SourceLocation(state.startLoc,state.endLoc);});var Tokenizer=/*#__PURE__*/function(_CommentsParser){function Tokenizer(options,input){var _this4;_classCallCheck(this,Tokenizer);_this4=_callSuper(this,Tokenizer);_this4.isLookahead=void 0;_this4.tokens=[];_this4.errorHandlers_readInt={invalidDigit:function invalidDigit(pos,lineStart,curLine,radix){if(!(_this4.optionFlags&1024))return false;_this4.raise(Errors.InvalidDigit,buildPosition(pos,lineStart,curLine),{radix:radix});return true;},numericSeparatorInEscapeSequence:_this4.errorBuilder(Errors.NumericSeparatorInEscapeSequence),unexpectedNumericSeparator:_this4.errorBuilder(Errors.UnexpectedNumericSeparator)};_this4.errorHandlers_readCodePoint=Object.assign({},_this4.errorHandlers_readInt,{invalidEscapeSequence:_this4.errorBuilder(Errors.InvalidEscapeSequence),invalidCodePoint:_this4.errorBuilder(Errors.InvalidCodePoint)});_this4.errorHandlers_readStringContents_string=Object.assign({},_this4.errorHandlers_readCodePoint,{strictNumericEscape:function strictNumericEscape(pos,lineStart,curLine){_this4.recordStrictModeErrors(Errors.StrictNumericEscape,buildPosition(pos,lineStart,curLine));},unterminated:function unterminated(pos,lineStart,curLine){throw _this4.raise(Errors.UnterminatedString,buildPosition(pos-1,lineStart,curLine));}});_this4.errorHandlers_readStringContents_template=Object.assign({},_this4.errorHandlers_readCodePoint,{strictNumericEscape:_this4.errorBuilder(Errors.StrictNumericEscape),unterminated:function unterminated(pos,lineStart,curLine){throw _this4.raise(Errors.UnterminatedTemplate,buildPosition(pos,lineStart,curLine));}});_this4.state=new State();_this4.state.init(options);_this4.input=input;_this4.length=input.length;_this4.comments=[];_this4.isLookahead=false;return _this4;}_inherits(Tokenizer,_CommentsParser);return _createClass(Tokenizer,[{key:"pushToken",value:function pushToken(token){this.tokens.length=this.state.tokensLength;this.tokens.push(token);++this.state.tokensLength;}},{key:"next",value:function next(){this.checkKeywordEscapes();if(this.optionFlags&128){this.pushToken(new Token(this.state));}this.state.lastTokEndLoc=this.state.endLoc;this.state.lastTokStartLoc=this.state.startLoc;this.nextToken();}},{key:"eat",value:function eat(type){if(this.match(type)){this.next();return true;}else {return false;}}},{key:"match",value:function match(type){return this.state.type===type;}},{key:"createLookaheadState",value:function createLookaheadState(state){return {pos:state.pos,value:null,type:state.type,start:state.start,end:state.end,context:[this.curContext()],inType:state.inType,startLoc:state.startLoc,lastTokEndLoc:state.lastTokEndLoc,curLine:state.curLine,lineStart:state.lineStart,curPosition:state.curPosition};}},{key:"lookahead",value:function lookahead(){var old=this.state;this.state=this.createLookaheadState(old);this.isLookahead=true;this.nextToken();this.isLookahead=false;var curr=this.state;this.state=old;return curr;}},{key:"nextTokenStart",value:function nextTokenStart(){return this.nextTokenStartSince(this.state.pos);}},{key:"nextTokenStartSince",value:function nextTokenStartSince(pos){skipWhiteSpace.lastIndex=pos;return skipWhiteSpace.test(this.input)?skipWhiteSpace.lastIndex:pos;}},{key:"lookaheadCharCode",value:function lookaheadCharCode(){return this.input.charCodeAt(this.nextTokenStart());}},{key:"nextTokenInLineStart",value:function nextTokenInLineStart(){return this.nextTokenInLineStartSince(this.state.pos);}},{key:"nextTokenInLineStartSince",value:function nextTokenInLineStartSince(pos){skipWhiteSpaceInLine.lastIndex=pos;return skipWhiteSpaceInLine.test(this.input)?skipWhiteSpaceInLine.lastIndex:pos;}},{key:"lookaheadInLineCharCode",value:function lookaheadInLineCharCode(){return this.input.charCodeAt(this.nextTokenInLineStart());}},{key:"codePointAtPos",value:function codePointAtPos(pos){var cp=this.input.charCodeAt(pos);if((cp&0xfc00)===0xd800&&++pos<this.input.length){var trail=this.input.charCodeAt(pos);if((trail&0xfc00)===0xdc00){cp=0x10000+((cp&0x3ff)<<10)+(trail&0x3ff);}}return cp;}},{key:"setStrict",value:function setStrict(strict){var _this5=this;this.state.strict=strict;if(strict){this.state.strictErrors.forEach(function(_ref40){var _ref41=_slicedToArray(_ref40,2),toParseError=_ref41[0],at=_ref41[1];return _this5.raise(toParseError,at);});this.state.strictErrors.clear();}}},{key:"curContext",value:function curContext(){return this.state.context[this.state.context.length-1];}},{key:"nextToken",value:function nextToken(){this.skipSpace();this.state.start=this.state.pos;if(!this.isLookahead)this.state.startLoc=this.state.curPosition();if(this.state.pos>=this.length){this.finishToken(140);return;}this.getTokenFromCode(this.codePointAtPos(this.state.pos));}},{key:"skipBlockComment",value:function skipBlockComment(commentEnd){var startLoc;if(!this.isLookahead)startLoc=this.state.curPosition();var start=this.state.pos;var end=this.input.indexOf(commentEnd,start+2);if(end===-1){throw this.raise(Errors.UnterminatedComment,this.state.curPosition());}this.state.pos=end+commentEnd.length;lineBreakG.lastIndex=start+2;while(lineBreakG.test(this.input)&&lineBreakG.lastIndex<=end){++this.state.curLine;this.state.lineStart=lineBreakG.lastIndex;}if(this.isLookahead)return;var comment={type:"CommentBlock",value:this.input.slice(start+2,end),start:this.sourceToOffsetPos(start),end:this.sourceToOffsetPos(end+commentEnd.length),loc:new SourceLocation(startLoc,this.state.curPosition())};if(this.optionFlags&128)this.pushToken(comment);return comment;}},{key:"skipLineComment",value:function skipLineComment(startSkip){var start=this.state.pos;var startLoc;if(!this.isLookahead)startLoc=this.state.curPosition();var ch=this.input.charCodeAt(this.state.pos+=startSkip);if(this.state.pos<this.length){while(!isNewLine(ch)&&++this.state.pos<this.length){ch=this.input.charCodeAt(this.state.pos);}}if(this.isLookahead)return;var end=this.state.pos;var value=this.input.slice(start+startSkip,end);var comment={type:"CommentLine",value:value,start:this.sourceToOffsetPos(start),end:this.sourceToOffsetPos(end),loc:new SourceLocation(startLoc,this.state.curPosition())};if(this.optionFlags&128)this.pushToken(comment);return comment;}},{key:"skipSpace",value:function skipSpace(){var spaceStart=this.state.pos;var comments=this.optionFlags&2048?[]:null;loop:while(this.state.pos<this.length){var ch=this.input.charCodeAt(this.state.pos);switch(ch){case 32:case 160:case 9:++this.state.pos;break;case 13:if(this.input.charCodeAt(this.state.pos+1)===10){++this.state.pos;}case 10:case 8232:case 8233:++this.state.pos;++this.state.curLine;this.state.lineStart=this.state.pos;break;case 47:switch(this.input.charCodeAt(this.state.pos+1)){case 42:{var comment=this.skipBlockComment("*/");if(comment!==undefined){this.addComment(comment);comments==null||comments.push(comment);}break;}case 47:{var _comment=this.skipLineComment(2);if(_comment!==undefined){this.addComment(_comment);comments==null||comments.push(_comment);}break;}default:break loop;}break;default:if(isWhitespace(ch)){++this.state.pos;}else if(ch===45&&!this.inModule&&this.optionFlags&4096){var pos=this.state.pos;if(this.input.charCodeAt(pos+1)===45&&this.input.charCodeAt(pos+2)===62&&(spaceStart===0||this.state.lineStart>spaceStart)){var _comment2=this.skipLineComment(3);if(_comment2!==undefined){this.addComment(_comment2);comments==null||comments.push(_comment2);}}else {break loop;}}else if(ch===60&&!this.inModule&&this.optionFlags&4096){var _pos=this.state.pos;if(this.input.charCodeAt(_pos+1)===33&&this.input.charCodeAt(_pos+2)===45&&this.input.charCodeAt(_pos+3)===45){var _comment3=this.skipLineComment(4);if(_comment3!==undefined){this.addComment(_comment3);comments==null||comments.push(_comment3);}}else {break loop;}}else {break loop;}}}if((comments==null?void 0:comments.length)>0){var end=this.state.pos;var commentWhitespace={start:this.sourceToOffsetPos(spaceStart),end:this.sourceToOffsetPos(end),comments:comments,leadingNode:null,trailingNode:null,containingNode:null};this.state.commentStack.push(commentWhitespace);}}},{key:"finishToken",value:function finishToken(type,val){this.state.end=this.state.pos;this.state.endLoc=this.state.curPosition();var prevType=this.state.type;this.state.type=type;this.state.value=val;if(!this.isLookahead){this.updateContext(prevType);}}},{key:"replaceToken",value:function replaceToken(type){this.state.type=type;this.updateContext();}},{key:"readToken_numberSign",value:function readToken_numberSign(){if(this.state.pos===0&&this.readToken_interpreter()){return;}var nextPos=this.state.pos+1;var next=this.codePointAtPos(nextPos);if(next>=48&&next<=57){throw this.raise(Errors.UnexpectedDigitAfterHash,this.state.curPosition());}if(next===123||next===91&&this.hasPlugin("recordAndTuple")){this.expectPlugin("recordAndTuple");if(this.getPluginOption("recordAndTuple","syntaxType")==="bar"){throw this.raise(next===123?Errors.RecordExpressionHashIncorrectStartSyntaxType:Errors.TupleExpressionHashIncorrectStartSyntaxType,this.state.curPosition());}this.state.pos+=2;if(next===123){this.finishToken(7);}else {this.finishToken(1);}}else if(isIdentifierStart(next)){++this.state.pos;this.finishToken(139,this.readWord1(next));}else if(next===92){++this.state.pos;this.finishToken(139,this.readWord1());}else {this.finishOp(27,1);}}},{key:"readToken_dot",value:function readToken_dot(){var next=this.input.charCodeAt(this.state.pos+1);if(next>=48&&next<=57){this.readNumber(true);return;}if(next===46&&this.input.charCodeAt(this.state.pos+2)===46){this.state.pos+=3;this.finishToken(21);}else {++this.state.pos;this.finishToken(16);}}},{key:"readToken_slash",value:function readToken_slash(){var next=this.input.charCodeAt(this.state.pos+1);if(next===61){this.finishOp(31,2);}else {this.finishOp(56,1);}}},{key:"readToken_interpreter",value:function readToken_interpreter(){if(this.state.pos!==0||this.length<2)return false;var ch=this.input.charCodeAt(this.state.pos+1);if(ch!==33)return false;var start=this.state.pos;this.state.pos+=1;while(!isNewLine(ch)&&++this.state.pos<this.length){ch=this.input.charCodeAt(this.state.pos);}var value=this.input.slice(start+2,this.state.pos);this.finishToken(28,value);return true;}},{key:"readToken_mult_modulo",value:function readToken_mult_modulo(code){var type=code===42?55:54;var width=1;var next=this.input.charCodeAt(this.state.pos+1);if(code===42&&next===42){width++;next=this.input.charCodeAt(this.state.pos+2);type=57;}if(next===61&&!this.state.inType){width++;type=code===37?33:30;}this.finishOp(type,width);}},{key:"readToken_pipe_amp",value:function readToken_pipe_amp(code){var next=this.input.charCodeAt(this.state.pos+1);if(next===code){if(this.input.charCodeAt(this.state.pos+2)===61){this.finishOp(30,3);}else {this.finishOp(code===124?41:42,2);}return;}if(code===124){if(next===62){this.finishOp(39,2);return;}if(this.hasPlugin("recordAndTuple")&&next===125){if(this.getPluginOption("recordAndTuple","syntaxType")!=="bar"){throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType,this.state.curPosition());}this.state.pos+=2;this.finishToken(9);return;}if(this.hasPlugin("recordAndTuple")&&next===93){if(this.getPluginOption("recordAndTuple","syntaxType")!=="bar"){throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType,this.state.curPosition());}this.state.pos+=2;this.finishToken(4);return;}}if(next===61){this.finishOp(30,2);return;}this.finishOp(code===124?43:45,1);}},{key:"readToken_caret",value:function readToken_caret(){var next=this.input.charCodeAt(this.state.pos+1);if(next===61&&!this.state.inType){this.finishOp(32,2);}else if(next===94&&this.hasPlugin(["pipelineOperator",{proposal:"hack",topicToken:"^^"}])){this.finishOp(37,2);var lookaheadCh=this.input.codePointAt(this.state.pos);if(lookaheadCh===94){this.unexpected();}}else {this.finishOp(44,1);}}},{key:"readToken_atSign",value:function readToken_atSign(){var next=this.input.charCodeAt(this.state.pos+1);if(next===64&&this.hasPlugin(["pipelineOperator",{proposal:"hack",topicToken:"@@"}])){this.finishOp(38,2);}else {this.finishOp(26,1);}}},{key:"readToken_plus_min",value:function readToken_plus_min(code){var next=this.input.charCodeAt(this.state.pos+1);if(next===code){this.finishOp(34,2);return;}if(next===61){this.finishOp(30,2);}else {this.finishOp(53,1);}}},{key:"readToken_lt",value:function readToken_lt(){var pos=this.state.pos;var next=this.input.charCodeAt(pos+1);if(next===60){if(this.input.charCodeAt(pos+2)===61){this.finishOp(30,3);return;}this.finishOp(51,2);return;}if(next===61){this.finishOp(49,2);return;}this.finishOp(47,1);}},{key:"readToken_gt",value:function readToken_gt(){var pos=this.state.pos;var next=this.input.charCodeAt(pos+1);if(next===62){var size=this.input.charCodeAt(pos+2)===62?3:2;if(this.input.charCodeAt(pos+size)===61){this.finishOp(30,size+1);return;}this.finishOp(52,size);return;}if(next===61){this.finishOp(49,2);return;}this.finishOp(48,1);}},{key:"readToken_eq_excl",value:function readToken_eq_excl(code){var next=this.input.charCodeAt(this.state.pos+1);if(next===61){this.finishOp(46,this.input.charCodeAt(this.state.pos+2)===61?3:2);return;}if(code===61&&next===62){this.state.pos+=2;this.finishToken(19);return;}this.finishOp(code===61?29:35,1);}},{key:"readToken_question",value:function readToken_question(){var next=this.input.charCodeAt(this.state.pos+1);var next2=this.input.charCodeAt(this.state.pos+2);if(next===63){if(next2===61){this.finishOp(30,3);}else {this.finishOp(40,2);}}else if(next===46&&!(next2>=48&&next2<=57)){this.state.pos+=2;this.finishToken(18);}else {++this.state.pos;this.finishToken(17);}}},{key:"getTokenFromCode",value:function getTokenFromCode(code){switch(code){case 46:this.readToken_dot();return;case 40:++this.state.pos;this.finishToken(10);return;case 41:++this.state.pos;this.finishToken(11);return;case 59:++this.state.pos;this.finishToken(13);return;case 44:++this.state.pos;this.finishToken(12);return;case 91:if(this.hasPlugin("recordAndTuple")&&this.input.charCodeAt(this.state.pos+1)===124){if(this.getPluginOption("recordAndTuple","syntaxType")!=="bar"){throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType,this.state.curPosition());}this.state.pos+=2;this.finishToken(2);}else {++this.state.pos;this.finishToken(0);}return;case 93:++this.state.pos;this.finishToken(3);return;case 123:if(this.hasPlugin("recordAndTuple")&&this.input.charCodeAt(this.state.pos+1)===124){if(this.getPluginOption("recordAndTuple","syntaxType")!=="bar"){throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType,this.state.curPosition());}this.state.pos+=2;this.finishToken(6);}else {++this.state.pos;this.finishToken(5);}return;case 125:++this.state.pos;this.finishToken(8);return;case 58:if(this.hasPlugin("functionBind")&&this.input.charCodeAt(this.state.pos+1)===58){this.finishOp(15,2);}else {++this.state.pos;this.finishToken(14);}return;case 63:this.readToken_question();return;case 96:this.readTemplateToken();return;case 48:{var next=this.input.charCodeAt(this.state.pos+1);if(next===120||next===88){this.readRadixNumber(16);return;}if(next===111||next===79){this.readRadixNumber(8);return;}if(next===98||next===66){this.readRadixNumber(2);return;}}case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:this.readNumber(false);return;case 34:case 39:this.readString(code);return;case 47:this.readToken_slash();return;case 37:case 42:this.readToken_mult_modulo(code);return;case 124:case 38:this.readToken_pipe_amp(code);return;case 94:this.readToken_caret();return;case 43:case 45:this.readToken_plus_min(code);return;case 60:this.readToken_lt();return;case 62:this.readToken_gt();return;case 61:case 33:this.readToken_eq_excl(code);return;case 126:this.finishOp(36,1);return;case 64:this.readToken_atSign();return;case 35:this.readToken_numberSign();return;case 92:this.readWord();return;default:if(isIdentifierStart(code)){this.readWord(code);return;}}throw this.raise(Errors.InvalidOrUnexpectedToken,this.state.curPosition(),{unexpected:String.fromCodePoint(code)});}},{key:"finishOp",value:function finishOp(type,size){var str=this.input.slice(this.state.pos,this.state.pos+size);this.state.pos+=size;this.finishToken(type,str);}},{key:"readRegexp",value:function readRegexp(){var startLoc=this.state.startLoc;var start=this.state.start+1;var escaped,inClass;var pos=this.state.pos;for(;;++pos){if(pos>=this.length){throw this.raise(Errors.UnterminatedRegExp,createPositionWithColumnOffset(startLoc,1));}var ch=this.input.charCodeAt(pos);if(isNewLine(ch)){throw this.raise(Errors.UnterminatedRegExp,createPositionWithColumnOffset(startLoc,1));}if(escaped){escaped=false;}else {if(ch===91){inClass=true;}else if(ch===93&&inClass){inClass=false;}else if(ch===47&&!inClass){break;}escaped=ch===92;}}var content=this.input.slice(start,pos);++pos;var mods="";var nextPos=function nextPos(){return createPositionWithColumnOffset(startLoc,pos+2-start);};while(pos<this.length){var cp=this.codePointAtPos(pos);var _char=String.fromCharCode(cp);if(VALID_REGEX_FLAGS.has(cp)){if(cp===118){if(mods.includes("u")){this.raise(Errors.IncompatibleRegExpUVFlags,nextPos());}}else if(cp===117){if(mods.includes("v")){this.raise(Errors.IncompatibleRegExpUVFlags,nextPos());}}if(mods.includes(_char)){this.raise(Errors.DuplicateRegExpFlags,nextPos());}}else if(isIdentifierChar(cp)||cp===92){this.raise(Errors.MalformedRegExpFlags,nextPos());}else {break;}++pos;mods+=_char;}this.state.pos=pos;this.finishToken(138,{pattern:content,flags:mods});}},{key:"readInt",value:function readInt(radix,len){var forceLen=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var allowNumSeparator=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;var _readInt3=_readInt2(this.input,this.state.pos,this.state.lineStart,this.state.curLine,radix,len,forceLen,allowNumSeparator,this.errorHandlers_readInt,false),n=_readInt3.n,pos=_readInt3.pos;this.state.pos=pos;return n;}},{key:"readRadixNumber",value:function readRadixNumber(radix){var start=this.state.pos;var startLoc=this.state.curPosition();var isBigInt=false;this.state.pos+=2;var val=this.readInt(radix);if(val==null){this.raise(Errors.InvalidDigit,createPositionWithColumnOffset(startLoc,2),{radix:radix});}var next=this.input.charCodeAt(this.state.pos);if(next===110){++this.state.pos;isBigInt=true;}else if(next===109){throw this.raise(Errors.InvalidDecimal,startLoc);}if(isIdentifierStart(this.codePointAtPos(this.state.pos))){throw this.raise(Errors.NumberIdentifier,this.state.curPosition());}if(isBigInt){var str=this.input.slice(start,this.state.pos).replace(/[_n]/g,"");this.finishToken(136,str);return;}this.finishToken(135,val);}},{key:"readNumber",value:function readNumber(startsWithDot){var start=this.state.pos;var startLoc=this.state.curPosition();var isFloat=false;var isBigInt=false;var hasExponent=false;var isOctal=false;if(!startsWithDot&&this.readInt(10)===null){this.raise(Errors.InvalidNumber,this.state.curPosition());}var hasLeadingZero=this.state.pos-start>=2&&this.input.charCodeAt(start)===48;if(hasLeadingZero){var integer=this.input.slice(start,this.state.pos);this.recordStrictModeErrors(Errors.StrictOctalLiteral,startLoc);if(!this.state.strict){var underscorePos=integer.indexOf("_");if(underscorePos>0){this.raise(Errors.ZeroDigitNumericSeparator,createPositionWithColumnOffset(startLoc,underscorePos));}}isOctal=hasLeadingZero&&!/[89]/.test(integer);}var next=this.input.charCodeAt(this.state.pos);if(next===46&&!isOctal){++this.state.pos;this.readInt(10);isFloat=true;next=this.input.charCodeAt(this.state.pos);}if((next===69||next===101)&&!isOctal){next=this.input.charCodeAt(++this.state.pos);if(next===43||next===45){++this.state.pos;}if(this.readInt(10)===null){this.raise(Errors.InvalidOrMissingExponent,startLoc);}isFloat=true;hasExponent=true;next=this.input.charCodeAt(this.state.pos);}if(next===110){if(isFloat||hasLeadingZero){this.raise(Errors.InvalidBigIntLiteral,startLoc);}++this.state.pos;isBigInt=true;}if(next===109){this.expectPlugin("decimal",this.state.curPosition());if(hasExponent||hasLeadingZero){this.raise(Errors.InvalidDecimal,startLoc);}++this.state.pos;var isDecimal=true;}if(isIdentifierStart(this.codePointAtPos(this.state.pos))){throw this.raise(Errors.NumberIdentifier,this.state.curPosition());}var str=this.input.slice(start,this.state.pos).replace(/[_mn]/g,"");if(isBigInt){this.finishToken(136,str);return;}if(isDecimal){this.finishToken(137,str);return;}var val=isOctal?parseInt(str,8):parseFloat(str);this.finishToken(135,val);}},{key:"readCodePoint",value:function readCodePoint(throwOnInvalid){var _readCodePoint3=_readCodePoint2(this.input,this.state.pos,this.state.lineStart,this.state.curLine,throwOnInvalid,this.errorHandlers_readCodePoint),code=_readCodePoint3.code,pos=_readCodePoint3.pos;this.state.pos=pos;return code;}},{key:"readString",value:function readString(quote){var _readStringContents=readStringContents(quote===34?"double":"single",this.input,this.state.pos+1,this.state.lineStart,this.state.curLine,this.errorHandlers_readStringContents_string),str=_readStringContents.str,pos=_readStringContents.pos,curLine=_readStringContents.curLine,lineStart=_readStringContents.lineStart;this.state.pos=pos+1;this.state.lineStart=lineStart;this.state.curLine=curLine;this.finishToken(134,str);}},{key:"readTemplateContinuation",value:function readTemplateContinuation(){if(!this.match(8)){this.unexpected(null,8);}this.state.pos--;this.readTemplateToken();}},{key:"readTemplateToken",value:function readTemplateToken(){var opening=this.input[this.state.pos];var _readStringContents2=readStringContents("template",this.input,this.state.pos+1,this.state.lineStart,this.state.curLine,this.errorHandlers_readStringContents_template),str=_readStringContents2.str,firstInvalidLoc=_readStringContents2.firstInvalidLoc,pos=_readStringContents2.pos,curLine=_readStringContents2.curLine,lineStart=_readStringContents2.lineStart;this.state.pos=pos+1;this.state.lineStart=lineStart;this.state.curLine=curLine;if(firstInvalidLoc){this.state.firstInvalidTemplateEscapePos=new Position(firstInvalidLoc.curLine,firstInvalidLoc.pos-firstInvalidLoc.lineStart,this.sourceToOffsetPos(firstInvalidLoc.pos));}if(this.input.codePointAt(pos)===96){this.finishToken(24,firstInvalidLoc?null:opening+str+"`");}else {this.state.pos++;this.finishToken(25,firstInvalidLoc?null:opening+str+"${");}}},{key:"recordStrictModeErrors",value:function recordStrictModeErrors(toParseError,at){var index=at.index;if(this.state.strict&&!this.state.strictErrors.has(index)){this.raise(toParseError,at);}else {this.state.strictErrors.set(index,[toParseError,at]);}}},{key:"readWord1",value:function readWord1(firstCode){this.state.containsEsc=false;var word="";var start=this.state.pos;var chunkStart=this.state.pos;if(firstCode!==undefined){this.state.pos+=firstCode<=0xffff?1:2;}while(this.state.pos<this.length){var ch=this.codePointAtPos(this.state.pos);if(isIdentifierChar(ch)){this.state.pos+=ch<=0xffff?1:2;}else if(ch===92){this.state.containsEsc=true;word+=this.input.slice(chunkStart,this.state.pos);var escStart=this.state.curPosition();var identifierCheck=this.state.pos===start?isIdentifierStart:isIdentifierChar;if(this.input.charCodeAt(++this.state.pos)!==117){this.raise(Errors.MissingUnicodeEscape,this.state.curPosition());chunkStart=this.state.pos-1;continue;}++this.state.pos;var esc=this.readCodePoint(true);if(esc!==null){if(!identifierCheck(esc)){this.raise(Errors.EscapedCharNotAnIdentifier,escStart);}word+=String.fromCodePoint(esc);}chunkStart=this.state.pos;}else {break;}}return word+this.input.slice(chunkStart,this.state.pos);}},{key:"readWord",value:function readWord(firstCode){var word=this.readWord1(firstCode);var type=keywords$1.get(word);if(type!==undefined){this.finishToken(type,tokenLabelName(type));}else {this.finishToken(132,word);}}},{key:"checkKeywordEscapes",value:function checkKeywordEscapes(){var type=this.state.type;if(tokenIsKeyword(type)&&this.state.containsEsc){this.raise(Errors.InvalidEscapedReservedWord,this.state.startLoc,{reservedWord:tokenLabelName(type)});}}},{key:"raise",value:function raise(toParseError,at){var details=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var loc=at instanceof Position?at:at.loc.start;var error=toParseError(loc,details);if(!(this.optionFlags&1024))throw error;if(!this.isLookahead)this.state.errors.push(error);return error;}},{key:"raiseOverwrite",value:function raiseOverwrite(toParseError,at){var details=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var loc=at instanceof Position?at:at.loc.start;var pos=loc.index;var errors=this.state.errors;for(var i=errors.length-1;i>=0;i--){var error=errors[i];if(error.loc.index===pos){return errors[i]=toParseError(loc,details);}if(error.loc.index<pos)break;}return this.raise(toParseError,at,details);}},{key:"updateContext",value:function updateContext(prevType){}},{key:"unexpected",value:function unexpected(loc,type){throw this.raise(Errors.UnexpectedToken,loc!=null?loc:this.state.startLoc,{expected:type?tokenLabelName(type):null});}},{key:"expectPlugin",value:function expectPlugin(pluginName,loc){if(this.hasPlugin(pluginName)){return true;}throw this.raise(Errors.MissingPlugin,loc!=null?loc:this.state.startLoc,{missingPlugin:[pluginName]});}},{key:"expectOnePlugin",value:function expectOnePlugin(pluginNames){var _this6=this;if(!pluginNames.some(function(name){return _this6.hasPlugin(name);})){throw this.raise(Errors.MissingOneOfPlugins,this.state.startLoc,{missingPlugin:pluginNames});}}},{key:"errorBuilder",value:function errorBuilder(error){var _this7=this;return function(pos,lineStart,curLine){_this7.raise(error,buildPosition(pos,lineStart,curLine));};}}]);}(CommentsParser);var ClassScope=/*#__PURE__*/_createClass(function ClassScope(){_classCallCheck(this,ClassScope);this.privateNames=new Set();this.loneAccessors=new Map();this.undefinedPrivateNames=new Map();});var ClassScopeHandler=/*#__PURE__*/function(){function ClassScopeHandler(parser){_classCallCheck(this,ClassScopeHandler);this.parser=void 0;this.stack=[];this.undefinedPrivateNames=new Map();this.parser=parser;}return _createClass(ClassScopeHandler,[{key:"current",value:function current(){return this.stack[this.stack.length-1];}},{key:"enter",value:function enter(){this.stack.push(new ClassScope());}},{key:"exit",value:function exit(){var oldClassScope=this.stack.pop();var current=this.current();for(var _i4=0,_Array$from=Array.from(oldClassScope.undefinedPrivateNames);_i4<_Array$from.length;_i4++){var _Array$from$_i=_slicedToArray(_Array$from[_i4],2),name=_Array$from$_i[0],loc=_Array$from$_i[1];if(current){if(!current.undefinedPrivateNames.has(name)){current.undefinedPrivateNames.set(name,loc);}}else {this.parser.raise(Errors.InvalidPrivateFieldResolution,loc,{identifierName:name});}}}},{key:"declarePrivateName",value:function declarePrivateName(name,elementType,loc){var _this$current=this.current(),privateNames=_this$current.privateNames,loneAccessors=_this$current.loneAccessors,undefinedPrivateNames=_this$current.undefinedPrivateNames;var redefined=privateNames.has(name);if(elementType&3){var accessor=redefined&&loneAccessors.get(name);if(accessor){var oldStatic=accessor&4;var newStatic=elementType&4;var oldKind=accessor&3;var newKind=elementType&3;redefined=oldKind===newKind||oldStatic!==newStatic;if(!redefined)loneAccessors["delete"](name);}else if(!redefined){loneAccessors.set(name,elementType);}}if(redefined){this.parser.raise(Errors.PrivateNameRedeclaration,loc,{identifierName:name});}privateNames.add(name);undefinedPrivateNames["delete"](name);}},{key:"usePrivateName",value:function usePrivateName(name,loc){var classScope;var _iterator=_createForOfIteratorHelper(this.stack),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){classScope=_step.value;if(classScope.privateNames.has(name))return;}}catch(err){_iterator.e(err);}finally{_iterator.f();}if(classScope){classScope.undefinedPrivateNames.set(name,loc);}else {this.parser.raise(Errors.InvalidPrivateFieldResolution,loc,{identifierName:name});}}}]);}();var ExpressionScope=/*#__PURE__*/function(){function ExpressionScope(){var type=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;_classCallCheck(this,ExpressionScope);this.type=type;}return _createClass(ExpressionScope,[{key:"canBeArrowParameterDeclaration",value:function canBeArrowParameterDeclaration(){return this.type===2||this.type===1;}},{key:"isCertainlyParameterDeclaration",value:function isCertainlyParameterDeclaration(){return this.type===3;}}]);}();var ArrowHeadParsingScope=/*#__PURE__*/function(_ExpressionScope){function ArrowHeadParsingScope(type){var _this8;_classCallCheck(this,ArrowHeadParsingScope);_this8=_callSuper(this,ArrowHeadParsingScope,[type]);_this8.declarationErrors=new Map();return _this8;}_inherits(ArrowHeadParsingScope,_ExpressionScope);return _createClass(ArrowHeadParsingScope,[{key:"recordDeclarationError",value:function recordDeclarationError(ParsingErrorClass,at){var index=at.index;this.declarationErrors.set(index,[ParsingErrorClass,at]);}},{key:"clearDeclarationError",value:function clearDeclarationError(index){this.declarationErrors["delete"](index);}},{key:"iterateErrors",value:function iterateErrors(iterator){this.declarationErrors.forEach(iterator);}}]);}(ExpressionScope);var ExpressionScopeHandler=/*#__PURE__*/function(){function ExpressionScopeHandler(parser){_classCallCheck(this,ExpressionScopeHandler);this.parser=void 0;this.stack=[new ExpressionScope()];this.parser=parser;}return _createClass(ExpressionScopeHandler,[{key:"enter",value:function enter(scope){this.stack.push(scope);}},{key:"exit",value:function exit(){this.stack.pop();}},{key:"recordParameterInitializerError",value:function recordParameterInitializerError(toParseError,node){var origin=node.loc.start;var stack=this.stack;var i=stack.length-1;var scope=stack[i];while(!scope.isCertainlyParameterDeclaration()){if(scope.canBeArrowParameterDeclaration()){scope.recordDeclarationError(toParseError,origin);}else {return;}scope=stack[--i];}this.parser.raise(toParseError,origin);}},{key:"recordArrowParameterBindingError",value:function recordArrowParameterBindingError(error,node){var stack=this.stack;var scope=stack[stack.length-1];var origin=node.loc.start;if(scope.isCertainlyParameterDeclaration()){this.parser.raise(error,origin);}else if(scope.canBeArrowParameterDeclaration()){scope.recordDeclarationError(error,origin);}else {return;}}},{key:"recordAsyncArrowParametersError",value:function recordAsyncArrowParametersError(at){var stack=this.stack;var i=stack.length-1;var scope=stack[i];while(scope.canBeArrowParameterDeclaration()){if(scope.type===2){scope.recordDeclarationError(Errors.AwaitBindingIdentifier,at);}scope=stack[--i];}}},{key:"validateAsPattern",value:function validateAsPattern(){var _this9=this;var stack=this.stack;var currentScope=stack[stack.length-1];if(!currentScope.canBeArrowParameterDeclaration())return;currentScope.iterateErrors(function(_ref42){var _ref43=_slicedToArray(_ref42,2),toParseError=_ref43[0],loc=_ref43[1];_this9.parser.raise(toParseError,loc);var i=stack.length-2;var scope=stack[i];while(scope.canBeArrowParameterDeclaration()){scope.clearDeclarationError(loc.index);scope=stack[--i];}});}}]);}();function newParameterDeclarationScope(){return new ExpressionScope(3);}function newArrowHeadScope(){return new ArrowHeadParsingScope(1);}function newAsyncArrowScope(){return new ArrowHeadParsingScope(2);}function newExpressionScope(){return new ExpressionScope();}var ProductionParameterHandler=/*#__PURE__*/function(){function ProductionParameterHandler(){_classCallCheck(this,ProductionParameterHandler);this.stacks=[];}return _createClass(ProductionParameterHandler,[{key:"enter",value:function enter(flags){this.stacks.push(flags);}},{key:"exit",value:function exit(){this.stacks.pop();}},{key:"currentFlags",value:function currentFlags(){return this.stacks[this.stacks.length-1];}},{key:"hasAwait",get:function get(){return (this.currentFlags()&2)>0;}},{key:"hasYield",get:function get(){return (this.currentFlags()&1)>0;}},{key:"hasReturn",get:function get(){return (this.currentFlags()&4)>0;}},{key:"hasIn",get:function get(){return (this.currentFlags()&8)>0;}}]);}();function functionFlags(isAsync,isGenerator){return (isAsync?2:0)|(isGenerator?1:0);}var UtilParser=/*#__PURE__*/function(_Tokenizer){function UtilParser(){_classCallCheck(this,UtilParser);return _callSuper(this,UtilParser,arguments);}_inherits(UtilParser,_Tokenizer);return _createClass(UtilParser,[{key:"addExtra",value:function addExtra(node,key,value){var enumerable=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;if(!node)return;var extra=node.extra;if(extra==null){extra={};node.extra=extra;}if(enumerable){extra[key]=value;}else {Object.defineProperty(extra,key,{enumerable:enumerable,value:value});}}},{key:"isContextual",value:function isContextual(token){return this.state.type===token&&!this.state.containsEsc;}},{key:"isUnparsedContextual",value:function isUnparsedContextual(nameStart,name){var nameEnd=nameStart+name.length;if(this.input.slice(nameStart,nameEnd)===name){var nextCh=this.input.charCodeAt(nameEnd);return !(isIdentifierChar(nextCh)||(nextCh&0xfc00)===0xd800);}return false;}},{key:"isLookaheadContextual",value:function isLookaheadContextual(name){var next=this.nextTokenStart();return this.isUnparsedContextual(next,name);}},{key:"eatContextual",value:function eatContextual(token){if(this.isContextual(token)){this.next();return true;}return false;}},{key:"expectContextual",value:function expectContextual(token,toParseError){if(!this.eatContextual(token)){if(toParseError!=null){throw this.raise(toParseError,this.state.startLoc);}this.unexpected(null,token);}}},{key:"canInsertSemicolon",value:function canInsertSemicolon(){return this.match(140)||this.match(8)||this.hasPrecedingLineBreak();}},{key:"hasPrecedingLineBreak",value:function hasPrecedingLineBreak(){return hasNewLine(this.input,this.offsetToSourcePos(this.state.lastTokEndLoc.index),this.state.start);}},{key:"hasFollowingLineBreak",value:function hasFollowingLineBreak(){return hasNewLine(this.input,this.state.end,this.nextTokenStart());}},{key:"isLineTerminator",value:function isLineTerminator(){return this.eat(13)||this.canInsertSemicolon();}},{key:"semicolon",value:function semicolon(){var allowAsi=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;if(allowAsi?this.isLineTerminator():this.eat(13))return;this.raise(Errors.MissingSemicolon,this.state.lastTokEndLoc);}},{key:"expect",value:function expect(type,loc){if(!this.eat(type)){this.unexpected(loc,type);}}},{key:"tryParse",value:function tryParse(fn){var oldState=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.state.clone();var abortSignal={node:null};try{var node=fn(function(){var node=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;abortSignal.node=node;throw abortSignal;});if(this.state.errors.length>oldState.errors.length){var failState=this.state;this.state=oldState;this.state.tokensLength=failState.tokensLength;return {node:node,error:failState.errors[oldState.errors.length],thrown:false,aborted:false,failState:failState};}return {node:node,error:null,thrown:false,aborted:false,failState:null};}catch(error){var _failState=this.state;this.state=oldState;if(error instanceof SyntaxError){return {node:null,error:error,thrown:true,aborted:false,failState:_failState};}if(error===abortSignal){return {node:abortSignal.node,error:null,thrown:false,aborted:true,failState:_failState};}throw error;}}},{key:"checkExpressionErrors",value:function checkExpressionErrors(refExpressionErrors,andThrow){if(!refExpressionErrors)return false;var shorthandAssignLoc=refExpressionErrors.shorthandAssignLoc,doubleProtoLoc=refExpressionErrors.doubleProtoLoc,privateKeyLoc=refExpressionErrors.privateKeyLoc,optionalParametersLoc=refExpressionErrors.optionalParametersLoc;var hasErrors=!!shorthandAssignLoc||!!doubleProtoLoc||!!optionalParametersLoc||!!privateKeyLoc;if(!andThrow){return hasErrors;}if(shorthandAssignLoc!=null){this.raise(Errors.InvalidCoverInitializedName,shorthandAssignLoc);}if(doubleProtoLoc!=null){this.raise(Errors.DuplicateProto,doubleProtoLoc);}if(privateKeyLoc!=null){this.raise(Errors.UnexpectedPrivateField,privateKeyLoc);}if(optionalParametersLoc!=null){this.unexpected(optionalParametersLoc);}}},{key:"isLiteralPropertyName",value:function isLiteralPropertyName(){return tokenIsLiteralPropertyName(this.state.type);}},{key:"isPrivateName",value:function isPrivateName(node){return node.type==="PrivateName";}},{key:"getPrivateNameSV",value:function getPrivateNameSV(node){return node.id.name;}},{key:"hasPropertyAsPrivateName",value:function hasPropertyAsPrivateName(node){return (node.type==="MemberExpression"||node.type==="OptionalMemberExpression")&&this.isPrivateName(node.property);}},{key:"isObjectProperty",value:function isObjectProperty(node){return node.type==="ObjectProperty";}},{key:"isObjectMethod",value:function isObjectMethod(node){return node.type==="ObjectMethod";}},{key:"initializeScopes",value:function initializeScopes(){var _this10=this;var inModule=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.options.sourceType==="module";var oldLabels=this.state.labels;this.state.labels=[];var oldExportedIdentifiers=this.exportedIdentifiers;this.exportedIdentifiers=new Set();var oldInModule=this.inModule;this.inModule=inModule;var oldScope=this.scope;var ScopeHandler=this.getScopeHandler();this.scope=new ScopeHandler(this,inModule);var oldProdParam=this.prodParam;this.prodParam=new ProductionParameterHandler();var oldClassScope=this.classScope;this.classScope=new ClassScopeHandler(this);var oldExpressionScope=this.expressionScope;this.expressionScope=new ExpressionScopeHandler(this);return function(){_this10.state.labels=oldLabels;_this10.exportedIdentifiers=oldExportedIdentifiers;_this10.inModule=oldInModule;_this10.scope=oldScope;_this10.prodParam=oldProdParam;_this10.classScope=oldClassScope;_this10.expressionScope=oldExpressionScope;};}},{key:"enterInitialScopes",value:function enterInitialScopes(){var paramFlags=0;if(this.inModule){paramFlags|=2;}this.scope.enter(1);this.prodParam.enter(paramFlags);}},{key:"checkDestructuringPrivate",value:function checkDestructuringPrivate(refExpressionErrors){var privateKeyLoc=refExpressionErrors.privateKeyLoc;if(privateKeyLoc!==null){this.expectPlugin("destructuringPrivate",privateKeyLoc);}}}]);}(Tokenizer);var ExpressionErrors=/*#__PURE__*/_createClass(function ExpressionErrors(){_classCallCheck(this,ExpressionErrors);this.shorthandAssignLoc=null;this.doubleProtoLoc=null;this.privateKeyLoc=null;this.optionalParametersLoc=null;});var Node=/*#__PURE__*/_createClass(function Node(parser,pos,loc){_classCallCheck(this,Node);this.type="";this.start=pos;this.end=0;this.loc=new SourceLocation(loc);if((parser==null?void 0:parser.optionFlags)&64)this.range=[pos,0];if(parser!=null&&parser.filename)this.loc.filename=parser.filename;});var NodePrototype=Node.prototype;{NodePrototype.__clone=function(){var newNode=new Node(undefined,this.start,this.loc.start);var keys=Object.keys(this);for(var i=0,length=keys.length;i<length;i++){var key=keys[i];if(key!=="leadingComments"&&key!=="trailingComments"&&key!=="innerComments"){newNode[key]=this[key];}}return newNode;};}function clonePlaceholder(node){return cloneIdentifier(node);}function cloneIdentifier(node){var type=node.type,start=node.start,end=node.end,loc=node.loc,range=node.range,extra=node.extra,name=node.name;var cloned=Object.create(NodePrototype);cloned.type=type;cloned.start=start;cloned.end=end;cloned.loc=loc;cloned.range=range;cloned.extra=extra;cloned.name=name;if(type==="Placeholder"){cloned.expectedNode=node.expectedNode;}return cloned;}function cloneStringLiteral(node){var type=node.type,start=node.start,end=node.end,loc=node.loc,range=node.range,extra=node.extra;if(type==="Placeholder"){return clonePlaceholder(node);}var cloned=Object.create(NodePrototype);cloned.type=type;cloned.start=start;cloned.end=end;cloned.loc=loc;cloned.range=range;if(node.raw!==undefined){cloned.raw=node.raw;}else {cloned.extra=extra;}cloned.value=node.value;return cloned;}var NodeUtils=/*#__PURE__*/function(_UtilParser){function NodeUtils(){_classCallCheck(this,NodeUtils);return _callSuper(this,NodeUtils,arguments);}_inherits(NodeUtils,_UtilParser);return _createClass(NodeUtils,[{key:"startNode",value:function startNode(){var loc=this.state.startLoc;return new Node(this,loc.index,loc);}},{key:"startNodeAt",value:function startNodeAt(loc){return new Node(this,loc.index,loc);}},{key:"startNodeAtNode",value:function startNodeAtNode(type){return this.startNodeAt(type.loc.start);}},{key:"finishNode",value:function finishNode(node,type){return this.finishNodeAt(node,type,this.state.lastTokEndLoc);}},{key:"finishNodeAt",value:function finishNodeAt(node,type,endLoc){node.type=type;node.end=endLoc.index;node.loc.end=endLoc;if(this.optionFlags&64)node.range[1]=endLoc.index;if(this.optionFlags&2048){this.processComment(node);}return node;}},{key:"resetStartLocation",value:function resetStartLocation(node,startLoc){node.start=startLoc.index;node.loc.start=startLoc;if(this.optionFlags&64)node.range[0]=startLoc.index;}},{key:"resetEndLocation",value:function resetEndLocation(node){var endLoc=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.state.lastTokEndLoc;node.end=endLoc.index;node.loc.end=endLoc;if(this.optionFlags&64)node.range[1]=endLoc.index;}},{key:"resetStartLocationFromNode",value:function resetStartLocationFromNode(node,locationNode){this.resetStartLocation(node,locationNode.loc.start);}}]);}(UtilParser);var reservedTypes=new Set(["_","any","bool","boolean","empty","extends","false","interface","mixed","null","number","static","string","true","typeof","void"]);var FlowErrors=ParseErrorEnum(_templateObject2||(_templateObject2=_taggedTemplateLiteral(["flow"])))({AmbiguousConditionalArrow:"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",AmbiguousDeclareModuleKind:"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",AssignReservedType:function AssignReservedType(_ref44){var reservedType=_ref44.reservedType;return "Cannot overwrite reserved type ".concat(reservedType,".");},DeclareClassElement:"The `declare` modifier can only appear on class fields.",DeclareClassFieldInitializer:"Initializers are not allowed in fields with the `declare` modifier.",DuplicateDeclareModuleExports:"Duplicate `declare module.exports` statement.",EnumBooleanMemberNotInitialized:function EnumBooleanMemberNotInitialized(_ref45){var memberName=_ref45.memberName,enumName=_ref45.enumName;return "Boolean enum members need to be initialized. Use either `".concat(memberName," = true,` or `").concat(memberName," = false,` in enum `").concat(enumName,"`.");},EnumDuplicateMemberName:function EnumDuplicateMemberName(_ref46){var memberName=_ref46.memberName,enumName=_ref46.enumName;return "Enum member names need to be unique, but the name `".concat(memberName,"` has already been used before in enum `").concat(enumName,"`.");},EnumInconsistentMemberValues:function EnumInconsistentMemberValues(_ref47){var enumName=_ref47.enumName;return "Enum `".concat(enumName,"` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.");},EnumInvalidExplicitType:function EnumInvalidExplicitType(_ref48){var invalidEnumType=_ref48.invalidEnumType,enumName=_ref48.enumName;return "Enum type `".concat(invalidEnumType,"` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `").concat(enumName,"`.");},EnumInvalidExplicitTypeUnknownSupplied:function EnumInvalidExplicitTypeUnknownSupplied(_ref49){var enumName=_ref49.enumName;return "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `".concat(enumName,"`.");},EnumInvalidMemberInitializerPrimaryType:function EnumInvalidMemberInitializerPrimaryType(_ref50){var enumName=_ref50.enumName,memberName=_ref50.memberName,explicitType=_ref50.explicitType;return "Enum `".concat(enumName,"` has type `").concat(explicitType,"`, so the initializer of `").concat(memberName,"` needs to be a ").concat(explicitType," literal.");},EnumInvalidMemberInitializerSymbolType:function EnumInvalidMemberInitializerSymbolType(_ref51){var enumName=_ref51.enumName,memberName=_ref51.memberName;return "Symbol enum members cannot be initialized. Use `".concat(memberName,",` in enum `").concat(enumName,"`.");},EnumInvalidMemberInitializerUnknownType:function EnumInvalidMemberInitializerUnknownType(_ref52){var enumName=_ref52.enumName,memberName=_ref52.memberName;return "The enum member initializer for `".concat(memberName,"` needs to be a literal (either a boolean, number, or string) in enum `").concat(enumName,"`.");},EnumInvalidMemberName:function EnumInvalidMemberName(_ref53){var enumName=_ref53.enumName,memberName=_ref53.memberName,suggestion=_ref53.suggestion;return "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `".concat(memberName,"`, consider using `").concat(suggestion,"`, in enum `").concat(enumName,"`.");},EnumNumberMemberNotInitialized:function EnumNumberMemberNotInitialized(_ref54){var enumName=_ref54.enumName,memberName=_ref54.memberName;return "Number enum members need to be initialized, e.g. `".concat(memberName," = 1` in enum `").concat(enumName,"`.");},EnumStringMemberInconsistentlyInitialized:function EnumStringMemberInconsistentlyInitialized(_ref55){var enumName=_ref55.enumName;return "String enum members need to consistently either all use initializers, or use no initializers, in enum `".concat(enumName,"`.");},GetterMayNotHaveThisParam:"A getter cannot have a `this` parameter.",ImportReflectionHasImportType:"An `import module` declaration can not use `type` or `typeof` keyword.",ImportTypeShorthandOnlyInPureImport:"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",InexactInsideExact:"Explicit inexact syntax cannot appear inside an explicit exact object type.",InexactInsideNonObject:"Explicit inexact syntax cannot appear in class or interface definitions.",InexactVariance:"Explicit inexact syntax cannot have variance.",InvalidNonTypeImportInDeclareModule:"Imports within a `declare module` body must always be `import type` or `import typeof`.",MissingTypeParamDefault:"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",NestedDeclareModule:"`declare module` cannot be used inside another `declare module`.",NestedFlowComment:"Cannot have a flow comment inside another flow comment.",PatternIsOptional:Object.assign({message:"A binding pattern parameter cannot be optional in an implementation signature."},{reasonCode:"OptionalBindingPattern"}),SetterMayNotHaveThisParam:"A setter cannot have a `this` parameter.",SpreadVariance:"Spread properties cannot have variance.",ThisParamAnnotationRequired:"A type annotation is required for the `this` parameter.",ThisParamBannedInConstructor:"Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",ThisParamMayNotBeOptional:"The `this` parameter cannot be optional.",ThisParamMustBeFirst:"The `this` parameter must be the first function parameter.",ThisParamNoDefault:"The `this` parameter may not have a default value.",TypeBeforeInitializer:"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",TypeCastInPattern:"The type cast expression is expected to be wrapped with parenthesis.",UnexpectedExplicitInexactInObject:"Explicit inexact syntax must appear at the end of an inexact object.",UnexpectedReservedType:function UnexpectedReservedType(_ref56){var reservedType=_ref56.reservedType;return "Unexpected reserved type ".concat(reservedType,".");},UnexpectedReservedUnderscore:"`_` is only allowed as a type argument to call or new.",UnexpectedSpaceBetweenModuloChecks:"Spaces between `%` and `checks` are not allowed here.",UnexpectedSpreadType:"Spread operator cannot appear in class or interface definitions.",UnexpectedSubtractionOperand:'Unexpected token, expected "number" or "bigint".',UnexpectedTokenAfterTypeParameter:"Expected an arrow function after this type parameter declaration.",UnexpectedTypeParameterBeforeAsyncArrowFunction:"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",UnsupportedDeclareExportKind:function UnsupportedDeclareExportKind(_ref57){var unsupportedExportKind=_ref57.unsupportedExportKind,suggestion=_ref57.suggestion;return "`declare export ".concat(unsupportedExportKind,"` is not supported. Use `").concat(suggestion,"` instead.");},UnsupportedStatementInDeclareModule:"Only declares and type imports are allowed inside declare module.",UnterminatedFlowComment:"Unterminated flow-comment."});function isEsModuleType(bodyElement){return bodyElement.type==="DeclareExportAllDeclaration"||bodyElement.type==="DeclareExportDeclaration"&&(!bodyElement.declaration||bodyElement.declaration.type!=="TypeAlias"&&bodyElement.declaration.type!=="InterfaceDeclaration");}function hasTypeImportKind(node){return node.importKind==="type"||node.importKind==="typeof";}var exportSuggestions={"const":"declare export var","let":"declare export var",type:"export type","interface":"export interface"};function partition(list,test){var list1=[];var list2=[];for(var i=0;i<list.length;i++){(test(list[i],i,list)?list1:list2).push(list[i]);}return [list1,list2];}var FLOW_PRAGMA_REGEX=/\*?\s*@((?:no)?flow)\b/;var flow=function flow(superClass){return/*#__PURE__*/function(_superClass2){function FlowParserMixin(){var _this11;_classCallCheck(this,FlowParserMixin);for(var _len4=arguments.length,args=new Array(_len4),_key4=0;_key4<_len4;_key4++){args[_key4]=arguments[_key4];}_this11=_callSuper(this,FlowParserMixin,[].concat(args));_this11.flowPragma=undefined;return _this11;}_inherits(FlowParserMixin,_superClass2);return _createClass(FlowParserMixin,[{key:"getScopeHandler",value:function getScopeHandler(){return FlowScopeHandler;}},{key:"shouldParseTypes",value:function shouldParseTypes(){return this.getPluginOption("flow","all")||this.flowPragma==="flow";}},{key:"finishToken",value:function finishToken(type,val){if(type!==134&&type!==13&&type!==28){if(this.flowPragma===undefined){this.flowPragma=null;}}_superPropGet(FlowParserMixin,"finishToken",this,3)([type,val]);}},{key:"addComment",value:function addComment(comment){if(this.flowPragma===undefined){var matches=FLOW_PRAGMA_REGEX.exec(comment.value);if(!matches);else if(matches[1]==="flow"){this.flowPragma="flow";}else if(matches[1]==="noflow"){this.flowPragma="noflow";}else {throw new Error("Unexpected flow pragma");}}_superPropGet(FlowParserMixin,"addComment",this,3)([comment]);}},{key:"flowParseTypeInitialiser",value:function flowParseTypeInitialiser(tok){var oldInType=this.state.inType;this.state.inType=true;this.expect(tok||14);var type=this.flowParseType();this.state.inType=oldInType;return type;}},{key:"flowParsePredicate",value:function flowParsePredicate(){var node=this.startNode();var moduloLoc=this.state.startLoc;this.next();this.expectContextual(110);if(this.state.lastTokStartLoc.index>moduloLoc.index+1){this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks,moduloLoc);}if(this.eat(10)){node.value=_superPropGet(FlowParserMixin,"parseExpression",this,3)([]);this.expect(11);return this.finishNode(node,"DeclaredPredicate");}else {return this.finishNode(node,"InferredPredicate");}}},{key:"flowParseTypeAndPredicateInitialiser",value:function flowParseTypeAndPredicateInitialiser(){var oldInType=this.state.inType;this.state.inType=true;this.expect(14);var type=null;var predicate=null;if(this.match(54)){this.state.inType=oldInType;predicate=this.flowParsePredicate();}else {type=this.flowParseType();this.state.inType=oldInType;if(this.match(54)){predicate=this.flowParsePredicate();}}return [type,predicate];}},{key:"flowParseDeclareClass",value:function flowParseDeclareClass(node){this.next();this.flowParseInterfaceish(node,true);return this.finishNode(node,"DeclareClass");}},{key:"flowParseDeclareFunction",value:function flowParseDeclareFunction(node){this.next();var id=node.id=this.parseIdentifier();var typeNode=this.startNode();var typeContainer=this.startNode();if(this.match(47)){typeNode.typeParameters=this.flowParseTypeParameterDeclaration();}else {typeNode.typeParameters=null;}this.expect(10);var tmp=this.flowParseFunctionTypeParams();typeNode.params=tmp.params;typeNode.rest=tmp.rest;typeNode["this"]=tmp._this;this.expect(11);var _this$flowParseTypeAn=this.flowParseTypeAndPredicateInitialiser();var _this$flowParseTypeAn2=_slicedToArray(_this$flowParseTypeAn,2);typeNode.returnType=_this$flowParseTypeAn2[0];node.predicate=_this$flowParseTypeAn2[1];typeContainer.typeAnnotation=this.finishNode(typeNode,"FunctionTypeAnnotation");id.typeAnnotation=this.finishNode(typeContainer,"TypeAnnotation");this.resetEndLocation(id);this.semicolon();this.scope.declareName(node.id.name,2048,node.id.loc.start);return this.finishNode(node,"DeclareFunction");}},{key:"flowParseDeclare",value:function flowParseDeclare(node,insideModule){if(this.match(80)){return this.flowParseDeclareClass(node);}else if(this.match(68)){return this.flowParseDeclareFunction(node);}else if(this.match(74)){return this.flowParseDeclareVariable(node);}else if(this.eatContextual(127)){if(this.match(16)){return this.flowParseDeclareModuleExports(node);}else {if(insideModule){this.raise(FlowErrors.NestedDeclareModule,this.state.lastTokStartLoc);}return this.flowParseDeclareModule(node);}}else if(this.isContextual(130)){return this.flowParseDeclareTypeAlias(node);}else if(this.isContextual(131)){return this.flowParseDeclareOpaqueType(node);}else if(this.isContextual(129)){return this.flowParseDeclareInterface(node);}else if(this.match(82)){return this.flowParseDeclareExportDeclaration(node,insideModule);}else {this.unexpected();}}},{key:"flowParseDeclareVariable",value:function flowParseDeclareVariable(node){this.next();node.id=this.flowParseTypeAnnotatableIdentifier(true);this.scope.declareName(node.id.name,5,node.id.loc.start);this.semicolon();return this.finishNode(node,"DeclareVariable");}},{key:"flowParseDeclareModule",value:function flowParseDeclareModule(node){var _this12=this;this.scope.enter(0);if(this.match(134)){node.id=_superPropGet(FlowParserMixin,"parseExprAtom",this,3)([]);}else {node.id=this.parseIdentifier();}var bodyNode=node.body=this.startNode();var body=bodyNode.body=[];this.expect(5);while(!this.match(8)){var _bodyNode=this.startNode();if(this.match(83)){this.next();if(!this.isContextual(130)&&!this.match(87)){this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule,this.state.lastTokStartLoc);}_superPropGet(FlowParserMixin,"parseImport",this,3)([_bodyNode]);}else {this.expectContextual(125,FlowErrors.UnsupportedStatementInDeclareModule);_bodyNode=this.flowParseDeclare(_bodyNode,true);}body.push(_bodyNode);}this.scope.exit();this.expect(8);this.finishNode(bodyNode,"BlockStatement");var kind=null;var hasModuleExport=false;body.forEach(function(bodyElement){if(isEsModuleType(bodyElement)){if(kind==="CommonJS"){_this12.raise(FlowErrors.AmbiguousDeclareModuleKind,bodyElement);}kind="ES";}else if(bodyElement.type==="DeclareModuleExports"){if(hasModuleExport){_this12.raise(FlowErrors.DuplicateDeclareModuleExports,bodyElement);}if(kind==="ES"){_this12.raise(FlowErrors.AmbiguousDeclareModuleKind,bodyElement);}kind="CommonJS";hasModuleExport=true;}});node.kind=kind||"CommonJS";return this.finishNode(node,"DeclareModule");}},{key:"flowParseDeclareExportDeclaration",value:function flowParseDeclareExportDeclaration(node,insideModule){this.expect(82);if(this.eat(65)){if(this.match(68)||this.match(80)){node.declaration=this.flowParseDeclare(this.startNode());}else {node.declaration=this.flowParseType();this.semicolon();}node["default"]=true;return this.finishNode(node,"DeclareExportDeclaration");}else {if(this.match(75)||this.isLet()||(this.isContextual(130)||this.isContextual(129))&&!insideModule){var label=this.state.value;throw this.raise(FlowErrors.UnsupportedDeclareExportKind,this.state.startLoc,{unsupportedExportKind:label,suggestion:exportSuggestions[label]});}if(this.match(74)||this.match(68)||this.match(80)||this.isContextual(131)){node.declaration=this.flowParseDeclare(this.startNode());node["default"]=false;return this.finishNode(node,"DeclareExportDeclaration");}else if(this.match(55)||this.match(5)||this.isContextual(129)||this.isContextual(130)||this.isContextual(131)){node=this.parseExport(node,null);if(node.type==="ExportNamedDeclaration"){node.type="ExportDeclaration";node["default"]=false;delete node.exportKind;}node.type="Declare"+node.type;return node;}}this.unexpected();}},{key:"flowParseDeclareModuleExports",value:function flowParseDeclareModuleExports(node){this.next();this.expectContextual(111);node.typeAnnotation=this.flowParseTypeAnnotation();this.semicolon();return this.finishNode(node,"DeclareModuleExports");}},{key:"flowParseDeclareTypeAlias",value:function flowParseDeclareTypeAlias(node){this.next();var finished=this.flowParseTypeAlias(node);finished.type="DeclareTypeAlias";return finished;}},{key:"flowParseDeclareOpaqueType",value:function flowParseDeclareOpaqueType(node){this.next();var finished=this.flowParseOpaqueType(node,true);finished.type="DeclareOpaqueType";return finished;}},{key:"flowParseDeclareInterface",value:function flowParseDeclareInterface(node){this.next();this.flowParseInterfaceish(node,false);return this.finishNode(node,"DeclareInterface");}},{key:"flowParseInterfaceish",value:function flowParseInterfaceish(node,isClass){node.id=this.flowParseRestrictedIdentifier(!isClass,true);this.scope.declareName(node.id.name,isClass?17:8201,node.id.loc.start);if(this.match(47)){node.typeParameters=this.flowParseTypeParameterDeclaration();}else {node.typeParameters=null;}node["extends"]=[];if(this.eat(81)){do{node["extends"].push(this.flowParseInterfaceExtends());}while(!isClass&&this.eat(12));}if(isClass){node["implements"]=[];node.mixins=[];if(this.eatContextual(117)){do{node.mixins.push(this.flowParseInterfaceExtends());}while(this.eat(12));}if(this.eatContextual(113)){do{node["implements"].push(this.flowParseInterfaceExtends());}while(this.eat(12));}}node.body=this.flowParseObjectType({allowStatic:isClass,allowExact:false,allowSpread:false,allowProto:isClass,allowInexact:false});}},{key:"flowParseInterfaceExtends",value:function flowParseInterfaceExtends(){var node=this.startNode();node.id=this.flowParseQualifiedTypeIdentifier();if(this.match(47)){node.typeParameters=this.flowParseTypeParameterInstantiation();}else {node.typeParameters=null;}return this.finishNode(node,"InterfaceExtends");}},{key:"flowParseInterface",value:function flowParseInterface(node){this.flowParseInterfaceish(node,false);return this.finishNode(node,"InterfaceDeclaration");}},{key:"checkNotUnderscore",value:function checkNotUnderscore(word){if(word==="_"){this.raise(FlowErrors.UnexpectedReservedUnderscore,this.state.startLoc);}}},{key:"checkReservedType",value:function checkReservedType(word,startLoc,declaration){if(!reservedTypes.has(word))return;this.raise(declaration?FlowErrors.AssignReservedType:FlowErrors.UnexpectedReservedType,startLoc,{reservedType:word});}},{key:"flowParseRestrictedIdentifier",value:function flowParseRestrictedIdentifier(liberal,declaration){this.checkReservedType(this.state.value,this.state.startLoc,declaration);return this.parseIdentifier(liberal);}},{key:"flowParseTypeAlias",value:function flowParseTypeAlias(node){node.id=this.flowParseRestrictedIdentifier(false,true);this.scope.declareName(node.id.name,8201,node.id.loc.start);if(this.match(47)){node.typeParameters=this.flowParseTypeParameterDeclaration();}else {node.typeParameters=null;}node.right=this.flowParseTypeInitialiser(29);this.semicolon();return this.finishNode(node,"TypeAlias");}},{key:"flowParseOpaqueType",value:function flowParseOpaqueType(node,declare){this.expectContextual(130);node.id=this.flowParseRestrictedIdentifier(true,true);this.scope.declareName(node.id.name,8201,node.id.loc.start);if(this.match(47)){node.typeParameters=this.flowParseTypeParameterDeclaration();}else {node.typeParameters=null;}node.supertype=null;if(this.match(14)){node.supertype=this.flowParseTypeInitialiser(14);}node.impltype=null;if(!declare){node.impltype=this.flowParseTypeInitialiser(29);}this.semicolon();return this.finishNode(node,"OpaqueType");}},{key:"flowParseTypeParameter",value:function flowParseTypeParameter(){var requireDefault=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;var nodeStartLoc=this.state.startLoc;var node=this.startNode();var variance=this.flowParseVariance();var ident=this.flowParseTypeAnnotatableIdentifier();node.name=ident.name;node.variance=variance;node.bound=ident.typeAnnotation;if(this.match(29)){this.eat(29);node["default"]=this.flowParseType();}else {if(requireDefault){this.raise(FlowErrors.MissingTypeParamDefault,nodeStartLoc);}}return this.finishNode(node,"TypeParameter");}},{key:"flowParseTypeParameterDeclaration",value:function flowParseTypeParameterDeclaration(){var oldInType=this.state.inType;var node=this.startNode();node.params=[];this.state.inType=true;if(this.match(47)||this.match(143)){this.next();}else {this.unexpected();}var defaultRequired=false;do{var typeParameter=this.flowParseTypeParameter(defaultRequired);node.params.push(typeParameter);if(typeParameter["default"]){defaultRequired=true;}if(!this.match(48)){this.expect(12);}}while(!this.match(48));this.expect(48);this.state.inType=oldInType;return this.finishNode(node,"TypeParameterDeclaration");}},{key:"flowInTopLevelContext",value:function flowInTopLevelContext(cb){if(this.curContext()!==types.brace){var oldContext=this.state.context;this.state.context=[oldContext[0]];try{return cb();}finally{this.state.context=oldContext;}}else {return cb();}}},{key:"flowParseTypeParameterInstantiationInExpression",value:function flowParseTypeParameterInstantiationInExpression(){if(this.reScan_lt()!==47)return;return this.flowParseTypeParameterInstantiation();}},{key:"flowParseTypeParameterInstantiation",value:function flowParseTypeParameterInstantiation(){var _this13=this;var node=this.startNode();var oldInType=this.state.inType;this.state.inType=true;node.params=[];this.flowInTopLevelContext(function(){_this13.expect(47);var oldNoAnonFunctionType=_this13.state.noAnonFunctionType;_this13.state.noAnonFunctionType=false;while(!_this13.match(48)){node.params.push(_this13.flowParseType());if(!_this13.match(48)){_this13.expect(12);}}_this13.state.noAnonFunctionType=oldNoAnonFunctionType;});this.state.inType=oldInType;if(!this.state.inType&&this.curContext()===types.brace){this.reScan_lt_gt();}this.expect(48);return this.finishNode(node,"TypeParameterInstantiation");}},{key:"flowParseTypeParameterInstantiationCallOrNew",value:function flowParseTypeParameterInstantiationCallOrNew(){if(this.reScan_lt()!==47)return;var node=this.startNode();var oldInType=this.state.inType;node.params=[];this.state.inType=true;this.expect(47);while(!this.match(48)){node.params.push(this.flowParseTypeOrImplicitInstantiation());if(!this.match(48)){this.expect(12);}}this.expect(48);this.state.inType=oldInType;return this.finishNode(node,"TypeParameterInstantiation");}},{key:"flowParseInterfaceType",value:function flowParseInterfaceType(){var node=this.startNode();this.expectContextual(129);node["extends"]=[];if(this.eat(81)){do{node["extends"].push(this.flowParseInterfaceExtends());}while(this.eat(12));}node.body=this.flowParseObjectType({allowStatic:false,allowExact:false,allowSpread:false,allowProto:false,allowInexact:false});return this.finishNode(node,"InterfaceTypeAnnotation");}},{key:"flowParseObjectPropertyKey",value:function flowParseObjectPropertyKey(){return this.match(135)||this.match(134)?_superPropGet(FlowParserMixin,"parseExprAtom",this,3)([]):this.parseIdentifier(true);}},{key:"flowParseObjectTypeIndexer",value:function flowParseObjectTypeIndexer(node,isStatic,variance){node["static"]=isStatic;if(this.lookahead().type===14){node.id=this.flowParseObjectPropertyKey();node.key=this.flowParseTypeInitialiser();}else {node.id=null;node.key=this.flowParseType();}this.expect(3);node.value=this.flowParseTypeInitialiser();node.variance=variance;return this.finishNode(node,"ObjectTypeIndexer");}},{key:"flowParseObjectTypeInternalSlot",value:function flowParseObjectTypeInternalSlot(node,isStatic){node["static"]=isStatic;node.id=this.flowParseObjectPropertyKey();this.expect(3);this.expect(3);if(this.match(47)||this.match(10)){node.method=true;node.optional=false;node.value=this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));}else {node.method=false;if(this.eat(17)){node.optional=true;}node.value=this.flowParseTypeInitialiser();}return this.finishNode(node,"ObjectTypeInternalSlot");}},{key:"flowParseObjectTypeMethodish",value:function flowParseObjectTypeMethodish(node){node.params=[];node.rest=null;node.typeParameters=null;node["this"]=null;if(this.match(47)){node.typeParameters=this.flowParseTypeParameterDeclaration();}this.expect(10);if(this.match(78)){node["this"]=this.flowParseFunctionTypeParam(true);node["this"].name=null;if(!this.match(11)){this.expect(12);}}while(!this.match(11)&&!this.match(21)){node.params.push(this.flowParseFunctionTypeParam(false));if(!this.match(11)){this.expect(12);}}if(this.eat(21)){node.rest=this.flowParseFunctionTypeParam(false);}this.expect(11);node.returnType=this.flowParseTypeInitialiser();return this.finishNode(node,"FunctionTypeAnnotation");}},{key:"flowParseObjectTypeCallProperty",value:function flowParseObjectTypeCallProperty(node,isStatic){var valueNode=this.startNode();node["static"]=isStatic;node.value=this.flowParseObjectTypeMethodish(valueNode);return this.finishNode(node,"ObjectTypeCallProperty");}},{key:"flowParseObjectType",value:function flowParseObjectType(_ref58){var allowStatic=_ref58.allowStatic,allowExact=_ref58.allowExact,allowSpread=_ref58.allowSpread,allowProto=_ref58.allowProto,allowInexact=_ref58.allowInexact;var oldInType=this.state.inType;this.state.inType=true;var nodeStart=this.startNode();nodeStart.callProperties=[];nodeStart.properties=[];nodeStart.indexers=[];nodeStart.internalSlots=[];var endDelim;var exact;var inexact=false;if(allowExact&&this.match(6)){this.expect(6);endDelim=9;exact=true;}else {this.expect(5);endDelim=8;exact=false;}nodeStart.exact=exact;while(!this.match(endDelim)){var isStatic=false;var protoStartLoc=null;var inexactStartLoc=null;var node=this.startNode();if(allowProto&&this.isContextual(118)){var lookahead=this.lookahead();if(lookahead.type!==14&&lookahead.type!==17){this.next();protoStartLoc=this.state.startLoc;allowStatic=false;}}if(allowStatic&&this.isContextual(106)){var _lookahead=this.lookahead();if(_lookahead.type!==14&&_lookahead.type!==17){this.next();isStatic=true;}}var variance=this.flowParseVariance();if(this.eat(0)){if(protoStartLoc!=null){this.unexpected(protoStartLoc);}if(this.eat(0)){if(variance){this.unexpected(variance.loc.start);}nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node,isStatic));}else {nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node,isStatic,variance));}}else if(this.match(10)||this.match(47)){if(protoStartLoc!=null){this.unexpected(protoStartLoc);}if(variance){this.unexpected(variance.loc.start);}nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node,isStatic));}else {var kind="init";if(this.isContextual(99)||this.isContextual(104)){var _lookahead2=this.lookahead();if(tokenIsLiteralPropertyName(_lookahead2.type)){kind=this.state.value;this.next();}}var propOrInexact=this.flowParseObjectTypeProperty(node,isStatic,protoStartLoc,variance,kind,allowSpread,allowInexact!=null?allowInexact:!exact);if(propOrInexact===null){inexact=true;inexactStartLoc=this.state.lastTokStartLoc;}else {nodeStart.properties.push(propOrInexact);}}this.flowObjectTypeSemicolon();if(inexactStartLoc&&!this.match(8)&&!this.match(9)){this.raise(FlowErrors.UnexpectedExplicitInexactInObject,inexactStartLoc);}}this.expect(endDelim);if(allowSpread){nodeStart.inexact=inexact;}var out=this.finishNode(nodeStart,"ObjectTypeAnnotation");this.state.inType=oldInType;return out;}},{key:"flowParseObjectTypeProperty",value:function flowParseObjectTypeProperty(node,isStatic,protoStartLoc,variance,kind,allowSpread,allowInexact){if(this.eat(21)){var isInexactToken=this.match(12)||this.match(13)||this.match(8)||this.match(9);if(isInexactToken){if(!allowSpread){this.raise(FlowErrors.InexactInsideNonObject,this.state.lastTokStartLoc);}else if(!allowInexact){this.raise(FlowErrors.InexactInsideExact,this.state.lastTokStartLoc);}if(variance){this.raise(FlowErrors.InexactVariance,variance);}return null;}if(!allowSpread){this.raise(FlowErrors.UnexpectedSpreadType,this.state.lastTokStartLoc);}if(protoStartLoc!=null){this.unexpected(protoStartLoc);}if(variance){this.raise(FlowErrors.SpreadVariance,variance);}node.argument=this.flowParseType();return this.finishNode(node,"ObjectTypeSpreadProperty");}else {node.key=this.flowParseObjectPropertyKey();node["static"]=isStatic;node.proto=protoStartLoc!=null;node.kind=kind;var optional=false;if(this.match(47)||this.match(10)){node.method=true;if(protoStartLoc!=null){this.unexpected(protoStartLoc);}if(variance){this.unexpected(variance.loc.start);}node.value=this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));if(kind==="get"||kind==="set"){this.flowCheckGetterSetterParams(node);}if(!allowSpread&&node.key.name==="constructor"&&node.value["this"]){this.raise(FlowErrors.ThisParamBannedInConstructor,node.value["this"]);}}else {if(kind!=="init")this.unexpected();node.method=false;if(this.eat(17)){optional=true;}node.value=this.flowParseTypeInitialiser();node.variance=variance;}node.optional=optional;return this.finishNode(node,"ObjectTypeProperty");}}},{key:"flowCheckGetterSetterParams",value:function flowCheckGetterSetterParams(property){var paramCount=property.kind==="get"?0:1;var length=property.value.params.length+(property.value.rest?1:0);if(property.value["this"]){this.raise(property.kind==="get"?FlowErrors.GetterMayNotHaveThisParam:FlowErrors.SetterMayNotHaveThisParam,property.value["this"]);}if(length!==paramCount){this.raise(property.kind==="get"?Errors.BadGetterArity:Errors.BadSetterArity,property);}if(property.kind==="set"&&property.value.rest){this.raise(Errors.BadSetterRestParameter,property);}}},{key:"flowObjectTypeSemicolon",value:function flowObjectTypeSemicolon(){if(!this.eat(13)&&!this.eat(12)&&!this.match(8)&&!this.match(9)){this.unexpected();}}},{key:"flowParseQualifiedTypeIdentifier",value:function flowParseQualifiedTypeIdentifier(startLoc,id){var _startLoc;(_startLoc=startLoc)!=null?_startLoc:startLoc=this.state.startLoc;var node=id||this.flowParseRestrictedIdentifier(true);while(this.eat(16)){var node2=this.startNodeAt(startLoc);node2.qualification=node;node2.id=this.flowParseRestrictedIdentifier(true);node=this.finishNode(node2,"QualifiedTypeIdentifier");}return node;}},{key:"flowParseGenericType",value:function flowParseGenericType(startLoc,id){var node=this.startNodeAt(startLoc);node.typeParameters=null;node.id=this.flowParseQualifiedTypeIdentifier(startLoc,id);if(this.match(47)){node.typeParameters=this.flowParseTypeParameterInstantiation();}return this.finishNode(node,"GenericTypeAnnotation");}},{key:"flowParseTypeofType",value:function flowParseTypeofType(){var node=this.startNode();this.expect(87);node.argument=this.flowParsePrimaryType();return this.finishNode(node,"TypeofTypeAnnotation");}},{key:"flowParseTupleType",value:function flowParseTupleType(){var node=this.startNode();node.types=[];this.expect(0);while(this.state.pos<this.length&&!this.match(3)){node.types.push(this.flowParseType());if(this.match(3))break;this.expect(12);}this.expect(3);return this.finishNode(node,"TupleTypeAnnotation");}},{key:"flowParseFunctionTypeParam",value:function flowParseFunctionTypeParam(first){var name=null;var optional=false;var typeAnnotation=null;var node=this.startNode();var lh=this.lookahead();var isThis=this.state.type===78;if(lh.type===14||lh.type===17){if(isThis&&!first){this.raise(FlowErrors.ThisParamMustBeFirst,node);}name=this.parseIdentifier(isThis);if(this.eat(17)){optional=true;if(isThis){this.raise(FlowErrors.ThisParamMayNotBeOptional,node);}}typeAnnotation=this.flowParseTypeInitialiser();}else {typeAnnotation=this.flowParseType();}node.name=name;node.optional=optional;node.typeAnnotation=typeAnnotation;return this.finishNode(node,"FunctionTypeParam");}},{key:"reinterpretTypeAsFunctionTypeParam",value:function reinterpretTypeAsFunctionTypeParam(type){var node=this.startNodeAt(type.loc.start);node.name=null;node.optional=false;node.typeAnnotation=type;return this.finishNode(node,"FunctionTypeParam");}},{key:"flowParseFunctionTypeParams",value:function flowParseFunctionTypeParams(){var params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var rest=null;var _this=null;if(this.match(78)){_this=this.flowParseFunctionTypeParam(true);_this.name=null;if(!this.match(11)){this.expect(12);}}while(!this.match(11)&&!this.match(21)){params.push(this.flowParseFunctionTypeParam(false));if(!this.match(11)){this.expect(12);}}if(this.eat(21)){rest=this.flowParseFunctionTypeParam(false);}return {params:params,rest:rest,_this:_this};}},{key:"flowIdentToTypeAnnotation",value:function flowIdentToTypeAnnotation(startLoc,node,id){switch(id.name){case "any":return this.finishNode(node,"AnyTypeAnnotation");case "bool":case "boolean":return this.finishNode(node,"BooleanTypeAnnotation");case "mixed":return this.finishNode(node,"MixedTypeAnnotation");case "empty":return this.finishNode(node,"EmptyTypeAnnotation");case "number":return this.finishNode(node,"NumberTypeAnnotation");case "string":return this.finishNode(node,"StringTypeAnnotation");case "symbol":return this.finishNode(node,"SymbolTypeAnnotation");default:this.checkNotUnderscore(id.name);return this.flowParseGenericType(startLoc,id);}}},{key:"flowParsePrimaryType",value:function flowParsePrimaryType(){var startLoc=this.state.startLoc;var node=this.startNode();var tmp;var type;var isGroupedType=false;var oldNoAnonFunctionType=this.state.noAnonFunctionType;switch(this.state.type){case 5:return this.flowParseObjectType({allowStatic:false,allowExact:false,allowSpread:true,allowProto:false,allowInexact:true});case 6:return this.flowParseObjectType({allowStatic:false,allowExact:true,allowSpread:true,allowProto:false,allowInexact:false});case 0:this.state.noAnonFunctionType=false;type=this.flowParseTupleType();this.state.noAnonFunctionType=oldNoAnonFunctionType;return type;case 47:{var _node=this.startNode();_node.typeParameters=this.flowParseTypeParameterDeclaration();this.expect(10);tmp=this.flowParseFunctionTypeParams();_node.params=tmp.params;_node.rest=tmp.rest;_node["this"]=tmp._this;this.expect(11);this.expect(19);_node.returnType=this.flowParseType();return this.finishNode(_node,"FunctionTypeAnnotation");}case 10:{var _node2=this.startNode();this.next();if(!this.match(11)&&!this.match(21)){if(tokenIsIdentifier(this.state.type)||this.match(78)){var token=this.lookahead().type;isGroupedType=token!==17&&token!==14;}else {isGroupedType=true;}}if(isGroupedType){this.state.noAnonFunctionType=false;type=this.flowParseType();this.state.noAnonFunctionType=oldNoAnonFunctionType;if(this.state.noAnonFunctionType||!(this.match(12)||this.match(11)&&this.lookahead().type===19)){this.expect(11);return type;}else {this.eat(12);}}if(type){tmp=this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);}else {tmp=this.flowParseFunctionTypeParams();}_node2.params=tmp.params;_node2.rest=tmp.rest;_node2["this"]=tmp._this;this.expect(11);this.expect(19);_node2.returnType=this.flowParseType();_node2.typeParameters=null;return this.finishNode(_node2,"FunctionTypeAnnotation");}case 134:return this.parseLiteral(this.state.value,"StringLiteralTypeAnnotation");case 85:case 86:node.value=this.match(85);this.next();return this.finishNode(node,"BooleanLiteralTypeAnnotation");case 53:if(this.state.value==="-"){this.next();if(this.match(135)){return this.parseLiteralAtNode(-this.state.value,"NumberLiteralTypeAnnotation",node);}if(this.match(136)){return this.parseLiteralAtNode(-this.state.value,"BigIntLiteralTypeAnnotation",node);}throw this.raise(FlowErrors.UnexpectedSubtractionOperand,this.state.startLoc);}this.unexpected();return;case 135:return this.parseLiteral(this.state.value,"NumberLiteralTypeAnnotation");case 136:return this.parseLiteral(this.state.value,"BigIntLiteralTypeAnnotation");case 88:this.next();return this.finishNode(node,"VoidTypeAnnotation");case 84:this.next();return this.finishNode(node,"NullLiteralTypeAnnotation");case 78:this.next();return this.finishNode(node,"ThisTypeAnnotation");case 55:this.next();return this.finishNode(node,"ExistsTypeAnnotation");case 87:return this.flowParseTypeofType();default:if(tokenIsKeyword(this.state.type)){var label=tokenLabelName(this.state.type);this.next();return _superPropGet(FlowParserMixin,"createIdentifier",this,3)([node,label]);}else if(tokenIsIdentifier(this.state.type)){if(this.isContextual(129)){return this.flowParseInterfaceType();}return this.flowIdentToTypeAnnotation(startLoc,node,this.parseIdentifier());}}this.unexpected();}},{key:"flowParsePostfixType",value:function flowParsePostfixType(){var startLoc=this.state.startLoc;var type=this.flowParsePrimaryType();var seenOptionalIndexedAccess=false;while((this.match(0)||this.match(18))&&!this.canInsertSemicolon()){var node=this.startNodeAt(startLoc);var optional=this.eat(18);seenOptionalIndexedAccess=seenOptionalIndexedAccess||optional;this.expect(0);if(!optional&&this.match(3)){node.elementType=type;this.next();type=this.finishNode(node,"ArrayTypeAnnotation");}else {node.objectType=type;node.indexType=this.flowParseType();this.expect(3);if(seenOptionalIndexedAccess){node.optional=optional;type=this.finishNode(node,"OptionalIndexedAccessType");}else {type=this.finishNode(node,"IndexedAccessType");}}}return type;}},{key:"flowParsePrefixType",value:function flowParsePrefixType(){var node=this.startNode();if(this.eat(17)){node.typeAnnotation=this.flowParsePrefixType();return this.finishNode(node,"NullableTypeAnnotation");}else {return this.flowParsePostfixType();}}},{key:"flowParseAnonFunctionWithoutParens",value:function flowParseAnonFunctionWithoutParens(){var param=this.flowParsePrefixType();if(!this.state.noAnonFunctionType&&this.eat(19)){var node=this.startNodeAt(param.loc.start);node.params=[this.reinterpretTypeAsFunctionTypeParam(param)];node.rest=null;node["this"]=null;node.returnType=this.flowParseType();node.typeParameters=null;return this.finishNode(node,"FunctionTypeAnnotation");}return param;}},{key:"flowParseIntersectionType",value:function flowParseIntersectionType(){var node=this.startNode();this.eat(45);var type=this.flowParseAnonFunctionWithoutParens();node.types=[type];while(this.eat(45)){node.types.push(this.flowParseAnonFunctionWithoutParens());}return node.types.length===1?type:this.finishNode(node,"IntersectionTypeAnnotation");}},{key:"flowParseUnionType",value:function flowParseUnionType(){var node=this.startNode();this.eat(43);var type=this.flowParseIntersectionType();node.types=[type];while(this.eat(43)){node.types.push(this.flowParseIntersectionType());}return node.types.length===1?type:this.finishNode(node,"UnionTypeAnnotation");}},{key:"flowParseType",value:function flowParseType(){var oldInType=this.state.inType;this.state.inType=true;var type=this.flowParseUnionType();this.state.inType=oldInType;return type;}},{key:"flowParseTypeOrImplicitInstantiation",value:function flowParseTypeOrImplicitInstantiation(){if(this.state.type===132&&this.state.value==="_"){var startLoc=this.state.startLoc;var node=this.parseIdentifier();return this.flowParseGenericType(startLoc,node);}else {return this.flowParseType();}}},{key:"flowParseTypeAnnotation",value:function flowParseTypeAnnotation(){var node=this.startNode();node.typeAnnotation=this.flowParseTypeInitialiser();return this.finishNode(node,"TypeAnnotation");}},{key:"flowParseTypeAnnotatableIdentifier",value:function flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride){var ident=allowPrimitiveOverride?this.parseIdentifier():this.flowParseRestrictedIdentifier();if(this.match(14)){ident.typeAnnotation=this.flowParseTypeAnnotation();this.resetEndLocation(ident);}return ident;}},{key:"typeCastToParameter",value:function typeCastToParameter(node){node.expression.typeAnnotation=node.typeAnnotation;this.resetEndLocation(node.expression,node.typeAnnotation.loc.end);return node.expression;}},{key:"flowParseVariance",value:function flowParseVariance(){var variance=null;if(this.match(53)){variance=this.startNode();if(this.state.value==="+"){variance.kind="plus";}else {variance.kind="minus";}this.next();return this.finishNode(variance,"Variance");}return variance;}},{key:"parseFunctionBody",value:function parseFunctionBody(node,allowExpressionBody){var _this14=this;var isMethod=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;if(allowExpressionBody){this.forwardNoArrowParamsConversionAt(node,function(){return _superPropGet(FlowParserMixin,"parseFunctionBody",_this14,3)([node,true,isMethod]);});return;}_superPropGet(FlowParserMixin,"parseFunctionBody",this,3)([node,false,isMethod]);}},{key:"parseFunctionBodyAndFinish",value:function parseFunctionBodyAndFinish(node,type){var isMethod=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;if(this.match(14)){var typeNode=this.startNode();var _this$flowParseTypeAn3=this.flowParseTypeAndPredicateInitialiser();var _this$flowParseTypeAn4=_slicedToArray(_this$flowParseTypeAn3,2);typeNode.typeAnnotation=_this$flowParseTypeAn4[0];node.predicate=_this$flowParseTypeAn4[1];node.returnType=typeNode.typeAnnotation?this.finishNode(typeNode,"TypeAnnotation"):null;}return _superPropGet(FlowParserMixin,"parseFunctionBodyAndFinish",this,3)([node,type,isMethod]);}},{key:"parseStatementLike",value:function parseStatementLike(flags){if(this.state.strict&&this.isContextual(129)){var lookahead=this.lookahead();if(tokenIsKeywordOrIdentifier(lookahead.type)){var node=this.startNode();this.next();return this.flowParseInterface(node);}}else if(this.isContextual(126)){var _node3=this.startNode();this.next();return this.flowParseEnumDeclaration(_node3);}var stmt=_superPropGet(FlowParserMixin,"parseStatementLike",this,3)([flags]);if(this.flowPragma===undefined&&!this.isValidDirective(stmt)){this.flowPragma=null;}return stmt;}},{key:"parseExpressionStatement",value:function parseExpressionStatement(node,expr,decorators){if(expr.type==="Identifier"){if(expr.name==="declare"){if(this.match(80)||tokenIsIdentifier(this.state.type)||this.match(68)||this.match(74)||this.match(82)){return this.flowParseDeclare(node);}}else if(tokenIsIdentifier(this.state.type)){if(expr.name==="interface"){return this.flowParseInterface(node);}else if(expr.name==="type"){return this.flowParseTypeAlias(node);}else if(expr.name==="opaque"){return this.flowParseOpaqueType(node,false);}}}return _superPropGet(FlowParserMixin,"parseExpressionStatement",this,3)([node,expr,decorators]);}},{key:"shouldParseExportDeclaration",value:function shouldParseExportDeclaration(){var type=this.state.type;if(type===126||tokenIsFlowInterfaceOrTypeOrOpaque(type)){return !this.state.containsEsc;}return _superPropGet(FlowParserMixin,"shouldParseExportDeclaration",this,3)([]);}},{key:"isExportDefaultSpecifier",value:function isExportDefaultSpecifier(){var type=this.state.type;if(type===126||tokenIsFlowInterfaceOrTypeOrOpaque(type)){return this.state.containsEsc;}return _superPropGet(FlowParserMixin,"isExportDefaultSpecifier",this,3)([]);}},{key:"parseExportDefaultExpression",value:function parseExportDefaultExpression(){if(this.isContextual(126)){var node=this.startNode();this.next();return this.flowParseEnumDeclaration(node);}return _superPropGet(FlowParserMixin,"parseExportDefaultExpression",this,3)([]);}},{key:"parseConditional",value:function parseConditional(expr,startLoc,refExpressionErrors){var _this15=this;if(!this.match(17))return expr;if(this.state.maybeInArrowParameters){var nextCh=this.lookaheadCharCode();if(nextCh===44||nextCh===61||nextCh===58||nextCh===41){this.setOptionalParametersError(refExpressionErrors);return expr;}}this.expect(17);var state=this.state.clone();var originalNoArrowAt=this.state.noArrowAt;var node=this.startNodeAt(startLoc);var _this$tryParseConditi=this.tryParseConditionalConsequent(),consequent=_this$tryParseConditi.consequent,failed=_this$tryParseConditi.failed;var _this$getArrowLikeExp=this.getArrowLikeExpressions(consequent),_this$getArrowLikeExp2=_slicedToArray(_this$getArrowLikeExp,2),valid=_this$getArrowLikeExp2[0],invalid=_this$getArrowLikeExp2[1];if(failed||invalid.length>0){var noArrowAt=_toConsumableArray(originalNoArrowAt);if(invalid.length>0){this.state=state;this.state.noArrowAt=noArrowAt;for(var i=0;i<invalid.length;i++){noArrowAt.push(invalid[i].start);}var _this$tryParseConditi2=this.tryParseConditionalConsequent();consequent=_this$tryParseConditi2.consequent;failed=_this$tryParseConditi2.failed;var _this$getArrowLikeExp3=this.getArrowLikeExpressions(consequent);var _this$getArrowLikeExp4=_slicedToArray(_this$getArrowLikeExp3,2);valid=_this$getArrowLikeExp4[0];invalid=_this$getArrowLikeExp4[1];}if(failed&&valid.length>1){this.raise(FlowErrors.AmbiguousConditionalArrow,state.startLoc);}if(failed&&valid.length===1){this.state=state;noArrowAt.push(valid[0].start);this.state.noArrowAt=noArrowAt;var _this$tryParseConditi3=this.tryParseConditionalConsequent();consequent=_this$tryParseConditi3.consequent;failed=_this$tryParseConditi3.failed;}}this.getArrowLikeExpressions(consequent,true);this.state.noArrowAt=originalNoArrowAt;this.expect(14);node.test=expr;node.consequent=consequent;node.alternate=this.forwardNoArrowParamsConversionAt(node,function(){return _this15.parseMaybeAssign(undefined,undefined);});return this.finishNode(node,"ConditionalExpression");}},{key:"tryParseConditionalConsequent",value:function tryParseConditionalConsequent(){this.state.noArrowParamsConversionAt.push(this.state.start);var consequent=this.parseMaybeAssignAllowIn();var failed=!this.match(14);this.state.noArrowParamsConversionAt.pop();return {consequent:consequent,failed:failed};}},{key:"getArrowLikeExpressions",value:function getArrowLikeExpressions(node,disallowInvalid){var _this16=this;var stack=[node];var arrows=[];while(stack.length!==0){var _node4=stack.pop();if(_node4.type==="ArrowFunctionExpression"&&_node4.body.type!=="BlockStatement"){if(_node4.typeParameters||!_node4.returnType){this.finishArrowValidation(_node4);}else {arrows.push(_node4);}stack.push(_node4.body);}else if(_node4.type==="ConditionalExpression"){stack.push(_node4.consequent);stack.push(_node4.alternate);}}if(disallowInvalid){arrows.forEach(function(node){return _this16.finishArrowValidation(node);});return [arrows,[]];}return partition(arrows,function(node){return node.params.every(function(param){return _this16.isAssignable(param,true);});});}},{key:"finishArrowValidation",value:function finishArrowValidation(node){var _node$extra;this.toAssignableList(node.params,(_node$extra=node.extra)==null?void 0:_node$extra.trailingCommaLoc,false);this.scope.enter(2|4);_superPropGet(FlowParserMixin,"checkParams",this,3)([node,false,true]);this.scope.exit();}},{key:"forwardNoArrowParamsConversionAt",value:function forwardNoArrowParamsConversionAt(node,parse){var result;if(this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))){this.state.noArrowParamsConversionAt.push(this.state.start);result=parse();this.state.noArrowParamsConversionAt.pop();}else {result=parse();}return result;}},{key:"parseParenItem",value:function parseParenItem(node,startLoc){var newNode=_superPropGet(FlowParserMixin,"parseParenItem",this,3)([node,startLoc]);if(this.eat(17)){newNode.optional=true;this.resetEndLocation(node);}if(this.match(14)){var typeCastNode=this.startNodeAt(startLoc);typeCastNode.expression=newNode;typeCastNode.typeAnnotation=this.flowParseTypeAnnotation();return this.finishNode(typeCastNode,"TypeCastExpression");}return newNode;}},{key:"assertModuleNodeAllowed",value:function assertModuleNodeAllowed(node){if(node.type==="ImportDeclaration"&&(node.importKind==="type"||node.importKind==="typeof")||node.type==="ExportNamedDeclaration"&&node.exportKind==="type"||node.type==="ExportAllDeclaration"&&node.exportKind==="type"){return;}_superPropGet(FlowParserMixin,"assertModuleNodeAllowed",this,3)([node]);}},{key:"parseExportDeclaration",value:function parseExportDeclaration(node){if(this.isContextual(130)){node.exportKind="type";var declarationNode=this.startNode();this.next();if(this.match(5)){node.specifiers=this.parseExportSpecifiers(true);_superPropGet(FlowParserMixin,"parseExportFrom",this,3)([node]);return null;}else {return this.flowParseTypeAlias(declarationNode);}}else if(this.isContextual(131)){node.exportKind="type";var _declarationNode=this.startNode();this.next();return this.flowParseOpaqueType(_declarationNode,false);}else if(this.isContextual(129)){node.exportKind="type";var _declarationNode2=this.startNode();this.next();return this.flowParseInterface(_declarationNode2);}else if(this.isContextual(126)){node.exportKind="value";var _declarationNode3=this.startNode();this.next();return this.flowParseEnumDeclaration(_declarationNode3);}else {return _superPropGet(FlowParserMixin,"parseExportDeclaration",this,3)([node]);}}},{key:"eatExportStar",value:function eatExportStar(node){if(_superPropGet(FlowParserMixin,"eatExportStar",this,3)([node]))return true;if(this.isContextual(130)&&this.lookahead().type===55){node.exportKind="type";this.next();this.next();return true;}return false;}},{key:"maybeParseExportNamespaceSpecifier",value:function maybeParseExportNamespaceSpecifier(node){var startLoc=this.state.startLoc;var hasNamespace=_superPropGet(FlowParserMixin,"maybeParseExportNamespaceSpecifier",this,3)([node]);if(hasNamespace&&node.exportKind==="type"){this.unexpected(startLoc);}return hasNamespace;}},{key:"parseClassId",value:function parseClassId(node,isStatement,optionalId){_superPropGet(FlowParserMixin,"parseClassId",this,3)([node,isStatement,optionalId]);if(this.match(47)){node.typeParameters=this.flowParseTypeParameterDeclaration();}}},{key:"parseClassMember",value:function parseClassMember(classBody,member,state){var startLoc=this.state.startLoc;if(this.isContextual(125)){if(_superPropGet(FlowParserMixin,"parseClassMemberFromModifier",this,3)([classBody,member])){return;}member.declare=true;}_superPropGet(FlowParserMixin,"parseClassMember",this,3)([classBody,member,state]);if(member.declare){if(member.type!=="ClassProperty"&&member.type!=="ClassPrivateProperty"&&member.type!=="PropertyDefinition"){this.raise(FlowErrors.DeclareClassElement,startLoc);}else if(member.value){this.raise(FlowErrors.DeclareClassFieldInitializer,member.value);}}}},{key:"isIterator",value:function isIterator(word){return word==="iterator"||word==="asyncIterator";}},{key:"readIterator",value:function readIterator(){var word=_superPropGet(FlowParserMixin,"readWord1",this,3)([]);var fullWord="@@"+word;if(!this.isIterator(word)||!this.state.inType){this.raise(Errors.InvalidIdentifier,this.state.curPosition(),{identifierName:fullWord});}this.finishToken(132,fullWord);}},{key:"getTokenFromCode",value:function getTokenFromCode(code){var next=this.input.charCodeAt(this.state.pos+1);if(code===123&&next===124){this.finishOp(6,2);}else if(this.state.inType&&(code===62||code===60)){this.finishOp(code===62?48:47,1);}else if(this.state.inType&&code===63){if(next===46){this.finishOp(18,2);}else {this.finishOp(17,1);}}else if(isIteratorStart(code,next,this.input.charCodeAt(this.state.pos+2))){this.state.pos+=2;this.readIterator();}else {_superPropGet(FlowParserMixin,"getTokenFromCode",this,3)([code]);}}},{key:"isAssignable",value:function isAssignable(node,isBinding){if(node.type==="TypeCastExpression"){return this.isAssignable(node.expression,isBinding);}else {return _superPropGet(FlowParserMixin,"isAssignable",this,3)([node,isBinding]);}}},{key:"toAssignable",value:function toAssignable(node){var isLHS=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;if(!isLHS&&node.type==="AssignmentExpression"&&node.left.type==="TypeCastExpression"){node.left=this.typeCastToParameter(node.left);}_superPropGet(FlowParserMixin,"toAssignable",this,3)([node,isLHS]);}},{key:"toAssignableList",value:function toAssignableList(exprList,trailingCommaLoc,isLHS){for(var i=0;i<exprList.length;i++){var expr=exprList[i];if((expr==null?void 0:expr.type)==="TypeCastExpression"){exprList[i]=this.typeCastToParameter(expr);}}_superPropGet(FlowParserMixin,"toAssignableList",this,3)([exprList,trailingCommaLoc,isLHS]);}},{key:"toReferencedList",value:function toReferencedList(exprList,isParenthesizedExpr){for(var i=0;i<exprList.length;i++){var _expr$extra;var expr=exprList[i];if(expr&&expr.type==="TypeCastExpression"&&!((_expr$extra=expr.extra)!=null&&_expr$extra.parenthesized)&&(exprList.length>1||!isParenthesizedExpr)){this.raise(FlowErrors.TypeCastInPattern,expr.typeAnnotation);}}return exprList;}},{key:"parseArrayLike",value:function parseArrayLike(close,canBePattern,isTuple,refExpressionErrors){var node=_superPropGet(FlowParserMixin,"parseArrayLike",this,3)([close,canBePattern,isTuple,refExpressionErrors]);if(canBePattern&&!this.state.maybeInArrowParameters){this.toReferencedList(node.elements);}return node;}},{key:"isValidLVal",value:function isValidLVal(type,isParenthesized,binding){return type==="TypeCastExpression"||_superPropGet(FlowParserMixin,"isValidLVal",this,3)([type,isParenthesized,binding]);}},{key:"parseClassProperty",value:function parseClassProperty(node){if(this.match(14)){node.typeAnnotation=this.flowParseTypeAnnotation();}return _superPropGet(FlowParserMixin,"parseClassProperty",this,3)([node]);}},{key:"parseClassPrivateProperty",value:function parseClassPrivateProperty(node){if(this.match(14)){node.typeAnnotation=this.flowParseTypeAnnotation();}return _superPropGet(FlowParserMixin,"parseClassPrivateProperty",this,3)([node]);}},{key:"isClassMethod",value:function isClassMethod(){return this.match(47)||_superPropGet(FlowParserMixin,"isClassMethod",this,3)([]);}},{key:"isClassProperty",value:function isClassProperty(){return this.match(14)||_superPropGet(FlowParserMixin,"isClassProperty",this,3)([]);}},{key:"isNonstaticConstructor",value:function isNonstaticConstructor(method){return !this.match(14)&&_superPropGet(FlowParserMixin,"isNonstaticConstructor",this,3)([method]);}},{key:"pushClassMethod",value:function pushClassMethod(classBody,method,isGenerator,isAsync,isConstructor,allowsDirectSuper){if(method.variance){this.unexpected(method.variance.loc.start);}delete method.variance;if(this.match(47)){method.typeParameters=this.flowParseTypeParameterDeclaration();}_superPropGet(FlowParserMixin,"pushClassMethod",this,3)([classBody,method,isGenerator,isAsync,isConstructor,allowsDirectSuper]);if(method.params&&isConstructor){var params=method.params;if(params.length>0&&this.isThisParam(params[0])){this.raise(FlowErrors.ThisParamBannedInConstructor,method);}}else if(method.type==="MethodDefinition"&&isConstructor&&method.value.params){var _params2=method.value.params;if(_params2.length>0&&this.isThisParam(_params2[0])){this.raise(FlowErrors.ThisParamBannedInConstructor,method);}}}},{key:"pushClassPrivateMethod",value:function pushClassPrivateMethod(classBody,method,isGenerator,isAsync){if(method.variance){this.unexpected(method.variance.loc.start);}delete method.variance;if(this.match(47)){method.typeParameters=this.flowParseTypeParameterDeclaration();}_superPropGet(FlowParserMixin,"pushClassPrivateMethod",this,3)([classBody,method,isGenerator,isAsync]);}},{key:"parseClassSuper",value:function parseClassSuper(node){_superPropGet(FlowParserMixin,"parseClassSuper",this,3)([node]);if(node.superClass&&(this.match(47)||this.match(51))){{node.superTypeParameters=this.flowParseTypeParameterInstantiationInExpression();}}if(this.isContextual(113)){this.next();var implemented=node["implements"]=[];do{var _node5=this.startNode();_node5.id=this.flowParseRestrictedIdentifier(true);if(this.match(47)){_node5.typeParameters=this.flowParseTypeParameterInstantiation();}else {_node5.typeParameters=null;}implemented.push(this.finishNode(_node5,"ClassImplements"));}while(this.eat(12));}}},{key:"checkGetterSetterParams",value:function checkGetterSetterParams(method){_superPropGet(FlowParserMixin,"checkGetterSetterParams",this,3)([method]);var params=this.getObjectOrClassMethodParams(method);if(params.length>0){var param=params[0];if(this.isThisParam(param)&&method.kind==="get"){this.raise(FlowErrors.GetterMayNotHaveThisParam,param);}else if(this.isThisParam(param)){this.raise(FlowErrors.SetterMayNotHaveThisParam,param);}}}},{key:"parsePropertyNamePrefixOperator",value:function parsePropertyNamePrefixOperator(node){node.variance=this.flowParseVariance();}},{key:"parseObjPropValue",value:function parseObjPropValue(prop,startLoc,isGenerator,isAsync,isPattern,isAccessor,refExpressionErrors){if(prop.variance){this.unexpected(prop.variance.loc.start);}delete prop.variance;var typeParameters;if(this.match(47)&&!isAccessor){typeParameters=this.flowParseTypeParameterDeclaration();if(!this.match(10))this.unexpected();}var result=_superPropGet(FlowParserMixin,"parseObjPropValue",this,3)([prop,startLoc,isGenerator,isAsync,isPattern,isAccessor,refExpressionErrors]);if(typeParameters){(result.value||result).typeParameters=typeParameters;}return result;}},{key:"parseFunctionParamType",value:function parseFunctionParamType(param){if(this.eat(17)){if(param.type!=="Identifier"){this.raise(FlowErrors.PatternIsOptional,param);}if(this.isThisParam(param)){this.raise(FlowErrors.ThisParamMayNotBeOptional,param);}param.optional=true;}if(this.match(14)){param.typeAnnotation=this.flowParseTypeAnnotation();}else if(this.isThisParam(param)){this.raise(FlowErrors.ThisParamAnnotationRequired,param);}if(this.match(29)&&this.isThisParam(param)){this.raise(FlowErrors.ThisParamNoDefault,param);}this.resetEndLocation(param);return param;}},{key:"parseMaybeDefault",value:function parseMaybeDefault(startLoc,left){var node=_superPropGet(FlowParserMixin,"parseMaybeDefault",this,3)([startLoc,left]);if(node.type==="AssignmentPattern"&&node.typeAnnotation&&node.right.start<node.typeAnnotation.start){this.raise(FlowErrors.TypeBeforeInitializer,node.typeAnnotation);}return node;}},{key:"checkImportReflection",value:function checkImportReflection(node){_superPropGet(FlowParserMixin,"checkImportReflection",this,3)([node]);if(node.module&&node.importKind!=="value"){this.raise(FlowErrors.ImportReflectionHasImportType,node.specifiers[0].loc.start);}}},{key:"parseImportSpecifierLocal",value:function parseImportSpecifierLocal(node,specifier,type){specifier.local=hasTypeImportKind(node)?this.flowParseRestrictedIdentifier(true,true):this.parseIdentifier();node.specifiers.push(this.finishImportSpecifier(specifier,type));}},{key:"isPotentialImportPhase",value:function isPotentialImportPhase(isExport){if(_superPropGet(FlowParserMixin,"isPotentialImportPhase",this,3)([isExport]))return true;if(this.isContextual(130)){if(!isExport)return true;var ch=this.lookaheadCharCode();return ch===123||ch===42;}return !isExport&&this.isContextual(87);}},{key:"applyImportPhase",value:function applyImportPhase(node,isExport,phase,loc){_superPropGet(FlowParserMixin,"applyImportPhase",this,3)([node,isExport,phase,loc]);if(isExport){if(!phase&&this.match(65)){return;}node.exportKind=phase==="type"?phase:"value";}else {if(phase==="type"&&this.match(55))this.unexpected();node.importKind=phase==="type"||phase==="typeof"?phase:"value";}}},{key:"parseImportSpecifier",value:function parseImportSpecifier(specifier,importedIsString,isInTypeOnlyImport,isMaybeTypeOnly,bindingType){var firstIdent=specifier.imported;var specifierTypeKind=null;if(firstIdent.type==="Identifier"){if(firstIdent.name==="type"){specifierTypeKind="type";}else if(firstIdent.name==="typeof"){specifierTypeKind="typeof";}}var isBinding=false;if(this.isContextual(93)&&!this.isLookaheadContextual("as")){var as_ident=this.parseIdentifier(true);if(specifierTypeKind!==null&&!tokenIsKeywordOrIdentifier(this.state.type)){specifier.imported=as_ident;specifier.importKind=specifierTypeKind;specifier.local=cloneIdentifier(as_ident);}else {specifier.imported=firstIdent;specifier.importKind=null;specifier.local=this.parseIdentifier();}}else {if(specifierTypeKind!==null&&tokenIsKeywordOrIdentifier(this.state.type)){specifier.imported=this.parseIdentifier(true);specifier.importKind=specifierTypeKind;}else {if(importedIsString){throw this.raise(Errors.ImportBindingIsString,specifier,{importName:firstIdent.value});}specifier.imported=firstIdent;specifier.importKind=null;}if(this.eatContextual(93)){specifier.local=this.parseIdentifier();}else {isBinding=true;specifier.local=cloneIdentifier(specifier.imported);}}var specifierIsTypeImport=hasTypeImportKind(specifier);if(isInTypeOnlyImport&&specifierIsTypeImport){this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport,specifier);}if(isInTypeOnlyImport||specifierIsTypeImport){this.checkReservedType(specifier.local.name,specifier.local.loc.start,true);}if(isBinding&&!isInTypeOnlyImport&&!specifierIsTypeImport){this.checkReservedWord(specifier.local.name,specifier.loc.start,true,true);}return this.finishImportSpecifier(specifier,"ImportSpecifier");}},{key:"parseBindingAtom",value:function parseBindingAtom(){switch(this.state.type){case 78:return this.parseIdentifier(true);default:return _superPropGet(FlowParserMixin,"parseBindingAtom",this,3)([]);}}},{key:"parseFunctionParams",value:function parseFunctionParams(node,isConstructor){var kind=node.kind;if(kind!=="get"&&kind!=="set"&&this.match(47)){node.typeParameters=this.flowParseTypeParameterDeclaration();}_superPropGet(FlowParserMixin,"parseFunctionParams",this,3)([node,isConstructor]);}},{key:"parseVarId",value:function parseVarId(decl,kind){_superPropGet(FlowParserMixin,"parseVarId",this,3)([decl,kind]);if(this.match(14)){decl.id.typeAnnotation=this.flowParseTypeAnnotation();this.resetEndLocation(decl.id);}}},{key:"parseAsyncArrowFromCallExpression",value:function parseAsyncArrowFromCallExpression(node,call){if(this.match(14)){var oldNoAnonFunctionType=this.state.noAnonFunctionType;this.state.noAnonFunctionType=true;node.returnType=this.flowParseTypeAnnotation();this.state.noAnonFunctionType=oldNoAnonFunctionType;}return _superPropGet(FlowParserMixin,"parseAsyncArrowFromCallExpression",this,3)([node,call]);}},{key:"shouldParseAsyncArrow",value:function shouldParseAsyncArrow(){return this.match(14)||_superPropGet(FlowParserMixin,"shouldParseAsyncArrow",this,3)([]);}},{key:"parseMaybeAssign",value:function parseMaybeAssign(refExpressionErrors,afterLeftParse){var _this17=this;var _jsx;var state=null;var jsx;if(this.hasPlugin("jsx")&&(this.match(143)||this.match(47))){state=this.state.clone();jsx=this.tryParse(function(){return _superPropGet(FlowParserMixin,"parseMaybeAssign",_this17,3)([refExpressionErrors,afterLeftParse]);},state);if(!jsx.error)return jsx.node;var context=this.state.context;var currentContext=context[context.length-1];if(currentContext===types.j_oTag||currentContext===types.j_expr){context.pop();}}if((_jsx=jsx)!=null&&_jsx.error||this.match(47)){var _jsx2,_jsx3;state=state||this.state.clone();var typeParameters;var arrow=this.tryParse(function(abort){var _arrowExpression$extr;typeParameters=_this17.flowParseTypeParameterDeclaration();var arrowExpression=_this17.forwardNoArrowParamsConversionAt(typeParameters,function(){var result=_superPropGet(FlowParserMixin,"parseMaybeAssign",_this17,3)([refExpressionErrors,afterLeftParse]);_this17.resetStartLocationFromNode(result,typeParameters);return result;});if((_arrowExpression$extr=arrowExpression.extra)!=null&&_arrowExpression$extr.parenthesized)abort();var expr=_this17.maybeUnwrapTypeCastExpression(arrowExpression);if(expr.type!=="ArrowFunctionExpression")abort();expr.typeParameters=typeParameters;_this17.resetStartLocationFromNode(expr,typeParameters);return arrowExpression;},state);var arrowExpression=null;if(arrow.node&&this.maybeUnwrapTypeCastExpression(arrow.node).type==="ArrowFunctionExpression"){if(!arrow.error&&!arrow.aborted){if(arrow.node.async){this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction,typeParameters);}return arrow.node;}arrowExpression=arrow.node;}if((_jsx2=jsx)!=null&&_jsx2.node){this.state=jsx.failState;return jsx.node;}if(arrowExpression){this.state=arrow.failState;return arrowExpression;}if((_jsx3=jsx)!=null&&_jsx3.thrown)throw jsx.error;if(arrow.thrown)throw arrow.error;throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter,typeParameters);}return _superPropGet(FlowParserMixin,"parseMaybeAssign",this,3)([refExpressionErrors,afterLeftParse]);}},{key:"parseArrow",value:function parseArrow(node){var _this18=this;if(this.match(14)){var result=this.tryParse(function(){var oldNoAnonFunctionType=_this18.state.noAnonFunctionType;_this18.state.noAnonFunctionType=true;var typeNode=_this18.startNode();var _this18$flowParseType=_this18.flowParseTypeAndPredicateInitialiser();var _this18$flowParseType2=_slicedToArray(_this18$flowParseType,2);typeNode.typeAnnotation=_this18$flowParseType2[0];node.predicate=_this18$flowParseType2[1];_this18.state.noAnonFunctionType=oldNoAnonFunctionType;if(_this18.canInsertSemicolon())_this18.unexpected();if(!_this18.match(19))_this18.unexpected();return typeNode;});if(result.thrown)return null;if(result.error)this.state=result.failState;node.returnType=result.node.typeAnnotation?this.finishNode(result.node,"TypeAnnotation"):null;}return _superPropGet(FlowParserMixin,"parseArrow",this,3)([node]);}},{key:"shouldParseArrow",value:function shouldParseArrow(params){return this.match(14)||_superPropGet(FlowParserMixin,"shouldParseArrow",this,3)([params]);}},{key:"setArrowFunctionParameters",value:function setArrowFunctionParameters(node,params){if(this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))){node.params=params;}else {_superPropGet(FlowParserMixin,"setArrowFunctionParameters",this,3)([node,params]);}}},{key:"checkParams",value:function checkParams(node,allowDuplicates,isArrowFunction){var strictModeChanged=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;if(isArrowFunction&&this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))){return;}for(var i=0;i<node.params.length;i++){if(this.isThisParam(node.params[i])&&i>0){this.raise(FlowErrors.ThisParamMustBeFirst,node.params[i]);}}_superPropGet(FlowParserMixin,"checkParams",this,3)([node,allowDuplicates,isArrowFunction,strictModeChanged]);}},{key:"parseParenAndDistinguishExpression",value:function parseParenAndDistinguishExpression(canBeArrow){return _superPropGet(FlowParserMixin,"parseParenAndDistinguishExpression",this,3)([canBeArrow&&!this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start))]);}},{key:"parseSubscripts",value:function parseSubscripts(base,startLoc,noCalls){var _this19=this;if(base.type==="Identifier"&&base.name==="async"&&this.state.noArrowAt.includes(startLoc.index)){this.next();var node=this.startNodeAt(startLoc);node.callee=base;node.arguments=_superPropGet(FlowParserMixin,"parseCallExpressionArguments",this,3)([11]);base=this.finishNode(node,"CallExpression");}else if(base.type==="Identifier"&&base.name==="async"&&this.match(47)){var state=this.state.clone();var arrow=this.tryParse(function(abort){return _this19.parseAsyncArrowWithTypeParameters(startLoc)||abort();},state);if(!arrow.error&&!arrow.aborted)return arrow.node;var result=this.tryParse(function(){return _superPropGet(FlowParserMixin,"parseSubscripts",_this19,3)([base,startLoc,noCalls]);},state);if(result.node&&!result.error)return result.node;if(arrow.node){this.state=arrow.failState;return arrow.node;}if(result.node){this.state=result.failState;return result.node;}throw arrow.error||result.error;}return _superPropGet(FlowParserMixin,"parseSubscripts",this,3)([base,startLoc,noCalls]);}},{key:"parseSubscript",value:function parseSubscript(base,startLoc,noCalls,subscriptState){var _this20=this;if(this.match(18)&&this.isLookaheadToken_lt()){subscriptState.optionalChainMember=true;if(noCalls){subscriptState.stop=true;return base;}this.next();var node=this.startNodeAt(startLoc);node.callee=base;node.typeArguments=this.flowParseTypeParameterInstantiationInExpression();this.expect(10);node.arguments=this.parseCallExpressionArguments(11);node.optional=true;return this.finishCallExpression(node,true);}else if(!noCalls&&this.shouldParseTypes()&&(this.match(47)||this.match(51))){var _node6=this.startNodeAt(startLoc);_node6.callee=base;var result=this.tryParse(function(){_node6.typeArguments=_this20.flowParseTypeParameterInstantiationCallOrNew();_this20.expect(10);_node6.arguments=_superPropGet(FlowParserMixin,"parseCallExpressionArguments",_this20,3)([11]);if(subscriptState.optionalChainMember){_node6.optional=false;}return _this20.finishCallExpression(_node6,subscriptState.optionalChainMember);});if(result.node){if(result.error)this.state=result.failState;return result.node;}}return _superPropGet(FlowParserMixin,"parseSubscript",this,3)([base,startLoc,noCalls,subscriptState]);}},{key:"parseNewCallee",value:function parseNewCallee(node){var _this21=this;_superPropGet(FlowParserMixin,"parseNewCallee",this,3)([node]);var targs=null;if(this.shouldParseTypes()&&this.match(47)){targs=this.tryParse(function(){return _this21.flowParseTypeParameterInstantiationCallOrNew();}).node;}node.typeArguments=targs;}},{key:"parseAsyncArrowWithTypeParameters",value:function parseAsyncArrowWithTypeParameters(startLoc){var node=this.startNodeAt(startLoc);this.parseFunctionParams(node,false);if(!this.parseArrow(node))return;return _superPropGet(FlowParserMixin,"parseArrowExpression",this,3)([node,undefined,true]);}},{key:"readToken_mult_modulo",value:function readToken_mult_modulo(code){var next=this.input.charCodeAt(this.state.pos+1);if(code===42&&next===47&&this.state.hasFlowComment){this.state.hasFlowComment=false;this.state.pos+=2;this.nextToken();return;}_superPropGet(FlowParserMixin,"readToken_mult_modulo",this,3)([code]);}},{key:"readToken_pipe_amp",value:function readToken_pipe_amp(code){var next=this.input.charCodeAt(this.state.pos+1);if(code===124&&next===125){this.finishOp(9,2);return;}_superPropGet(FlowParserMixin,"readToken_pipe_amp",this,3)([code]);}},{key:"parseTopLevel",value:function parseTopLevel(file,program){var fileNode=_superPropGet(FlowParserMixin,"parseTopLevel",this,3)([file,program]);if(this.state.hasFlowComment){this.raise(FlowErrors.UnterminatedFlowComment,this.state.curPosition());}return fileNode;}},{key:"skipBlockComment",value:function skipBlockComment(){if(this.hasPlugin("flowComments")&&this.skipFlowComment()){if(this.state.hasFlowComment){throw this.raise(FlowErrors.NestedFlowComment,this.state.startLoc);}this.hasFlowCommentCompletion();var commentSkip=this.skipFlowComment();if(commentSkip){this.state.pos+=commentSkip;this.state.hasFlowComment=true;}return;}return _superPropGet(FlowParserMixin,"skipBlockComment",this,3)([this.state.hasFlowComment?"*-/":"*/"]);}},{key:"skipFlowComment",value:function skipFlowComment(){var pos=this.state.pos;var shiftToFirstNonWhiteSpace=2;while([32,9].includes(this.input.charCodeAt(pos+shiftToFirstNonWhiteSpace))){shiftToFirstNonWhiteSpace++;}var ch2=this.input.charCodeAt(shiftToFirstNonWhiteSpace+pos);var ch3=this.input.charCodeAt(shiftToFirstNonWhiteSpace+pos+1);if(ch2===58&&ch3===58){return shiftToFirstNonWhiteSpace+2;}if(this.input.slice(shiftToFirstNonWhiteSpace+pos,shiftToFirstNonWhiteSpace+pos+12)==="flow-include"){return shiftToFirstNonWhiteSpace+12;}if(ch2===58&&ch3!==58){return shiftToFirstNonWhiteSpace;}return false;}},{key:"hasFlowCommentCompletion",value:function hasFlowCommentCompletion(){var end=this.input.indexOf("*/",this.state.pos);if(end===-1){throw this.raise(Errors.UnterminatedComment,this.state.curPosition());}}},{key:"flowEnumErrorBooleanMemberNotInitialized",value:function flowEnumErrorBooleanMemberNotInitialized(loc,_ref59){var enumName=_ref59.enumName,memberName=_ref59.memberName;this.raise(FlowErrors.EnumBooleanMemberNotInitialized,loc,{memberName:memberName,enumName:enumName});}},{key:"flowEnumErrorInvalidMemberInitializer",value:function flowEnumErrorInvalidMemberInitializer(loc,enumContext){return this.raise(!enumContext.explicitType?FlowErrors.EnumInvalidMemberInitializerUnknownType:enumContext.explicitType==="symbol"?FlowErrors.EnumInvalidMemberInitializerSymbolType:FlowErrors.EnumInvalidMemberInitializerPrimaryType,loc,enumContext);}},{key:"flowEnumErrorNumberMemberNotInitialized",value:function flowEnumErrorNumberMemberNotInitialized(loc,details){this.raise(FlowErrors.EnumNumberMemberNotInitialized,loc,details);}},{key:"flowEnumErrorStringMemberInconsistentlyInitialized",value:function flowEnumErrorStringMemberInconsistentlyInitialized(node,details){this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized,node,details);}},{key:"flowEnumMemberInit",value:function flowEnumMemberInit(){var _this22=this;var startLoc=this.state.startLoc;var endOfInit=function endOfInit(){return _this22.match(12)||_this22.match(8);};switch(this.state.type){case 135:{var literal=this.parseNumericLiteral(this.state.value);if(endOfInit()){return {type:"number",loc:literal.loc.start,value:literal};}return {type:"invalid",loc:startLoc};}case 134:{var _literal=this.parseStringLiteral(this.state.value);if(endOfInit()){return {type:"string",loc:_literal.loc.start,value:_literal};}return {type:"invalid",loc:startLoc};}case 85:case 86:{var _literal2=this.parseBooleanLiteral(this.match(85));if(endOfInit()){return {type:"boolean",loc:_literal2.loc.start,value:_literal2};}return {type:"invalid",loc:startLoc};}default:return {type:"invalid",loc:startLoc};}}},{key:"flowEnumMemberRaw",value:function flowEnumMemberRaw(){var loc=this.state.startLoc;var id=this.parseIdentifier(true);var init=this.eat(29)?this.flowEnumMemberInit():{type:"none",loc:loc};return {id:id,init:init};}},{key:"flowEnumCheckExplicitTypeMismatch",value:function flowEnumCheckExplicitTypeMismatch(loc,context,expectedType){var explicitType=context.explicitType;if(explicitType===null){return;}if(explicitType!==expectedType){this.flowEnumErrorInvalidMemberInitializer(loc,context);}}},{key:"flowEnumMembers",value:function flowEnumMembers(_ref60){var enumName=_ref60.enumName,explicitType=_ref60.explicitType;var seenNames=new Set();var members={booleanMembers:[],numberMembers:[],stringMembers:[],defaultedMembers:[]};var hasUnknownMembers=false;while(!this.match(8)){if(this.eat(21)){hasUnknownMembers=true;break;}var memberNode=this.startNode();var _this$flowEnumMemberR=this.flowEnumMemberRaw(),id=_this$flowEnumMemberR.id,init=_this$flowEnumMemberR.init;var memberName=id.name;if(memberName===""){continue;}if(/^[a-z]/.test(memberName)){this.raise(FlowErrors.EnumInvalidMemberName,id,{memberName:memberName,suggestion:memberName[0].toUpperCase()+memberName.slice(1),enumName:enumName});}if(seenNames.has(memberName)){this.raise(FlowErrors.EnumDuplicateMemberName,id,{memberName:memberName,enumName:enumName});}seenNames.add(memberName);var context={enumName:enumName,explicitType:explicitType,memberName:memberName};memberNode.id=id;switch(init.type){case "boolean":{this.flowEnumCheckExplicitTypeMismatch(init.loc,context,"boolean");memberNode.init=init.value;members.booleanMembers.push(this.finishNode(memberNode,"EnumBooleanMember"));break;}case "number":{this.flowEnumCheckExplicitTypeMismatch(init.loc,context,"number");memberNode.init=init.value;members.numberMembers.push(this.finishNode(memberNode,"EnumNumberMember"));break;}case "string":{this.flowEnumCheckExplicitTypeMismatch(init.loc,context,"string");memberNode.init=init.value;members.stringMembers.push(this.finishNode(memberNode,"EnumStringMember"));break;}case "invalid":{throw this.flowEnumErrorInvalidMemberInitializer(init.loc,context);}case "none":{switch(explicitType){case "boolean":this.flowEnumErrorBooleanMemberNotInitialized(init.loc,context);break;case "number":this.flowEnumErrorNumberMemberNotInitialized(init.loc,context);break;default:members.defaultedMembers.push(this.finishNode(memberNode,"EnumDefaultedMember"));}}}if(!this.match(8)){this.expect(12);}}return {members:members,hasUnknownMembers:hasUnknownMembers};}},{key:"flowEnumStringMembers",value:function flowEnumStringMembers(initializedMembers,defaultedMembers,_ref61){var enumName=_ref61.enumName;if(initializedMembers.length===0){return defaultedMembers;}else if(defaultedMembers.length===0){return initializedMembers;}else if(defaultedMembers.length>initializedMembers.length){var _iterator2=_createForOfIteratorHelper(initializedMembers),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var member=_step2.value;this.flowEnumErrorStringMemberInconsistentlyInitialized(member,{enumName:enumName});}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}return defaultedMembers;}else {var _iterator3=_createForOfIteratorHelper(defaultedMembers),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var _member=_step3.value;this.flowEnumErrorStringMemberInconsistentlyInitialized(_member,{enumName:enumName});}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}return initializedMembers;}}},{key:"flowEnumParseExplicitType",value:function flowEnumParseExplicitType(_ref62){var enumName=_ref62.enumName;if(!this.eatContextual(102))return null;if(!tokenIsIdentifier(this.state.type)){throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied,this.state.startLoc,{enumName:enumName});}var value=this.state.value;this.next();if(value!=="boolean"&&value!=="number"&&value!=="string"&&value!=="symbol"){this.raise(FlowErrors.EnumInvalidExplicitType,this.state.startLoc,{enumName:enumName,invalidEnumType:value});}return value;}},{key:"flowEnumBody",value:function flowEnumBody(node,id){var _this23=this;var enumName=id.name;var nameLoc=id.loc.start;var explicitType=this.flowEnumParseExplicitType({enumName:enumName});this.expect(5);var _this$flowEnumMembers=this.flowEnumMembers({enumName:enumName,explicitType:explicitType}),members=_this$flowEnumMembers.members,hasUnknownMembers=_this$flowEnumMembers.hasUnknownMembers;node.hasUnknownMembers=hasUnknownMembers;switch(explicitType){case "boolean":node.explicitType=true;node.members=members.booleanMembers;this.expect(8);return this.finishNode(node,"EnumBooleanBody");case "number":node.explicitType=true;node.members=members.numberMembers;this.expect(8);return this.finishNode(node,"EnumNumberBody");case "string":node.explicitType=true;node.members=this.flowEnumStringMembers(members.stringMembers,members.defaultedMembers,{enumName:enumName});this.expect(8);return this.finishNode(node,"EnumStringBody");case "symbol":node.members=members.defaultedMembers;this.expect(8);return this.finishNode(node,"EnumSymbolBody");default:{var empty=function empty(){node.members=[];_this23.expect(8);return _this23.finishNode(node,"EnumStringBody");};node.explicitType=false;var boolsLen=members.booleanMembers.length;var numsLen=members.numberMembers.length;var strsLen=members.stringMembers.length;var defaultedLen=members.defaultedMembers.length;if(!boolsLen&&!numsLen&&!strsLen&&!defaultedLen){return empty();}else if(!boolsLen&&!numsLen){node.members=this.flowEnumStringMembers(members.stringMembers,members.defaultedMembers,{enumName:enumName});this.expect(8);return this.finishNode(node,"EnumStringBody");}else if(!numsLen&&!strsLen&&boolsLen>=defaultedLen){var _iterator4=_createForOfIteratorHelper(members.defaultedMembers),_step4;try{for(_iterator4.s();!(_step4=_iterator4.n()).done;){var member=_step4.value;this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start,{enumName:enumName,memberName:member.id.name});}}catch(err){_iterator4.e(err);}finally{_iterator4.f();}node.members=members.booleanMembers;this.expect(8);return this.finishNode(node,"EnumBooleanBody");}else if(!boolsLen&&!strsLen&&numsLen>=defaultedLen){var _iterator5=_createForOfIteratorHelper(members.defaultedMembers),_step5;try{for(_iterator5.s();!(_step5=_iterator5.n()).done;){var _member2=_step5.value;this.flowEnumErrorNumberMemberNotInitialized(_member2.loc.start,{enumName:enumName,memberName:_member2.id.name});}}catch(err){_iterator5.e(err);}finally{_iterator5.f();}node.members=members.numberMembers;this.expect(8);return this.finishNode(node,"EnumNumberBody");}else {this.raise(FlowErrors.EnumInconsistentMemberValues,nameLoc,{enumName:enumName});return empty();}}}}},{key:"flowParseEnumDeclaration",value:function flowParseEnumDeclaration(node){var id=this.parseIdentifier();node.id=id;node.body=this.flowEnumBody(this.startNode(),id);return this.finishNode(node,"EnumDeclaration");}},{key:"jsxParseOpeningElementAfterName",value:function jsxParseOpeningElementAfterName(node){if(this.shouldParseTypes()){if(this.match(47)||this.match(51)){node.typeArguments=this.flowParseTypeParameterInstantiationInExpression();}}return _superPropGet(FlowParserMixin,"jsxParseOpeningElementAfterName",this,3)([node]);}},{key:"isLookaheadToken_lt",value:function isLookaheadToken_lt(){var next=this.nextTokenStart();if(this.input.charCodeAt(next)===60){var afterNext=this.input.charCodeAt(next+1);return afterNext!==60&&afterNext!==61;}return false;}},{key:"reScan_lt_gt",value:function reScan_lt_gt(){var type=this.state.type;if(type===47){this.state.pos-=1;this.readToken_lt();}else if(type===48){this.state.pos-=1;this.readToken_gt();}}},{key:"reScan_lt",value:function reScan_lt(){var type=this.state.type;if(type===51){this.state.pos-=2;this.finishOp(47,1);return 47;}return type;}},{key:"maybeUnwrapTypeCastExpression",value:function maybeUnwrapTypeCastExpression(node){return node.type==="TypeCastExpression"?node.expression:node;}}]);}(superClass);};var entities={__proto__:null,quot:"\"",amp:"&",apos:"'",lt:"<",gt:">",nbsp:"\xA0",iexcl:"\xA1",cent:"\xA2",pound:"\xA3",curren:"\xA4",yen:"\xA5",brvbar:"\xA6",sect:"\xA7",uml:"\xA8",copy:"\xA9",ordf:"\xAA",laquo:"\xAB",not:"\xAC",shy:"\xAD",reg:"\xAE",macr:"\xAF",deg:"\xB0",plusmn:"\xB1",sup2:"\xB2",sup3:"\xB3",acute:"\xB4",micro:"\xB5",para:"\xB6",middot:"\xB7",cedil:"\xB8",sup1:"\xB9",ordm:"\xBA",raquo:"\xBB",frac14:"\xBC",frac12:"\xBD",frac34:"\xBE",iquest:"\xBF",Agrave:"\xC0",Aacute:"\xC1",Acirc:"\xC2",Atilde:"\xC3",Auml:"\xC4",Aring:"\xC5",AElig:"\xC6",Ccedil:"\xC7",Egrave:"\xC8",Eacute:"\xC9",Ecirc:"\xCA",Euml:"\xCB",Igrave:"\xCC",Iacute:"\xCD",Icirc:"\xCE",Iuml:"\xCF",ETH:"\xD0",Ntilde:"\xD1",Ograve:"\xD2",Oacute:"\xD3",Ocirc:"\xD4",Otilde:"\xD5",Ouml:"\xD6",times:"\xD7",Oslash:"\xD8",Ugrave:"\xD9",Uacute:"\xDA",Ucirc:"\xDB",Uuml:"\xDC",Yacute:"\xDD",THORN:"\xDE",szlig:"\xDF",agrave:"\xE0",aacute:"\xE1",acirc:"\xE2",atilde:"\xE3",auml:"\xE4",aring:"\xE5",aelig:"\xE6",ccedil:"\xE7",egrave:"\xE8",eacute:"\xE9",ecirc:"\xEA",euml:"\xEB",igrave:"\xEC",iacute:"\xED",icirc:"\xEE",iuml:"\xEF",eth:"\xF0",ntilde:"\xF1",ograve:"\xF2",oacute:"\xF3",ocirc:"\xF4",otilde:"\xF5",ouml:"\xF6",divide:"\xF7",oslash:"\xF8",ugrave:"\xF9",uacute:"\xFA",ucirc:"\xFB",uuml:"\xFC",yacute:"\xFD",thorn:"\xFE",yuml:"\xFF",OElig:"\u0152",oelig:"\u0153",Scaron:"\u0160",scaron:"\u0161",Yuml:"\u0178",fnof:"\u0192",circ:"\u02C6",tilde:"\u02DC",Alpha:"\u0391",Beta:"\u0392",Gamma:"\u0393",Delta:"\u0394",Epsilon:"\u0395",Zeta:"\u0396",Eta:"\u0397",Theta:"\u0398",Iota:"\u0399",Kappa:"\u039A",Lambda:"\u039B",Mu:"\u039C",Nu:"\u039D",Xi:"\u039E",Omicron:"\u039F",Pi:"\u03A0",Rho:"\u03A1",Sigma:"\u03A3",Tau:"\u03A4",Upsilon:"\u03A5",Phi:"\u03A6",Chi:"\u03A7",Psi:"\u03A8",Omega:"\u03A9",alpha:"\u03B1",beta:"\u03B2",gamma:"\u03B3",delta:"\u03B4",epsilon:"\u03B5",zeta:"\u03B6",eta:"\u03B7",theta:"\u03B8",iota:"\u03B9",kappa:"\u03BA",lambda:"\u03BB",mu:"\u03BC",nu:"\u03BD",xi:"\u03BE",omicron:"\u03BF",pi:"\u03C0",rho:"\u03C1",sigmaf:"\u03C2",sigma:"\u03C3",tau:"\u03C4",upsilon:"\u03C5",phi:"\u03C6",chi:"\u03C7",psi:"\u03C8",omega:"\u03C9",thetasym:"\u03D1",upsih:"\u03D2",piv:"\u03D6",ensp:"\u2002",emsp:"\u2003",thinsp:"\u2009",zwnj:"\u200C",zwj:"\u200D",lrm:"\u200E",rlm:"\u200F",ndash:"\u2013",mdash:"\u2014",lsquo:"\u2018",rsquo:"\u2019",sbquo:"\u201A",ldquo:"\u201C",rdquo:"\u201D",bdquo:"\u201E",dagger:"\u2020",Dagger:"\u2021",bull:"\u2022",hellip:"\u2026",permil:"\u2030",prime:"\u2032",Prime:"\u2033",lsaquo:"\u2039",rsaquo:"\u203A",oline:"\u203E",frasl:"\u2044",euro:"\u20AC",image:"\u2111",weierp:"\u2118",real:"\u211C",trade:"\u2122",alefsym:"\u2135",larr:"\u2190",uarr:"\u2191",rarr:"\u2192",darr:"\u2193",harr:"\u2194",crarr:"\u21B5",lArr:"\u21D0",uArr:"\u21D1",rArr:"\u21D2",dArr:"\u21D3",hArr:"\u21D4",forall:"\u2200",part:"\u2202",exist:"\u2203",empty:"\u2205",nabla:"\u2207",isin:"\u2208",notin:"\u2209",ni:"\u220B",prod:"\u220F",sum:"\u2211",minus:"\u2212",lowast:"\u2217",radic:"\u221A",prop:"\u221D",infin:"\u221E",ang:"\u2220",and:"\u2227",or:"\u2228",cap:"\u2229",cup:"\u222A","int":"\u222B",there4:"\u2234",sim:"\u223C",cong:"\u2245",asymp:"\u2248",ne:"\u2260",equiv:"\u2261",le:"\u2264",ge:"\u2265",sub:"\u2282",sup:"\u2283",nsub:"\u2284",sube:"\u2286",supe:"\u2287",oplus:"\u2295",otimes:"\u2297",perp:"\u22A5",sdot:"\u22C5",lceil:"\u2308",rceil:"\u2309",lfloor:"\u230A",rfloor:"\u230B",lang:"\u2329",rang:"\u232A",loz:"\u25CA",spades:"\u2660",clubs:"\u2663",hearts:"\u2665",diams:"\u2666"};var JsxErrors=ParseErrorEnum(_templateObject3||(_templateObject3=_taggedTemplateLiteral(["jsx"])))({AttributeIsEmpty:"JSX attributes must only be assigned a non-empty expression.",MissingClosingTagElement:function MissingClosingTagElement(_ref63){var openingTagName=_ref63.openingTagName;return "Expected corresponding JSX closing tag for <".concat(openingTagName,">.");},MissingClosingTagFragment:"Expected corresponding JSX closing tag for <>.",UnexpectedSequenceExpression:"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",UnexpectedToken:function UnexpectedToken(_ref64){var unexpected=_ref64.unexpected,HTMLEntity=_ref64.HTMLEntity;return "Unexpected token `".concat(unexpected,"`. Did you mean `").concat(HTMLEntity,"` or `{'").concat(unexpected,"'}`?");},UnsupportedJsxValue:"JSX value should be either an expression or a quoted JSX text.",UnterminatedJsxContent:"Unterminated JSX contents.",UnwrappedAdjacentJSXElements:"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"});function isFragment(object){return object?object.type==="JSXOpeningFragment"||object.type==="JSXClosingFragment":false;}function getQualifiedJSXName(object){if(object.type==="JSXIdentifier"){return object.name;}if(object.type==="JSXNamespacedName"){return object.namespace.name+":"+object.name.name;}if(object.type==="JSXMemberExpression"){return getQualifiedJSXName(object.object)+"."+getQualifiedJSXName(object.property);}throw new Error("Node had unexpected type: "+object.type);}var jsx=function jsx(superClass){return/*#__PURE__*/function(_superClass3){function JSXParserMixin(){_classCallCheck(this,JSXParserMixin);return _callSuper(this,JSXParserMixin,arguments);}_inherits(JSXParserMixin,_superClass3);return _createClass(JSXParserMixin,[{key:"jsxReadToken",value:function jsxReadToken(){var out="";var chunkStart=this.state.pos;for(;;){if(this.state.pos>=this.length){throw this.raise(JsxErrors.UnterminatedJsxContent,this.state.startLoc);}var ch=this.input.charCodeAt(this.state.pos);switch(ch){case 60:case 123:if(this.state.pos===this.state.start){if(ch===60&&this.state.canStartJSXElement){++this.state.pos;this.finishToken(143);}else {_superPropGet(JSXParserMixin,"getTokenFromCode",this,3)([ch]);}return;}out+=this.input.slice(chunkStart,this.state.pos);this.finishToken(142,out);return;case 38:out+=this.input.slice(chunkStart,this.state.pos);out+=this.jsxReadEntity();chunkStart=this.state.pos;break;case 62:case 125:default:if(isNewLine(ch)){out+=this.input.slice(chunkStart,this.state.pos);out+=this.jsxReadNewLine(true);chunkStart=this.state.pos;}else {++this.state.pos;}}}}},{key:"jsxReadNewLine",value:function jsxReadNewLine(normalizeCRLF){var ch=this.input.charCodeAt(this.state.pos);var out;++this.state.pos;if(ch===13&&this.input.charCodeAt(this.state.pos)===10){++this.state.pos;out=normalizeCRLF?"\n":"\r\n";}else {out=String.fromCharCode(ch);}++this.state.curLine;this.state.lineStart=this.state.pos;return out;}},{key:"jsxReadString",value:function jsxReadString(quote){var out="";var chunkStart=++this.state.pos;for(;;){if(this.state.pos>=this.length){throw this.raise(Errors.UnterminatedString,this.state.startLoc);}var ch=this.input.charCodeAt(this.state.pos);if(ch===quote)break;if(ch===38){out+=this.input.slice(chunkStart,this.state.pos);out+=this.jsxReadEntity();chunkStart=this.state.pos;}else if(isNewLine(ch)){out+=this.input.slice(chunkStart,this.state.pos);out+=this.jsxReadNewLine(false);chunkStart=this.state.pos;}else {++this.state.pos;}}out+=this.input.slice(chunkStart,this.state.pos++);this.finishToken(134,out);}},{key:"jsxReadEntity",value:function jsxReadEntity(){var startPos=++this.state.pos;if(this.codePointAtPos(this.state.pos)===35){++this.state.pos;var radix=10;if(this.codePointAtPos(this.state.pos)===120){radix=16;++this.state.pos;}var codePoint=this.readInt(radix,undefined,false,"bail");if(codePoint!==null&&this.codePointAtPos(this.state.pos)===59){++this.state.pos;return String.fromCodePoint(codePoint);}}else {var count=0;var semi=false;while(count++<10&&this.state.pos<this.length&&!(semi=this.codePointAtPos(this.state.pos)===59)){++this.state.pos;}if(semi){var desc=this.input.slice(startPos,this.state.pos);var entity=entities[desc];++this.state.pos;if(entity){return entity;}}}this.state.pos=startPos;return "&";}},{key:"jsxReadWord",value:function jsxReadWord(){var ch;var start=this.state.pos;do{ch=this.input.charCodeAt(++this.state.pos);}while(isIdentifierChar(ch)||ch===45);this.finishToken(141,this.input.slice(start,this.state.pos));}},{key:"jsxParseIdentifier",value:function jsxParseIdentifier(){var node=this.startNode();if(this.match(141)){node.name=this.state.value;}else if(tokenIsKeyword(this.state.type)){node.name=tokenLabelName(this.state.type);}else {this.unexpected();}this.next();return this.finishNode(node,"JSXIdentifier");}},{key:"jsxParseNamespacedName",value:function jsxParseNamespacedName(){var startLoc=this.state.startLoc;var name=this.jsxParseIdentifier();if(!this.eat(14))return name;var node=this.startNodeAt(startLoc);node.namespace=name;node.name=this.jsxParseIdentifier();return this.finishNode(node,"JSXNamespacedName");}},{key:"jsxParseElementName",value:function jsxParseElementName(){var startLoc=this.state.startLoc;var node=this.jsxParseNamespacedName();if(node.type==="JSXNamespacedName"){return node;}while(this.eat(16)){var newNode=this.startNodeAt(startLoc);newNode.object=node;newNode.property=this.jsxParseIdentifier();node=this.finishNode(newNode,"JSXMemberExpression");}return node;}},{key:"jsxParseAttributeValue",value:function jsxParseAttributeValue(){var node;switch(this.state.type){case 5:node=this.startNode();this.setContext(types.brace);this.next();node=this.jsxParseExpressionContainer(node,types.j_oTag);if(node.expression.type==="JSXEmptyExpression"){this.raise(JsxErrors.AttributeIsEmpty,node);}return node;case 143:case 134:return this.parseExprAtom();default:throw this.raise(JsxErrors.UnsupportedJsxValue,this.state.startLoc);}}},{key:"jsxParseEmptyExpression",value:function jsxParseEmptyExpression(){var node=this.startNodeAt(this.state.lastTokEndLoc);return this.finishNodeAt(node,"JSXEmptyExpression",this.state.startLoc);}},{key:"jsxParseSpreadChild",value:function jsxParseSpreadChild(node){this.next();node.expression=this.parseExpression();this.setContext(types.j_expr);this.state.canStartJSXElement=true;this.expect(8);return this.finishNode(node,"JSXSpreadChild");}},{key:"jsxParseExpressionContainer",value:function jsxParseExpressionContainer(node,previousContext){if(this.match(8)){node.expression=this.jsxParseEmptyExpression();}else {var expression=this.parseExpression();node.expression=expression;}this.setContext(previousContext);this.state.canStartJSXElement=true;this.expect(8);return this.finishNode(node,"JSXExpressionContainer");}},{key:"jsxParseAttribute",value:function jsxParseAttribute(){var node=this.startNode();if(this.match(5)){this.setContext(types.brace);this.next();this.expect(21);node.argument=this.parseMaybeAssignAllowIn();this.setContext(types.j_oTag);this.state.canStartJSXElement=true;this.expect(8);return this.finishNode(node,"JSXSpreadAttribute");}node.name=this.jsxParseNamespacedName();node.value=this.eat(29)?this.jsxParseAttributeValue():null;return this.finishNode(node,"JSXAttribute");}},{key:"jsxParseOpeningElementAt",value:function jsxParseOpeningElementAt(startLoc){var node=this.startNodeAt(startLoc);if(this.eat(144)){return this.finishNode(node,"JSXOpeningFragment");}node.name=this.jsxParseElementName();return this.jsxParseOpeningElementAfterName(node);}},{key:"jsxParseOpeningElementAfterName",value:function jsxParseOpeningElementAfterName(node){var attributes=[];while(!this.match(56)&&!this.match(144)){attributes.push(this.jsxParseAttribute());}node.attributes=attributes;node.selfClosing=this.eat(56);this.expect(144);return this.finishNode(node,"JSXOpeningElement");}},{key:"jsxParseClosingElementAt",value:function jsxParseClosingElementAt(startLoc){var node=this.startNodeAt(startLoc);if(this.eat(144)){return this.finishNode(node,"JSXClosingFragment");}node.name=this.jsxParseElementName();this.expect(144);return this.finishNode(node,"JSXClosingElement");}},{key:"jsxParseElementAt",value:function jsxParseElementAt(startLoc){var node=this.startNodeAt(startLoc);var children=[];var openingElement=this.jsxParseOpeningElementAt(startLoc);var closingElement=null;if(!openingElement.selfClosing){contents:for(;;){switch(this.state.type){case 143:startLoc=this.state.startLoc;this.next();if(this.eat(56)){closingElement=this.jsxParseClosingElementAt(startLoc);break contents;}children.push(this.jsxParseElementAt(startLoc));break;case 142:children.push(this.parseLiteral(this.state.value,"JSXText"));break;case 5:{var _node7=this.startNode();this.setContext(types.brace);this.next();if(this.match(21)){children.push(this.jsxParseSpreadChild(_node7));}else {children.push(this.jsxParseExpressionContainer(_node7,types.j_expr));}break;}default:this.unexpected();}}if(isFragment(openingElement)&&!isFragment(closingElement)&&closingElement!==null){this.raise(JsxErrors.MissingClosingTagFragment,closingElement);}else if(!isFragment(openingElement)&&isFragment(closingElement)){this.raise(JsxErrors.MissingClosingTagElement,closingElement,{openingTagName:getQualifiedJSXName(openingElement.name)});}else if(!isFragment(openingElement)&&!isFragment(closingElement)){if(getQualifiedJSXName(closingElement.name)!==getQualifiedJSXName(openingElement.name)){this.raise(JsxErrors.MissingClosingTagElement,closingElement,{openingTagName:getQualifiedJSXName(openingElement.name)});}}}if(isFragment(openingElement)){node.openingFragment=openingElement;node.closingFragment=closingElement;}else {node.openingElement=openingElement;node.closingElement=closingElement;}node.children=children;if(this.match(47)){throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements,this.state.startLoc);}return isFragment(openingElement)?this.finishNode(node,"JSXFragment"):this.finishNode(node,"JSXElement");}},{key:"jsxParseElement",value:function jsxParseElement(){var startLoc=this.state.startLoc;this.next();return this.jsxParseElementAt(startLoc);}},{key:"setContext",value:function setContext(newContext){var context=this.state.context;context[context.length-1]=newContext;}},{key:"parseExprAtom",value:function parseExprAtom(refExpressionErrors){if(this.match(143)){return this.jsxParseElement();}else if(this.match(47)&&this.input.charCodeAt(this.state.pos)!==33){this.replaceToken(143);return this.jsxParseElement();}else {return _superPropGet(JSXParserMixin,"parseExprAtom",this,3)([refExpressionErrors]);}}},{key:"skipSpace",value:function skipSpace(){var curContext=this.curContext();if(!curContext.preserveSpace)_superPropGet(JSXParserMixin,"skipSpace",this,3)([]);}},{key:"getTokenFromCode",value:function getTokenFromCode(code){var context=this.curContext();if(context===types.j_expr){this.jsxReadToken();return;}if(context===types.j_oTag||context===types.j_cTag){if(isIdentifierStart(code)){this.jsxReadWord();return;}if(code===62){++this.state.pos;this.finishToken(144);return;}if((code===34||code===39)&&context===types.j_oTag){this.jsxReadString(code);return;}}if(code===60&&this.state.canStartJSXElement&&this.input.charCodeAt(this.state.pos+1)!==33){++this.state.pos;this.finishToken(143);return;}_superPropGet(JSXParserMixin,"getTokenFromCode",this,3)([code]);}},{key:"updateContext",value:function updateContext(prevType){var _this$state=this.state,context=_this$state.context,type=_this$state.type;if(type===56&&prevType===143){context.splice(-2,2,types.j_cTag);this.state.canStartJSXElement=false;}else if(type===143){context.push(types.j_oTag);}else if(type===144){var out=context[context.length-1];if(out===types.j_oTag&&prevType===56||out===types.j_cTag){context.pop();this.state.canStartJSXElement=context[context.length-1]===types.j_expr;}else {this.setContext(types.j_expr);this.state.canStartJSXElement=true;}}else {this.state.canStartJSXElement=tokenComesBeforeExpression(type);}}}]);}(superClass);};var TypeScriptScope=/*#__PURE__*/function(_Scope2){function TypeScriptScope(){var _this24;_classCallCheck(this,TypeScriptScope);for(var _len5=arguments.length,args=new Array(_len5),_key5=0;_key5<_len5;_key5++){args[_key5]=arguments[_key5];}_this24=_callSuper(this,TypeScriptScope,[].concat(args));_this24.tsNames=new Map();return _this24;}_inherits(TypeScriptScope,_Scope2);return _createClass(TypeScriptScope);}(Scope);var TypeScriptScopeHandler=/*#__PURE__*/function(_ScopeHandler2){function TypeScriptScopeHandler(){var _this25;_classCallCheck(this,TypeScriptScopeHandler);for(var _len6=arguments.length,args=new Array(_len6),_key6=0;_key6<_len6;_key6++){args[_key6]=arguments[_key6];}_this25=_callSuper(this,TypeScriptScopeHandler,[].concat(args));_this25.importsStack=[];return _this25;}_inherits(TypeScriptScopeHandler,_ScopeHandler2);return _createClass(TypeScriptScopeHandler,[{key:"createScope",value:function createScope(flags){this.importsStack.push(new Set());return new TypeScriptScope(flags);}},{key:"enter",value:function enter(flags){if(flags===256){this.importsStack.push(new Set());}_superPropGet(TypeScriptScopeHandler,"enter",this,3)([flags]);}},{key:"exit",value:function exit(){var flags=_superPropGet(TypeScriptScopeHandler,"exit",this,3)([]);if(flags===256){this.importsStack.pop();}return flags;}},{key:"hasImport",value:function hasImport(name,allowShadow){var len=this.importsStack.length;if(this.importsStack[len-1].has(name)){return true;}if(!allowShadow&&len>1){for(var i=0;i<len-1;i++){if(this.importsStack[i].has(name))return true;}}return false;}},{key:"declareName",value:function declareName(name,bindingType,loc){if(bindingType&4096){if(this.hasImport(name,true)){this.parser.raise(Errors.VarRedeclaration,loc,{identifierName:name});}this.importsStack[this.importsStack.length-1].add(name);return;}var scope=this.currentScope();var type=scope.tsNames.get(name)||0;if(bindingType&1024){this.maybeExportDefined(scope,name);scope.tsNames.set(name,type|16);return;}_superPropGet(TypeScriptScopeHandler,"declareName",this,3)([name,bindingType,loc]);if(bindingType&2){if(!(bindingType&1)){this.checkRedeclarationInScope(scope,name,bindingType,loc);this.maybeExportDefined(scope,name);}type=type|1;}if(bindingType&256){type=type|2;}if(bindingType&512){type=type|4;}if(bindingType&128){type=type|8;}if(type)scope.tsNames.set(name,type);}},{key:"isRedeclaredInScope",value:function isRedeclaredInScope(scope,name,bindingType){var type=scope.tsNames.get(name);if((type&2)>0){if(bindingType&256){var isConst=!!(bindingType&512);var wasConst=(type&4)>0;return isConst!==wasConst;}return true;}if(bindingType&128&&(type&8)>0){if(scope.names.get(name)&2){return !!(bindingType&1);}else {return false;}}if(bindingType&2&&(type&1)>0){return true;}return _superPropGet(TypeScriptScopeHandler,"isRedeclaredInScope",this,3)([scope,name,bindingType]);}},{key:"checkLocalExport",value:function checkLocalExport(id){var name=id.name;if(this.hasImport(name))return;var len=this.scopeStack.length;for(var i=len-1;i>=0;i--){var scope=this.scopeStack[i];var type=scope.tsNames.get(name);if((type&1)>0||(type&16)>0){return;}}_superPropGet(TypeScriptScopeHandler,"checkLocalExport",this,3)([id]);}}]);}(ScopeHandler);var _unwrapParenthesizedExpression=function unwrapParenthesizedExpression(node){return node.type==="ParenthesizedExpression"?_unwrapParenthesizedExpression(node.expression):node;};var LValParser=/*#__PURE__*/function(_NodeUtils){function LValParser(){_classCallCheck(this,LValParser);return _callSuper(this,LValParser,arguments);}_inherits(LValParser,_NodeUtils);return _createClass(LValParser,[{key:"toAssignable",value:function toAssignable(node){var isLHS=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var _node$extra,_node$extra3;var parenthesized=undefined;if(node.type==="ParenthesizedExpression"||(_node$extra=node.extra)!=null&&_node$extra.parenthesized){parenthesized=_unwrapParenthesizedExpression(node);if(isLHS){if(parenthesized.type==="Identifier"){this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment,node);}else if(parenthesized.type!=="MemberExpression"&&!this.isOptionalMemberExpression(parenthesized)){this.raise(Errors.InvalidParenthesizedAssignment,node);}}else {this.raise(Errors.InvalidParenthesizedAssignment,node);}}switch(node.type){case "Identifier":case "ObjectPattern":case "ArrayPattern":case "AssignmentPattern":case "RestElement":break;case "ObjectExpression":node.type="ObjectPattern";for(var i=0,length=node.properties.length,last=length-1;i<length;i++){var _node$extra2;var prop=node.properties[i];var isLast=i===last;this.toAssignableObjectExpressionProp(prop,isLast,isLHS);if(isLast&&prop.type==="RestElement"&&(_node$extra2=node.extra)!=null&&_node$extra2.trailingCommaLoc){this.raise(Errors.RestTrailingComma,node.extra.trailingCommaLoc);}}break;case "ObjectProperty":{var key=node.key,value=node.value;if(this.isPrivateName(key)){this.classScope.usePrivateName(this.getPrivateNameSV(key),key.loc.start);}this.toAssignable(value,isLHS);break;}case "SpreadElement":{throw new Error("Internal @babel/parser error (this is a bug, please report it)."+" SpreadElement should be converted by .toAssignable's caller.");}case "ArrayExpression":node.type="ArrayPattern";this.toAssignableList(node.elements,(_node$extra3=node.extra)==null?void 0:_node$extra3.trailingCommaLoc,isLHS);break;case "AssignmentExpression":if(node.operator!=="="){this.raise(Errors.MissingEqInAssignment,node.left.loc.end);}node.type="AssignmentPattern";delete node.operator;this.toAssignable(node.left,isLHS);break;case "ParenthesizedExpression":this.toAssignable(parenthesized,isLHS);break;}}},{key:"toAssignableObjectExpressionProp",value:function toAssignableObjectExpressionProp(prop,isLast,isLHS){if(prop.type==="ObjectMethod"){this.raise(prop.kind==="get"||prop.kind==="set"?Errors.PatternHasAccessor:Errors.PatternHasMethod,prop.key);}else if(prop.type==="SpreadElement"){prop.type="RestElement";var arg=prop.argument;this.checkToRestConversion(arg,false);this.toAssignable(arg,isLHS);if(!isLast){this.raise(Errors.RestTrailingComma,prop);}}else {this.toAssignable(prop,isLHS);}}},{key:"toAssignableList",value:function toAssignableList(exprList,trailingCommaLoc,isLHS){var end=exprList.length-1;for(var i=0;i<=end;i++){var elt=exprList[i];if(!elt)continue;if(elt.type==="SpreadElement"){elt.type="RestElement";var arg=elt.argument;this.checkToRestConversion(arg,true);this.toAssignable(arg,isLHS);}else {this.toAssignable(elt,isLHS);}if(elt.type==="RestElement"){if(i<end){this.raise(Errors.RestTrailingComma,elt);}else if(trailingCommaLoc){this.raise(Errors.RestTrailingComma,trailingCommaLoc);}}}}},{key:"isAssignable",value:function isAssignable(node,isBinding){var _this26=this;switch(node.type){case "Identifier":case "ObjectPattern":case "ArrayPattern":case "AssignmentPattern":case "RestElement":return true;case "ObjectExpression":{var last=node.properties.length-1;return node.properties.every(function(prop,i){return prop.type!=="ObjectMethod"&&(i===last||prop.type!=="SpreadElement")&&_this26.isAssignable(prop);});}case "ObjectProperty":return this.isAssignable(node.value);case "SpreadElement":return this.isAssignable(node.argument);case "ArrayExpression":return node.elements.every(function(element){return element===null||_this26.isAssignable(element);});case "AssignmentExpression":return node.operator==="=";case "ParenthesizedExpression":return this.isAssignable(node.expression);case "MemberExpression":case "OptionalMemberExpression":return !isBinding;default:return false;}}},{key:"toReferencedList",value:function toReferencedList(exprList,isParenthesizedExpr){return exprList;}},{key:"toReferencedListDeep",value:function toReferencedListDeep(exprList,isParenthesizedExpr){this.toReferencedList(exprList,isParenthesizedExpr);var _iterator6=_createForOfIteratorHelper(exprList),_step6;try{for(_iterator6.s();!(_step6=_iterator6.n()).done;){var expr=_step6.value;if((expr==null?void 0:expr.type)==="ArrayExpression"){this.toReferencedListDeep(expr.elements);}}}catch(err){_iterator6.e(err);}finally{_iterator6.f();}}},{key:"parseSpread",value:function parseSpread(refExpressionErrors){var node=this.startNode();this.next();node.argument=this.parseMaybeAssignAllowIn(refExpressionErrors,undefined);return this.finishNode(node,"SpreadElement");}},{key:"parseRestBinding",value:function parseRestBinding(){var node=this.startNode();this.next();node.argument=this.parseBindingAtom();return this.finishNode(node,"RestElement");}},{key:"parseBindingAtom",value:function parseBindingAtom(){switch(this.state.type){case 0:{var node=this.startNode();this.next();node.elements=this.parseBindingList(3,93,1);return this.finishNode(node,"ArrayPattern");}case 5:return this.parseObjectLike(8,true);}return this.parseIdentifier();}},{key:"parseBindingList",value:function parseBindingList(close,closeCharCode,flags){var allowEmpty=flags&1;var elts=[];var first=true;while(!this.eat(close)){if(first){first=false;}else {this.expect(12);}if(allowEmpty&&this.match(12)){elts.push(null);}else if(this.eat(close)){break;}else if(this.match(21)){var rest=this.parseRestBinding();if(this.hasPlugin("flow")||flags&2){rest=this.parseFunctionParamType(rest);}elts.push(rest);if(!this.checkCommaAfterRest(closeCharCode)){this.expect(close);break;}}else {var decorators=[];if(this.match(26)&&this.hasPlugin("decorators")){this.raise(Errors.UnsupportedParameterDecorator,this.state.startLoc);}while(this.match(26)){decorators.push(this.parseDecorator());}elts.push(this.parseAssignableListItem(flags,decorators));}}return elts;}},{key:"parseBindingRestProperty",value:function parseBindingRestProperty(prop){this.next();prop.argument=this.parseIdentifier();this.checkCommaAfterRest(125);return this.finishNode(prop,"RestElement");}},{key:"parseBindingProperty",value:function parseBindingProperty(){var _this$state2=this.state,type=_this$state2.type,startLoc=_this$state2.startLoc;if(type===21){return this.parseBindingRestProperty(this.startNode());}var prop=this.startNode();if(type===139){this.expectPlugin("destructuringPrivate",startLoc);this.classScope.usePrivateName(this.state.value,startLoc);prop.key=this.parsePrivateName();}else {this.parsePropertyName(prop);}prop.method=false;return this.parseObjPropValue(prop,startLoc,false,false,true,false);}},{key:"parseAssignableListItem",value:function parseAssignableListItem(flags,decorators){var left=this.parseMaybeDefault();if(this.hasPlugin("flow")||flags&2){this.parseFunctionParamType(left);}var elt=this.parseMaybeDefault(left.loc.start,left);if(decorators.length){left.decorators=decorators;}return elt;}},{key:"parseFunctionParamType",value:function parseFunctionParamType(param){return param;}},{key:"parseMaybeDefault",value:function parseMaybeDefault(startLoc,left){var _startLoc,_left;(_startLoc=startLoc)!=null?_startLoc:startLoc=this.state.startLoc;left=(_left=left)!=null?_left:this.parseBindingAtom();if(!this.eat(29))return left;var node=this.startNodeAt(startLoc);node.left=left;node.right=this.parseMaybeAssignAllowIn();return this.finishNode(node,"AssignmentPattern");}},{key:"isValidLVal",value:function isValidLVal(type,isUnparenthesizedInAssign,binding){switch(type){case "AssignmentPattern":return "left";case "RestElement":return "argument";case "ObjectProperty":return "value";case "ParenthesizedExpression":return "expression";case "ArrayPattern":return "elements";case "ObjectPattern":return "properties";}return false;}},{key:"isOptionalMemberExpression",value:function isOptionalMemberExpression(expression){return expression.type==="OptionalMemberExpression";}},{key:"checkLVal",value:function checkLVal(expression,ancestor){var binding=arguments.length>2&&arguments[2]!==undefined?arguments[2]:64;var checkClashes=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;var strictModeChanged=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;var hasParenthesizedAncestor=arguments.length>5&&arguments[5]!==undefined?arguments[5]:false;var _expression$extra;var type=expression.type;if(this.isObjectMethod(expression))return;var isOptionalMemberExpression=this.isOptionalMemberExpression(expression);if(isOptionalMemberExpression||type==="MemberExpression"){if(isOptionalMemberExpression){this.expectPlugin("optionalChainingAssign",expression.loc.start);if(ancestor.type!=="AssignmentExpression"){this.raise(Errors.InvalidLhsOptionalChaining,expression,{ancestor:ancestor});}}if(binding!==64){this.raise(Errors.InvalidPropertyBindingPattern,expression);}return;}if(type==="Identifier"){this.checkIdentifier(expression,binding,strictModeChanged);var name=expression.name;if(checkClashes){if(checkClashes.has(name)){this.raise(Errors.ParamDupe,expression);}else {checkClashes.add(name);}}return;}var validity=this.isValidLVal(type,!(hasParenthesizedAncestor||(_expression$extra=expression.extra)!=null&&_expression$extra.parenthesized)&&ancestor.type==="AssignmentExpression",binding);if(validity===true)return;if(validity===false){var ParseErrorClass=binding===64?Errors.InvalidLhs:Errors.InvalidLhsBinding;this.raise(ParseErrorClass,expression,{ancestor:ancestor});return;}var key,isParenthesizedExpression;if(typeof validity==="string"){key=validity;isParenthesizedExpression=type==="ParenthesizedExpression";}else {var _validity=_slicedToArray(validity,2);key=_validity[0];isParenthesizedExpression=_validity[1];}var nextAncestor=type==="ArrayPattern"||type==="ObjectPattern"?{type:type}:ancestor;var val=expression[key];if(Array.isArray(val)){var _iterator7=_createForOfIteratorHelper(val),_step7;try{for(_iterator7.s();!(_step7=_iterator7.n()).done;){var child=_step7.value;if(child){this.checkLVal(child,nextAncestor,binding,checkClashes,strictModeChanged,isParenthesizedExpression);}}}catch(err){_iterator7.e(err);}finally{_iterator7.f();}}else if(val){this.checkLVal(val,nextAncestor,binding,checkClashes,strictModeChanged,isParenthesizedExpression);}}},{key:"checkIdentifier",value:function checkIdentifier(at,bindingType){var strictModeChanged=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;if(this.state.strict&&(strictModeChanged?isStrictBindReservedWord(at.name,this.inModule):isStrictBindOnlyReservedWord(at.name))){if(bindingType===64){this.raise(Errors.StrictEvalArguments,at,{referenceName:at.name});}else {this.raise(Errors.StrictEvalArgumentsBinding,at,{bindingName:at.name});}}if(bindingType&8192&&at.name==="let"){this.raise(Errors.LetInLexicalBinding,at);}if(!(bindingType&64)){this.declareNameFromIdentifier(at,bindingType);}}},{key:"declareNameFromIdentifier",value:function declareNameFromIdentifier(identifier,binding){this.scope.declareName(identifier.name,binding,identifier.loc.start);}},{key:"checkToRestConversion",value:function checkToRestConversion(node,allowPattern){switch(node.type){case "ParenthesizedExpression":this.checkToRestConversion(node.expression,allowPattern);break;case "Identifier":case "MemberExpression":break;case "ArrayExpression":case "ObjectExpression":if(allowPattern)break;default:this.raise(Errors.InvalidRestAssignmentPattern,node);}}},{key:"checkCommaAfterRest",value:function checkCommaAfterRest(close){if(!this.match(12)){return false;}this.raise(this.lookaheadCharCode()===close?Errors.RestTrailingComma:Errors.ElementAfterRest,this.state.startLoc);return true;}}]);}(NodeUtils);function nonNull(x){if(x==null){throw new Error("Unexpected ".concat(x," value."));}return x;}function assert(x){if(!x){throw new Error("Assert fail");}}var TSErrors=ParseErrorEnum(_templateObject4||(_templateObject4=_taggedTemplateLiteral(["typescript"])))({AbstractMethodHasImplementation:function AbstractMethodHasImplementation(_ref65){var methodName=_ref65.methodName;return "Method '".concat(methodName,"' cannot have an implementation because it is marked abstract.");},AbstractPropertyHasInitializer:function AbstractPropertyHasInitializer(_ref66){var propertyName=_ref66.propertyName;return "Property '".concat(propertyName,"' cannot have an initializer because it is marked abstract.");},AccessorCannotBeOptional:"An 'accessor' property cannot be declared optional.",AccessorCannotDeclareThisParameter:"'get' and 'set' accessors cannot declare 'this' parameters.",AccessorCannotHaveTypeParameters:"An accessor cannot have type parameters.",ClassMethodHasDeclare:"Class methods cannot have the 'declare' modifier.",ClassMethodHasReadonly:"Class methods cannot have the 'readonly' modifier.",ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference:"A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",ConstructorHasTypeParameters:"Type parameters cannot appear on a constructor declaration.",DeclareAccessor:function DeclareAccessor(_ref67){var kind=_ref67.kind;return "'declare' is not allowed in ".concat(kind,"ters.");},DeclareClassFieldHasInitializer:"Initializers are not allowed in ambient contexts.",DeclareFunctionHasImplementation:"An implementation cannot be declared in ambient contexts.",DuplicateAccessibilityModifier:function DuplicateAccessibilityModifier(_ref68){_ref68.modifier;return "Accessibility modifier already seen.";},DuplicateModifier:function DuplicateModifier(_ref69){var modifier=_ref69.modifier;return "Duplicate modifier: '".concat(modifier,"'.");},EmptyHeritageClauseType:function EmptyHeritageClauseType(_ref70){var token=_ref70.token;return "'".concat(token,"' list cannot be empty.");},EmptyTypeArguments:"Type argument list cannot be empty.",EmptyTypeParameters:"Type parameter list cannot be empty.",ExpectedAmbientAfterExportDeclare:"'export declare' must be followed by an ambient declaration.",ImportAliasHasImportType:"An import alias can not use 'import type'.",ImportReflectionHasImportType:"An `import module` declaration can not use `type` modifier",IncompatibleModifiers:function IncompatibleModifiers(_ref71){var modifiers=_ref71.modifiers;return "'".concat(modifiers[0],"' modifier cannot be used with '").concat(modifiers[1],"' modifier.");},IndexSignatureHasAbstract:"Index signatures cannot have the 'abstract' modifier.",IndexSignatureHasAccessibility:function IndexSignatureHasAccessibility(_ref72){var modifier=_ref72.modifier;return "Index signatures cannot have an accessibility modifier ('".concat(modifier,"').");},IndexSignatureHasDeclare:"Index signatures cannot have the 'declare' modifier.",IndexSignatureHasOverride:"'override' modifier cannot appear on an index signature.",IndexSignatureHasStatic:"Index signatures cannot have the 'static' modifier.",InitializerNotAllowedInAmbientContext:"Initializers are not allowed in ambient contexts.",InvalidModifierOnTypeMember:function InvalidModifierOnTypeMember(_ref73){var modifier=_ref73.modifier;return "'".concat(modifier,"' modifier cannot appear on a type member.");},InvalidModifierOnTypeParameter:function InvalidModifierOnTypeParameter(_ref74){var modifier=_ref74.modifier;return "'".concat(modifier,"' modifier cannot appear on a type parameter.");},InvalidModifierOnTypeParameterPositions:function InvalidModifierOnTypeParameterPositions(_ref75){var modifier=_ref75.modifier;return "'".concat(modifier,"' modifier can only appear on a type parameter of a class, interface or type alias.");},InvalidModifiersOrder:function InvalidModifiersOrder(_ref76){var orderedModifiers=_ref76.orderedModifiers;return "'".concat(orderedModifiers[0],"' modifier must precede '").concat(orderedModifiers[1],"' modifier.");},InvalidPropertyAccessAfterInstantiationExpression:"Invalid property access after an instantiation expression. "+"You can either wrap the instantiation expression in parentheses, or delete the type arguments.",InvalidTupleMemberLabel:"Tuple members must be labeled with a simple identifier.",MissingInterfaceName:"'interface' declarations must be followed by an identifier.",NonAbstractClassHasAbstractMethod:"Abstract methods can only appear within an abstract class.",NonClassMethodPropertyHasAbstractModifer:"'abstract' modifier can only appear on a class, method, or property declaration.",OptionalTypeBeforeRequired:"A required element cannot follow an optional element.",OverrideNotInSubClass:"This member cannot have an 'override' modifier because its containing class does not extend another class.",PatternIsOptional:"A binding pattern parameter cannot be optional in an implementation signature.",PrivateElementHasAbstract:"Private elements cannot have the 'abstract' modifier.",PrivateElementHasAccessibility:function PrivateElementHasAccessibility(_ref77){var modifier=_ref77.modifier;return "Private elements cannot have an accessibility modifier ('".concat(modifier,"').");},ReadonlyForMethodSignature:"'readonly' modifier can only appear on a property declaration or index signature.",ReservedArrowTypeParam:"This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",ReservedTypeAssertion:"This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",SetAccessorCannotHaveOptionalParameter:"A 'set' accessor cannot have an optional parameter.",SetAccessorCannotHaveRestParameter:"A 'set' accessor cannot have rest parameter.",SetAccessorCannotHaveReturnType:"A 'set' accessor cannot have a return type annotation.",SingleTypeParameterWithoutTrailingComma:function SingleTypeParameterWithoutTrailingComma(_ref78){var typeParameterName=_ref78.typeParameterName;return "Single type parameter ".concat(typeParameterName," should have a trailing comma. Example usage: <").concat(typeParameterName,",>.");},StaticBlockCannotHaveModifier:"Static class blocks cannot have any modifier.",TupleOptionalAfterType:"A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",TypeAnnotationAfterAssign:"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",TypeImportCannotSpecifyDefaultAndNamed:"A type-only import can specify a default import or named bindings, but not both.",TypeModifierIsUsedInTypeExports:"The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",TypeModifierIsUsedInTypeImports:"The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",UnexpectedParameterModifier:"A parameter property is only allowed in a constructor implementation.",UnexpectedReadonly:"'readonly' type modifier is only permitted on array and tuple literal types.",UnexpectedTypeAnnotation:"Did not expect a type annotation here.",UnexpectedTypeCastInParameter:"Unexpected type cast in parameter position.",UnsupportedImportTypeArgument:"Argument in a type import must be a string literal.",UnsupportedParameterPropertyKind:"A parameter property may not be declared using a binding pattern.",UnsupportedSignatureParameterKind:function UnsupportedSignatureParameterKind(_ref79){var type=_ref79.type;return "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ".concat(type,".");}});function keywordTypeFromName(value){switch(value){case "any":return "TSAnyKeyword";case "boolean":return "TSBooleanKeyword";case "bigint":return "TSBigIntKeyword";case "never":return "TSNeverKeyword";case "number":return "TSNumberKeyword";case "object":return "TSObjectKeyword";case "string":return "TSStringKeyword";case "symbol":return "TSSymbolKeyword";case "undefined":return "TSUndefinedKeyword";case "unknown":return "TSUnknownKeyword";default:return undefined;}}function tsIsAccessModifier(modifier){return modifier==="private"||modifier==="public"||modifier==="protected";}function tsIsVarianceAnnotations(modifier){return modifier==="in"||modifier==="out";}var typescript=function typescript(superClass){return/*#__PURE__*/function(_superClass4){function TypeScriptParserMixin(){var _this27;_classCallCheck(this,TypeScriptParserMixin);for(var _len7=arguments.length,args=new Array(_len7),_key7=0;_key7<_len7;_key7++){args[_key7]=arguments[_key7];}_this27=_callSuper(this,TypeScriptParserMixin,[].concat(args));_this27.tsParseInOutModifiers=_this27.tsParseModifiers.bind(_this27,{allowedModifiers:["in","out"],disallowedModifiers:["const","public","private","protected","readonly","declare","abstract","override"],errorTemplate:TSErrors.InvalidModifierOnTypeParameter});_this27.tsParseConstModifier=_this27.tsParseModifiers.bind(_this27,{allowedModifiers:["const"],disallowedModifiers:["in","out"],errorTemplate:TSErrors.InvalidModifierOnTypeParameterPositions});_this27.tsParseInOutConstModifiers=_this27.tsParseModifiers.bind(_this27,{allowedModifiers:["in","out","const"],disallowedModifiers:["public","private","protected","readonly","declare","abstract","override"],errorTemplate:TSErrors.InvalidModifierOnTypeParameter});return _this27;}_inherits(TypeScriptParserMixin,_superClass4);return _createClass(TypeScriptParserMixin,[{key:"getScopeHandler",value:function getScopeHandler(){return TypeScriptScopeHandler;}},{key:"tsIsIdentifier",value:function tsIsIdentifier(){return tokenIsIdentifier(this.state.type);}},{key:"tsTokenCanFollowModifier",value:function tsTokenCanFollowModifier(){return this.match(0)||this.match(5)||this.match(55)||this.match(21)||this.match(139)||this.isLiteralPropertyName();}},{key:"tsNextTokenOnSameLineAndCanFollowModifier",value:function tsNextTokenOnSameLineAndCanFollowModifier(){this.next();if(this.hasPrecedingLineBreak()){return false;}return this.tsTokenCanFollowModifier();}},{key:"tsNextTokenCanFollowModifier",value:function tsNextTokenCanFollowModifier(){if(this.match(106)){this.next();return this.tsTokenCanFollowModifier();}return this.tsNextTokenOnSameLineAndCanFollowModifier();}},{key:"tsParseModifier",value:function tsParseModifier(allowedModifiers,stopOnStartOfClassStaticBlock){if(!tokenIsIdentifier(this.state.type)&&this.state.type!==58&&this.state.type!==75){return undefined;}var modifier=this.state.value;if(allowedModifiers.includes(modifier)){if(stopOnStartOfClassStaticBlock&&this.tsIsStartOfStaticBlocks()){return undefined;}if(this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))){return modifier;}}return undefined;}},{key:"tsParseModifiers",value:function tsParseModifiers(_ref80,modified){var _this28=this;var allowedModifiers=_ref80.allowedModifiers,disallowedModifiers=_ref80.disallowedModifiers,stopOnStartOfClassStaticBlock=_ref80.stopOnStartOfClassStaticBlock,_ref80$errorTemplate=_ref80.errorTemplate,errorTemplate=_ref80$errorTemplate===void 0?TSErrors.InvalidModifierOnTypeMember:_ref80$errorTemplate;var enforceOrder=function enforceOrder(loc,modifier,before,after){if(modifier===before&&modified[after]){_this28.raise(TSErrors.InvalidModifiersOrder,loc,{orderedModifiers:[before,after]});}};var incompatible=function incompatible(loc,modifier,mod1,mod2){if(modified[mod1]&&modifier===mod2||modified[mod2]&&modifier===mod1){_this28.raise(TSErrors.IncompatibleModifiers,loc,{modifiers:[mod1,mod2]});}};for(;;){var startLoc=this.state.startLoc;var modifier=this.tsParseModifier(allowedModifiers.concat(disallowedModifiers!=null?disallowedModifiers:[]),stopOnStartOfClassStaticBlock);if(!modifier)break;if(tsIsAccessModifier(modifier)){if(modified.accessibility){this.raise(TSErrors.DuplicateAccessibilityModifier,startLoc,{modifier:modifier});}else {enforceOrder(startLoc,modifier,modifier,"override");enforceOrder(startLoc,modifier,modifier,"static");enforceOrder(startLoc,modifier,modifier,"readonly");modified.accessibility=modifier;}}else if(tsIsVarianceAnnotations(modifier)){if(modified[modifier]){this.raise(TSErrors.DuplicateModifier,startLoc,{modifier:modifier});}modified[modifier]=true;enforceOrder(startLoc,modifier,"in","out");}else {if(hasOwnProperty.call(modified,modifier)){this.raise(TSErrors.DuplicateModifier,startLoc,{modifier:modifier});}else {enforceOrder(startLoc,modifier,"static","readonly");enforceOrder(startLoc,modifier,"static","override");enforceOrder(startLoc,modifier,"override","readonly");enforceOrder(startLoc,modifier,"abstract","override");incompatible(startLoc,modifier,"declare","override");incompatible(startLoc,modifier,"static","abstract");}modified[modifier]=true;}if(disallowedModifiers!=null&&disallowedModifiers.includes(modifier)){this.raise(errorTemplate,startLoc,{modifier:modifier});}}}},{key:"tsIsListTerminator",value:function tsIsListTerminator(kind){switch(kind){case "EnumMembers":case "TypeMembers":return this.match(8);case "HeritageClauseElement":return this.match(5);case "TupleElementTypes":return this.match(3);case "TypeParametersOrArguments":return this.match(48);}}},{key:"tsParseList",value:function tsParseList(kind,parseElement){var result=[];while(!this.tsIsListTerminator(kind)){result.push(parseElement());}return result;}},{key:"tsParseDelimitedList",value:function tsParseDelimitedList(kind,parseElement,refTrailingCommaPos){return nonNull(this.tsParseDelimitedListWorker(kind,parseElement,true,refTrailingCommaPos));}},{key:"tsParseDelimitedListWorker",value:function tsParseDelimitedListWorker(kind,parseElement,expectSuccess,refTrailingCommaPos){var result=[];var trailingCommaPos=-1;for(;;){if(this.tsIsListTerminator(kind)){break;}trailingCommaPos=-1;var element=parseElement();if(element==null){return undefined;}result.push(element);if(this.eat(12)){trailingCommaPos=this.state.lastTokStartLoc.index;continue;}if(this.tsIsListTerminator(kind)){break;}if(expectSuccess){this.expect(12);}return undefined;}if(refTrailingCommaPos){refTrailingCommaPos.value=trailingCommaPos;}return result;}},{key:"tsParseBracketedList",value:function tsParseBracketedList(kind,parseElement,bracket,skipFirstToken,refTrailingCommaPos){if(!skipFirstToken){if(bracket){this.expect(0);}else {this.expect(47);}}var result=this.tsParseDelimitedList(kind,parseElement,refTrailingCommaPos);if(bracket){this.expect(3);}else {this.expect(48);}return result;}},{key:"tsParseImportType",value:function tsParseImportType(){var node=this.startNode();this.expect(83);this.expect(10);if(!this.match(134)){this.raise(TSErrors.UnsupportedImportTypeArgument,this.state.startLoc);{node.argument=_superPropGet(TypeScriptParserMixin,"parseExprAtom",this,3)([]);}}else {{node.argument=this.parseStringLiteral(this.state.value);}}if(this.eat(12)&&!this.match(11)){node.options=_superPropGet(TypeScriptParserMixin,"parseMaybeAssignAllowIn",this,3)([]);this.eat(12);}else {node.options=null;}this.expect(11);if(this.eat(16)){node.qualifier=this.tsParseEntityName(1|2);}if(this.match(47)){{node.typeParameters=this.tsParseTypeArguments();}}return this.finishNode(node,"TSImportType");}},{key:"tsParseEntityName",value:function tsParseEntityName(flags){var entity;if(flags&1&&this.match(78)){if(flags&2){entity=this.parseIdentifier(true);}else {var node=this.startNode();this.next();entity=this.finishNode(node,"ThisExpression");}}else {entity=this.parseIdentifier(!!(flags&1));}while(this.eat(16)){var _node8=this.startNodeAtNode(entity);_node8.left=entity;_node8.right=this.parseIdentifier(!!(flags&1));entity=this.finishNode(_node8,"TSQualifiedName");}return entity;}},{key:"tsParseTypeReference",value:function tsParseTypeReference(){var node=this.startNode();node.typeName=this.tsParseEntityName(1);if(!this.hasPrecedingLineBreak()&&this.match(47)){{node.typeParameters=this.tsParseTypeArguments();}}return this.finishNode(node,"TSTypeReference");}},{key:"tsParseThisTypePredicate",value:function tsParseThisTypePredicate(lhs){this.next();var node=this.startNodeAtNode(lhs);node.parameterName=lhs;node.typeAnnotation=this.tsParseTypeAnnotation(false);node.asserts=false;return this.finishNode(node,"TSTypePredicate");}},{key:"tsParseThisTypeNode",value:function tsParseThisTypeNode(){var node=this.startNode();this.next();return this.finishNode(node,"TSThisType");}},{key:"tsParseTypeQuery",value:function tsParseTypeQuery(){var node=this.startNode();this.expect(87);if(this.match(83)){node.exprName=this.tsParseImportType();}else {{node.exprName=this.tsParseEntityName(1|2);}}if(!this.hasPrecedingLineBreak()&&this.match(47)){{node.typeParameters=this.tsParseTypeArguments();}}return this.finishNode(node,"TSTypeQuery");}},{key:"tsParseTypeParameter",value:function tsParseTypeParameter(parseModifiers){var node=this.startNode();parseModifiers(node);node.name=this.tsParseTypeParameterName();node.constraint=this.tsEatThenParseType(81);node["default"]=this.tsEatThenParseType(29);return this.finishNode(node,"TSTypeParameter");}},{key:"tsTryParseTypeParameters",value:function tsTryParseTypeParameters(parseModifiers){if(this.match(47)){return this.tsParseTypeParameters(parseModifiers);}}},{key:"tsParseTypeParameters",value:function tsParseTypeParameters(parseModifiers){var node=this.startNode();if(this.match(47)||this.match(143)){this.next();}else {this.unexpected();}var refTrailingCommaPos={value:-1};node.params=this.tsParseBracketedList("TypeParametersOrArguments",this.tsParseTypeParameter.bind(this,parseModifiers),false,true,refTrailingCommaPos);if(node.params.length===0){this.raise(TSErrors.EmptyTypeParameters,node);}if(refTrailingCommaPos.value!==-1){this.addExtra(node,"trailingComma",refTrailingCommaPos.value);}return this.finishNode(node,"TSTypeParameterDeclaration");}},{key:"tsFillSignature",value:function tsFillSignature(returnToken,signature){var returnTokenRequired=returnToken===19;var paramsKey="parameters";var returnTypeKey="typeAnnotation";signature.typeParameters=this.tsTryParseTypeParameters(this.tsParseConstModifier);this.expect(10);signature[paramsKey]=this.tsParseBindingListForSignature();if(returnTokenRequired){signature[returnTypeKey]=this.tsParseTypeOrTypePredicateAnnotation(returnToken);}else if(this.match(returnToken)){signature[returnTypeKey]=this.tsParseTypeOrTypePredicateAnnotation(returnToken);}}},{key:"tsParseBindingListForSignature",value:function tsParseBindingListForSignature(){var list=_superPropGet(TypeScriptParserMixin,"parseBindingList",this,3)([11,41,2]);var _iterator8=_createForOfIteratorHelper(list),_step8;try{for(_iterator8.s();!(_step8=_iterator8.n()).done;){var pattern=_step8.value;var type=pattern.type;if(type==="AssignmentPattern"||type==="TSParameterProperty"){this.raise(TSErrors.UnsupportedSignatureParameterKind,pattern,{type:type});}}}catch(err){_iterator8.e(err);}finally{_iterator8.f();}return list;}},{key:"tsParseTypeMemberSemicolon",value:function tsParseTypeMemberSemicolon(){if(!this.eat(12)&&!this.isLineTerminator()){this.expect(13);}}},{key:"tsParseSignatureMember",value:function tsParseSignatureMember(kind,node){this.tsFillSignature(14,node);this.tsParseTypeMemberSemicolon();return this.finishNode(node,kind);}},{key:"tsIsUnambiguouslyIndexSignature",value:function tsIsUnambiguouslyIndexSignature(){this.next();if(tokenIsIdentifier(this.state.type)){this.next();return this.match(14);}return false;}},{key:"tsTryParseIndexSignature",value:function tsTryParseIndexSignature(node){if(!(this.match(0)&&this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))){return;}this.expect(0);var id=this.parseIdentifier();id.typeAnnotation=this.tsParseTypeAnnotation();this.resetEndLocation(id);this.expect(3);node.parameters=[id];var type=this.tsTryParseTypeAnnotation();if(type)node.typeAnnotation=type;this.tsParseTypeMemberSemicolon();return this.finishNode(node,"TSIndexSignature");}},{key:"tsParsePropertyOrMethodSignature",value:function tsParsePropertyOrMethodSignature(node,readonly){if(this.eat(17))node.optional=true;var nodeAny=node;if(this.match(10)||this.match(47)){if(readonly){this.raise(TSErrors.ReadonlyForMethodSignature,node);}var method=nodeAny;if(method.kind&&this.match(47)){this.raise(TSErrors.AccessorCannotHaveTypeParameters,this.state.curPosition());}this.tsFillSignature(14,method);this.tsParseTypeMemberSemicolon();var paramsKey="parameters";var returnTypeKey="typeAnnotation";if(method.kind==="get"){if(method[paramsKey].length>0){this.raise(Errors.BadGetterArity,this.state.curPosition());if(this.isThisParam(method[paramsKey][0])){this.raise(TSErrors.AccessorCannotDeclareThisParameter,this.state.curPosition());}}}else if(method.kind==="set"){if(method[paramsKey].length!==1){this.raise(Errors.BadSetterArity,this.state.curPosition());}else {var firstParameter=method[paramsKey][0];if(this.isThisParam(firstParameter)){this.raise(TSErrors.AccessorCannotDeclareThisParameter,this.state.curPosition());}if(firstParameter.type==="Identifier"&&firstParameter.optional){this.raise(TSErrors.SetAccessorCannotHaveOptionalParameter,this.state.curPosition());}if(firstParameter.type==="RestElement"){this.raise(TSErrors.SetAccessorCannotHaveRestParameter,this.state.curPosition());}}if(method[returnTypeKey]){this.raise(TSErrors.SetAccessorCannotHaveReturnType,method[returnTypeKey]);}}else {method.kind="method";}return this.finishNode(method,"TSMethodSignature");}else {var property=nodeAny;if(readonly)property.readonly=true;var type=this.tsTryParseTypeAnnotation();if(type)property.typeAnnotation=type;this.tsParseTypeMemberSemicolon();return this.finishNode(property,"TSPropertySignature");}}},{key:"tsParseTypeMember",value:function tsParseTypeMember(){var node=this.startNode();if(this.match(10)||this.match(47)){return this.tsParseSignatureMember("TSCallSignatureDeclaration",node);}if(this.match(77)){var id=this.startNode();this.next();if(this.match(10)||this.match(47)){return this.tsParseSignatureMember("TSConstructSignatureDeclaration",node);}else {node.key=this.createIdentifier(id,"new");return this.tsParsePropertyOrMethodSignature(node,false);}}this.tsParseModifiers({allowedModifiers:["readonly"],disallowedModifiers:["declare","abstract","private","protected","public","static","override"]},node);var idx=this.tsTryParseIndexSignature(node);if(idx){return idx;}_superPropGet(TypeScriptParserMixin,"parsePropertyName",this,3)([node]);if(!node.computed&&node.key.type==="Identifier"&&(node.key.name==="get"||node.key.name==="set")&&this.tsTokenCanFollowModifier()){node.kind=node.key.name;_superPropGet(TypeScriptParserMixin,"parsePropertyName",this,3)([node]);}return this.tsParsePropertyOrMethodSignature(node,!!node.readonly);}},{key:"tsParseTypeLiteral",value:function tsParseTypeLiteral(){var node=this.startNode();node.members=this.tsParseObjectTypeMembers();return this.finishNode(node,"TSTypeLiteral");}},{key:"tsParseObjectTypeMembers",value:function tsParseObjectTypeMembers(){this.expect(5);var members=this.tsParseList("TypeMembers",this.tsParseTypeMember.bind(this));this.expect(8);return members;}},{key:"tsIsStartOfMappedType",value:function tsIsStartOfMappedType(){this.next();if(this.eat(53)){return this.isContextual(122);}if(this.isContextual(122)){this.next();}if(!this.match(0)){return false;}this.next();if(!this.tsIsIdentifier()){return false;}this.next();return this.match(58);}},{key:"tsParseMappedType",value:function tsParseMappedType(){var node=this.startNode();this.expect(5);if(this.match(53)){node.readonly=this.state.value;this.next();this.expectContextual(122);}else if(this.eatContextual(122)){node.readonly=true;}this.expect(0);{var typeParameter=this.startNode();typeParameter.name=this.tsParseTypeParameterName();typeParameter.constraint=this.tsExpectThenParseType(58);node.typeParameter=this.finishNode(typeParameter,"TSTypeParameter");}node.nameType=this.eatContextual(93)?this.tsParseType():null;this.expect(3);if(this.match(53)){node.optional=this.state.value;this.next();this.expect(17);}else if(this.eat(17)){node.optional=true;}node.typeAnnotation=this.tsTryParseType();this.semicolon();this.expect(8);return this.finishNode(node,"TSMappedType");}},{key:"tsParseTupleType",value:function tsParseTupleType(){var _this29=this;var node=this.startNode();node.elementTypes=this.tsParseBracketedList("TupleElementTypes",this.tsParseTupleElementType.bind(this),true,false);var seenOptionalElement=false;node.elementTypes.forEach(function(elementNode){var type=elementNode.type;if(seenOptionalElement&&type!=="TSRestType"&&type!=="TSOptionalType"&&!(type==="TSNamedTupleMember"&&elementNode.optional)){_this29.raise(TSErrors.OptionalTypeBeforeRequired,elementNode);}seenOptionalElement||(seenOptionalElement=type==="TSNamedTupleMember"&&elementNode.optional||type==="TSOptionalType");});return this.finishNode(node,"TSTupleType");}},{key:"tsParseTupleElementType",value:function tsParseTupleElementType(){var restStartLoc=this.state.startLoc;var rest=this.eat(21);var startLoc=this.state.startLoc;var labeled;var label;var optional;var type;var isWord=tokenIsKeywordOrIdentifier(this.state.type);var chAfterWord=isWord?this.lookaheadCharCode():null;if(chAfterWord===58){labeled=true;optional=false;label=this.parseIdentifier(true);this.expect(14);type=this.tsParseType();}else if(chAfterWord===63){optional=true;var wordName=this.state.value;var typeOrLabel=this.tsParseNonArrayType();if(this.lookaheadCharCode()===58){labeled=true;label=this.createIdentifier(this.startNodeAt(startLoc),wordName);this.expect(17);this.expect(14);type=this.tsParseType();}else {labeled=false;type=typeOrLabel;this.expect(17);}}else {type=this.tsParseType();optional=this.eat(17);labeled=this.eat(14);}if(labeled){var labeledNode;if(label){labeledNode=this.startNodeAt(startLoc);labeledNode.optional=optional;labeledNode.label=label;labeledNode.elementType=type;if(this.eat(17)){labeledNode.optional=true;this.raise(TSErrors.TupleOptionalAfterType,this.state.lastTokStartLoc);}}else {labeledNode=this.startNodeAt(startLoc);labeledNode.optional=optional;this.raise(TSErrors.InvalidTupleMemberLabel,type);labeledNode.label=type;labeledNode.elementType=this.tsParseType();}type=this.finishNode(labeledNode,"TSNamedTupleMember");}else if(optional){var optionalTypeNode=this.startNodeAt(startLoc);optionalTypeNode.typeAnnotation=type;type=this.finishNode(optionalTypeNode,"TSOptionalType");}if(rest){var restNode=this.startNodeAt(restStartLoc);restNode.typeAnnotation=type;type=this.finishNode(restNode,"TSRestType");}return type;}},{key:"tsParseParenthesizedType",value:function tsParseParenthesizedType(){var node=this.startNode();this.expect(10);node.typeAnnotation=this.tsParseType();this.expect(11);return this.finishNode(node,"TSParenthesizedType");}},{key:"tsParseFunctionOrConstructorType",value:function tsParseFunctionOrConstructorType(type,_abstract){var _this30=this;var node=this.startNode();if(type==="TSConstructorType"){node["abstract"]=!!_abstract;if(_abstract)this.next();this.next();}this.tsInAllowConditionalTypesContext(function(){return _this30.tsFillSignature(19,node);});return this.finishNode(node,type);}},{key:"tsParseLiteralTypeNode",value:function tsParseLiteralTypeNode(){var node=this.startNode();switch(this.state.type){case 135:case 136:case 134:case 85:case 86:node.literal=_superPropGet(TypeScriptParserMixin,"parseExprAtom",this,3)([]);break;default:this.unexpected();}return this.finishNode(node,"TSLiteralType");}},{key:"tsParseTemplateLiteralType",value:function tsParseTemplateLiteralType(){{var node=this.startNode();node.literal=_superPropGet(TypeScriptParserMixin,"parseTemplate",this,3)([false]);return this.finishNode(node,"TSLiteralType");}}},{key:"parseTemplateSubstitution",value:function parseTemplateSubstitution(){if(this.state.inType)return this.tsParseType();return _superPropGet(TypeScriptParserMixin,"parseTemplateSubstitution",this,3)([]);}},{key:"tsParseThisTypeOrThisTypePredicate",value:function tsParseThisTypeOrThisTypePredicate(){var thisKeyword=this.tsParseThisTypeNode();if(this.isContextual(116)&&!this.hasPrecedingLineBreak()){return this.tsParseThisTypePredicate(thisKeyword);}else {return thisKeyword;}}},{key:"tsParseNonArrayType",value:function tsParseNonArrayType(){switch(this.state.type){case 134:case 135:case 136:case 85:case 86:return this.tsParseLiteralTypeNode();case 53:if(this.state.value==="-"){var node=this.startNode();var nextToken=this.lookahead();if(nextToken.type!==135&&nextToken.type!==136){this.unexpected();}node.literal=this.parseMaybeUnary();return this.finishNode(node,"TSLiteralType");}break;case 78:return this.tsParseThisTypeOrThisTypePredicate();case 87:return this.tsParseTypeQuery();case 83:return this.tsParseImportType();case 5:return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this))?this.tsParseMappedType():this.tsParseTypeLiteral();case 0:return this.tsParseTupleType();case 10:return this.tsParseParenthesizedType();case 25:case 24:return this.tsParseTemplateLiteralType();default:{var type=this.state.type;if(tokenIsIdentifier(type)||type===88||type===84){var nodeType=type===88?"TSVoidKeyword":type===84?"TSNullKeyword":keywordTypeFromName(this.state.value);if(nodeType!==undefined&&this.lookaheadCharCode()!==46){var _node9=this.startNode();this.next();return this.finishNode(_node9,nodeType);}return this.tsParseTypeReference();}}}this.unexpected();}},{key:"tsParseArrayTypeOrHigher",value:function tsParseArrayTypeOrHigher(){var startLoc=this.state.startLoc;var type=this.tsParseNonArrayType();while(!this.hasPrecedingLineBreak()&&this.eat(0)){if(this.match(3)){var node=this.startNodeAt(startLoc);node.elementType=type;this.expect(3);type=this.finishNode(node,"TSArrayType");}else {var _node10=this.startNodeAt(startLoc);_node10.objectType=type;_node10.indexType=this.tsParseType();this.expect(3);type=this.finishNode(_node10,"TSIndexedAccessType");}}return type;}},{key:"tsParseTypeOperator",value:function tsParseTypeOperator(){var node=this.startNode();var operator=this.state.value;this.next();node.operator=operator;node.typeAnnotation=this.tsParseTypeOperatorOrHigher();if(operator==="readonly"){this.tsCheckTypeAnnotationForReadOnly(node);}return this.finishNode(node,"TSTypeOperator");}},{key:"tsCheckTypeAnnotationForReadOnly",value:function tsCheckTypeAnnotationForReadOnly(node){switch(node.typeAnnotation.type){case "TSTupleType":case "TSArrayType":return;default:this.raise(TSErrors.UnexpectedReadonly,node);}}},{key:"tsParseInferType",value:function tsParseInferType(){var _this31=this;var node=this.startNode();this.expectContextual(115);var typeParameter=this.startNode();typeParameter.name=this.tsParseTypeParameterName();typeParameter.constraint=this.tsTryParse(function(){return _this31.tsParseConstraintForInferType();});node.typeParameter=this.finishNode(typeParameter,"TSTypeParameter");return this.finishNode(node,"TSInferType");}},{key:"tsParseConstraintForInferType",value:function tsParseConstraintForInferType(){var _this32=this;if(this.eat(81)){var constraint=this.tsInDisallowConditionalTypesContext(function(){return _this32.tsParseType();});if(this.state.inDisallowConditionalTypesContext||!this.match(17)){return constraint;}}}},{key:"tsParseTypeOperatorOrHigher",value:function tsParseTypeOperatorOrHigher(){var _this33=this;var isTypeOperator=tokenIsTSTypeOperator(this.state.type)&&!this.state.containsEsc;return isTypeOperator?this.tsParseTypeOperator():this.isContextual(115)?this.tsParseInferType():this.tsInAllowConditionalTypesContext(function(){return _this33.tsParseArrayTypeOrHigher();});}},{key:"tsParseUnionOrIntersectionType",value:function tsParseUnionOrIntersectionType(kind,parseConstituentType,operator){var node=this.startNode();var hasLeadingOperator=this.eat(operator);var types=[];do{types.push(parseConstituentType());}while(this.eat(operator));if(types.length===1&&!hasLeadingOperator){return types[0];}node.types=types;return this.finishNode(node,kind);}},{key:"tsParseIntersectionTypeOrHigher",value:function tsParseIntersectionTypeOrHigher(){return this.tsParseUnionOrIntersectionType("TSIntersectionType",this.tsParseTypeOperatorOrHigher.bind(this),45);}},{key:"tsParseUnionTypeOrHigher",value:function tsParseUnionTypeOrHigher(){return this.tsParseUnionOrIntersectionType("TSUnionType",this.tsParseIntersectionTypeOrHigher.bind(this),43);}},{key:"tsIsStartOfFunctionType",value:function tsIsStartOfFunctionType(){if(this.match(47)){return true;}return this.match(10)&&this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));}},{key:"tsSkipParameterStart",value:function tsSkipParameterStart(){if(tokenIsIdentifier(this.state.type)||this.match(78)){this.next();return true;}if(this.match(5)){var errors=this.state.errors;var previousErrorCount=errors.length;try{this.parseObjectLike(8,true);return errors.length===previousErrorCount;}catch(_unused){return false;}}if(this.match(0)){this.next();var _errors=this.state.errors;var _previousErrorCount=_errors.length;try{_superPropGet(TypeScriptParserMixin,"parseBindingList",this,3)([3,93,1]);return _errors.length===_previousErrorCount;}catch(_unused2){return false;}}return false;}},{key:"tsIsUnambiguouslyStartOfFunctionType",value:function tsIsUnambiguouslyStartOfFunctionType(){this.next();if(this.match(11)||this.match(21)){return true;}if(this.tsSkipParameterStart()){if(this.match(14)||this.match(12)||this.match(17)||this.match(29)){return true;}if(this.match(11)){this.next();if(this.match(19)){return true;}}}return false;}},{key:"tsParseTypeOrTypePredicateAnnotation",value:function tsParseTypeOrTypePredicateAnnotation(returnToken){var _this34=this;return this.tsInType(function(){var t=_this34.startNode();_this34.expect(returnToken);var node=_this34.startNode();var asserts=!!_this34.tsTryParse(_this34.tsParseTypePredicateAsserts.bind(_this34));if(asserts&&_this34.match(78)){var thisTypePredicate=_this34.tsParseThisTypeOrThisTypePredicate();if(thisTypePredicate.type==="TSThisType"){node.parameterName=thisTypePredicate;node.asserts=true;node.typeAnnotation=null;thisTypePredicate=_this34.finishNode(node,"TSTypePredicate");}else {_this34.resetStartLocationFromNode(thisTypePredicate,node);thisTypePredicate.asserts=true;}t.typeAnnotation=thisTypePredicate;return _this34.finishNode(t,"TSTypeAnnotation");}var typePredicateVariable=_this34.tsIsIdentifier()&&_this34.tsTryParse(_this34.tsParseTypePredicatePrefix.bind(_this34));if(!typePredicateVariable){if(!asserts){return _this34.tsParseTypeAnnotation(false,t);}node.parameterName=_this34.parseIdentifier();node.asserts=asserts;node.typeAnnotation=null;t.typeAnnotation=_this34.finishNode(node,"TSTypePredicate");return _this34.finishNode(t,"TSTypeAnnotation");}var type=_this34.tsParseTypeAnnotation(false);node.parameterName=typePredicateVariable;node.typeAnnotation=type;node.asserts=asserts;t.typeAnnotation=_this34.finishNode(node,"TSTypePredicate");return _this34.finishNode(t,"TSTypeAnnotation");});}},{key:"tsTryParseTypeOrTypePredicateAnnotation",value:function tsTryParseTypeOrTypePredicateAnnotation(){if(this.match(14)){return this.tsParseTypeOrTypePredicateAnnotation(14);}}},{key:"tsTryParseTypeAnnotation",value:function tsTryParseTypeAnnotation(){if(this.match(14)){return this.tsParseTypeAnnotation();}}},{key:"tsTryParseType",value:function tsTryParseType(){return this.tsEatThenParseType(14);}},{key:"tsParseTypePredicatePrefix",value:function tsParseTypePredicatePrefix(){var id=this.parseIdentifier();if(this.isContextual(116)&&!this.hasPrecedingLineBreak()){this.next();return id;}}},{key:"tsParseTypePredicateAsserts",value:function tsParseTypePredicateAsserts(){if(this.state.type!==109){return false;}var containsEsc=this.state.containsEsc;this.next();if(!tokenIsIdentifier(this.state.type)&&!this.match(78)){return false;}if(containsEsc){this.raise(Errors.InvalidEscapedReservedWord,this.state.lastTokStartLoc,{reservedWord:"asserts"});}return true;}},{key:"tsParseTypeAnnotation",value:function tsParseTypeAnnotation(){var _this35=this;var eatColon=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;var t=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.startNode();this.tsInType(function(){if(eatColon)_this35.expect(14);t.typeAnnotation=_this35.tsParseType();});return this.finishNode(t,"TSTypeAnnotation");}},{key:"tsParseType",value:function tsParseType(){var _this36=this;assert(this.state.inType);var type=this.tsParseNonConditionalType();if(this.state.inDisallowConditionalTypesContext||this.hasPrecedingLineBreak()||!this.eat(81)){return type;}var node=this.startNodeAtNode(type);node.checkType=type;node.extendsType=this.tsInDisallowConditionalTypesContext(function(){return _this36.tsParseNonConditionalType();});this.expect(17);node.trueType=this.tsInAllowConditionalTypesContext(function(){return _this36.tsParseType();});this.expect(14);node.falseType=this.tsInAllowConditionalTypesContext(function(){return _this36.tsParseType();});return this.finishNode(node,"TSConditionalType");}},{key:"isAbstractConstructorSignature",value:function isAbstractConstructorSignature(){return this.isContextual(124)&&this.lookahead().type===77;}},{key:"tsParseNonConditionalType",value:function tsParseNonConditionalType(){if(this.tsIsStartOfFunctionType()){return this.tsParseFunctionOrConstructorType("TSFunctionType");}if(this.match(77)){return this.tsParseFunctionOrConstructorType("TSConstructorType");}else if(this.isAbstractConstructorSignature()){return this.tsParseFunctionOrConstructorType("TSConstructorType",true);}return this.tsParseUnionTypeOrHigher();}},{key:"tsParseTypeAssertion",value:function tsParseTypeAssertion(){var _this37=this;if(this.getPluginOption("typescript","disallowAmbiguousJSXLike")){this.raise(TSErrors.ReservedTypeAssertion,this.state.startLoc);}var node=this.startNode();node.typeAnnotation=this.tsInType(function(){_this37.next();return _this37.match(75)?_this37.tsParseTypeReference():_this37.tsParseType();});this.expect(48);node.expression=this.parseMaybeUnary();return this.finishNode(node,"TSTypeAssertion");}},{key:"tsParseHeritageClause",value:function tsParseHeritageClause(token){var _this38=this;var originalStartLoc=this.state.startLoc;var delimitedList=this.tsParseDelimitedList("HeritageClauseElement",function(){var node=_this38.startNode();{node.expression=_this38.tsParseEntityName(1|2);if(_this38.match(47)){node.typeParameters=_this38.tsParseTypeArguments();}return _this38.finishNode(node,"TSExpressionWithTypeArguments");}});if(!delimitedList.length){this.raise(TSErrors.EmptyHeritageClauseType,originalStartLoc,{token:token});}return delimitedList;}},{key:"tsParseInterfaceDeclaration",value:function tsParseInterfaceDeclaration(node){var properties=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(this.hasFollowingLineBreak())return null;this.expectContextual(129);if(properties.declare)node.declare=true;if(tokenIsIdentifier(this.state.type)){node.id=this.parseIdentifier();this.checkIdentifier(node.id,130);}else {node.id=null;this.raise(TSErrors.MissingInterfaceName,this.state.startLoc);}node.typeParameters=this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);if(this.eat(81)){node["extends"]=this.tsParseHeritageClause("extends");}var body=this.startNode();body.body=this.tsInType(this.tsParseObjectTypeMembers.bind(this));node.body=this.finishNode(body,"TSInterfaceBody");return this.finishNode(node,"TSInterfaceDeclaration");}},{key:"tsParseTypeAliasDeclaration",value:function tsParseTypeAliasDeclaration(node){var _this39=this;node.id=this.parseIdentifier();this.checkIdentifier(node.id,2);node.typeAnnotation=this.tsInType(function(){node.typeParameters=_this39.tsTryParseTypeParameters(_this39.tsParseInOutModifiers);_this39.expect(29);if(_this39.isContextual(114)&&_this39.lookahead().type!==16){var _node11=_this39.startNode();_this39.next();return _this39.finishNode(_node11,"TSIntrinsicKeyword");}return _this39.tsParseType();});this.semicolon();return this.finishNode(node,"TSTypeAliasDeclaration");}},{key:"tsInTopLevelContext",value:function tsInTopLevelContext(cb){if(this.curContext()!==types.brace){var oldContext=this.state.context;this.state.context=[oldContext[0]];try{return cb();}finally{this.state.context=oldContext;}}else {return cb();}}},{key:"tsInType",value:function tsInType(cb){var oldInType=this.state.inType;this.state.inType=true;try{return cb();}finally{this.state.inType=oldInType;}}},{key:"tsInDisallowConditionalTypesContext",value:function tsInDisallowConditionalTypesContext(cb){var oldInDisallowConditionalTypesContext=this.state.inDisallowConditionalTypesContext;this.state.inDisallowConditionalTypesContext=true;try{return cb();}finally{this.state.inDisallowConditionalTypesContext=oldInDisallowConditionalTypesContext;}}},{key:"tsInAllowConditionalTypesContext",value:function tsInAllowConditionalTypesContext(cb){var oldInDisallowConditionalTypesContext=this.state.inDisallowConditionalTypesContext;this.state.inDisallowConditionalTypesContext=false;try{return cb();}finally{this.state.inDisallowConditionalTypesContext=oldInDisallowConditionalTypesContext;}}},{key:"tsEatThenParseType",value:function tsEatThenParseType(token){if(this.match(token)){return this.tsNextThenParseType();}}},{key:"tsExpectThenParseType",value:function tsExpectThenParseType(token){var _this40=this;return this.tsInType(function(){_this40.expect(token);return _this40.tsParseType();});}},{key:"tsNextThenParseType",value:function tsNextThenParseType(){var _this41=this;return this.tsInType(function(){_this41.next();return _this41.tsParseType();});}},{key:"tsParseEnumMember",value:function tsParseEnumMember(){var node=this.startNode();node.id=this.match(134)?_superPropGet(TypeScriptParserMixin,"parseStringLiteral",this,3)([this.state.value]):this.parseIdentifier(true);if(this.eat(29)){node.initializer=_superPropGet(TypeScriptParserMixin,"parseMaybeAssignAllowIn",this,3)([]);}return this.finishNode(node,"TSEnumMember");}},{key:"tsParseEnumDeclaration",value:function tsParseEnumDeclaration(node){var properties=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(properties["const"])node["const"]=true;if(properties.declare)node.declare=true;this.expectContextual(126);node.id=this.parseIdentifier();this.checkIdentifier(node.id,node["const"]?8971:8459);{this.expect(5);node.members=this.tsParseDelimitedList("EnumMembers",this.tsParseEnumMember.bind(this));this.expect(8);}return this.finishNode(node,"TSEnumDeclaration");}},{key:"tsParseEnumBody",value:function tsParseEnumBody(){var node=this.startNode();this.expect(5);node.members=this.tsParseDelimitedList("EnumMembers",this.tsParseEnumMember.bind(this));this.expect(8);return this.finishNode(node,"TSEnumBody");}},{key:"tsParseModuleBlock",value:function tsParseModuleBlock(){var node=this.startNode();this.scope.enter(0);this.expect(5);_superPropGet(TypeScriptParserMixin,"parseBlockOrModuleBlockBody",this,3)([node.body=[],undefined,true,8]);this.scope.exit();return this.finishNode(node,"TSModuleBlock");}},{key:"tsParseModuleOrNamespaceDeclaration",value:function tsParseModuleOrNamespaceDeclaration(node){var nested=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;node.id=this.parseIdentifier();if(!nested){this.checkIdentifier(node.id,1024);}if(this.eat(16)){var inner=this.startNode();this.tsParseModuleOrNamespaceDeclaration(inner,true);node.body=inner;}else {this.scope.enter(256);this.prodParam.enter(0);node.body=this.tsParseModuleBlock();this.prodParam.exit();this.scope.exit();}return this.finishNode(node,"TSModuleDeclaration");}},{key:"tsParseAmbientExternalModuleDeclaration",value:function tsParseAmbientExternalModuleDeclaration(node){if(this.isContextual(112)){node.kind="global";{node.global=true;}node.id=this.parseIdentifier();}else if(this.match(134)){node.kind="module";node.id=_superPropGet(TypeScriptParserMixin,"parseStringLiteral",this,3)([this.state.value]);}else {this.unexpected();}if(this.match(5)){this.scope.enter(256);this.prodParam.enter(0);node.body=this.tsParseModuleBlock();this.prodParam.exit();this.scope.exit();}else {this.semicolon();}return this.finishNode(node,"TSModuleDeclaration");}},{key:"tsParseImportEqualsDeclaration",value:function tsParseImportEqualsDeclaration(node,maybeDefaultIdentifier,isExport){{node.isExport=isExport||false;}node.id=maybeDefaultIdentifier||this.parseIdentifier();this.checkIdentifier(node.id,4096);this.expect(29);var moduleReference=this.tsParseModuleReference();if(node.importKind==="type"&&moduleReference.type!=="TSExternalModuleReference"){this.raise(TSErrors.ImportAliasHasImportType,moduleReference);}node.moduleReference=moduleReference;this.semicolon();return this.finishNode(node,"TSImportEqualsDeclaration");}},{key:"tsIsExternalModuleReference",value:function tsIsExternalModuleReference(){return this.isContextual(119)&&this.lookaheadCharCode()===40;}},{key:"tsParseModuleReference",value:function tsParseModuleReference(){return this.tsIsExternalModuleReference()?this.tsParseExternalModuleReference():this.tsParseEntityName(0);}},{key:"tsParseExternalModuleReference",value:function tsParseExternalModuleReference(){var node=this.startNode();this.expectContextual(119);this.expect(10);if(!this.match(134)){this.unexpected();}node.expression=_superPropGet(TypeScriptParserMixin,"parseExprAtom",this,3)([]);this.expect(11);this.sawUnambiguousESM=true;return this.finishNode(node,"TSExternalModuleReference");}},{key:"tsLookAhead",value:function tsLookAhead(f){var state=this.state.clone();var res=f();this.state=state;return res;}},{key:"tsTryParseAndCatch",value:function tsTryParseAndCatch(f){var result=this.tryParse(function(abort){return f()||abort();});if(result.aborted||!result.node)return;if(result.error)this.state=result.failState;return result.node;}},{key:"tsTryParse",value:function tsTryParse(f){var state=this.state.clone();var result=f();if(result!==undefined&&result!==false){return result;}this.state=state;}},{key:"tsTryParseDeclare",value:function tsTryParseDeclare(nany){var _this42=this;if(this.isLineTerminator()){return;}var startType=this.state.type;var kind;if(this.isContextual(100)){startType=74;kind="let";}return this.tsInAmbientContext(function(){switch(startType){case 68:nany.declare=true;return _superPropGet(TypeScriptParserMixin,"parseFunctionStatement",_this42,3)([nany,false,false]);case 80:nany.declare=true;return _this42.parseClass(nany,true,false);case 126:return _this42.tsParseEnumDeclaration(nany,{declare:true});case 112:return _this42.tsParseAmbientExternalModuleDeclaration(nany);case 75:case 74:if(!_this42.match(75)||!_this42.isLookaheadContextual("enum")){nany.declare=true;return _this42.parseVarStatement(nany,kind||_this42.state.value,true);}_this42.expect(75);return _this42.tsParseEnumDeclaration(nany,{"const":true,declare:true});case 129:{var result=_this42.tsParseInterfaceDeclaration(nany,{declare:true});if(result)return result;}default:if(tokenIsIdentifier(startType)){return _this42.tsParseDeclaration(nany,_this42.state.value,true,null);}}});}},{key:"tsTryParseExportDeclaration",value:function tsTryParseExportDeclaration(){return this.tsParseDeclaration(this.startNode(),this.state.value,true,null);}},{key:"tsParseExpressionStatement",value:function tsParseExpressionStatement(node,expr,decorators){switch(expr.name){case "declare":{var declaration=this.tsTryParseDeclare(node);if(declaration){declaration.declare=true;}return declaration;}case "global":if(this.match(5)){this.scope.enter(256);this.prodParam.enter(0);var mod=node;mod.kind="global";{node.global=true;}mod.id=expr;mod.body=this.tsParseModuleBlock();this.scope.exit();this.prodParam.exit();return this.finishNode(mod,"TSModuleDeclaration");}break;default:return this.tsParseDeclaration(node,expr.name,false,decorators);}}},{key:"tsParseDeclaration",value:function tsParseDeclaration(node,value,next,decorators){switch(value){case "abstract":if(this.tsCheckLineTerminator(next)&&(this.match(80)||tokenIsIdentifier(this.state.type))){return this.tsParseAbstractDeclaration(node,decorators);}break;case "module":if(this.tsCheckLineTerminator(next)){if(this.match(134)){return this.tsParseAmbientExternalModuleDeclaration(node);}else if(tokenIsIdentifier(this.state.type)){node.kind="module";return this.tsParseModuleOrNamespaceDeclaration(node);}}break;case "namespace":if(this.tsCheckLineTerminator(next)&&tokenIsIdentifier(this.state.type)){node.kind="namespace";return this.tsParseModuleOrNamespaceDeclaration(node);}break;case "type":if(this.tsCheckLineTerminator(next)&&tokenIsIdentifier(this.state.type)){return this.tsParseTypeAliasDeclaration(node);}break;}}},{key:"tsCheckLineTerminator",value:function tsCheckLineTerminator(next){if(next){if(this.hasFollowingLineBreak())return false;this.next();return true;}return !this.isLineTerminator();}},{key:"tsTryParseGenericAsyncArrowFunction",value:function tsTryParseGenericAsyncArrowFunction(startLoc){var _this43=this;if(!this.match(47))return;var oldMaybeInArrowParameters=this.state.maybeInArrowParameters;this.state.maybeInArrowParameters=true;var res=this.tsTryParseAndCatch(function(){var node=_this43.startNodeAt(startLoc);node.typeParameters=_this43.tsParseTypeParameters(_this43.tsParseConstModifier);_superPropGet(TypeScriptParserMixin,"parseFunctionParams",_this43,3)([node]);node.returnType=_this43.tsTryParseTypeOrTypePredicateAnnotation();_this43.expect(19);return node;});this.state.maybeInArrowParameters=oldMaybeInArrowParameters;if(!res)return;return _superPropGet(TypeScriptParserMixin,"parseArrowExpression",this,3)([res,null,true]);}},{key:"tsParseTypeArgumentsInExpression",value:function tsParseTypeArgumentsInExpression(){if(this.reScan_lt()!==47)return;return this.tsParseTypeArguments();}},{key:"tsParseTypeArguments",value:function tsParseTypeArguments(){var _this44=this;var node=this.startNode();node.params=this.tsInType(function(){return _this44.tsInTopLevelContext(function(){_this44.expect(47);return _this44.tsParseDelimitedList("TypeParametersOrArguments",_this44.tsParseType.bind(_this44));});});if(node.params.length===0){this.raise(TSErrors.EmptyTypeArguments,node);}else if(!this.state.inType&&this.curContext()===types.brace){this.reScan_lt_gt();}this.expect(48);return this.finishNode(node,"TSTypeParameterInstantiation");}},{key:"tsIsDeclarationStart",value:function tsIsDeclarationStart(){return tokenIsTSDeclarationStart(this.state.type);}},{key:"isExportDefaultSpecifier",value:function isExportDefaultSpecifier(){if(this.tsIsDeclarationStart())return false;return _superPropGet(TypeScriptParserMixin,"isExportDefaultSpecifier",this,3)([]);}},{key:"parseAssignableListItem",value:function parseAssignableListItem(flags,decorators){var startLoc=this.state.startLoc;var modified={};this.tsParseModifiers({allowedModifiers:["public","private","protected","override","readonly"]},modified);var accessibility=modified.accessibility;var override=modified.override;var readonly=modified.readonly;if(!(flags&4)&&(accessibility||readonly||override)){this.raise(TSErrors.UnexpectedParameterModifier,startLoc);}var left=this.parseMaybeDefault();if(flags&2){this.parseFunctionParamType(left);}var elt=this.parseMaybeDefault(left.loc.start,left);if(accessibility||readonly||override){var pp=this.startNodeAt(startLoc);if(decorators.length){pp.decorators=decorators;}if(accessibility)pp.accessibility=accessibility;if(readonly)pp.readonly=readonly;if(override)pp.override=override;if(elt.type!=="Identifier"&&elt.type!=="AssignmentPattern"){this.raise(TSErrors.UnsupportedParameterPropertyKind,pp);}pp.parameter=elt;return this.finishNode(pp,"TSParameterProperty");}if(decorators.length){left.decorators=decorators;}return elt;}},{key:"isSimpleParameter",value:function isSimpleParameter(node){return node.type==="TSParameterProperty"&&_superPropGet(TypeScriptParserMixin,"isSimpleParameter",this,3)([node.parameter])||_superPropGet(TypeScriptParserMixin,"isSimpleParameter",this,3)([node]);}},{key:"tsDisallowOptionalPattern",value:function tsDisallowOptionalPattern(node){var _iterator9=_createForOfIteratorHelper(node.params),_step9;try{for(_iterator9.s();!(_step9=_iterator9.n()).done;){var param=_step9.value;if(param.type!=="Identifier"&&param.optional&&!this.state.isAmbientContext){this.raise(TSErrors.PatternIsOptional,param);}}}catch(err){_iterator9.e(err);}finally{_iterator9.f();}}},{key:"setArrowFunctionParameters",value:function setArrowFunctionParameters(node,params,trailingCommaLoc){_superPropGet(TypeScriptParserMixin,"setArrowFunctionParameters",this,3)([node,params,trailingCommaLoc]);this.tsDisallowOptionalPattern(node);}},{key:"parseFunctionBodyAndFinish",value:function parseFunctionBodyAndFinish(node,type){var isMethod=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;if(this.match(14)){node.returnType=this.tsParseTypeOrTypePredicateAnnotation(14);}var bodilessType=type==="FunctionDeclaration"?"TSDeclareFunction":type==="ClassMethod"||type==="ClassPrivateMethod"?"TSDeclareMethod":undefined;if(bodilessType&&!this.match(5)&&this.isLineTerminator()){return this.finishNode(node,bodilessType);}if(bodilessType==="TSDeclareFunction"&&this.state.isAmbientContext){this.raise(TSErrors.DeclareFunctionHasImplementation,node);if(node.declare){return _superPropGet(TypeScriptParserMixin,"parseFunctionBodyAndFinish",this,3)([node,bodilessType,isMethod]);}}this.tsDisallowOptionalPattern(node);return _superPropGet(TypeScriptParserMixin,"parseFunctionBodyAndFinish",this,3)([node,type,isMethod]);}},{key:"registerFunctionStatementId",value:function registerFunctionStatementId(node){if(!node.body&&node.id){this.checkIdentifier(node.id,1024);}else {_superPropGet(TypeScriptParserMixin,"registerFunctionStatementId",this,3)([node]);}}},{key:"tsCheckForInvalidTypeCasts",value:function tsCheckForInvalidTypeCasts(items){var _this45=this;items.forEach(function(node){if((node==null?void 0:node.type)==="TSTypeCastExpression"){_this45.raise(TSErrors.UnexpectedTypeAnnotation,node.typeAnnotation);}});}},{key:"toReferencedList",value:function toReferencedList(exprList,isInParens){this.tsCheckForInvalidTypeCasts(exprList);return exprList;}},{key:"parseArrayLike",value:function parseArrayLike(close,canBePattern,isTuple,refExpressionErrors){var node=_superPropGet(TypeScriptParserMixin,"parseArrayLike",this,3)([close,canBePattern,isTuple,refExpressionErrors]);if(node.type==="ArrayExpression"){this.tsCheckForInvalidTypeCasts(node.elements);}return node;}},{key:"parseSubscript",value:function parseSubscript(base,startLoc,noCalls,state){var _this46=this;if(!this.hasPrecedingLineBreak()&&this.match(35)){this.state.canStartJSXElement=false;this.next();var nonNullExpression=this.startNodeAt(startLoc);nonNullExpression.expression=base;return this.finishNode(nonNullExpression,"TSNonNullExpression");}var isOptionalCall=false;if(this.match(18)&&this.lookaheadCharCode()===60){if(noCalls){state.stop=true;return base;}state.optionalChainMember=isOptionalCall=true;this.next();}if(this.match(47)||this.match(51)){var missingParenErrorLoc;var result=this.tsTryParseAndCatch(function(){if(!noCalls&&_this46.atPossibleAsyncArrow(base)){var asyncArrowFn=_this46.tsTryParseGenericAsyncArrowFunction(startLoc);if(asyncArrowFn){return asyncArrowFn;}}var typeArguments=_this46.tsParseTypeArgumentsInExpression();if(!typeArguments)return;if(isOptionalCall&&!_this46.match(10)){missingParenErrorLoc=_this46.state.curPosition();return;}if(tokenIsTemplate(_this46.state.type)){var _result=_superPropGet(TypeScriptParserMixin,"parseTaggedTemplateExpression",_this46,3)([base,startLoc,state]);{_result.typeParameters=typeArguments;}return _result;}if(!noCalls&&_this46.eat(10)){var _node12=_this46.startNodeAt(startLoc);_node12.callee=base;_node12.arguments=_this46.parseCallExpressionArguments(11);_this46.tsCheckForInvalidTypeCasts(_node12.arguments);{_node12.typeParameters=typeArguments;}if(state.optionalChainMember){_node12.optional=isOptionalCall;}return _this46.finishCallExpression(_node12,state.optionalChainMember);}var tokenType=_this46.state.type;if(tokenType===48||tokenType===52||tokenType!==10&&tokenCanStartExpression(tokenType)&&!_this46.hasPrecedingLineBreak()){return;}var node=_this46.startNodeAt(startLoc);node.expression=base;{node.typeParameters=typeArguments;}return _this46.finishNode(node,"TSInstantiationExpression");});if(missingParenErrorLoc){this.unexpected(missingParenErrorLoc,10);}if(result){if(result.type==="TSInstantiationExpression"&&(this.match(16)||this.match(18)&&this.lookaheadCharCode()!==40)){this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression,this.state.startLoc);}return result;}}return _superPropGet(TypeScriptParserMixin,"parseSubscript",this,3)([base,startLoc,noCalls,state]);}},{key:"parseNewCallee",value:function parseNewCallee(node){var _callee$extra;_superPropGet(TypeScriptParserMixin,"parseNewCallee",this,3)([node]);var callee=node.callee;if(callee.type==="TSInstantiationExpression"&&!((_callee$extra=callee.extra)!=null&&_callee$extra.parenthesized)){{node.typeParameters=callee.typeParameters;}node.callee=callee.expression;}}},{key:"parseExprOp",value:function parseExprOp(left,leftStartLoc,minPrec){var _this47=this;var isSatisfies;if(tokenOperatorPrecedence(58)>minPrec&&!this.hasPrecedingLineBreak()&&(this.isContextual(93)||(isSatisfies=this.isContextual(120)))){var node=this.startNodeAt(leftStartLoc);node.expression=left;node.typeAnnotation=this.tsInType(function(){_this47.next();if(_this47.match(75)){if(isSatisfies){_this47.raise(Errors.UnexpectedKeyword,_this47.state.startLoc,{keyword:"const"});}return _this47.tsParseTypeReference();}return _this47.tsParseType();});this.finishNode(node,isSatisfies?"TSSatisfiesExpression":"TSAsExpression");this.reScan_lt_gt();return this.parseExprOp(node,leftStartLoc,minPrec);}return _superPropGet(TypeScriptParserMixin,"parseExprOp",this,3)([left,leftStartLoc,minPrec]);}},{key:"checkReservedWord",value:function checkReservedWord(word,startLoc,checkKeywords,isBinding){if(!this.state.isAmbientContext){_superPropGet(TypeScriptParserMixin,"checkReservedWord",this,3)([word,startLoc,checkKeywords,isBinding]);}}},{key:"checkImportReflection",value:function checkImportReflection(node){_superPropGet(TypeScriptParserMixin,"checkImportReflection",this,3)([node]);if(node.module&&node.importKind!=="value"){this.raise(TSErrors.ImportReflectionHasImportType,node.specifiers[0].loc.start);}}},{key:"checkDuplicateExports",value:function checkDuplicateExports(){}},{key:"isPotentialImportPhase",value:function isPotentialImportPhase(isExport){if(_superPropGet(TypeScriptParserMixin,"isPotentialImportPhase",this,3)([isExport]))return true;if(this.isContextual(130)){var ch=this.lookaheadCharCode();return isExport?ch===123||ch===42:ch!==61;}return !isExport&&this.isContextual(87);}},{key:"applyImportPhase",value:function applyImportPhase(node,isExport,phase,loc){_superPropGet(TypeScriptParserMixin,"applyImportPhase",this,3)([node,isExport,phase,loc]);if(isExport){node.exportKind=phase==="type"?"type":"value";}else {node.importKind=phase==="type"||phase==="typeof"?phase:"value";}}},{key:"parseImport",value:function parseImport(node){if(this.match(134)){node.importKind="value";return _superPropGet(TypeScriptParserMixin,"parseImport",this,3)([node]);}var importNode;if(tokenIsIdentifier(this.state.type)&&this.lookaheadCharCode()===61){node.importKind="value";return this.tsParseImportEqualsDeclaration(node);}else if(this.isContextual(130)){var maybeDefaultIdentifier=this.parseMaybeImportPhase(node,false);if(this.lookaheadCharCode()===61){return this.tsParseImportEqualsDeclaration(node,maybeDefaultIdentifier);}else {importNode=_superPropGet(TypeScriptParserMixin,"parseImportSpecifiersAndAfter",this,3)([node,maybeDefaultIdentifier]);}}else {importNode=_superPropGet(TypeScriptParserMixin,"parseImport",this,3)([node]);}if(importNode.importKind==="type"&&importNode.specifiers.length>1&&importNode.specifiers[0].type==="ImportDefaultSpecifier"){this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed,importNode);}return importNode;}},{key:"parseExport",value:function parseExport(node,decorators){if(this.match(83)){var nodeImportEquals=node;this.next();var maybeDefaultIdentifier=null;if(this.isContextual(130)&&this.isPotentialImportPhase(false)){maybeDefaultIdentifier=this.parseMaybeImportPhase(nodeImportEquals,false);}else {nodeImportEquals.importKind="value";}var declaration=this.tsParseImportEqualsDeclaration(nodeImportEquals,maybeDefaultIdentifier,true);{return declaration;}}else if(this.eat(29)){var assign=node;assign.expression=_superPropGet(TypeScriptParserMixin,"parseExpression",this,3)([]);this.semicolon();this.sawUnambiguousESM=true;return this.finishNode(assign,"TSExportAssignment");}else if(this.eatContextual(93)){var decl=node;this.expectContextual(128);decl.id=this.parseIdentifier();this.semicolon();return this.finishNode(decl,"TSNamespaceExportDeclaration");}else {return _superPropGet(TypeScriptParserMixin,"parseExport",this,3)([node,decorators]);}}},{key:"isAbstractClass",value:function isAbstractClass(){return this.isContextual(124)&&this.lookahead().type===80;}},{key:"parseExportDefaultExpression",value:function parseExportDefaultExpression(){if(this.isAbstractClass()){var cls=this.startNode();this.next();cls["abstract"]=true;return this.parseClass(cls,true,true);}if(this.match(129)){var result=this.tsParseInterfaceDeclaration(this.startNode());if(result)return result;}return _superPropGet(TypeScriptParserMixin,"parseExportDefaultExpression",this,3)([]);}},{key:"parseVarStatement",value:function parseVarStatement(node,kind){var allowMissingInitializer=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var isAmbientContext=this.state.isAmbientContext;var declaration=_superPropGet(TypeScriptParserMixin,"parseVarStatement",this,3)([node,kind,allowMissingInitializer||isAmbientContext]);if(!isAmbientContext)return declaration;var _iterator10=_createForOfIteratorHelper(declaration.declarations),_step10;try{for(_iterator10.s();!(_step10=_iterator10.n()).done;){var _step10$value=_step10.value,id=_step10$value.id,init=_step10$value.init;if(!init)continue;if(kind!=="const"||!!id.typeAnnotation){this.raise(TSErrors.InitializerNotAllowedInAmbientContext,init);}else if(!isValidAmbientConstInitializer(init,this.hasPlugin("estree"))){this.raise(TSErrors.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference,init);}}}catch(err){_iterator10.e(err);}finally{_iterator10.f();}return declaration;}},{key:"parseStatementContent",value:function parseStatementContent(flags,decorators){if(this.match(75)&&this.isLookaheadContextual("enum")){var node=this.startNode();this.expect(75);return this.tsParseEnumDeclaration(node,{"const":true});}if(this.isContextual(126)){return this.tsParseEnumDeclaration(this.startNode());}if(this.isContextual(129)){var result=this.tsParseInterfaceDeclaration(this.startNode());if(result)return result;}return _superPropGet(TypeScriptParserMixin,"parseStatementContent",this,3)([flags,decorators]);}},{key:"parseAccessModifier",value:function parseAccessModifier(){return this.tsParseModifier(["public","protected","private"]);}},{key:"tsHasSomeModifiers",value:function tsHasSomeModifiers(member,modifiers){return modifiers.some(function(modifier){if(tsIsAccessModifier(modifier)){return member.accessibility===modifier;}return !!member[modifier];});}},{key:"tsIsStartOfStaticBlocks",value:function tsIsStartOfStaticBlocks(){return this.isContextual(106)&&this.lookaheadCharCode()===123;}},{key:"parseClassMember",value:function parseClassMember(classBody,member,state){var _this48=this;var modifiers=["declare","private","public","protected","override","abstract","readonly","static"];this.tsParseModifiers({allowedModifiers:modifiers,disallowedModifiers:["in","out"],stopOnStartOfClassStaticBlock:true,errorTemplate:TSErrors.InvalidModifierOnTypeParameterPositions},member);var callParseClassMemberWithIsStatic=function callParseClassMemberWithIsStatic(){if(_this48.tsIsStartOfStaticBlocks()){_this48.next();_this48.next();if(_this48.tsHasSomeModifiers(member,modifiers)){_this48.raise(TSErrors.StaticBlockCannotHaveModifier,_this48.state.curPosition());}_superPropGet(TypeScriptParserMixin,"parseClassStaticBlock",_this48,3)([classBody,member]);}else {_this48.parseClassMemberWithIsStatic(classBody,member,state,!!member["static"]);}};if(member.declare){this.tsInAmbientContext(callParseClassMemberWithIsStatic);}else {callParseClassMemberWithIsStatic();}}},{key:"parseClassMemberWithIsStatic",value:function parseClassMemberWithIsStatic(classBody,member,state,isStatic){var idx=this.tsTryParseIndexSignature(member);if(idx){classBody.body.push(idx);if(member["abstract"]){this.raise(TSErrors.IndexSignatureHasAbstract,member);}if(member.accessibility){this.raise(TSErrors.IndexSignatureHasAccessibility,member,{modifier:member.accessibility});}if(member.declare){this.raise(TSErrors.IndexSignatureHasDeclare,member);}if(member.override){this.raise(TSErrors.IndexSignatureHasOverride,member);}return;}if(!this.state.inAbstractClass&&member["abstract"]){this.raise(TSErrors.NonAbstractClassHasAbstractMethod,member);}if(member.override){if(!state.hadSuperClass){this.raise(TSErrors.OverrideNotInSubClass,member);}}_superPropGet(TypeScriptParserMixin,"parseClassMemberWithIsStatic",this,3)([classBody,member,state,isStatic]);}},{key:"parsePostMemberNameModifiers",value:function parsePostMemberNameModifiers(methodOrProp){var optional=this.eat(17);if(optional)methodOrProp.optional=true;if(methodOrProp.readonly&&this.match(10)){this.raise(TSErrors.ClassMethodHasReadonly,methodOrProp);}if(methodOrProp.declare&&this.match(10)){this.raise(TSErrors.ClassMethodHasDeclare,methodOrProp);}}},{key:"parseExpressionStatement",value:function parseExpressionStatement(node,expr,decorators){var decl=expr.type==="Identifier"?this.tsParseExpressionStatement(node,expr,decorators):undefined;return decl||_superPropGet(TypeScriptParserMixin,"parseExpressionStatement",this,3)([node,expr,decorators]);}},{key:"shouldParseExportDeclaration",value:function shouldParseExportDeclaration(){if(this.tsIsDeclarationStart())return true;return _superPropGet(TypeScriptParserMixin,"shouldParseExportDeclaration",this,3)([]);}},{key:"parseConditional",value:function parseConditional(expr,startLoc,refExpressionErrors){var _this49=this;if(!this.state.maybeInArrowParameters||!this.match(17)){return _superPropGet(TypeScriptParserMixin,"parseConditional",this,3)([expr,startLoc,refExpressionErrors]);}var result=this.tryParse(function(){return _superPropGet(TypeScriptParserMixin,"parseConditional",_this49,3)([expr,startLoc]);});if(!result.node){if(result.error){_superPropGet(TypeScriptParserMixin,"setOptionalParametersError",this,3)([refExpressionErrors,result.error]);}return expr;}if(result.error)this.state=result.failState;return result.node;}},{key:"parseParenItem",value:function parseParenItem(node,startLoc){var newNode=_superPropGet(TypeScriptParserMixin,"parseParenItem",this,3)([node,startLoc]);if(this.eat(17)){newNode.optional=true;this.resetEndLocation(node);}if(this.match(14)){var typeCastNode=this.startNodeAt(startLoc);typeCastNode.expression=node;typeCastNode.typeAnnotation=this.tsParseTypeAnnotation();return this.finishNode(typeCastNode,"TSTypeCastExpression");}return node;}},{key:"parseExportDeclaration",value:function parseExportDeclaration(node){var _this50=this;if(!this.state.isAmbientContext&&this.isContextual(125)){return this.tsInAmbientContext(function(){return _this50.parseExportDeclaration(node);});}var startLoc=this.state.startLoc;var isDeclare=this.eatContextual(125);if(isDeclare&&(this.isContextual(125)||!this.shouldParseExportDeclaration())){throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare,this.state.startLoc);}var isIdentifier=tokenIsIdentifier(this.state.type);var declaration=isIdentifier&&this.tsTryParseExportDeclaration()||_superPropGet(TypeScriptParserMixin,"parseExportDeclaration",this,3)([node]);if(!declaration)return null;if(declaration.type==="TSInterfaceDeclaration"||declaration.type==="TSTypeAliasDeclaration"||isDeclare){node.exportKind="type";}if(isDeclare&&declaration.type!=="TSImportEqualsDeclaration"){this.resetStartLocation(declaration,startLoc);declaration.declare=true;}return declaration;}},{key:"parseClassId",value:function parseClassId(node,isStatement,optionalId,bindingType){if((!isStatement||optionalId)&&this.isContextual(113)){return;}_superPropGet(TypeScriptParserMixin,"parseClassId",this,3)([node,isStatement,optionalId,node.declare?1024:8331]);var typeParameters=this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);if(typeParameters)node.typeParameters=typeParameters;}},{key:"parseClassPropertyAnnotation",value:function parseClassPropertyAnnotation(node){if(!node.optional){if(this.eat(35)){node.definite=true;}else if(this.eat(17)){node.optional=true;}}var type=this.tsTryParseTypeAnnotation();if(type)node.typeAnnotation=type;}},{key:"parseClassProperty",value:function parseClassProperty(node){this.parseClassPropertyAnnotation(node);if(this.state.isAmbientContext&&!(node.readonly&&!node.typeAnnotation)&&this.match(29)){this.raise(TSErrors.DeclareClassFieldHasInitializer,this.state.startLoc);}if(node["abstract"]&&this.match(29)){var key=node.key;this.raise(TSErrors.AbstractPropertyHasInitializer,this.state.startLoc,{propertyName:key.type==="Identifier"&&!node.computed?key.name:"[".concat(this.input.slice(this.offsetToSourcePos(key.start),this.offsetToSourcePos(key.end)),"]")});}return _superPropGet(TypeScriptParserMixin,"parseClassProperty",this,3)([node]);}},{key:"parseClassPrivateProperty",value:function parseClassPrivateProperty(node){if(node["abstract"]){this.raise(TSErrors.PrivateElementHasAbstract,node);}if(node.accessibility){this.raise(TSErrors.PrivateElementHasAccessibility,node,{modifier:node.accessibility});}this.parseClassPropertyAnnotation(node);return _superPropGet(TypeScriptParserMixin,"parseClassPrivateProperty",this,3)([node]);}},{key:"parseClassAccessorProperty",value:function parseClassAccessorProperty(node){this.parseClassPropertyAnnotation(node);if(node.optional){this.raise(TSErrors.AccessorCannotBeOptional,node);}return _superPropGet(TypeScriptParserMixin,"parseClassAccessorProperty",this,3)([node]);}},{key:"pushClassMethod",value:function pushClassMethod(classBody,method,isGenerator,isAsync,isConstructor,allowsDirectSuper){var typeParameters=this.tsTryParseTypeParameters(this.tsParseConstModifier);if(typeParameters&&isConstructor){this.raise(TSErrors.ConstructorHasTypeParameters,typeParameters);}var _method$declare=method.declare,declare=_method$declare===void 0?false:_method$declare,kind=method.kind;if(declare&&(kind==="get"||kind==="set")){this.raise(TSErrors.DeclareAccessor,method,{kind:kind});}if(typeParameters)method.typeParameters=typeParameters;_superPropGet(TypeScriptParserMixin,"pushClassMethod",this,3)([classBody,method,isGenerator,isAsync,isConstructor,allowsDirectSuper]);}},{key:"pushClassPrivateMethod",value:function pushClassPrivateMethod(classBody,method,isGenerator,isAsync){var typeParameters=this.tsTryParseTypeParameters(this.tsParseConstModifier);if(typeParameters)method.typeParameters=typeParameters;_superPropGet(TypeScriptParserMixin,"pushClassPrivateMethod",this,3)([classBody,method,isGenerator,isAsync]);}},{key:"declareClassPrivateMethodInScope",value:function declareClassPrivateMethodInScope(node,kind){if(node.type==="TSDeclareMethod")return;if(node.type==="MethodDefinition"&&!hasOwnProperty.call(node.value,"body")){return;}_superPropGet(TypeScriptParserMixin,"declareClassPrivateMethodInScope",this,3)([node,kind]);}},{key:"parseClassSuper",value:function parseClassSuper(node){_superPropGet(TypeScriptParserMixin,"parseClassSuper",this,3)([node]);if(node.superClass&&(this.match(47)||this.match(51))){{node.superTypeParameters=this.tsParseTypeArgumentsInExpression();}}if(this.eatContextual(113)){node["implements"]=this.tsParseHeritageClause("implements");}}},{key:"parseObjPropValue",value:function parseObjPropValue(prop,startLoc,isGenerator,isAsync,isPattern,isAccessor,refExpressionErrors){var typeParameters=this.tsTryParseTypeParameters(this.tsParseConstModifier);if(typeParameters)prop.typeParameters=typeParameters;return _superPropGet(TypeScriptParserMixin,"parseObjPropValue",this,3)([prop,startLoc,isGenerator,isAsync,isPattern,isAccessor,refExpressionErrors]);}},{key:"parseFunctionParams",value:function parseFunctionParams(node,isConstructor){var typeParameters=this.tsTryParseTypeParameters(this.tsParseConstModifier);if(typeParameters)node.typeParameters=typeParameters;_superPropGet(TypeScriptParserMixin,"parseFunctionParams",this,3)([node,isConstructor]);}},{key:"parseVarId",value:function parseVarId(decl,kind){_superPropGet(TypeScriptParserMixin,"parseVarId",this,3)([decl,kind]);if(decl.id.type==="Identifier"&&!this.hasPrecedingLineBreak()&&this.eat(35)){decl.definite=true;}var type=this.tsTryParseTypeAnnotation();if(type){decl.id.typeAnnotation=type;this.resetEndLocation(decl.id);}}},{key:"parseAsyncArrowFromCallExpression",value:function parseAsyncArrowFromCallExpression(node,call){if(this.match(14)){node.returnType=this.tsParseTypeAnnotation();}return _superPropGet(TypeScriptParserMixin,"parseAsyncArrowFromCallExpression",this,3)([node,call]);}},{key:"parseMaybeAssign",value:function parseMaybeAssign(refExpressionErrors,afterLeftParse){var _this51=this;var _jsx,_jsx2,_typeCast,_jsx3,_typeCast2;var state;var jsx;var typeCast;if(this.hasPlugin("jsx")&&(this.match(143)||this.match(47))){state=this.state.clone();jsx=this.tryParse(function(){return _superPropGet(TypeScriptParserMixin,"parseMaybeAssign",_this51,3)([refExpressionErrors,afterLeftParse]);},state);if(!jsx.error)return jsx.node;var context=this.state.context;var currentContext=context[context.length-1];if(currentContext===types.j_oTag||currentContext===types.j_expr){context.pop();}}if(!((_jsx=jsx)!=null&&_jsx.error)&&!this.match(47)){return _superPropGet(TypeScriptParserMixin,"parseMaybeAssign",this,3)([refExpressionErrors,afterLeftParse]);}if(!state||state===this.state)state=this.state.clone();var typeParameters;var arrow=this.tryParse(function(abort){var _expr$extra,_typeParameters;typeParameters=_this51.tsParseTypeParameters(_this51.tsParseConstModifier);var expr=_superPropGet(TypeScriptParserMixin,"parseMaybeAssign",_this51,3)([refExpressionErrors,afterLeftParse]);if(expr.type!=="ArrowFunctionExpression"||(_expr$extra=expr.extra)!=null&&_expr$extra.parenthesized){abort();}if(((_typeParameters=typeParameters)==null?void 0:_typeParameters.params.length)!==0){_this51.resetStartLocationFromNode(expr,typeParameters);}expr.typeParameters=typeParameters;return expr;},state);if(!arrow.error&&!arrow.aborted){if(typeParameters)this.reportReservedArrowTypeParam(typeParameters);return arrow.node;}if(!jsx){assert(!this.hasPlugin("jsx"));typeCast=this.tryParse(function(){return _superPropGet(TypeScriptParserMixin,"parseMaybeAssign",_this51,3)([refExpressionErrors,afterLeftParse]);},state);if(!typeCast.error)return typeCast.node;}if((_jsx2=jsx)!=null&&_jsx2.node){this.state=jsx.failState;return jsx.node;}if(arrow.node){this.state=arrow.failState;if(typeParameters)this.reportReservedArrowTypeParam(typeParameters);return arrow.node;}if((_typeCast=typeCast)!=null&&_typeCast.node){this.state=typeCast.failState;return typeCast.node;}throw ((_jsx3=jsx)==null?void 0:_jsx3.error)||arrow.error||((_typeCast2=typeCast)==null?void 0:_typeCast2.error);}},{key:"reportReservedArrowTypeParam",value:function reportReservedArrowTypeParam(node){var _node$extra;if(node.params.length===1&&!node.params[0].constraint&&!((_node$extra=node.extra)!=null&&_node$extra.trailingComma)&&this.getPluginOption("typescript","disallowAmbiguousJSXLike")){this.raise(TSErrors.ReservedArrowTypeParam,node);}}},{key:"parseMaybeUnary",value:function parseMaybeUnary(refExpressionErrors,sawUnary){if(!this.hasPlugin("jsx")&&this.match(47)){return this.tsParseTypeAssertion();}return _superPropGet(TypeScriptParserMixin,"parseMaybeUnary",this,3)([refExpressionErrors,sawUnary]);}},{key:"parseArrow",value:function parseArrow(node){var _this52=this;if(this.match(14)){var result=this.tryParse(function(abort){var returnType=_this52.tsParseTypeOrTypePredicateAnnotation(14);if(_this52.canInsertSemicolon()||!_this52.match(19))abort();return returnType;});if(result.aborted)return;if(!result.thrown){if(result.error)this.state=result.failState;node.returnType=result.node;}}return _superPropGet(TypeScriptParserMixin,"parseArrow",this,3)([node]);}},{key:"parseFunctionParamType",value:function parseFunctionParamType(param){if(this.eat(17)){param.optional=true;}var type=this.tsTryParseTypeAnnotation();if(type)param.typeAnnotation=type;this.resetEndLocation(param);return param;}},{key:"isAssignable",value:function isAssignable(node,isBinding){switch(node.type){case "TSTypeCastExpression":return this.isAssignable(node.expression,isBinding);case "TSParameterProperty":return true;default:return _superPropGet(TypeScriptParserMixin,"isAssignable",this,3)([node,isBinding]);}}},{key:"toAssignable",value:function toAssignable(node){var isLHS=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;switch(node.type){case "ParenthesizedExpression":this.toAssignableParenthesizedExpression(node,isLHS);break;case "TSAsExpression":case "TSSatisfiesExpression":case "TSNonNullExpression":case "TSTypeAssertion":if(isLHS){this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter,node);}else {this.raise(TSErrors.UnexpectedTypeCastInParameter,node);}this.toAssignable(node.expression,isLHS);break;case "AssignmentExpression":if(!isLHS&&node.left.type==="TSTypeCastExpression"){node.left=this.typeCastToParameter(node.left);}default:_superPropGet(TypeScriptParserMixin,"toAssignable",this,3)([node,isLHS]);}}},{key:"toAssignableParenthesizedExpression",value:function toAssignableParenthesizedExpression(node,isLHS){switch(node.expression.type){case "TSAsExpression":case "TSSatisfiesExpression":case "TSNonNullExpression":case "TSTypeAssertion":case "ParenthesizedExpression":this.toAssignable(node.expression,isLHS);break;default:_superPropGet(TypeScriptParserMixin,"toAssignable",this,3)([node,isLHS]);}}},{key:"checkToRestConversion",value:function checkToRestConversion(node,allowPattern){switch(node.type){case "TSAsExpression":case "TSSatisfiesExpression":case "TSTypeAssertion":case "TSNonNullExpression":this.checkToRestConversion(node.expression,false);break;default:_superPropGet(TypeScriptParserMixin,"checkToRestConversion",this,3)([node,allowPattern]);}}},{key:"isValidLVal",value:function isValidLVal(type,isUnparenthesizedInAssign,binding){switch(type){case "TSTypeCastExpression":return true;case "TSParameterProperty":return "parameter";case "TSNonNullExpression":case "TSInstantiationExpression":return "expression";case "TSAsExpression":case "TSSatisfiesExpression":case "TSTypeAssertion":return (binding!==64||!isUnparenthesizedInAssign)&&["expression",true];default:return _superPropGet(TypeScriptParserMixin,"isValidLVal",this,3)([type,isUnparenthesizedInAssign,binding]);}}},{key:"parseBindingAtom",value:function parseBindingAtom(){if(this.state.type===78){return this.parseIdentifier(true);}return _superPropGet(TypeScriptParserMixin,"parseBindingAtom",this,3)([]);}},{key:"parseMaybeDecoratorArguments",value:function parseMaybeDecoratorArguments(expr,startLoc){if(this.match(47)||this.match(51)){var typeArguments=this.tsParseTypeArgumentsInExpression();if(this.match(10)){var call=_superPropGet(TypeScriptParserMixin,"parseMaybeDecoratorArguments",this,3)([expr,startLoc]);{call.typeParameters=typeArguments;}return call;}this.unexpected(null,10);}return _superPropGet(TypeScriptParserMixin,"parseMaybeDecoratorArguments",this,3)([expr,startLoc]);}},{key:"checkCommaAfterRest",value:function checkCommaAfterRest(close){if(this.state.isAmbientContext&&this.match(12)&&this.lookaheadCharCode()===close){this.next();return false;}return _superPropGet(TypeScriptParserMixin,"checkCommaAfterRest",this,3)([close]);}},{key:"isClassMethod",value:function isClassMethod(){return this.match(47)||_superPropGet(TypeScriptParserMixin,"isClassMethod",this,3)([]);}},{key:"isClassProperty",value:function isClassProperty(){return this.match(35)||this.match(14)||_superPropGet(TypeScriptParserMixin,"isClassProperty",this,3)([]);}},{key:"parseMaybeDefault",value:function parseMaybeDefault(startLoc,left){var node=_superPropGet(TypeScriptParserMixin,"parseMaybeDefault",this,3)([startLoc,left]);if(node.type==="AssignmentPattern"&&node.typeAnnotation&&node.right.start<node.typeAnnotation.start){this.raise(TSErrors.TypeAnnotationAfterAssign,node.typeAnnotation);}return node;}},{key:"getTokenFromCode",value:function getTokenFromCode(code){if(this.state.inType){if(code===62){this.finishOp(48,1);return;}if(code===60){this.finishOp(47,1);return;}}_superPropGet(TypeScriptParserMixin,"getTokenFromCode",this,3)([code]);}},{key:"reScan_lt_gt",value:function reScan_lt_gt(){var type=this.state.type;if(type===47){this.state.pos-=1;this.readToken_lt();}else if(type===48){this.state.pos-=1;this.readToken_gt();}}},{key:"reScan_lt",value:function reScan_lt(){var type=this.state.type;if(type===51){this.state.pos-=2;this.finishOp(47,1);return 47;}return type;}},{key:"toAssignableList",value:function toAssignableList(exprList,trailingCommaLoc,isLHS){for(var i=0;i<exprList.length;i++){var expr=exprList[i];if((expr==null?void 0:expr.type)==="TSTypeCastExpression"){exprList[i]=this.typeCastToParameter(expr);}}_superPropGet(TypeScriptParserMixin,"toAssignableList",this,3)([exprList,trailingCommaLoc,isLHS]);}},{key:"typeCastToParameter",value:function typeCastToParameter(node){node.expression.typeAnnotation=node.typeAnnotation;this.resetEndLocation(node.expression,node.typeAnnotation.loc.end);return node.expression;}},{key:"shouldParseArrow",value:function shouldParseArrow(params){var _this53=this;if(this.match(14)){return params.every(function(expr){return _this53.isAssignable(expr,true);});}return _superPropGet(TypeScriptParserMixin,"shouldParseArrow",this,3)([params]);}},{key:"shouldParseAsyncArrow",value:function shouldParseAsyncArrow(){return this.match(14)||_superPropGet(TypeScriptParserMixin,"shouldParseAsyncArrow",this,3)([]);}},{key:"canHaveLeadingDecorator",value:function canHaveLeadingDecorator(){return _superPropGet(TypeScriptParserMixin,"canHaveLeadingDecorator",this,3)([])||this.isAbstractClass();}},{key:"jsxParseOpeningElementAfterName",value:function jsxParseOpeningElementAfterName(node){var _this54=this;if(this.match(47)||this.match(51)){var typeArguments=this.tsTryParseAndCatch(function(){return _this54.tsParseTypeArgumentsInExpression();});if(typeArguments){{node.typeParameters=typeArguments;}}}return _superPropGet(TypeScriptParserMixin,"jsxParseOpeningElementAfterName",this,3)([node]);}},{key:"getGetterSetterExpectedParamCount",value:function getGetterSetterExpectedParamCount(method){var baseCount=_superPropGet(TypeScriptParserMixin,"getGetterSetterExpectedParamCount",this,3)([method]);var params=this.getObjectOrClassMethodParams(method);var firstParam=params[0];var hasContextParam=firstParam&&this.isThisParam(firstParam);return hasContextParam?baseCount+1:baseCount;}},{key:"parseCatchClauseParam",value:function parseCatchClauseParam(){var param=_superPropGet(TypeScriptParserMixin,"parseCatchClauseParam",this,3)([]);var type=this.tsTryParseTypeAnnotation();if(type){param.typeAnnotation=type;this.resetEndLocation(param);}return param;}},{key:"tsInAmbientContext",value:function tsInAmbientContext(cb){var _this$state3=this.state,oldIsAmbientContext=_this$state3.isAmbientContext,oldStrict=_this$state3.strict;this.state.isAmbientContext=true;this.state.strict=false;try{return cb();}finally{this.state.isAmbientContext=oldIsAmbientContext;this.state.strict=oldStrict;}}},{key:"parseClass",value:function parseClass(node,isStatement,optionalId){var oldInAbstractClass=this.state.inAbstractClass;this.state.inAbstractClass=!!node["abstract"];try{return _superPropGet(TypeScriptParserMixin,"parseClass",this,3)([node,isStatement,optionalId]);}finally{this.state.inAbstractClass=oldInAbstractClass;}}},{key:"tsParseAbstractDeclaration",value:function tsParseAbstractDeclaration(node,decorators){if(this.match(80)){node["abstract"]=true;return this.maybeTakeDecorators(decorators,this.parseClass(node,true,false));}else if(this.isContextual(129)){if(!this.hasFollowingLineBreak()){node["abstract"]=true;this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer,node);return this.tsParseInterfaceDeclaration(node);}}else {this.unexpected(null,80);}}},{key:"parseMethod",value:function parseMethod(node,isGenerator,isAsync,isConstructor,allowDirectSuper,type,inClassScope){var method=_superPropGet(TypeScriptParserMixin,"parseMethod",this,3)([node,isGenerator,isAsync,isConstructor,allowDirectSuper,type,inClassScope]);if(method["abstract"]){var hasEstreePlugin=this.hasPlugin("estree");var methodFn=hasEstreePlugin?method.value:method;if(methodFn.body){var key=method.key;this.raise(TSErrors.AbstractMethodHasImplementation,method,{methodName:key.type==="Identifier"&&!method.computed?key.name:"[".concat(this.input.slice(this.offsetToSourcePos(key.start),this.offsetToSourcePos(key.end)),"]")});}}return method;}},{key:"tsParseTypeParameterName",value:function tsParseTypeParameterName(){var typeName=this.parseIdentifier();return typeName.name;}},{key:"shouldParseAsAmbientContext",value:function shouldParseAsAmbientContext(){return !!this.getPluginOption("typescript","dts");}},{key:"parse",value:function parse(){if(this.shouldParseAsAmbientContext()){this.state.isAmbientContext=true;}return _superPropGet(TypeScriptParserMixin,"parse",this,3)([]);}},{key:"getExpression",value:function getExpression(){if(this.shouldParseAsAmbientContext()){this.state.isAmbientContext=true;}return _superPropGet(TypeScriptParserMixin,"getExpression",this,3)([]);}},{key:"parseExportSpecifier",value:function parseExportSpecifier(node,isString,isInTypeExport,isMaybeTypeOnly){if(!isString&&isMaybeTypeOnly){this.parseTypeOnlyImportExportSpecifier(node,false,isInTypeExport);return this.finishNode(node,"ExportSpecifier");}node.exportKind="value";return _superPropGet(TypeScriptParserMixin,"parseExportSpecifier",this,3)([node,isString,isInTypeExport,isMaybeTypeOnly]);}},{key:"parseImportSpecifier",value:function parseImportSpecifier(specifier,importedIsString,isInTypeOnlyImport,isMaybeTypeOnly,bindingType){if(!importedIsString&&isMaybeTypeOnly){this.parseTypeOnlyImportExportSpecifier(specifier,true,isInTypeOnlyImport);return this.finishNode(specifier,"ImportSpecifier");}specifier.importKind="value";return _superPropGet(TypeScriptParserMixin,"parseImportSpecifier",this,3)([specifier,importedIsString,isInTypeOnlyImport,isMaybeTypeOnly,isInTypeOnlyImport?4098:4096]);}},{key:"parseTypeOnlyImportExportSpecifier",value:function parseTypeOnlyImportExportSpecifier(node,isImport,isInTypeOnlyImportExport){var leftOfAsKey=isImport?"imported":"local";var rightOfAsKey=isImport?"local":"exported";var leftOfAs=node[leftOfAsKey];var rightOfAs;var hasTypeSpecifier=false;var canParseAsKeyword=true;var loc=leftOfAs.loc.start;if(this.isContextual(93)){var firstAs=this.parseIdentifier();if(this.isContextual(93)){var secondAs=this.parseIdentifier();if(tokenIsKeywordOrIdentifier(this.state.type)){hasTypeSpecifier=true;leftOfAs=firstAs;rightOfAs=isImport?this.parseIdentifier():this.parseModuleExportName();canParseAsKeyword=false;}else {rightOfAs=secondAs;canParseAsKeyword=false;}}else if(tokenIsKeywordOrIdentifier(this.state.type)){canParseAsKeyword=false;rightOfAs=isImport?this.parseIdentifier():this.parseModuleExportName();}else {hasTypeSpecifier=true;leftOfAs=firstAs;}}else if(tokenIsKeywordOrIdentifier(this.state.type)){hasTypeSpecifier=true;if(isImport){leftOfAs=this.parseIdentifier(true);if(!this.isContextual(93)){this.checkReservedWord(leftOfAs.name,leftOfAs.loc.start,true,true);}}else {leftOfAs=this.parseModuleExportName();}}if(hasTypeSpecifier&&isInTypeOnlyImportExport){this.raise(isImport?TSErrors.TypeModifierIsUsedInTypeImports:TSErrors.TypeModifierIsUsedInTypeExports,loc);}node[leftOfAsKey]=leftOfAs;node[rightOfAsKey]=rightOfAs;var kindKey=isImport?"importKind":"exportKind";node[kindKey]=hasTypeSpecifier?"type":"value";if(canParseAsKeyword&&this.eatContextual(93)){node[rightOfAsKey]=isImport?this.parseIdentifier():this.parseModuleExportName();}if(!node[rightOfAsKey]){node[rightOfAsKey]=cloneIdentifier(node[leftOfAsKey]);}if(isImport){this.checkIdentifier(node[rightOfAsKey],hasTypeSpecifier?4098:4096);}}}]);}(superClass);};function isPossiblyLiteralEnum(expression){if(expression.type!=="MemberExpression")return false;var computed=expression.computed,property=expression.property;if(computed&&property.type!=="StringLiteral"&&(property.type!=="TemplateLiteral"||property.expressions.length>0)){return false;}return isUncomputedMemberExpressionChain(expression.object);}function isValidAmbientConstInitializer(expression,estree){var _expression$extra;var type=expression.type;if((_expression$extra=expression.extra)!=null&&_expression$extra.parenthesized){return false;}if(estree){if(type==="Literal"){var value=expression.value;if(typeof value==="string"||typeof value==="boolean"){return true;}}}else {if(type==="StringLiteral"||type==="BooleanLiteral"){return true;}}if(isNumber(expression,estree)||isNegativeNumber(expression,estree)){return true;}if(type==="TemplateLiteral"&&expression.expressions.length===0){return true;}if(isPossiblyLiteralEnum(expression)){return true;}return false;}function isNumber(expression,estree){if(estree){return expression.type==="Literal"&&(typeof expression.value==="number"||"bigint"in expression);}return expression.type==="NumericLiteral"||expression.type==="BigIntLiteral";}function isNegativeNumber(expression,estree){if(expression.type==="UnaryExpression"){var operator=expression.operator,argument=expression.argument;if(operator==="-"&&isNumber(argument,estree)){return true;}}return false;}function isUncomputedMemberExpressionChain(expression){if(expression.type==="Identifier")return true;if(expression.type!=="MemberExpression"||expression.computed){return false;}return isUncomputedMemberExpressionChain(expression.object);}var PlaceholderErrors=ParseErrorEnum(_templateObject5||(_templateObject5=_taggedTemplateLiteral(["placeholders"])))({ClassNameIsRequired:"A class name is required.",UnexpectedSpace:"Unexpected space in placeholder."});var placeholders=function placeholders(superClass){return/*#__PURE__*/function(_superClass5){function PlaceholdersParserMixin(){_classCallCheck(this,PlaceholdersParserMixin);return _callSuper(this,PlaceholdersParserMixin,arguments);}_inherits(PlaceholdersParserMixin,_superClass5);return _createClass(PlaceholdersParserMixin,[{key:"parsePlaceholder",value:function parsePlaceholder(expectedNode){if(this.match(133)){var node=this.startNode();this.next();this.assertNoSpace();node.name=_superPropGet(PlaceholdersParserMixin,"parseIdentifier",this,3)([true]);this.assertNoSpace();this.expect(133);return this.finishPlaceholder(node,expectedNode);}}},{key:"finishPlaceholder",value:function finishPlaceholder(node,expectedNode){var placeholder=node;if(!placeholder.expectedNode||!placeholder.type){placeholder=this.finishNode(placeholder,"Placeholder");}placeholder.expectedNode=expectedNode;return placeholder;}},{key:"getTokenFromCode",value:function getTokenFromCode(code){if(code===37&&this.input.charCodeAt(this.state.pos+1)===37){this.finishOp(133,2);}else {_superPropGet(PlaceholdersParserMixin,"getTokenFromCode",this,3)([code]);}}},{key:"parseExprAtom",value:function parseExprAtom(refExpressionErrors){return this.parsePlaceholder("Expression")||_superPropGet(PlaceholdersParserMixin,"parseExprAtom",this,3)([refExpressionErrors]);}},{key:"parseIdentifier",value:function parseIdentifier(liberal){return this.parsePlaceholder("Identifier")||_superPropGet(PlaceholdersParserMixin,"parseIdentifier",this,3)([liberal]);}},{key:"checkReservedWord",value:function checkReservedWord(word,startLoc,checkKeywords,isBinding){if(word!==undefined){_superPropGet(PlaceholdersParserMixin,"checkReservedWord",this,3)([word,startLoc,checkKeywords,isBinding]);}}},{key:"parseBindingAtom",value:function parseBindingAtom(){return this.parsePlaceholder("Pattern")||_superPropGet(PlaceholdersParserMixin,"parseBindingAtom",this,3)([]);}},{key:"isValidLVal",value:function isValidLVal(type,isParenthesized,binding){return type==="Placeholder"||_superPropGet(PlaceholdersParserMixin,"isValidLVal",this,3)([type,isParenthesized,binding]);}},{key:"toAssignable",value:function toAssignable(node,isLHS){if(node&&node.type==="Placeholder"&&node.expectedNode==="Expression"){node.expectedNode="Pattern";}else {_superPropGet(PlaceholdersParserMixin,"toAssignable",this,3)([node,isLHS]);}}},{key:"chStartsBindingIdentifier",value:function chStartsBindingIdentifier(ch,pos){if(_superPropGet(PlaceholdersParserMixin,"chStartsBindingIdentifier",this,3)([ch,pos])){return true;}var nextToken=this.lookahead();if(nextToken.type===133){return true;}return false;}},{key:"verifyBreakContinue",value:function verifyBreakContinue(node,isBreak){if(node.label&&node.label.type==="Placeholder")return;_superPropGet(PlaceholdersParserMixin,"verifyBreakContinue",this,3)([node,isBreak]);}},{key:"parseExpressionStatement",value:function parseExpressionStatement(node,expr){var _expr$extra;if(expr.type!=="Placeholder"||(_expr$extra=expr.extra)!=null&&_expr$extra.parenthesized){return _superPropGet(PlaceholdersParserMixin,"parseExpressionStatement",this,3)([node,expr]);}if(this.match(14)){var stmt=node;stmt.label=this.finishPlaceholder(expr,"Identifier");this.next();stmt.body=_superPropGet(PlaceholdersParserMixin,"parseStatementOrSloppyAnnexBFunctionDeclaration",this,3)([]);return this.finishNode(stmt,"LabeledStatement");}this.semicolon();var stmtPlaceholder=node;stmtPlaceholder.name=expr.name;return this.finishPlaceholder(stmtPlaceholder,"Statement");}},{key:"parseBlock",value:function parseBlock(allowDirectives,createNewLexicalScope,afterBlockParse){return this.parsePlaceholder("BlockStatement")||_superPropGet(PlaceholdersParserMixin,"parseBlock",this,3)([allowDirectives,createNewLexicalScope,afterBlockParse]);}},{key:"parseFunctionId",value:function parseFunctionId(requireId){return this.parsePlaceholder("Identifier")||_superPropGet(PlaceholdersParserMixin,"parseFunctionId",this,3)([requireId]);}},{key:"parseClass",value:function parseClass(node,isStatement,optionalId){var type=isStatement?"ClassDeclaration":"ClassExpression";this.next();var oldStrict=this.state.strict;var placeholder=this.parsePlaceholder("Identifier");if(placeholder){if(this.match(81)||this.match(133)||this.match(5)){node.id=placeholder;}else if(optionalId||!isStatement){node.id=null;node.body=this.finishPlaceholder(placeholder,"ClassBody");return this.finishNode(node,type);}else {throw this.raise(PlaceholderErrors.ClassNameIsRequired,this.state.startLoc);}}else {this.parseClassId(node,isStatement,optionalId);}_superPropGet(PlaceholdersParserMixin,"parseClassSuper",this,3)([node]);node.body=this.parsePlaceholder("ClassBody")||_superPropGet(PlaceholdersParserMixin,"parseClassBody",this,3)([!!node.superClass,oldStrict]);return this.finishNode(node,type);}},{key:"parseExport",value:function parseExport(node,decorators){var placeholder=this.parsePlaceholder("Identifier");if(!placeholder)return _superPropGet(PlaceholdersParserMixin,"parseExport",this,3)([node,decorators]);var node2=node;if(!this.isContextual(98)&&!this.match(12)){node2.specifiers=[];node2.source=null;node2.declaration=this.finishPlaceholder(placeholder,"Declaration");return this.finishNode(node2,"ExportNamedDeclaration");}this.expectPlugin("exportDefaultFrom");var specifier=this.startNode();specifier.exported=placeholder;node2.specifiers=[this.finishNode(specifier,"ExportDefaultSpecifier")];return _superPropGet(PlaceholdersParserMixin,"parseExport",this,3)([node2,decorators]);}},{key:"isExportDefaultSpecifier",value:function isExportDefaultSpecifier(){if(this.match(65)){var next=this.nextTokenStart();if(this.isUnparsedContextual(next,"from")){if(this.input.startsWith(tokenLabelName(133),this.nextTokenStartSince(next+4))){return true;}}}return _superPropGet(PlaceholdersParserMixin,"isExportDefaultSpecifier",this,3)([]);}},{key:"maybeParseExportDefaultSpecifier",value:function maybeParseExportDefaultSpecifier(node,maybeDefaultIdentifier){var _specifiers;if((_specifiers=node.specifiers)!=null&&_specifiers.length){return true;}return _superPropGet(PlaceholdersParserMixin,"maybeParseExportDefaultSpecifier",this,3)([node,maybeDefaultIdentifier]);}},{key:"checkExport",value:function checkExport(node){var specifiers=node.specifiers;if(specifiers!=null&&specifiers.length){node.specifiers=specifiers.filter(function(node){return node.exported.type==="Placeholder";});}_superPropGet(PlaceholdersParserMixin,"checkExport",this,3)([node]);node.specifiers=specifiers;}},{key:"parseImport",value:function parseImport(node){var placeholder=this.parsePlaceholder("Identifier");if(!placeholder)return _superPropGet(PlaceholdersParserMixin,"parseImport",this,3)([node]);node.specifiers=[];if(!this.isContextual(98)&&!this.match(12)){node.source=this.finishPlaceholder(placeholder,"StringLiteral");this.semicolon();return this.finishNode(node,"ImportDeclaration");}var specifier=this.startNodeAtNode(placeholder);specifier.local=placeholder;node.specifiers.push(this.finishNode(specifier,"ImportDefaultSpecifier"));if(this.eat(12)){var hasStarImport=this.maybeParseStarImportSpecifier(node);if(!hasStarImport)this.parseNamedImportSpecifiers(node);}this.expectContextual(98);node.source=this.parseImportSource();this.semicolon();return this.finishNode(node,"ImportDeclaration");}},{key:"parseImportSource",value:function parseImportSource(){return this.parsePlaceholder("StringLiteral")||_superPropGet(PlaceholdersParserMixin,"parseImportSource",this,3)([]);}},{key:"assertNoSpace",value:function assertNoSpace(){if(this.state.start>this.offsetToSourcePos(this.state.lastTokEndLoc.index)){this.raise(PlaceholderErrors.UnexpectedSpace,this.state.lastTokEndLoc);}}}]);}(superClass);};var v8intrinsic=function v8intrinsic(superClass){return/*#__PURE__*/function(_superClass6){function V8IntrinsicMixin(){_classCallCheck(this,V8IntrinsicMixin);return _callSuper(this,V8IntrinsicMixin,arguments);}_inherits(V8IntrinsicMixin,_superClass6);return _createClass(V8IntrinsicMixin,[{key:"parseV8Intrinsic",value:function parseV8Intrinsic(){if(this.match(54)){var v8IntrinsicStartLoc=this.state.startLoc;var node=this.startNode();this.next();if(tokenIsIdentifier(this.state.type)){var name=this.parseIdentifierName();var identifier=this.createIdentifier(node,name);identifier.type="V8IntrinsicIdentifier";if(this.match(10)){return identifier;}}this.unexpected(v8IntrinsicStartLoc);}}},{key:"parseExprAtom",value:function parseExprAtom(refExpressionErrors){return this.parseV8Intrinsic()||_superPropGet(V8IntrinsicMixin,"parseExprAtom",this,3)([refExpressionErrors]);}}]);}(superClass);};var PIPELINE_PROPOSALS=["minimal","fsharp","hack","smart"];var TOPIC_TOKENS=["^^","@@","^","%","#"];function validatePlugins(pluginsMap){if(pluginsMap.has("decorators")){if(pluginsMap.has("decorators-legacy")){throw new Error("Cannot use the decorators and decorators-legacy plugin together");}var decoratorsBeforeExport=pluginsMap.get("decorators").decoratorsBeforeExport;if(decoratorsBeforeExport!=null&&typeof decoratorsBeforeExport!=="boolean"){throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");}var allowCallParenthesized=pluginsMap.get("decorators").allowCallParenthesized;if(allowCallParenthesized!=null&&typeof allowCallParenthesized!=="boolean"){throw new Error("'allowCallParenthesized' must be a boolean.");}}if(pluginsMap.has("flow")&&pluginsMap.has("typescript")){throw new Error("Cannot combine flow and typescript plugins.");}if(pluginsMap.has("placeholders")&&pluginsMap.has("v8intrinsic")){throw new Error("Cannot combine placeholders and v8intrinsic plugins.");}if(pluginsMap.has("pipelineOperator")){var _pluginsMap$get;var proposal=pluginsMap.get("pipelineOperator").proposal;if(!PIPELINE_PROPOSALS.includes(proposal)){var proposalList=PIPELINE_PROPOSALS.map(function(p){return "\"".concat(p,"\"");}).join(", ");throw new Error("\"pipelineOperator\" requires \"proposal\" option whose value must be one of: ".concat(proposalList,"."));}var tupleSyntaxIsHash=((_pluginsMap$get=pluginsMap.get("recordAndTuple"))==null?void 0:_pluginsMap$get.syntaxType)==="hash";if(proposal==="hack"){if(pluginsMap.has("placeholders")){throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");}if(pluginsMap.has("v8intrinsic")){throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");}var topicToken=pluginsMap.get("pipelineOperator").topicToken;if(!TOPIC_TOKENS.includes(topicToken)){var tokenList=TOPIC_TOKENS.map(function(t){return "\"".concat(t,"\"");}).join(", ");throw new Error("\"pipelineOperator\" in \"proposal\": \"hack\" mode also requires a \"topicToken\" option whose value must be one of: ".concat(tokenList,"."));}if(topicToken==="#"&&tupleSyntaxIsHash){throw new Error("Plugin conflict between `[\"pipelineOperator\", { proposal: \"hack\", topicToken: \"#\" }]` and `".concat(JSON.stringify(["recordAndTuple",pluginsMap.get("recordAndTuple")]),"`."));}}else if(proposal==="smart"&&tupleSyntaxIsHash){throw new Error("Plugin conflict between `[\"pipelineOperator\", { proposal: \"smart\" }]` and `".concat(JSON.stringify(["recordAndTuple",pluginsMap.get("recordAndTuple")]),"`."));}}if(pluginsMap.has("moduleAttributes")){{if(pluginsMap.has("deprecatedImportAssert")||pluginsMap.has("importAssertions")){throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");}var moduleAttributesVersionPluginOption=pluginsMap.get("moduleAttributes").version;if(moduleAttributesVersionPluginOption!=="may-2020"){throw new Error("The 'moduleAttributes' plugin requires a 'version' option,"+" representing the last proposal update. Currently, the"+" only supported value is 'may-2020'.");}}}if(pluginsMap.has("importAssertions")){if(pluginsMap.has("deprecatedImportAssert")){throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");}}if(!pluginsMap.has("deprecatedImportAssert")&&pluginsMap.has("importAttributes")&&pluginsMap.get("importAttributes").deprecatedAssertSyntax){{pluginsMap.set("deprecatedImportAssert",{});}}if(pluginsMap.has("recordAndTuple")){var syntaxType=pluginsMap.get("recordAndTuple").syntaxType;if(syntaxType!=null){{var RECORD_AND_TUPLE_SYNTAX_TYPES=["hash","bar"];if(!RECORD_AND_TUPLE_SYNTAX_TYPES.includes(syntaxType)){throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: "+RECORD_AND_TUPLE_SYNTAX_TYPES.map(function(p){return "'".concat(p,"'");}).join(", "));}}}}if(pluginsMap.has("asyncDoExpressions")&&!pluginsMap.has("doExpressions")){var error=new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");error.missingPlugins="doExpressions";throw error;}if(pluginsMap.has("optionalChainingAssign")&&pluginsMap.get("optionalChainingAssign").version!=="2023-07"){throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option,"+" representing the last proposal update. Currently, the"+" only supported value is '2023-07'.");}}var mixinPlugins={estree:estree,jsx:jsx,flow:flow,typescript:typescript,v8intrinsic:v8intrinsic,placeholders:placeholders};var mixinPluginNames=Object.keys(mixinPlugins);var ExpressionParser=/*#__PURE__*/function(_LValParser){function ExpressionParser(){_classCallCheck(this,ExpressionParser);return _callSuper(this,ExpressionParser,arguments);}_inherits(ExpressionParser,_LValParser);return _createClass(ExpressionParser,[{key:"checkProto",value:function checkProto(prop,isRecord,protoRef,refExpressionErrors){if(prop.type==="SpreadElement"||this.isObjectMethod(prop)||prop.computed||prop.shorthand){return;}var key=prop.key;var name=key.type==="Identifier"?key.name:key.value;if(name==="__proto__"){if(isRecord){this.raise(Errors.RecordNoProto,key);return;}if(protoRef.used){if(refExpressionErrors){if(refExpressionErrors.doubleProtoLoc===null){refExpressionErrors.doubleProtoLoc=key.loc.start;}}else {this.raise(Errors.DuplicateProto,key);}}protoRef.used=true;}}},{key:"shouldExitDescending",value:function shouldExitDescending(expr,potentialArrowAt){return expr.type==="ArrowFunctionExpression"&&this.offsetToSourcePos(expr.start)===potentialArrowAt;}},{key:"getExpression",value:function getExpression(){this.enterInitialScopes();this.nextToken();var expr=this.parseExpression();if(!this.match(140)){this.unexpected();}this.finalizeRemainingComments();expr.comments=this.comments;expr.errors=this.state.errors;if(this.optionFlags&128){expr.tokens=this.tokens;}return expr;}},{key:"parseExpression",value:function parseExpression(disallowIn,refExpressionErrors){var _this55=this;if(disallowIn){return this.disallowInAnd(function(){return _this55.parseExpressionBase(refExpressionErrors);});}return this.allowInAnd(function(){return _this55.parseExpressionBase(refExpressionErrors);});}},{key:"parseExpressionBase",value:function parseExpressionBase(refExpressionErrors){var startLoc=this.state.startLoc;var expr=this.parseMaybeAssign(refExpressionErrors);if(this.match(12)){var node=this.startNodeAt(startLoc);node.expressions=[expr];while(this.eat(12)){node.expressions.push(this.parseMaybeAssign(refExpressionErrors));}this.toReferencedList(node.expressions);return this.finishNode(node,"SequenceExpression");}return expr;}},{key:"parseMaybeAssignDisallowIn",value:function parseMaybeAssignDisallowIn(refExpressionErrors,afterLeftParse){var _this56=this;return this.disallowInAnd(function(){return _this56.parseMaybeAssign(refExpressionErrors,afterLeftParse);});}},{key:"parseMaybeAssignAllowIn",value:function parseMaybeAssignAllowIn(refExpressionErrors,afterLeftParse){var _this57=this;return this.allowInAnd(function(){return _this57.parseMaybeAssign(refExpressionErrors,afterLeftParse);});}},{key:"setOptionalParametersError",value:function setOptionalParametersError(refExpressionErrors,resultError){var _resultError$loc;refExpressionErrors.optionalParametersLoc=(_resultError$loc=resultError==null?void 0:resultError.loc)!=null?_resultError$loc:this.state.startLoc;}},{key:"parseMaybeAssign",value:function parseMaybeAssign(refExpressionErrors,afterLeftParse){var startLoc=this.state.startLoc;if(this.isContextual(108)){if(this.prodParam.hasYield){var _left2=this.parseYield();if(afterLeftParse){_left2=afterLeftParse.call(this,_left2,startLoc);}return _left2;}}var ownExpressionErrors;if(refExpressionErrors){ownExpressionErrors=false;}else {refExpressionErrors=new ExpressionErrors();ownExpressionErrors=true;}var type=this.state.type;if(type===10||tokenIsIdentifier(type)){this.state.potentialArrowAt=this.state.start;}var left=this.parseMaybeConditional(refExpressionErrors);if(afterLeftParse){left=afterLeftParse.call(this,left,startLoc);}if(tokenIsAssignment(this.state.type)){var node=this.startNodeAt(startLoc);var operator=this.state.value;node.operator=operator;if(this.match(29)){this.toAssignable(left,true);node.left=left;var startIndex=startLoc.index;if(refExpressionErrors.doubleProtoLoc!=null&&refExpressionErrors.doubleProtoLoc.index>=startIndex){refExpressionErrors.doubleProtoLoc=null;}if(refExpressionErrors.shorthandAssignLoc!=null&&refExpressionErrors.shorthandAssignLoc.index>=startIndex){refExpressionErrors.shorthandAssignLoc=null;}if(refExpressionErrors.privateKeyLoc!=null&&refExpressionErrors.privateKeyLoc.index>=startIndex){this.checkDestructuringPrivate(refExpressionErrors);refExpressionErrors.privateKeyLoc=null;}}else {node.left=left;}this.next();node.right=this.parseMaybeAssign();this.checkLVal(left,this.finishNode(node,"AssignmentExpression"));return node;}else if(ownExpressionErrors){this.checkExpressionErrors(refExpressionErrors,true);}return left;}},{key:"parseMaybeConditional",value:function parseMaybeConditional(refExpressionErrors){var startLoc=this.state.startLoc;var potentialArrowAt=this.state.potentialArrowAt;var expr=this.parseExprOps(refExpressionErrors);if(this.shouldExitDescending(expr,potentialArrowAt)){return expr;}return this.parseConditional(expr,startLoc,refExpressionErrors);}},{key:"parseConditional",value:function parseConditional(expr,startLoc,refExpressionErrors){if(this.eat(17)){var node=this.startNodeAt(startLoc);node.test=expr;node.consequent=this.parseMaybeAssignAllowIn();this.expect(14);node.alternate=this.parseMaybeAssign();return this.finishNode(node,"ConditionalExpression");}return expr;}},{key:"parseMaybeUnaryOrPrivate",value:function parseMaybeUnaryOrPrivate(refExpressionErrors){return this.match(139)?this.parsePrivateName():this.parseMaybeUnary(refExpressionErrors);}},{key:"parseExprOps",value:function parseExprOps(refExpressionErrors){var startLoc=this.state.startLoc;var potentialArrowAt=this.state.potentialArrowAt;var expr=this.parseMaybeUnaryOrPrivate(refExpressionErrors);if(this.shouldExitDescending(expr,potentialArrowAt)){return expr;}return this.parseExprOp(expr,startLoc,-1);}},{key:"parseExprOp",value:function parseExprOp(left,leftStartLoc,minPrec){if(this.isPrivateName(left)){var value=this.getPrivateNameSV(left);if(minPrec>=tokenOperatorPrecedence(58)||!this.prodParam.hasIn||!this.match(58)){this.raise(Errors.PrivateInExpectedIn,left,{identifierName:value});}this.classScope.usePrivateName(value,left.loc.start);}var op=this.state.type;if(tokenIsOperator(op)&&(this.prodParam.hasIn||!this.match(58))){var prec=tokenOperatorPrecedence(op);if(prec>minPrec){if(op===39){this.expectPlugin("pipelineOperator");if(this.state.inFSharpPipelineDirectBody){return left;}this.checkPipelineAtInfixOperator(left,leftStartLoc);}var node=this.startNodeAt(leftStartLoc);node.left=left;node.operator=this.state.value;var logical=op===41||op===42;var coalesce=op===40;if(coalesce){prec=tokenOperatorPrecedence(42);}this.next();if(op===39&&this.hasPlugin(["pipelineOperator",{proposal:"minimal"}])){if(this.state.type===96&&this.prodParam.hasAwait){throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody,this.state.startLoc);}}node.right=this.parseExprOpRightExpr(op,prec);var finishedNode=this.finishNode(node,logical||coalesce?"LogicalExpression":"BinaryExpression");var nextOp=this.state.type;if(coalesce&&(nextOp===41||nextOp===42)||logical&&nextOp===40){throw this.raise(Errors.MixingCoalesceWithLogical,this.state.startLoc);}return this.parseExprOp(finishedNode,leftStartLoc,minPrec);}}return left;}},{key:"parseExprOpRightExpr",value:function parseExprOpRightExpr(op,prec){var _this58=this;var startLoc=this.state.startLoc;switch(op){case 39:switch(this.getPluginOption("pipelineOperator","proposal")){case "hack":return this.withTopicBindingContext(function(){return _this58.parseHackPipeBody();});case "fsharp":return this.withSoloAwaitPermittingContext(function(){return _this58.parseFSharpPipelineBody(prec);});}if(this.getPluginOption("pipelineOperator","proposal")==="smart"){return this.withTopicBindingContext(function(){if(_this58.prodParam.hasYield&&_this58.isContextual(108)){throw _this58.raise(Errors.PipeBodyIsTighter,_this58.state.startLoc);}return _this58.parseSmartPipelineBodyInStyle(_this58.parseExprOpBaseRightExpr(op,prec),startLoc);});}default:return this.parseExprOpBaseRightExpr(op,prec);}}},{key:"parseExprOpBaseRightExpr",value:function parseExprOpBaseRightExpr(op,prec){var startLoc=this.state.startLoc;return this.parseExprOp(this.parseMaybeUnaryOrPrivate(),startLoc,tokenIsRightAssociative(op)?prec-1:prec);}},{key:"parseHackPipeBody",value:function parseHackPipeBody(){var _body$extra;var startLoc=this.state.startLoc;var body=this.parseMaybeAssign();var requiredParentheses=UnparenthesizedPipeBodyDescriptions.has(body.type);if(requiredParentheses&&!((_body$extra=body.extra)!=null&&_body$extra.parenthesized)){this.raise(Errors.PipeUnparenthesizedBody,startLoc,{type:body.type});}if(!this.topicReferenceWasUsedInCurrentContext()){this.raise(Errors.PipeTopicUnused,startLoc);}return body;}},{key:"checkExponentialAfterUnary",value:function checkExponentialAfterUnary(node){if(this.match(57)){this.raise(Errors.UnexpectedTokenUnaryExponentiation,node.argument);}}},{key:"parseMaybeUnary",value:function parseMaybeUnary(refExpressionErrors,sawUnary){var startLoc=this.state.startLoc;var isAwait=this.isContextual(96);if(isAwait&&this.recordAwaitIfAllowed()){this.next();var _expr=this.parseAwait(startLoc);if(!sawUnary)this.checkExponentialAfterUnary(_expr);return _expr;}var update=this.match(34);var node=this.startNode();if(tokenIsPrefix(this.state.type)){node.operator=this.state.value;node.prefix=true;if(this.match(72)){this.expectPlugin("throwExpressions");}var isDelete=this.match(89);this.next();node.argument=this.parseMaybeUnary(null,true);this.checkExpressionErrors(refExpressionErrors,true);if(this.state.strict&&isDelete){var arg=node.argument;if(arg.type==="Identifier"){this.raise(Errors.StrictDelete,node);}else if(this.hasPropertyAsPrivateName(arg)){this.raise(Errors.DeletePrivateField,node);}}if(!update){if(!sawUnary){this.checkExponentialAfterUnary(node);}return this.finishNode(node,"UnaryExpression");}}var expr=this.parseUpdate(node,update,refExpressionErrors);if(isAwait){var type=this.state.type;var _startsExpr=this.hasPlugin("v8intrinsic")?tokenCanStartExpression(type):tokenCanStartExpression(type)&&!this.match(54);if(_startsExpr&&!this.isAmbiguousAwait()){this.raiseOverwrite(Errors.AwaitNotInAsyncContext,startLoc);return this.parseAwait(startLoc);}}return expr;}},{key:"parseUpdate",value:function parseUpdate(node,update,refExpressionErrors){if(update){var updateExpressionNode=node;this.checkLVal(updateExpressionNode.argument,this.finishNode(updateExpressionNode,"UpdateExpression"));return node;}var startLoc=this.state.startLoc;var expr=this.parseExprSubscripts(refExpressionErrors);if(this.checkExpressionErrors(refExpressionErrors,false))return expr;while(tokenIsPostfix(this.state.type)&&!this.canInsertSemicolon()){var _node13=this.startNodeAt(startLoc);_node13.operator=this.state.value;_node13.prefix=false;_node13.argument=expr;this.next();this.checkLVal(expr,expr=this.finishNode(_node13,"UpdateExpression"));}return expr;}},{key:"parseExprSubscripts",value:function parseExprSubscripts(refExpressionErrors){var startLoc=this.state.startLoc;var potentialArrowAt=this.state.potentialArrowAt;var expr=this.parseExprAtom(refExpressionErrors);if(this.shouldExitDescending(expr,potentialArrowAt)){return expr;}return this.parseSubscripts(expr,startLoc);}},{key:"parseSubscripts",value:function parseSubscripts(base,startLoc,noCalls){var state={optionalChainMember:false,maybeAsyncArrow:this.atPossibleAsyncArrow(base),stop:false};do{base=this.parseSubscript(base,startLoc,noCalls,state);state.maybeAsyncArrow=false;}while(!state.stop);return base;}},{key:"parseSubscript",value:function parseSubscript(base,startLoc,noCalls,state){var type=this.state.type;if(!noCalls&&type===15){return this.parseBind(base,startLoc,noCalls,state);}else if(tokenIsTemplate(type)){return this.parseTaggedTemplateExpression(base,startLoc,state);}var optional=false;if(type===18){if(noCalls){this.raise(Errors.OptionalChainingNoNew,this.state.startLoc);if(this.lookaheadCharCode()===40){state.stop=true;return base;}}state.optionalChainMember=optional=true;this.next();}if(!noCalls&&this.match(10)){return this.parseCoverCallAndAsyncArrowHead(base,startLoc,state,optional);}else {var computed=this.eat(0);if(computed||optional||this.eat(16)){return this.parseMember(base,startLoc,state,computed,optional);}else {state.stop=true;return base;}}}},{key:"parseMember",value:function parseMember(base,startLoc,state,computed,optional){var node=this.startNodeAt(startLoc);node.object=base;node.computed=computed;if(computed){node.property=this.parseExpression();this.expect(3);}else if(this.match(139)){if(base.type==="Super"){this.raise(Errors.SuperPrivateField,startLoc);}this.classScope.usePrivateName(this.state.value,this.state.startLoc);node.property=this.parsePrivateName();}else {node.property=this.parseIdentifier(true);}if(state.optionalChainMember){node.optional=optional;return this.finishNode(node,"OptionalMemberExpression");}else {return this.finishNode(node,"MemberExpression");}}},{key:"parseBind",value:function parseBind(base,startLoc,noCalls,state){var node=this.startNodeAt(startLoc);node.object=base;this.next();node.callee=this.parseNoCallExpr();state.stop=true;return this.parseSubscripts(this.finishNode(node,"BindExpression"),startLoc,noCalls);}},{key:"parseCoverCallAndAsyncArrowHead",value:function parseCoverCallAndAsyncArrowHead(base,startLoc,state,optional){var oldMaybeInArrowParameters=this.state.maybeInArrowParameters;var refExpressionErrors=null;this.state.maybeInArrowParameters=true;this.next();var node=this.startNodeAt(startLoc);node.callee=base;var maybeAsyncArrow=state.maybeAsyncArrow,optionalChainMember=state.optionalChainMember;if(maybeAsyncArrow){this.expressionScope.enter(newAsyncArrowScope());refExpressionErrors=new ExpressionErrors();}if(optionalChainMember){node.optional=optional;}if(optional){node.arguments=this.parseCallExpressionArguments(11);}else {node.arguments=this.parseCallExpressionArguments(11,base.type!=="Super",node,refExpressionErrors);}var finishedNode=this.finishCallExpression(node,optionalChainMember);if(maybeAsyncArrow&&this.shouldParseAsyncArrow()&&!optional){state.stop=true;this.checkDestructuringPrivate(refExpressionErrors);this.expressionScope.validateAsPattern();this.expressionScope.exit();finishedNode=this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc),finishedNode);}else {if(maybeAsyncArrow){this.checkExpressionErrors(refExpressionErrors,true);this.expressionScope.exit();}this.toReferencedArguments(finishedNode);}this.state.maybeInArrowParameters=oldMaybeInArrowParameters;return finishedNode;}},{key:"toReferencedArguments",value:function toReferencedArguments(node,isParenthesizedExpr){this.toReferencedListDeep(node.arguments,isParenthesizedExpr);}},{key:"parseTaggedTemplateExpression",value:function parseTaggedTemplateExpression(base,startLoc,state){var node=this.startNodeAt(startLoc);node.tag=base;node.quasi=this.parseTemplate(true);if(state.optionalChainMember){this.raise(Errors.OptionalChainingNoTemplate,startLoc);}return this.finishNode(node,"TaggedTemplateExpression");}},{key:"atPossibleAsyncArrow",value:function atPossibleAsyncArrow(base){return base.type==="Identifier"&&base.name==="async"&&this.state.lastTokEndLoc.index===base.end&&!this.canInsertSemicolon()&&base.end-base.start===5&&this.offsetToSourcePos(base.start)===this.state.potentialArrowAt;}},{key:"finishCallExpression",value:function finishCallExpression(node,optional){if(node.callee.type==="Import"){if(node.arguments.length===0||node.arguments.length>2){this.raise(Errors.ImportCallArity,node);}else {var _iterator11=_createForOfIteratorHelper(node.arguments),_step11;try{for(_iterator11.s();!(_step11=_iterator11.n()).done;){var arg=_step11.value;if(arg.type==="SpreadElement"){this.raise(Errors.ImportCallSpreadArgument,arg);}}}catch(err){_iterator11.e(err);}finally{_iterator11.f();}}}return this.finishNode(node,optional?"OptionalCallExpression":"CallExpression");}},{key:"parseCallExpressionArguments",value:function parseCallExpressionArguments(close,allowPlaceholder,nodeForExtra,refExpressionErrors){var elts=[];var first=true;var oldInFSharpPipelineDirectBody=this.state.inFSharpPipelineDirectBody;this.state.inFSharpPipelineDirectBody=false;while(!this.eat(close)){if(first){first=false;}else {this.expect(12);if(this.match(close)){if(nodeForExtra){this.addTrailingCommaExtraToNode(nodeForExtra);}this.next();break;}}elts.push(this.parseExprListItem(false,refExpressionErrors,allowPlaceholder));}this.state.inFSharpPipelineDirectBody=oldInFSharpPipelineDirectBody;return elts;}},{key:"shouldParseAsyncArrow",value:function shouldParseAsyncArrow(){return this.match(19)&&!this.canInsertSemicolon();}},{key:"parseAsyncArrowFromCallExpression",value:function parseAsyncArrowFromCallExpression(node,call){var _call$extra;this.resetPreviousNodeTrailingComments(call);this.expect(19);this.parseArrowExpression(node,call.arguments,true,(_call$extra=call.extra)==null?void 0:_call$extra.trailingCommaLoc);if(call.innerComments){setInnerComments(node,call.innerComments);}if(call.callee.trailingComments){setInnerComments(node,call.callee.trailingComments);}return node;}},{key:"parseNoCallExpr",value:function parseNoCallExpr(){var startLoc=this.state.startLoc;return this.parseSubscripts(this.parseExprAtom(),startLoc,true);}},{key:"parseExprAtom",value:function parseExprAtom(refExpressionErrors){var node;var decorators=null;var type=this.state.type;switch(type){case 79:return this.parseSuper();case 83:node=this.startNode();this.next();if(this.match(16)){return this.parseImportMetaProperty(node);}if(this.match(10)){if(this.optionFlags&256){return this.parseImportCall(node);}else {return this.finishNode(node,"Import");}}else {this.raise(Errors.UnsupportedImport,this.state.lastTokStartLoc);return this.finishNode(node,"Import");}case 78:node=this.startNode();this.next();return this.finishNode(node,"ThisExpression");case 90:{return this.parseDo(this.startNode(),false);}case 56:case 31:{this.readRegexp();return this.parseRegExpLiteral(this.state.value);}case 135:return this.parseNumericLiteral(this.state.value);case 136:return this.parseBigIntLiteral(this.state.value);case 134:return this.parseStringLiteral(this.state.value);case 84:return this.parseNullLiteral();case 85:return this.parseBooleanLiteral(true);case 86:return this.parseBooleanLiteral(false);case 10:{var canBeArrow=this.state.potentialArrowAt===this.state.start;return this.parseParenAndDistinguishExpression(canBeArrow);}case 2:case 1:{return this.parseArrayLike(this.state.type===2?4:3,false,true);}case 0:{return this.parseArrayLike(3,true,false,refExpressionErrors);}case 6:case 7:{return this.parseObjectLike(this.state.type===6?9:8,false,true);}case 5:{return this.parseObjectLike(8,false,false,refExpressionErrors);}case 68:return this.parseFunctionOrFunctionSent();case 26:decorators=this.parseDecorators();case 80:return this.parseClass(this.maybeTakeDecorators(decorators,this.startNode()),false);case 77:return this.parseNewOrNewTarget();case 25:case 24:return this.parseTemplate(false);case 15:{node=this.startNode();this.next();node.object=null;var callee=node.callee=this.parseNoCallExpr();if(callee.type==="MemberExpression"){return this.finishNode(node,"BindExpression");}else {throw this.raise(Errors.UnsupportedBind,callee);}}case 139:{this.raise(Errors.PrivateInExpectedIn,this.state.startLoc,{identifierName:this.state.value});return this.parsePrivateName();}case 33:{return this.parseTopicReferenceThenEqualsSign(54,"%");}case 32:{return this.parseTopicReferenceThenEqualsSign(44,"^");}case 37:case 38:{return this.parseTopicReference("hack");}case 44:case 54:case 27:{var pipeProposal=this.getPluginOption("pipelineOperator","proposal");if(pipeProposal){return this.parseTopicReference(pipeProposal);}this.unexpected();break;}case 47:{var lookaheadCh=this.input.codePointAt(this.nextTokenStart());if(isIdentifierStart(lookaheadCh)||lookaheadCh===62){this.expectOnePlugin(["jsx","flow","typescript"]);}else {this.unexpected();}break;}default:if(type===137){return this.parseDecimalLiteral(this.state.value);}if(tokenIsIdentifier(type)){if(this.isContextual(127)&&this.lookaheadInLineCharCode()===123){return this.parseModuleExpression();}var _canBeArrow=this.state.potentialArrowAt===this.state.start;var containsEsc=this.state.containsEsc;var id=this.parseIdentifier();if(!containsEsc&&id.name==="async"&&!this.canInsertSemicolon()){var _type=this.state.type;if(_type===68){this.resetPreviousNodeTrailingComments(id);this.next();return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));}else if(tokenIsIdentifier(_type)){if(this.lookaheadCharCode()===61){return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));}else {return id;}}else if(_type===90){this.resetPreviousNodeTrailingComments(id);return this.parseDo(this.startNodeAtNode(id),true);}}if(_canBeArrow&&this.match(19)&&!this.canInsertSemicolon()){this.next();return this.parseArrowExpression(this.startNodeAtNode(id),[id],false);}return id;}else {this.unexpected();}}}},{key:"parseTopicReferenceThenEqualsSign",value:function parseTopicReferenceThenEqualsSign(topicTokenType,topicTokenValue){var pipeProposal=this.getPluginOption("pipelineOperator","proposal");if(pipeProposal){this.state.type=topicTokenType;this.state.value=topicTokenValue;this.state.pos--;this.state.end--;this.state.endLoc=createPositionWithColumnOffset(this.state.endLoc,-1);return this.parseTopicReference(pipeProposal);}else {this.unexpected();}}},{key:"parseTopicReference",value:function parseTopicReference(pipeProposal){var node=this.startNode();var startLoc=this.state.startLoc;var tokenType=this.state.type;this.next();return this.finishTopicReference(node,startLoc,pipeProposal,tokenType);}},{key:"finishTopicReference",value:function finishTopicReference(node,startLoc,pipeProposal,tokenType){if(this.testTopicReferenceConfiguration(pipeProposal,startLoc,tokenType)){if(pipeProposal==="hack"){if(!this.topicReferenceIsAllowedInCurrentContext()){this.raise(Errors.PipeTopicUnbound,startLoc);}this.registerTopicReference();return this.finishNode(node,"TopicReference");}else {if(!this.topicReferenceIsAllowedInCurrentContext()){this.raise(Errors.PrimaryTopicNotAllowed,startLoc);}this.registerTopicReference();return this.finishNode(node,"PipelinePrimaryTopicReference");}}else {throw this.raise(Errors.PipeTopicUnconfiguredToken,startLoc,{token:tokenLabelName(tokenType)});}}},{key:"testTopicReferenceConfiguration",value:function testTopicReferenceConfiguration(pipeProposal,startLoc,tokenType){switch(pipeProposal){case "hack":{return this.hasPlugin(["pipelineOperator",{topicToken:tokenLabelName(tokenType)}]);}case "smart":return tokenType===27;default:throw this.raise(Errors.PipeTopicRequiresHackPipes,startLoc);}}},{key:"parseAsyncArrowUnaryFunction",value:function parseAsyncArrowUnaryFunction(node){this.prodParam.enter(functionFlags(true,this.prodParam.hasYield));var params=[this.parseIdentifier()];this.prodParam.exit();if(this.hasPrecedingLineBreak()){this.raise(Errors.LineTerminatorBeforeArrow,this.state.curPosition());}this.expect(19);return this.parseArrowExpression(node,params,true);}},{key:"parseDo",value:function parseDo(node,isAsync){this.expectPlugin("doExpressions");if(isAsync){this.expectPlugin("asyncDoExpressions");}node.async=isAsync;this.next();var oldLabels=this.state.labels;this.state.labels=[];if(isAsync){this.prodParam.enter(2);node.body=this.parseBlock();this.prodParam.exit();}else {node.body=this.parseBlock();}this.state.labels=oldLabels;return this.finishNode(node,"DoExpression");}},{key:"parseSuper",value:function parseSuper(){var node=this.startNode();this.next();if(this.match(10)&&!this.scope.allowDirectSuper&&!(this.optionFlags&16)){this.raise(Errors.SuperNotAllowed,node);}else if(!this.scope.allowSuper&&!(this.optionFlags&16)){this.raise(Errors.UnexpectedSuper,node);}if(!this.match(10)&&!this.match(0)&&!this.match(16)){this.raise(Errors.UnsupportedSuper,node);}return this.finishNode(node,"Super");}},{key:"parsePrivateName",value:function parsePrivateName(){var node=this.startNode();var id=this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc,1));var name=this.state.value;this.next();node.id=this.createIdentifier(id,name);return this.finishNode(node,"PrivateName");}},{key:"parseFunctionOrFunctionSent",value:function parseFunctionOrFunctionSent(){var node=this.startNode();this.next();if(this.prodParam.hasYield&&this.match(16)){var meta=this.createIdentifier(this.startNodeAtNode(node),"function");this.next();if(this.match(103)){this.expectPlugin("functionSent");}else if(!this.hasPlugin("functionSent")){this.unexpected();}return this.parseMetaProperty(node,meta,"sent");}return this.parseFunction(node);}},{key:"parseMetaProperty",value:function parseMetaProperty(node,meta,propertyName){node.meta=meta;var containsEsc=this.state.containsEsc;node.property=this.parseIdentifier(true);if(node.property.name!==propertyName||containsEsc){this.raise(Errors.UnsupportedMetaProperty,node.property,{target:meta.name,onlyValidPropertyName:propertyName});}return this.finishNode(node,"MetaProperty");}},{key:"parseImportMetaProperty",value:function parseImportMetaProperty(node){var id=this.createIdentifier(this.startNodeAtNode(node),"import");this.next();if(this.isContextual(101)){if(!this.inModule){this.raise(Errors.ImportMetaOutsideModule,id);}this.sawUnambiguousESM=true;}else if(this.isContextual(105)||this.isContextual(97)){var isSource=this.isContextual(105);this.expectPlugin(isSource?"sourcePhaseImports":"deferredImportEvaluation");if(!(this.optionFlags&256)){throw this.raise(Errors.DynamicImportPhaseRequiresImportExpressions,this.state.startLoc,{phase:this.state.value});}this.next();node.phase=isSource?"source":"defer";return this.parseImportCall(node);}return this.parseMetaProperty(node,id,"meta");}},{key:"parseLiteralAtNode",value:function parseLiteralAtNode(value,type,node){this.addExtra(node,"rawValue",value);this.addExtra(node,"raw",this.input.slice(this.offsetToSourcePos(node.start),this.state.end));node.value=value;this.next();return this.finishNode(node,type);}},{key:"parseLiteral",value:function parseLiteral(value,type){var node=this.startNode();return this.parseLiteralAtNode(value,type,node);}},{key:"parseStringLiteral",value:function parseStringLiteral(value){return this.parseLiteral(value,"StringLiteral");}},{key:"parseNumericLiteral",value:function parseNumericLiteral(value){return this.parseLiteral(value,"NumericLiteral");}},{key:"parseBigIntLiteral",value:function parseBigIntLiteral(value){return this.parseLiteral(value,"BigIntLiteral");}},{key:"parseDecimalLiteral",value:function parseDecimalLiteral(value){return this.parseLiteral(value,"DecimalLiteral");}},{key:"parseRegExpLiteral",value:function parseRegExpLiteral(value){var node=this.startNode();this.addExtra(node,"raw",this.input.slice(this.offsetToSourcePos(node.start),this.state.end));node.pattern=value.pattern;node.flags=value.flags;this.next();return this.finishNode(node,"RegExpLiteral");}},{key:"parseBooleanLiteral",value:function parseBooleanLiteral(value){var node=this.startNode();node.value=value;this.next();return this.finishNode(node,"BooleanLiteral");}},{key:"parseNullLiteral",value:function parseNullLiteral(){var node=this.startNode();this.next();return this.finishNode(node,"NullLiteral");}},{key:"parseParenAndDistinguishExpression",value:function parseParenAndDistinguishExpression(canBeArrow){var startLoc=this.state.startLoc;var val;this.next();this.expressionScope.enter(newArrowHeadScope());var oldMaybeInArrowParameters=this.state.maybeInArrowParameters;var oldInFSharpPipelineDirectBody=this.state.inFSharpPipelineDirectBody;this.state.maybeInArrowParameters=true;this.state.inFSharpPipelineDirectBody=false;var innerStartLoc=this.state.startLoc;var exprList=[];var refExpressionErrors=new ExpressionErrors();var first=true;var spreadStartLoc;var optionalCommaStartLoc;while(!this.match(11)){if(first){first=false;}else {this.expect(12,refExpressionErrors.optionalParametersLoc===null?null:refExpressionErrors.optionalParametersLoc);if(this.match(11)){optionalCommaStartLoc=this.state.startLoc;break;}}if(this.match(21)){var spreadNodeStartLoc=this.state.startLoc;spreadStartLoc=this.state.startLoc;exprList.push(this.parseParenItem(this.parseRestBinding(),spreadNodeStartLoc));if(!this.checkCommaAfterRest(41)){break;}}else {exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors,this.parseParenItem));}}var innerEndLoc=this.state.lastTokEndLoc;this.expect(11);this.state.maybeInArrowParameters=oldMaybeInArrowParameters;this.state.inFSharpPipelineDirectBody=oldInFSharpPipelineDirectBody;var arrowNode=this.startNodeAt(startLoc);if(canBeArrow&&this.shouldParseArrow(exprList)&&(arrowNode=this.parseArrow(arrowNode))){this.checkDestructuringPrivate(refExpressionErrors);this.expressionScope.validateAsPattern();this.expressionScope.exit();this.parseArrowExpression(arrowNode,exprList,false);return arrowNode;}this.expressionScope.exit();if(!exprList.length){this.unexpected(this.state.lastTokStartLoc);}if(optionalCommaStartLoc)this.unexpected(optionalCommaStartLoc);if(spreadStartLoc)this.unexpected(spreadStartLoc);this.checkExpressionErrors(refExpressionErrors,true);this.toReferencedListDeep(exprList,true);if(exprList.length>1){val=this.startNodeAt(innerStartLoc);val.expressions=exprList;this.finishNode(val,"SequenceExpression");this.resetEndLocation(val,innerEndLoc);}else {val=exprList[0];}return this.wrapParenthesis(startLoc,val);}},{key:"wrapParenthesis",value:function wrapParenthesis(startLoc,expression){if(!(this.optionFlags&512)){this.addExtra(expression,"parenthesized",true);this.addExtra(expression,"parenStart",startLoc.index);this.takeSurroundingComments(expression,startLoc.index,this.state.lastTokEndLoc.index);return expression;}var parenExpression=this.startNodeAt(startLoc);parenExpression.expression=expression;return this.finishNode(parenExpression,"ParenthesizedExpression");}},{key:"shouldParseArrow",value:function shouldParseArrow(params){return !this.canInsertSemicolon();}},{key:"parseArrow",value:function parseArrow(node){if(this.eat(19)){return node;}}},{key:"parseParenItem",value:function parseParenItem(node,startLoc){return node;}},{key:"parseNewOrNewTarget",value:function parseNewOrNewTarget(){var node=this.startNode();this.next();if(this.match(16)){var meta=this.createIdentifier(this.startNodeAtNode(node),"new");this.next();var metaProp=this.parseMetaProperty(node,meta,"target");if(!this.scope.inNonArrowFunction&&!this.scope.inClass&&!(this.optionFlags&4)){this.raise(Errors.UnexpectedNewTarget,metaProp);}return metaProp;}return this.parseNew(node);}},{key:"parseNew",value:function parseNew(node){this.parseNewCallee(node);if(this.eat(10)){var args=this.parseExprList(11);this.toReferencedList(args);node.arguments=args;}else {node.arguments=[];}return this.finishNode(node,"NewExpression");}},{key:"parseNewCallee",value:function parseNewCallee(node){var isImport=this.match(83);var callee=this.parseNoCallExpr();node.callee=callee;if(isImport&&(callee.type==="Import"||callee.type==="ImportExpression")){this.raise(Errors.ImportCallNotNewExpression,callee);}}},{key:"parseTemplateElement",value:function parseTemplateElement(isTagged){var _this$state4=this.state,start=_this$state4.start,startLoc=_this$state4.startLoc,end=_this$state4.end,value=_this$state4.value;var elemStart=start+1;var elem=this.startNodeAt(createPositionWithColumnOffset(startLoc,1));if(value===null){if(!isTagged){this.raise(Errors.InvalidEscapeSequenceTemplate,createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos,1));}}var isTail=this.match(24);var endOffset=isTail?-1:-2;var elemEnd=end+endOffset;elem.value={raw:this.input.slice(elemStart,elemEnd).replace(/\r\n?/g,"\n"),cooked:value===null?null:value.slice(1,endOffset)};elem.tail=isTail;this.next();var finishedNode=this.finishNode(elem,"TemplateElement");this.resetEndLocation(finishedNode,createPositionWithColumnOffset(this.state.lastTokEndLoc,endOffset));return finishedNode;}},{key:"parseTemplate",value:function parseTemplate(isTagged){var node=this.startNode();var curElt=this.parseTemplateElement(isTagged);var quasis=[curElt];var substitutions=[];while(!curElt.tail){substitutions.push(this.parseTemplateSubstitution());this.readTemplateContinuation();quasis.push(curElt=this.parseTemplateElement(isTagged));}node.expressions=substitutions;node.quasis=quasis;return this.finishNode(node,"TemplateLiteral");}},{key:"parseTemplateSubstitution",value:function parseTemplateSubstitution(){return this.parseExpression();}},{key:"parseObjectLike",value:function parseObjectLike(close,isPattern,isRecord,refExpressionErrors){if(isRecord){this.expectPlugin("recordAndTuple");}var oldInFSharpPipelineDirectBody=this.state.inFSharpPipelineDirectBody;this.state.inFSharpPipelineDirectBody=false;var propHash=Object.create(null);var first=true;var node=this.startNode();node.properties=[];this.next();while(!this.match(close)){if(first){first=false;}else {this.expect(12);if(this.match(close)){this.addTrailingCommaExtraToNode(node);break;}}var prop=void 0;if(isPattern){prop=this.parseBindingProperty();}else {prop=this.parsePropertyDefinition(refExpressionErrors);this.checkProto(prop,isRecord,propHash,refExpressionErrors);}if(isRecord&&!this.isObjectProperty(prop)&&prop.type!=="SpreadElement"){this.raise(Errors.InvalidRecordProperty,prop);}{if(prop.shorthand){this.addExtra(prop,"shorthand",true);}}node.properties.push(prop);}this.next();this.state.inFSharpPipelineDirectBody=oldInFSharpPipelineDirectBody;var type="ObjectExpression";if(isPattern){type="ObjectPattern";}else if(isRecord){type="RecordExpression";}return this.finishNode(node,type);}},{key:"addTrailingCommaExtraToNode",value:function addTrailingCommaExtraToNode(node){this.addExtra(node,"trailingComma",this.state.lastTokStartLoc.index);this.addExtra(node,"trailingCommaLoc",this.state.lastTokStartLoc,false);}},{key:"maybeAsyncOrAccessorProp",value:function maybeAsyncOrAccessorProp(prop){return !prop.computed&&prop.key.type==="Identifier"&&(this.isLiteralPropertyName()||this.match(0)||this.match(55));}},{key:"parsePropertyDefinition",value:function parsePropertyDefinition(refExpressionErrors){var decorators=[];if(this.match(26)){if(this.hasPlugin("decorators")){this.raise(Errors.UnsupportedPropertyDecorator,this.state.startLoc);}while(this.match(26)){decorators.push(this.parseDecorator());}}var prop=this.startNode();var isAsync=false;var isAccessor=false;var startLoc;if(this.match(21)){if(decorators.length)this.unexpected();return this.parseSpread();}if(decorators.length){prop.decorators=decorators;decorators=[];}prop.method=false;if(refExpressionErrors){startLoc=this.state.startLoc;}var isGenerator=this.eat(55);this.parsePropertyNamePrefixOperator(prop);var containsEsc=this.state.containsEsc;this.parsePropertyName(prop,refExpressionErrors);if(!isGenerator&&!containsEsc&&this.maybeAsyncOrAccessorProp(prop)){var key=prop.key;var keyName=key.name;if(keyName==="async"&&!this.hasPrecedingLineBreak()){isAsync=true;this.resetPreviousNodeTrailingComments(key);isGenerator=this.eat(55);this.parsePropertyName(prop);}if(keyName==="get"||keyName==="set"){isAccessor=true;this.resetPreviousNodeTrailingComments(key);prop.kind=keyName;if(this.match(55)){isGenerator=true;this.raise(Errors.AccessorIsGenerator,this.state.curPosition(),{kind:keyName});this.next();}this.parsePropertyName(prop);}}return this.parseObjPropValue(prop,startLoc,isGenerator,isAsync,false,isAccessor,refExpressionErrors);}},{key:"getGetterSetterExpectedParamCount",value:function getGetterSetterExpectedParamCount(method){return method.kind==="get"?0:1;}},{key:"getObjectOrClassMethodParams",value:function getObjectOrClassMethodParams(method){return method.params;}},{key:"checkGetterSetterParams",value:function checkGetterSetterParams(method){var _params;var paramCount=this.getGetterSetterExpectedParamCount(method);var params=this.getObjectOrClassMethodParams(method);if(params.length!==paramCount){this.raise(method.kind==="get"?Errors.BadGetterArity:Errors.BadSetterArity,method);}if(method.kind==="set"&&((_params=params[params.length-1])==null?void 0:_params.type)==="RestElement"){this.raise(Errors.BadSetterRestParameter,method);}}},{key:"parseObjectMethod",value:function parseObjectMethod(prop,isGenerator,isAsync,isPattern,isAccessor){if(isAccessor){var finishedProp=this.parseMethod(prop,isGenerator,false,false,false,"ObjectMethod");this.checkGetterSetterParams(finishedProp);return finishedProp;}if(isAsync||isGenerator||this.match(10)){if(isPattern)this.unexpected();prop.kind="method";prop.method=true;return this.parseMethod(prop,isGenerator,isAsync,false,false,"ObjectMethod");}}},{key:"parseObjectProperty",value:function parseObjectProperty(prop,startLoc,isPattern,refExpressionErrors){prop.shorthand=false;if(this.eat(14)){prop.value=isPattern?this.parseMaybeDefault(this.state.startLoc):this.parseMaybeAssignAllowIn(refExpressionErrors);return this.finishNode(prop,"ObjectProperty");}if(!prop.computed&&prop.key.type==="Identifier"){this.checkReservedWord(prop.key.name,prop.key.loc.start,true,false);if(isPattern){prop.value=this.parseMaybeDefault(startLoc,cloneIdentifier(prop.key));}else if(this.match(29)){var shorthandAssignLoc=this.state.startLoc;if(refExpressionErrors!=null){if(refExpressionErrors.shorthandAssignLoc===null){refExpressionErrors.shorthandAssignLoc=shorthandAssignLoc;}}else {this.raise(Errors.InvalidCoverInitializedName,shorthandAssignLoc);}prop.value=this.parseMaybeDefault(startLoc,cloneIdentifier(prop.key));}else {prop.value=cloneIdentifier(prop.key);}prop.shorthand=true;return this.finishNode(prop,"ObjectProperty");}}},{key:"parseObjPropValue",value:function parseObjPropValue(prop,startLoc,isGenerator,isAsync,isPattern,isAccessor,refExpressionErrors){var node=this.parseObjectMethod(prop,isGenerator,isAsync,isPattern,isAccessor)||this.parseObjectProperty(prop,startLoc,isPattern,refExpressionErrors);if(!node)this.unexpected();return node;}},{key:"parsePropertyName",value:function parsePropertyName(prop,refExpressionErrors){if(this.eat(0)){prop.computed=true;prop.key=this.parseMaybeAssignAllowIn();this.expect(3);}else {var _this$state5=this.state,type=_this$state5.type,value=_this$state5.value;var key;if(tokenIsKeywordOrIdentifier(type)){key=this.parseIdentifier(true);}else {switch(type){case 135:key=this.parseNumericLiteral(value);break;case 134:key=this.parseStringLiteral(value);break;case 136:key=this.parseBigIntLiteral(value);break;case 139:{var privateKeyLoc=this.state.startLoc;if(refExpressionErrors!=null){if(refExpressionErrors.privateKeyLoc===null){refExpressionErrors.privateKeyLoc=privateKeyLoc;}}else {this.raise(Errors.UnexpectedPrivateField,privateKeyLoc);}key=this.parsePrivateName();break;}default:if(type===137){key=this.parseDecimalLiteral(value);break;}this.unexpected();}}prop.key=key;if(type!==139){prop.computed=false;}}}},{key:"initFunction",value:function initFunction(node,isAsync){node.id=null;node.generator=false;node.async=isAsync;}},{key:"parseMethod",value:function parseMethod(node,isGenerator,isAsync,isConstructor,allowDirectSuper,type){var inClassScope=arguments.length>6&&arguments[6]!==undefined?arguments[6]:false;this.initFunction(node,isAsync);node.generator=isGenerator;this.scope.enter(2|16|(inClassScope?64:0)|(allowDirectSuper?32:0));this.prodParam.enter(functionFlags(isAsync,node.generator));this.parseFunctionParams(node,isConstructor);var finishedNode=this.parseFunctionBodyAndFinish(node,type,true);this.prodParam.exit();this.scope.exit();return finishedNode;}},{key:"parseArrayLike",value:function parseArrayLike(close,canBePattern,isTuple,refExpressionErrors){if(isTuple){this.expectPlugin("recordAndTuple");}var oldInFSharpPipelineDirectBody=this.state.inFSharpPipelineDirectBody;this.state.inFSharpPipelineDirectBody=false;var node=this.startNode();this.next();node.elements=this.parseExprList(close,!isTuple,refExpressionErrors,node);this.state.inFSharpPipelineDirectBody=oldInFSharpPipelineDirectBody;return this.finishNode(node,isTuple?"TupleExpression":"ArrayExpression");}},{key:"parseArrowExpression",value:function parseArrowExpression(node,params,isAsync,trailingCommaLoc){this.scope.enter(2|4);var flags=functionFlags(isAsync,false);if(!this.match(5)&&this.prodParam.hasIn){flags|=8;}this.prodParam.enter(flags);this.initFunction(node,isAsync);var oldMaybeInArrowParameters=this.state.maybeInArrowParameters;if(params){this.state.maybeInArrowParameters=true;this.setArrowFunctionParameters(node,params,trailingCommaLoc);}this.state.maybeInArrowParameters=false;this.parseFunctionBody(node,true);this.prodParam.exit();this.scope.exit();this.state.maybeInArrowParameters=oldMaybeInArrowParameters;return this.finishNode(node,"ArrowFunctionExpression");}},{key:"setArrowFunctionParameters",value:function setArrowFunctionParameters(node,params,trailingCommaLoc){this.toAssignableList(params,trailingCommaLoc,false);node.params=params;}},{key:"parseFunctionBodyAndFinish",value:function parseFunctionBodyAndFinish(node,type){var isMethod=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;this.parseFunctionBody(node,false,isMethod);return this.finishNode(node,type);}},{key:"parseFunctionBody",value:function parseFunctionBody(node,allowExpression){var _this59=this;var isMethod=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var isExpression=allowExpression&&!this.match(5);this.expressionScope.enter(newExpressionScope());if(isExpression){node.body=this.parseMaybeAssign();this.checkParams(node,false,allowExpression,false);}else {var oldStrict=this.state.strict;var oldLabels=this.state.labels;this.state.labels=[];this.prodParam.enter(this.prodParam.currentFlags()|4);node.body=this.parseBlock(true,false,function(hasStrictModeDirective){var nonSimple=!_this59.isSimpleParamList(node.params);if(hasStrictModeDirective&&nonSimple){_this59.raise(Errors.IllegalLanguageModeDirective,(node.kind==="method"||node.kind==="constructor")&&!!node.key?node.key.loc.end:node);}var strictModeChanged=!oldStrict&&_this59.state.strict;_this59.checkParams(node,!_this59.state.strict&&!allowExpression&&!isMethod&&!nonSimple,allowExpression,strictModeChanged);if(_this59.state.strict&&node.id){_this59.checkIdentifier(node.id,65,strictModeChanged);}});this.prodParam.exit();this.state.labels=oldLabels;}this.expressionScope.exit();}},{key:"isSimpleParameter",value:function isSimpleParameter(node){return node.type==="Identifier";}},{key:"isSimpleParamList",value:function isSimpleParamList(params){for(var i=0,len=params.length;i<len;i++){if(!this.isSimpleParameter(params[i]))return false;}return true;}},{key:"checkParams",value:function checkParams(node,allowDuplicates,isArrowFunction){var strictModeChanged=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;var checkClashes=!allowDuplicates&&new Set();var formalParameters={type:"FormalParameters"};var _iterator12=_createForOfIteratorHelper(node.params),_step12;try{for(_iterator12.s();!(_step12=_iterator12.n()).done;){var param=_step12.value;this.checkLVal(param,formalParameters,5,checkClashes,strictModeChanged);}}catch(err){_iterator12.e(err);}finally{_iterator12.f();}}},{key:"parseExprList",value:function parseExprList(close,allowEmpty,refExpressionErrors,nodeForExtra){var elts=[];var first=true;while(!this.eat(close)){if(first){first=false;}else {this.expect(12);if(this.match(close)){if(nodeForExtra){this.addTrailingCommaExtraToNode(nodeForExtra);}this.next();break;}}elts.push(this.parseExprListItem(allowEmpty,refExpressionErrors));}return elts;}},{key:"parseExprListItem",value:function parseExprListItem(allowEmpty,refExpressionErrors,allowPlaceholder){var elt;if(this.match(12)){if(!allowEmpty){this.raise(Errors.UnexpectedToken,this.state.curPosition(),{unexpected:","});}elt=null;}else if(this.match(21)){var spreadNodeStartLoc=this.state.startLoc;elt=this.parseParenItem(this.parseSpread(refExpressionErrors),spreadNodeStartLoc);}else if(this.match(17)){this.expectPlugin("partialApplication");if(!allowPlaceholder){this.raise(Errors.UnexpectedArgumentPlaceholder,this.state.startLoc);}var node=this.startNode();this.next();elt=this.finishNode(node,"ArgumentPlaceholder");}else {elt=this.parseMaybeAssignAllowIn(refExpressionErrors,this.parseParenItem);}return elt;}},{key:"parseIdentifier",value:function parseIdentifier(liberal){var node=this.startNode();var name=this.parseIdentifierName(liberal);return this.createIdentifier(node,name);}},{key:"createIdentifier",value:function createIdentifier(node,name){node.name=name;node.loc.identifierName=name;return this.finishNode(node,"Identifier");}},{key:"parseIdentifierName",value:function parseIdentifierName(liberal){var name;var _this$state6=this.state,startLoc=_this$state6.startLoc,type=_this$state6.type;if(tokenIsKeywordOrIdentifier(type)){name=this.state.value;}else {this.unexpected();}var tokenIsKeyword=tokenKeywordOrIdentifierIsKeyword(type);if(liberal){if(tokenIsKeyword){this.replaceToken(132);}}else {this.checkReservedWord(name,startLoc,tokenIsKeyword,false);}this.next();return name;}},{key:"checkReservedWord",value:function checkReservedWord(word,startLoc,checkKeywords,isBinding){if(word.length>10){return;}if(!canBeReservedWord(word)){return;}if(checkKeywords&&isKeyword(word)){this.raise(Errors.UnexpectedKeyword,startLoc,{keyword:word});return;}var reservedTest=!this.state.strict?isReservedWord:isBinding?isStrictBindReservedWord:isStrictReservedWord;if(reservedTest(word,this.inModule)){this.raise(Errors.UnexpectedReservedWord,startLoc,{reservedWord:word});return;}else if(word==="yield"){if(this.prodParam.hasYield){this.raise(Errors.YieldBindingIdentifier,startLoc);return;}}else if(word==="await"){if(this.prodParam.hasAwait){this.raise(Errors.AwaitBindingIdentifier,startLoc);return;}if(this.scope.inStaticBlock){this.raise(Errors.AwaitBindingIdentifierInStaticBlock,startLoc);return;}this.expressionScope.recordAsyncArrowParametersError(startLoc);}else if(word==="arguments"){if(this.scope.inClassAndNotInNonArrowFunction){this.raise(Errors.ArgumentsInClass,startLoc);return;}}}},{key:"recordAwaitIfAllowed",value:function recordAwaitIfAllowed(){var isAwaitAllowed=this.prodParam.hasAwait||this.optionFlags&1&&!this.scope.inFunction;if(isAwaitAllowed&&!this.scope.inFunction){this.state.hasTopLevelAwait=true;}return isAwaitAllowed;}},{key:"parseAwait",value:function parseAwait(startLoc){var node=this.startNodeAt(startLoc);this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter,node);if(this.eat(55)){this.raise(Errors.ObsoleteAwaitStar,node);}if(!this.scope.inFunction&&!(this.optionFlags&1)){if(this.isAmbiguousAwait()){this.ambiguousScriptDifferentAst=true;}else {this.sawUnambiguousESM=true;}}if(!this.state.soloAwait){node.argument=this.parseMaybeUnary(null,true);}return this.finishNode(node,"AwaitExpression");}},{key:"isAmbiguousAwait",value:function isAmbiguousAwait(){if(this.hasPrecedingLineBreak())return true;var type=this.state.type;return type===53||type===10||type===0||tokenIsTemplate(type)||type===102&&!this.state.containsEsc||type===138||type===56||this.hasPlugin("v8intrinsic")&&type===54;}},{key:"parseYield",value:function parseYield(){var node=this.startNode();this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter,node);this.next();var delegating=false;var argument=null;if(!this.hasPrecedingLineBreak()){delegating=this.eat(55);switch(this.state.type){case 13:case 140:case 8:case 11:case 3:case 9:case 14:case 12:if(!delegating)break;default:argument=this.parseMaybeAssign();}}node.delegate=delegating;node.argument=argument;return this.finishNode(node,"YieldExpression");}},{key:"parseImportCall",value:function parseImportCall(node){this.next();node.source=this.parseMaybeAssignAllowIn();node.options=null;if(this.eat(12)){if(!this.match(11)){node.options=this.parseMaybeAssignAllowIn();if(this.eat(12)&&!this.match(11)){do{this.parseMaybeAssignAllowIn();}while(this.eat(12)&&!this.match(11));this.raise(Errors.ImportCallArity,node);}}}this.expect(11);return this.finishNode(node,"ImportExpression");}},{key:"checkPipelineAtInfixOperator",value:function checkPipelineAtInfixOperator(left,leftStartLoc){if(this.hasPlugin(["pipelineOperator",{proposal:"smart"}])){if(left.type==="SequenceExpression"){this.raise(Errors.PipelineHeadSequenceExpression,leftStartLoc);}}}},{key:"parseSmartPipelineBodyInStyle",value:function parseSmartPipelineBodyInStyle(childExpr,startLoc){if(this.isSimpleReference(childExpr)){var bodyNode=this.startNodeAt(startLoc);bodyNode.callee=childExpr;return this.finishNode(bodyNode,"PipelineBareFunction");}else {var _bodyNode2=this.startNodeAt(startLoc);this.checkSmartPipeTopicBodyEarlyErrors(startLoc);_bodyNode2.expression=childExpr;return this.finishNode(_bodyNode2,"PipelineTopicExpression");}}},{key:"isSimpleReference",value:function isSimpleReference(expression){switch(expression.type){case "MemberExpression":return !expression.computed&&this.isSimpleReference(expression.object);case "Identifier":return true;default:return false;}}},{key:"checkSmartPipeTopicBodyEarlyErrors",value:function checkSmartPipeTopicBodyEarlyErrors(startLoc){if(this.match(19)){throw this.raise(Errors.PipelineBodyNoArrow,this.state.startLoc);}if(!this.topicReferenceWasUsedInCurrentContext()){this.raise(Errors.PipelineTopicUnused,startLoc);}}},{key:"withTopicBindingContext",value:function withTopicBindingContext(callback){var outerContextTopicState=this.state.topicContext;this.state.topicContext={maxNumOfResolvableTopics:1,maxTopicIndex:null};try{return callback();}finally{this.state.topicContext=outerContextTopicState;}}},{key:"withSmartMixTopicForbiddingContext",value:function withSmartMixTopicForbiddingContext(callback){if(this.hasPlugin(["pipelineOperator",{proposal:"smart"}])){var outerContextTopicState=this.state.topicContext;this.state.topicContext={maxNumOfResolvableTopics:0,maxTopicIndex:null};try{return callback();}finally{this.state.topicContext=outerContextTopicState;}}else {return callback();}}},{key:"withSoloAwaitPermittingContext",value:function withSoloAwaitPermittingContext(callback){var outerContextSoloAwaitState=this.state.soloAwait;this.state.soloAwait=true;try{return callback();}finally{this.state.soloAwait=outerContextSoloAwaitState;}}},{key:"allowInAnd",value:function allowInAnd(callback){var flags=this.prodParam.currentFlags();var prodParamToSet=8&~flags;if(prodParamToSet){this.prodParam.enter(flags|8);try{return callback();}finally{this.prodParam.exit();}}return callback();}},{key:"disallowInAnd",value:function disallowInAnd(callback){var flags=this.prodParam.currentFlags();var prodParamToClear=8&flags;if(prodParamToClear){this.prodParam.enter(flags&-9);try{return callback();}finally{this.prodParam.exit();}}return callback();}},{key:"registerTopicReference",value:function registerTopicReference(){this.state.topicContext.maxTopicIndex=0;}},{key:"topicReferenceIsAllowedInCurrentContext",value:function topicReferenceIsAllowedInCurrentContext(){return this.state.topicContext.maxNumOfResolvableTopics>=1;}},{key:"topicReferenceWasUsedInCurrentContext",value:function topicReferenceWasUsedInCurrentContext(){return this.state.topicContext.maxTopicIndex!=null&&this.state.topicContext.maxTopicIndex>=0;}},{key:"parseFSharpPipelineBody",value:function parseFSharpPipelineBody(prec){var startLoc=this.state.startLoc;this.state.potentialArrowAt=this.state.start;var oldInFSharpPipelineDirectBody=this.state.inFSharpPipelineDirectBody;this.state.inFSharpPipelineDirectBody=true;var ret=this.parseExprOp(this.parseMaybeUnaryOrPrivate(),startLoc,prec);this.state.inFSharpPipelineDirectBody=oldInFSharpPipelineDirectBody;return ret;}},{key:"parseModuleExpression",value:function parseModuleExpression(){this.expectPlugin("moduleBlocks");var node=this.startNode();this.next();if(!this.match(5)){this.unexpected(null,5);}var program=this.startNodeAt(this.state.endLoc);this.next();var revertScopes=this.initializeScopes(true);this.enterInitialScopes();try{node.body=this.parseProgram(program,8,"module");}finally{revertScopes();}return this.finishNode(node,"ModuleExpression");}},{key:"parsePropertyNamePrefixOperator",value:function parsePropertyNamePrefixOperator(prop){}}]);}(LValParser);var loopLabel={kind:1},switchLabel={kind:2};var loneSurrogate=/(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;var keywordRelationalOperator=new RegExp("in(?:stanceof)?","y");function babel7CompatTokens(tokens,input,startIndex){for(var i=0;i<tokens.length;i++){var token=tokens[i];var type=token.type;if(typeof type==="number"){{if(type===139){var loc=token.loc,start=token.start,value=token.value,end=token.end;var hashEndPos=start+1;var hashEndLoc=createPositionWithColumnOffset(loc.start,1);tokens.splice(i,1,new Token({type:getExportedToken(27),value:"#",start:start,end:hashEndPos,startLoc:loc.start,endLoc:hashEndLoc}),new Token({type:getExportedToken(132),value:value,start:hashEndPos,end:end,startLoc:hashEndLoc,endLoc:loc.end}));i++;continue;}if(tokenIsTemplate(type)){var _loc=token.loc,_start=token.start,_value=token.value,_end=token.end;var backquoteEnd=_start+1;var backquoteEndLoc=createPositionWithColumnOffset(_loc.start,1);var startToken=void 0;if(input.charCodeAt(_start-startIndex)===96){startToken=new Token({type:getExportedToken(22),value:"`",start:_start,end:backquoteEnd,startLoc:_loc.start,endLoc:backquoteEndLoc});}else {startToken=new Token({type:getExportedToken(8),value:"}",start:_start,end:backquoteEnd,startLoc:_loc.start,endLoc:backquoteEndLoc});}var templateValue=void 0,templateElementEnd=void 0,templateElementEndLoc=void 0,endToken=void 0;if(type===24){templateElementEnd=_end-1;templateElementEndLoc=createPositionWithColumnOffset(_loc.end,-1);templateValue=_value===null?null:_value.slice(1,-1);endToken=new Token({type:getExportedToken(22),value:"`",start:templateElementEnd,end:_end,startLoc:templateElementEndLoc,endLoc:_loc.end});}else {templateElementEnd=_end-2;templateElementEndLoc=createPositionWithColumnOffset(_loc.end,-2);templateValue=_value===null?null:_value.slice(1,-2);endToken=new Token({type:getExportedToken(23),value:"${",start:templateElementEnd,end:_end,startLoc:templateElementEndLoc,endLoc:_loc.end});}tokens.splice(i,1,startToken,new Token({type:getExportedToken(20),value:templateValue,start:backquoteEnd,end:templateElementEnd,startLoc:backquoteEndLoc,endLoc:templateElementEndLoc}),endToken);i+=2;continue;}}token.type=getExportedToken(type);}}return tokens;}var StatementParser=/*#__PURE__*/function(_ExpressionParser){function StatementParser(){_classCallCheck(this,StatementParser);return _callSuper(this,StatementParser,arguments);}_inherits(StatementParser,_ExpressionParser);return _createClass(StatementParser,[{key:"parseTopLevel",value:function parseTopLevel(file,program){file.program=this.parseProgram(program);file.comments=this.comments;if(this.optionFlags&128){file.tokens=babel7CompatTokens(this.tokens,this.input,this.startIndex);}return this.finishNode(file,"File");}},{key:"parseProgram",value:function parseProgram(program){var end=arguments.length>1&&arguments[1]!==undefined?arguments[1]:140;var sourceType=arguments.length>2&&arguments[2]!==undefined?arguments[2]:this.options.sourceType;program.sourceType=sourceType;program.interpreter=this.parseInterpreterDirective();this.parseBlockBody(program,true,true,end);if(this.inModule){if(!(this.optionFlags&32)&&this.scope.undefinedExports.size>0){for(var _i5=0,_Array$from2=Array.from(this.scope.undefinedExports);_i5<_Array$from2.length;_i5++){var _Array$from2$_i=_slicedToArray(_Array$from2[_i5],2),localName=_Array$from2$_i[0],at=_Array$from2$_i[1];this.raise(Errors.ModuleExportUndefined,at,{localName:localName});}}this.addExtra(program,"topLevelAwait",this.state.hasTopLevelAwait);}var finishedProgram;if(end===140){finishedProgram=this.finishNode(program,"Program");}else {finishedProgram=this.finishNodeAt(program,"Program",createPositionWithColumnOffset(this.state.startLoc,-1));}return finishedProgram;}},{key:"stmtToDirective",value:function stmtToDirective(stmt){var directive=stmt;directive.type="Directive";directive.value=directive.expression;delete directive.expression;var directiveLiteral=directive.value;var expressionValue=directiveLiteral.value;var raw=this.input.slice(this.offsetToSourcePos(directiveLiteral.start),this.offsetToSourcePos(directiveLiteral.end));var val=directiveLiteral.value=raw.slice(1,-1);this.addExtra(directiveLiteral,"raw",raw);this.addExtra(directiveLiteral,"rawValue",val);this.addExtra(directiveLiteral,"expressionValue",expressionValue);directiveLiteral.type="DirectiveLiteral";return directive;}},{key:"parseInterpreterDirective",value:function parseInterpreterDirective(){if(!this.match(28)){return null;}var node=this.startNode();node.value=this.state.value;this.next();return this.finishNode(node,"InterpreterDirective");}},{key:"isLet",value:function isLet(){if(!this.isContextual(100)){return false;}return this.hasFollowingBindingAtom();}},{key:"chStartsBindingIdentifier",value:function chStartsBindingIdentifier(ch,pos){if(isIdentifierStart(ch)){keywordRelationalOperator.lastIndex=pos;if(keywordRelationalOperator.test(this.input)){var endCh=this.codePointAtPos(keywordRelationalOperator.lastIndex);if(!isIdentifierChar(endCh)&&endCh!==92){return false;}}return true;}else if(ch===92){return true;}else {return false;}}},{key:"chStartsBindingPattern",value:function chStartsBindingPattern(ch){return ch===91||ch===123;}},{key:"hasFollowingBindingAtom",value:function hasFollowingBindingAtom(){var next=this.nextTokenStart();var nextCh=this.codePointAtPos(next);return this.chStartsBindingPattern(nextCh)||this.chStartsBindingIdentifier(nextCh,next);}},{key:"hasInLineFollowingBindingIdentifierOrBrace",value:function hasInLineFollowingBindingIdentifierOrBrace(){var next=this.nextTokenInLineStart();var nextCh=this.codePointAtPos(next);return nextCh===123||this.chStartsBindingIdentifier(nextCh,next);}},{key:"startsUsingForOf",value:function startsUsingForOf(){var _this$lookahead=this.lookahead(),type=_this$lookahead.type,containsEsc=_this$lookahead.containsEsc;if(type===102&&!containsEsc){return false;}else if(tokenIsIdentifier(type)&&!this.hasFollowingLineBreak()){this.expectPlugin("explicitResourceManagement");return true;}}},{key:"startsAwaitUsing",value:function startsAwaitUsing(){var next=this.nextTokenInLineStart();if(this.isUnparsedContextual(next,"using")){next=this.nextTokenInLineStartSince(next+5);var nextCh=this.codePointAtPos(next);if(this.chStartsBindingIdentifier(nextCh,next)){this.expectPlugin("explicitResourceManagement");return true;}}return false;}},{key:"parseModuleItem",value:function parseModuleItem(){return this.parseStatementLike(1|2|4|8);}},{key:"parseStatementListItem",value:function parseStatementListItem(){return this.parseStatementLike(2|4|(!this.options.annexB||this.state.strict?0:8));}},{key:"parseStatementOrSloppyAnnexBFunctionDeclaration",value:function parseStatementOrSloppyAnnexBFunctionDeclaration(){var allowLabeledFunction=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;var flags=0;if(this.options.annexB&&!this.state.strict){flags|=4;if(allowLabeledFunction){flags|=8;}}return this.parseStatementLike(flags);}},{key:"parseStatement",value:function parseStatement(){return this.parseStatementLike(0);}},{key:"parseStatementLike",value:function parseStatementLike(flags){var decorators=null;if(this.match(26)){decorators=this.parseDecorators(true);}return this.parseStatementContent(flags,decorators);}},{key:"parseStatementContent",value:function parseStatementContent(flags,decorators){var startType=this.state.type;var node=this.startNode();var allowDeclaration=!!(flags&2);var allowFunctionDeclaration=!!(flags&4);var topLevel=flags&1;switch(startType){case 60:return this.parseBreakContinueStatement(node,true);case 63:return this.parseBreakContinueStatement(node,false);case 64:return this.parseDebuggerStatement(node);case 90:return this.parseDoWhileStatement(node);case 91:return this.parseForStatement(node);case 68:if(this.lookaheadCharCode()===46)break;if(!allowFunctionDeclaration){this.raise(this.state.strict?Errors.StrictFunction:this.options.annexB?Errors.SloppyFunctionAnnexB:Errors.SloppyFunction,this.state.startLoc);}return this.parseFunctionStatement(node,false,!allowDeclaration&&allowFunctionDeclaration);case 80:if(!allowDeclaration)this.unexpected();return this.parseClass(this.maybeTakeDecorators(decorators,node),true);case 69:return this.parseIfStatement(node);case 70:return this.parseReturnStatement(node);case 71:return this.parseSwitchStatement(node);case 72:return this.parseThrowStatement(node);case 73:return this.parseTryStatement(node);case 96:if(!this.state.containsEsc&&this.startsAwaitUsing()){if(!this.recordAwaitIfAllowed()){this.raise(Errors.AwaitUsingNotInAsyncContext,node);}else if(!allowDeclaration){this.raise(Errors.UnexpectedLexicalDeclaration,node);}this.next();return this.parseVarStatement(node,"await using");}break;case 107:if(this.state.containsEsc||!this.hasInLineFollowingBindingIdentifierOrBrace()){break;}this.expectPlugin("explicitResourceManagement");if(!this.scope.inModule&&this.scope.inTopLevel){this.raise(Errors.UnexpectedUsingDeclaration,this.state.startLoc);}else if(!allowDeclaration){this.raise(Errors.UnexpectedLexicalDeclaration,this.state.startLoc);}return this.parseVarStatement(node,"using");case 100:{if(this.state.containsEsc){break;}var next=this.nextTokenStart();var nextCh=this.codePointAtPos(next);if(nextCh!==91){if(!allowDeclaration&&this.hasFollowingLineBreak())break;if(!this.chStartsBindingIdentifier(nextCh,next)&&nextCh!==123){break;}}}case 75:{if(!allowDeclaration){this.raise(Errors.UnexpectedLexicalDeclaration,this.state.startLoc);}}case 74:{var kind=this.state.value;return this.parseVarStatement(node,kind);}case 92:return this.parseWhileStatement(node);case 76:return this.parseWithStatement(node);case 5:return this.parseBlock();case 13:return this.parseEmptyStatement(node);case 83:{var nextTokenCharCode=this.lookaheadCharCode();if(nextTokenCharCode===40||nextTokenCharCode===46){break;}}case 82:{if(!(this.optionFlags&8)&&!topLevel){this.raise(Errors.UnexpectedImportExport,this.state.startLoc);}this.next();var result;if(startType===83){result=this.parseImport(node);if(result.type==="ImportDeclaration"&&(!result.importKind||result.importKind==="value")){this.sawUnambiguousESM=true;}}else {result=this.parseExport(node,decorators);if(result.type==="ExportNamedDeclaration"&&(!result.exportKind||result.exportKind==="value")||result.type==="ExportAllDeclaration"&&(!result.exportKind||result.exportKind==="value")||result.type==="ExportDefaultDeclaration"){this.sawUnambiguousESM=true;}}this.assertModuleNodeAllowed(result);return result;}default:{if(this.isAsyncFunction()){if(!allowDeclaration){this.raise(Errors.AsyncFunctionInSingleStatementContext,this.state.startLoc);}this.next();return this.parseFunctionStatement(node,true,!allowDeclaration&&allowFunctionDeclaration);}}}var maybeName=this.state.value;var expr=this.parseExpression();if(tokenIsIdentifier(startType)&&expr.type==="Identifier"&&this.eat(14)){return this.parseLabeledStatement(node,maybeName,expr,flags);}else {return this.parseExpressionStatement(node,expr,decorators);}}},{key:"assertModuleNodeAllowed",value:function assertModuleNodeAllowed(node){if(!(this.optionFlags&8)&&!this.inModule){this.raise(Errors.ImportOutsideModule,node);}}},{key:"decoratorsEnabledBeforeExport",value:function decoratorsEnabledBeforeExport(){if(this.hasPlugin("decorators-legacy"))return true;return this.hasPlugin("decorators")&&this.getPluginOption("decorators","decoratorsBeforeExport")!==false;}},{key:"maybeTakeDecorators",value:function maybeTakeDecorators(maybeDecorators,classNode,exportNode){if(maybeDecorators){var _classNode$decorators;if((_classNode$decorators=classNode.decorators)!=null&&_classNode$decorators.length){var _classNode$decorators2;if(typeof this.getPluginOption("decorators","decoratorsBeforeExport")!=="boolean"){this.raise(Errors.DecoratorsBeforeAfterExport,classNode.decorators[0]);}(_classNode$decorators2=classNode.decorators).unshift.apply(_classNode$decorators2,_toConsumableArray(maybeDecorators));}else {classNode.decorators=maybeDecorators;}this.resetStartLocationFromNode(classNode,maybeDecorators[0]);if(exportNode)this.resetStartLocationFromNode(exportNode,classNode);}return classNode;}},{key:"canHaveLeadingDecorator",value:function canHaveLeadingDecorator(){return this.match(80);}},{key:"parseDecorators",value:function parseDecorators(allowExport){var decorators=[];do{decorators.push(this.parseDecorator());}while(this.match(26));if(this.match(82)){if(!allowExport){this.unexpected();}if(!this.decoratorsEnabledBeforeExport()){this.raise(Errors.DecoratorExportClass,this.state.startLoc);}}else if(!this.canHaveLeadingDecorator()){throw this.raise(Errors.UnexpectedLeadingDecorator,this.state.startLoc);}return decorators;}},{key:"parseDecorator",value:function parseDecorator(){this.expectOnePlugin(["decorators","decorators-legacy"]);var node=this.startNode();this.next();if(this.hasPlugin("decorators")){var startLoc=this.state.startLoc;var expr;if(this.match(10)){var _startLoc2=this.state.startLoc;this.next();expr=this.parseExpression();this.expect(11);expr=this.wrapParenthesis(_startLoc2,expr);var paramsStartLoc=this.state.startLoc;node.expression=this.parseMaybeDecoratorArguments(expr,_startLoc2);if(this.getPluginOption("decorators","allowCallParenthesized")===false&&node.expression!==expr){this.raise(Errors.DecoratorArgumentsOutsideParentheses,paramsStartLoc);}}else {expr=this.parseIdentifier(false);while(this.eat(16)){var _node14=this.startNodeAt(startLoc);_node14.object=expr;if(this.match(139)){this.classScope.usePrivateName(this.state.value,this.state.startLoc);_node14.property=this.parsePrivateName();}else {_node14.property=this.parseIdentifier(true);}_node14.computed=false;expr=this.finishNode(_node14,"MemberExpression");}node.expression=this.parseMaybeDecoratorArguments(expr,startLoc);}}else {node.expression=this.parseExprSubscripts();}return this.finishNode(node,"Decorator");}},{key:"parseMaybeDecoratorArguments",value:function parseMaybeDecoratorArguments(expr,startLoc){if(this.eat(10)){var node=this.startNodeAt(startLoc);node.callee=expr;node.arguments=this.parseCallExpressionArguments(11);this.toReferencedList(node.arguments);return this.finishNode(node,"CallExpression");}return expr;}},{key:"parseBreakContinueStatement",value:function parseBreakContinueStatement(node,isBreak){this.next();if(this.isLineTerminator()){node.label=null;}else {node.label=this.parseIdentifier();this.semicolon();}this.verifyBreakContinue(node,isBreak);return this.finishNode(node,isBreak?"BreakStatement":"ContinueStatement");}},{key:"verifyBreakContinue",value:function verifyBreakContinue(node,isBreak){var i;for(i=0;i<this.state.labels.length;++i){var lab=this.state.labels[i];if(node.label==null||lab.name===node.label.name){if(lab.kind!=null&&(isBreak||lab.kind===1)){break;}if(node.label&&isBreak)break;}}if(i===this.state.labels.length){var type=isBreak?"BreakStatement":"ContinueStatement";this.raise(Errors.IllegalBreakContinue,node,{type:type});}}},{key:"parseDebuggerStatement",value:function parseDebuggerStatement(node){this.next();this.semicolon();return this.finishNode(node,"DebuggerStatement");}},{key:"parseHeaderExpression",value:function parseHeaderExpression(){this.expect(10);var val=this.parseExpression();this.expect(11);return val;}},{key:"parseDoWhileStatement",value:function parseDoWhileStatement(node){var _this60=this;this.next();this.state.labels.push(loopLabel);node.body=this.withSmartMixTopicForbiddingContext(function(){return _this60.parseStatement();});this.state.labels.pop();this.expect(92);node.test=this.parseHeaderExpression();this.eat(13);return this.finishNode(node,"DoWhileStatement");}},{key:"parseForStatement",value:function parseForStatement(node){this.next();this.state.labels.push(loopLabel);var awaitAt=null;if(this.isContextual(96)&&this.recordAwaitIfAllowed()){awaitAt=this.state.startLoc;this.next();}this.scope.enter(0);this.expect(10);if(this.match(13)){if(awaitAt!==null){this.unexpected(awaitAt);}return this.parseFor(node,null);}var startsWithLet=this.isContextual(100);{var startsWithAwaitUsing=this.isContextual(96)&&this.startsAwaitUsing();var starsWithUsingDeclaration=startsWithAwaitUsing||this.isContextual(107)&&this.startsUsingForOf();var isLetOrUsing=startsWithLet&&this.hasFollowingBindingAtom()||starsWithUsingDeclaration;if(this.match(74)||this.match(75)||isLetOrUsing){var initNode=this.startNode();var kind;if(startsWithAwaitUsing){kind="await using";if(!this.recordAwaitIfAllowed()){this.raise(Errors.AwaitUsingNotInAsyncContext,this.state.startLoc);}this.next();}else {kind=this.state.value;}this.next();this.parseVar(initNode,true,kind);var _init=this.finishNode(initNode,"VariableDeclaration");var isForIn=this.match(58);if(isForIn&&starsWithUsingDeclaration){this.raise(Errors.ForInUsing,_init);}if((isForIn||this.isContextual(102))&&_init.declarations.length===1){return this.parseForIn(node,_init,awaitAt);}if(awaitAt!==null){this.unexpected(awaitAt);}return this.parseFor(node,_init);}}var startsWithAsync=this.isContextual(95);var refExpressionErrors=new ExpressionErrors();var init=this.parseExpression(true,refExpressionErrors);var isForOf=this.isContextual(102);if(isForOf){if(startsWithLet){this.raise(Errors.ForOfLet,init);}if(awaitAt===null&&startsWithAsync&&init.type==="Identifier"){this.raise(Errors.ForOfAsync,init);}}if(isForOf||this.match(58)){this.checkDestructuringPrivate(refExpressionErrors);this.toAssignable(init,true);var type=isForOf?"ForOfStatement":"ForInStatement";this.checkLVal(init,{type:type});return this.parseForIn(node,init,awaitAt);}else {this.checkExpressionErrors(refExpressionErrors,true);}if(awaitAt!==null){this.unexpected(awaitAt);}return this.parseFor(node,init);}},{key:"parseFunctionStatement",value:function parseFunctionStatement(node,isAsync,isHangingDeclaration){this.next();return this.parseFunction(node,1|(isHangingDeclaration?2:0)|(isAsync?8:0));}},{key:"parseIfStatement",value:function parseIfStatement(node){this.next();node.test=this.parseHeaderExpression();node.consequent=this.parseStatementOrSloppyAnnexBFunctionDeclaration();node.alternate=this.eat(66)?this.parseStatementOrSloppyAnnexBFunctionDeclaration():null;return this.finishNode(node,"IfStatement");}},{key:"parseReturnStatement",value:function parseReturnStatement(node){if(!this.prodParam.hasReturn&&!(this.optionFlags&2)){this.raise(Errors.IllegalReturn,this.state.startLoc);}this.next();if(this.isLineTerminator()){node.argument=null;}else {node.argument=this.parseExpression();this.semicolon();}return this.finishNode(node,"ReturnStatement");}},{key:"parseSwitchStatement",value:function parseSwitchStatement(node){this.next();node.discriminant=this.parseHeaderExpression();var cases=node.cases=[];this.expect(5);this.state.labels.push(switchLabel);this.scope.enter(0);var cur;for(var sawDefault;!this.match(8);){if(this.match(61)||this.match(65)){var isCase=this.match(61);if(cur)this.finishNode(cur,"SwitchCase");cases.push(cur=this.startNode());cur.consequent=[];this.next();if(isCase){cur.test=this.parseExpression();}else {if(sawDefault){this.raise(Errors.MultipleDefaultsInSwitch,this.state.lastTokStartLoc);}sawDefault=true;cur.test=null;}this.expect(14);}else {if(cur){cur.consequent.push(this.parseStatementListItem());}else {this.unexpected();}}}this.scope.exit();if(cur)this.finishNode(cur,"SwitchCase");this.next();this.state.labels.pop();return this.finishNode(node,"SwitchStatement");}},{key:"parseThrowStatement",value:function parseThrowStatement(node){this.next();if(this.hasPrecedingLineBreak()){this.raise(Errors.NewlineAfterThrow,this.state.lastTokEndLoc);}node.argument=this.parseExpression();this.semicolon();return this.finishNode(node,"ThrowStatement");}},{key:"parseCatchClauseParam",value:function parseCatchClauseParam(){var param=this.parseBindingAtom();this.scope.enter(this.options.annexB&&param.type==="Identifier"?8:0);this.checkLVal(param,{type:"CatchClause"},9);return param;}},{key:"parseTryStatement",value:function parseTryStatement(node){var _this61=this;this.next();node.block=this.parseBlock();node.handler=null;if(this.match(62)){var clause=this.startNode();this.next();if(this.match(10)){this.expect(10);clause.param=this.parseCatchClauseParam();this.expect(11);}else {clause.param=null;this.scope.enter(0);}clause.body=this.withSmartMixTopicForbiddingContext(function(){return _this61.parseBlock(false,false);});this.scope.exit();node.handler=this.finishNode(clause,"CatchClause");}node.finalizer=this.eat(67)?this.parseBlock():null;if(!node.handler&&!node.finalizer){this.raise(Errors.NoCatchOrFinally,node);}return this.finishNode(node,"TryStatement");}},{key:"parseVarStatement",value:function parseVarStatement(node,kind){var allowMissingInitializer=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;this.next();this.parseVar(node,false,kind,allowMissingInitializer);this.semicolon();return this.finishNode(node,"VariableDeclaration");}},{key:"parseWhileStatement",value:function parseWhileStatement(node){var _this62=this;this.next();node.test=this.parseHeaderExpression();this.state.labels.push(loopLabel);node.body=this.withSmartMixTopicForbiddingContext(function(){return _this62.parseStatement();});this.state.labels.pop();return this.finishNode(node,"WhileStatement");}},{key:"parseWithStatement",value:function parseWithStatement(node){var _this63=this;if(this.state.strict){this.raise(Errors.StrictWith,this.state.startLoc);}this.next();node.object=this.parseHeaderExpression();node.body=this.withSmartMixTopicForbiddingContext(function(){return _this63.parseStatement();});return this.finishNode(node,"WithStatement");}},{key:"parseEmptyStatement",value:function parseEmptyStatement(node){this.next();return this.finishNode(node,"EmptyStatement");}},{key:"parseLabeledStatement",value:function parseLabeledStatement(node,maybeName,expr,flags){var _iterator13=_createForOfIteratorHelper(this.state.labels),_step13;try{for(_iterator13.s();!(_step13=_iterator13.n()).done;){var _label=_step13.value;if(_label.name===maybeName){this.raise(Errors.LabelRedeclaration,expr,{labelName:maybeName});}}}catch(err){_iterator13.e(err);}finally{_iterator13.f();}var kind=tokenIsLoop(this.state.type)?1:this.match(71)?2:null;for(var i=this.state.labels.length-1;i>=0;i--){var label=this.state.labels[i];if(label.statementStart===node.start){label.statementStart=this.sourceToOffsetPos(this.state.start);label.kind=kind;}else {break;}}this.state.labels.push({name:maybeName,kind:kind,statementStart:this.sourceToOffsetPos(this.state.start)});node.body=flags&8?this.parseStatementOrSloppyAnnexBFunctionDeclaration(true):this.parseStatement();this.state.labels.pop();node.label=expr;return this.finishNode(node,"LabeledStatement");}},{key:"parseExpressionStatement",value:function parseExpressionStatement(node,expr,decorators){node.expression=expr;this.semicolon();return this.finishNode(node,"ExpressionStatement");}},{key:"parseBlock",value:function parseBlock(){var allowDirectives=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;var createNewLexicalScope=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;var afterBlockParse=arguments.length>2?arguments[2]:undefined;var node=this.startNode();if(allowDirectives){this.state.strictErrors.clear();}this.expect(5);if(createNewLexicalScope){this.scope.enter(0);}this.parseBlockBody(node,allowDirectives,false,8,afterBlockParse);if(createNewLexicalScope){this.scope.exit();}return this.finishNode(node,"BlockStatement");}},{key:"isValidDirective",value:function isValidDirective(stmt){return stmt.type==="ExpressionStatement"&&stmt.expression.type==="StringLiteral"&&!stmt.expression.extra.parenthesized;}},{key:"parseBlockBody",value:function parseBlockBody(node,allowDirectives,topLevel,end,afterBlockParse){var body=node.body=[];var directives=node.directives=[];this.parseBlockOrModuleBlockBody(body,allowDirectives?directives:undefined,topLevel,end,afterBlockParse);}},{key:"parseBlockOrModuleBlockBody",value:function parseBlockOrModuleBlockBody(body,directives,topLevel,end,afterBlockParse){var oldStrict=this.state.strict;var hasStrictModeDirective=false;var parsedNonDirective=false;while(!this.match(end)){var stmt=topLevel?this.parseModuleItem():this.parseStatementListItem();if(directives&&!parsedNonDirective){if(this.isValidDirective(stmt)){var directive=this.stmtToDirective(stmt);directives.push(directive);if(!hasStrictModeDirective&&directive.value.value==="use strict"){hasStrictModeDirective=true;this.setStrict(true);}continue;}parsedNonDirective=true;this.state.strictErrors.clear();}body.push(stmt);}afterBlockParse==null||afterBlockParse.call(this,hasStrictModeDirective);if(!oldStrict){this.setStrict(false);}this.next();}},{key:"parseFor",value:function parseFor(node,init){var _this64=this;node.init=init;this.semicolon(false);node.test=this.match(13)?null:this.parseExpression();this.semicolon(false);node.update=this.match(11)?null:this.parseExpression();this.expect(11);node.body=this.withSmartMixTopicForbiddingContext(function(){return _this64.parseStatement();});this.scope.exit();this.state.labels.pop();return this.finishNode(node,"ForStatement");}},{key:"parseForIn",value:function parseForIn(node,init,awaitAt){var _this65=this;var isForIn=this.match(58);this.next();if(isForIn){if(awaitAt!==null)this.unexpected(awaitAt);}else {node["await"]=awaitAt!==null;}if(init.type==="VariableDeclaration"&&init.declarations[0].init!=null&&(!isForIn||!this.options.annexB||this.state.strict||init.kind!=="var"||init.declarations[0].id.type!=="Identifier")){this.raise(Errors.ForInOfLoopInitializer,init,{type:isForIn?"ForInStatement":"ForOfStatement"});}if(init.type==="AssignmentPattern"){this.raise(Errors.InvalidLhs,init,{ancestor:{type:"ForStatement"}});}node.left=init;node.right=isForIn?this.parseExpression():this.parseMaybeAssignAllowIn();this.expect(11);node.body=this.withSmartMixTopicForbiddingContext(function(){return _this65.parseStatement();});this.scope.exit();this.state.labels.pop();return this.finishNode(node,isForIn?"ForInStatement":"ForOfStatement");}},{key:"parseVar",value:function parseVar(node,isFor,kind){var allowMissingInitializer=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;var declarations=node.declarations=[];node.kind=kind;for(;;){var decl=this.startNode();this.parseVarId(decl,kind);decl.init=!this.eat(29)?null:isFor?this.parseMaybeAssignDisallowIn():this.parseMaybeAssignAllowIn();if(decl.init===null&&!allowMissingInitializer){if(decl.id.type!=="Identifier"&&!(isFor&&(this.match(58)||this.isContextual(102)))){this.raise(Errors.DeclarationMissingInitializer,this.state.lastTokEndLoc,{kind:"destructuring"});}else if((kind==="const"||kind==="using"||kind==="await using")&&!(this.match(58)||this.isContextual(102))){this.raise(Errors.DeclarationMissingInitializer,this.state.lastTokEndLoc,{kind:kind});}}declarations.push(this.finishNode(decl,"VariableDeclarator"));if(!this.eat(12))break;}return node;}},{key:"parseVarId",value:function parseVarId(decl,kind){var id=this.parseBindingAtom();if(kind==="using"||kind==="await using"){if(id.type==="ArrayPattern"||id.type==="ObjectPattern"){this.raise(Errors.UsingDeclarationHasBindingPattern,id.loc.start);}}this.checkLVal(id,{type:"VariableDeclarator"},kind==="var"?5:8201);decl.id=id;}},{key:"parseAsyncFunctionExpression",value:function parseAsyncFunctionExpression(node){return this.parseFunction(node,8);}},{key:"parseFunction",value:function parseFunction(node){var _this66=this;var flags=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var hangingDeclaration=flags&2;var isDeclaration=!!(flags&1);var requireId=isDeclaration&&!(flags&4);var isAsync=!!(flags&8);this.initFunction(node,isAsync);if(this.match(55)){if(hangingDeclaration){this.raise(Errors.GeneratorInSingleStatementContext,this.state.startLoc);}this.next();node.generator=true;}if(isDeclaration){node.id=this.parseFunctionId(requireId);}var oldMaybeInArrowParameters=this.state.maybeInArrowParameters;this.state.maybeInArrowParameters=false;this.scope.enter(2);this.prodParam.enter(functionFlags(isAsync,node.generator));if(!isDeclaration){node.id=this.parseFunctionId();}this.parseFunctionParams(node,false);this.withSmartMixTopicForbiddingContext(function(){_this66.parseFunctionBodyAndFinish(node,isDeclaration?"FunctionDeclaration":"FunctionExpression");});this.prodParam.exit();this.scope.exit();if(isDeclaration&&!hangingDeclaration){this.registerFunctionStatementId(node);}this.state.maybeInArrowParameters=oldMaybeInArrowParameters;return node;}},{key:"parseFunctionId",value:function parseFunctionId(requireId){return requireId||tokenIsIdentifier(this.state.type)?this.parseIdentifier():null;}},{key:"parseFunctionParams",value:function parseFunctionParams(node,isConstructor){this.expect(10);this.expressionScope.enter(newParameterDeclarationScope());node.params=this.parseBindingList(11,41,2|(isConstructor?4:0));this.expressionScope.exit();}},{key:"registerFunctionStatementId",value:function registerFunctionStatementId(node){if(!node.id)return;this.scope.declareName(node.id.name,!this.options.annexB||this.state.strict||node.generator||node.async?this.scope.treatFunctionsAsVar?5:8201:17,node.id.loc.start);}},{key:"parseClass",value:function parseClass(node,isStatement,optionalId){this.next();var oldStrict=this.state.strict;this.state.strict=true;this.parseClassId(node,isStatement,optionalId);this.parseClassSuper(node);node.body=this.parseClassBody(!!node.superClass,oldStrict);return this.finishNode(node,isStatement?"ClassDeclaration":"ClassExpression");}},{key:"isClassProperty",value:function isClassProperty(){return this.match(29)||this.match(13)||this.match(8);}},{key:"isClassMethod",value:function isClassMethod(){return this.match(10);}},{key:"nameIsConstructor",value:function nameIsConstructor(key){return key.type==="Identifier"&&key.name==="constructor"||key.type==="StringLiteral"&&key.value==="constructor";}},{key:"isNonstaticConstructor",value:function isNonstaticConstructor(method){return !method.computed&&!method["static"]&&this.nameIsConstructor(method.key);}},{key:"parseClassBody",value:function parseClassBody(hadSuperClass,oldStrict){var _this67=this;this.classScope.enter();var state={hadConstructor:false,hadSuperClass:hadSuperClass};var decorators=[];var classBody=this.startNode();classBody.body=[];this.expect(5);this.withSmartMixTopicForbiddingContext(function(){while(!_this67.match(8)){if(_this67.eat(13)){if(decorators.length>0){throw _this67.raise(Errors.DecoratorSemicolon,_this67.state.lastTokEndLoc);}continue;}if(_this67.match(26)){decorators.push(_this67.parseDecorator());continue;}var member=_this67.startNode();if(decorators.length){member.decorators=decorators;_this67.resetStartLocationFromNode(member,decorators[0]);decorators=[];}_this67.parseClassMember(classBody,member,state);if(member.kind==="constructor"&&member.decorators&&member.decorators.length>0){_this67.raise(Errors.DecoratorConstructor,member);}}});this.state.strict=oldStrict;this.next();if(decorators.length){throw this.raise(Errors.TrailingDecorator,this.state.startLoc);}this.classScope.exit();return this.finishNode(classBody,"ClassBody");}},{key:"parseClassMemberFromModifier",value:function parseClassMemberFromModifier(classBody,member){var key=this.parseIdentifier(true);if(this.isClassMethod()){var method=member;method.kind="method";method.computed=false;method.key=key;method["static"]=false;this.pushClassMethod(classBody,method,false,false,false,false);return true;}else if(this.isClassProperty()){var prop=member;prop.computed=false;prop.key=key;prop["static"]=false;classBody.body.push(this.parseClassProperty(prop));return true;}this.resetPreviousNodeTrailingComments(key);return false;}},{key:"parseClassMember",value:function parseClassMember(classBody,member,state){var isStatic=this.isContextual(106);if(isStatic){if(this.parseClassMemberFromModifier(classBody,member)){return;}if(this.eat(5)){this.parseClassStaticBlock(classBody,member);return;}}this.parseClassMemberWithIsStatic(classBody,member,state,isStatic);}},{key:"parseClassMemberWithIsStatic",value:function parseClassMemberWithIsStatic(classBody,member,state,isStatic){var publicMethod=member;var privateMethod=member;var publicProp=member;var privateProp=member;var accessorProp=member;var method=publicMethod;var publicMember=publicMethod;member["static"]=isStatic;this.parsePropertyNamePrefixOperator(member);if(this.eat(55)){method.kind="method";var isPrivateName=this.match(139);this.parseClassElementName(method);if(isPrivateName){this.pushClassPrivateMethod(classBody,privateMethod,true,false);return;}if(this.isNonstaticConstructor(publicMethod)){this.raise(Errors.ConstructorIsGenerator,publicMethod.key);}this.pushClassMethod(classBody,publicMethod,true,false,false,false);return;}var isContextual=!this.state.containsEsc&&tokenIsIdentifier(this.state.type);var key=this.parseClassElementName(member);var maybeContextualKw=isContextual?key.name:null;var isPrivate=this.isPrivateName(key);var maybeQuestionTokenStartLoc=this.state.startLoc;this.parsePostMemberNameModifiers(publicMember);if(this.isClassMethod()){method.kind="method";if(isPrivate){this.pushClassPrivateMethod(classBody,privateMethod,false,false);return;}var isConstructor=this.isNonstaticConstructor(publicMethod);var allowsDirectSuper=false;if(isConstructor){publicMethod.kind="constructor";if(state.hadConstructor&&!this.hasPlugin("typescript")){this.raise(Errors.DuplicateConstructor,key);}if(isConstructor&&this.hasPlugin("typescript")&&member.override){this.raise(Errors.OverrideOnConstructor,key);}state.hadConstructor=true;allowsDirectSuper=state.hadSuperClass;}this.pushClassMethod(classBody,publicMethod,false,false,isConstructor,allowsDirectSuper);}else if(this.isClassProperty()){if(isPrivate){this.pushClassPrivateProperty(classBody,privateProp);}else {this.pushClassProperty(classBody,publicProp);}}else if(maybeContextualKw==="async"&&!this.isLineTerminator()){this.resetPreviousNodeTrailingComments(key);var isGenerator=this.eat(55);if(publicMember.optional){this.unexpected(maybeQuestionTokenStartLoc);}method.kind="method";var _isPrivate=this.match(139);this.parseClassElementName(method);this.parsePostMemberNameModifiers(publicMember);if(_isPrivate){this.pushClassPrivateMethod(classBody,privateMethod,isGenerator,true);}else {if(this.isNonstaticConstructor(publicMethod)){this.raise(Errors.ConstructorIsAsync,publicMethod.key);}this.pushClassMethod(classBody,publicMethod,isGenerator,true,false,false);}}else if((maybeContextualKw==="get"||maybeContextualKw==="set")&&!(this.match(55)&&this.isLineTerminator())){this.resetPreviousNodeTrailingComments(key);method.kind=maybeContextualKw;var _isPrivate2=this.match(139);this.parseClassElementName(publicMethod);if(_isPrivate2){this.pushClassPrivateMethod(classBody,privateMethod,false,false);}else {if(this.isNonstaticConstructor(publicMethod)){this.raise(Errors.ConstructorIsAccessor,publicMethod.key);}this.pushClassMethod(classBody,publicMethod,false,false,false,false);}this.checkGetterSetterParams(publicMethod);}else if(maybeContextualKw==="accessor"&&!this.isLineTerminator()){this.expectPlugin("decoratorAutoAccessors");this.resetPreviousNodeTrailingComments(key);var _isPrivate3=this.match(139);this.parseClassElementName(publicProp);this.pushClassAccessorProperty(classBody,accessorProp,_isPrivate3);}else if(this.isLineTerminator()){if(isPrivate){this.pushClassPrivateProperty(classBody,privateProp);}else {this.pushClassProperty(classBody,publicProp);}}else {this.unexpected();}}},{key:"parseClassElementName",value:function parseClassElementName(member){var _this$state7=this.state,type=_this$state7.type,value=_this$state7.value;if((type===132||type===134)&&member["static"]&&value==="prototype"){this.raise(Errors.StaticPrototype,this.state.startLoc);}if(type===139){if(value==="constructor"){this.raise(Errors.ConstructorClassPrivateField,this.state.startLoc);}var key=this.parsePrivateName();member.key=key;return key;}this.parsePropertyName(member);return member.key;}},{key:"parseClassStaticBlock",value:function parseClassStaticBlock(classBody,member){var _member$decorators;this.scope.enter(64|128|16);var oldLabels=this.state.labels;this.state.labels=[];this.prodParam.enter(0);var body=member.body=[];this.parseBlockOrModuleBlockBody(body,undefined,false,8);this.prodParam.exit();this.scope.exit();this.state.labels=oldLabels;classBody.body.push(this.finishNode(member,"StaticBlock"));if((_member$decorators=member.decorators)!=null&&_member$decorators.length){this.raise(Errors.DecoratorStaticBlock,member);}}},{key:"pushClassProperty",value:function pushClassProperty(classBody,prop){if(!prop.computed&&this.nameIsConstructor(prop.key)){this.raise(Errors.ConstructorClassField,prop.key);}classBody.body.push(this.parseClassProperty(prop));}},{key:"pushClassPrivateProperty",value:function pushClassPrivateProperty(classBody,prop){var node=this.parseClassPrivateProperty(prop);classBody.body.push(node);this.classScope.declarePrivateName(this.getPrivateNameSV(node.key),0,node.key.loc.start);}},{key:"pushClassAccessorProperty",value:function pushClassAccessorProperty(classBody,prop,isPrivate){if(!isPrivate&&!prop.computed&&this.nameIsConstructor(prop.key)){this.raise(Errors.ConstructorClassField,prop.key);}var node=this.parseClassAccessorProperty(prop);classBody.body.push(node);if(isPrivate){this.classScope.declarePrivateName(this.getPrivateNameSV(node.key),0,node.key.loc.start);}}},{key:"pushClassMethod",value:function pushClassMethod(classBody,method,isGenerator,isAsync,isConstructor,allowsDirectSuper){classBody.body.push(this.parseMethod(method,isGenerator,isAsync,isConstructor,allowsDirectSuper,"ClassMethod",true));}},{key:"pushClassPrivateMethod",value:function pushClassPrivateMethod(classBody,method,isGenerator,isAsync){var node=this.parseMethod(method,isGenerator,isAsync,false,false,"ClassPrivateMethod",true);classBody.body.push(node);var kind=node.kind==="get"?node["static"]?6:2:node.kind==="set"?node["static"]?5:1:0;this.declareClassPrivateMethodInScope(node,kind);}},{key:"declareClassPrivateMethodInScope",value:function declareClassPrivateMethodInScope(node,kind){this.classScope.declarePrivateName(this.getPrivateNameSV(node.key),kind,node.key.loc.start);}},{key:"parsePostMemberNameModifiers",value:function parsePostMemberNameModifiers(methodOrProp){}},{key:"parseClassPrivateProperty",value:function parseClassPrivateProperty(node){this.parseInitializer(node);this.semicolon();return this.finishNode(node,"ClassPrivateProperty");}},{key:"parseClassProperty",value:function parseClassProperty(node){this.parseInitializer(node);this.semicolon();return this.finishNode(node,"ClassProperty");}},{key:"parseClassAccessorProperty",value:function parseClassAccessorProperty(node){this.parseInitializer(node);this.semicolon();return this.finishNode(node,"ClassAccessorProperty");}},{key:"parseInitializer",value:function parseInitializer(node){this.scope.enter(64|16);this.expressionScope.enter(newExpressionScope());this.prodParam.enter(0);node.value=this.eat(29)?this.parseMaybeAssignAllowIn():null;this.expressionScope.exit();this.prodParam.exit();this.scope.exit();}},{key:"parseClassId",value:function parseClassId(node,isStatement,optionalId){var bindingType=arguments.length>3&&arguments[3]!==undefined?arguments[3]:8331;if(tokenIsIdentifier(this.state.type)){node.id=this.parseIdentifier();if(isStatement){this.declareNameFromIdentifier(node.id,bindingType);}}else {if(optionalId||!isStatement){node.id=null;}else {throw this.raise(Errors.MissingClassName,this.state.startLoc);}}}},{key:"parseClassSuper",value:function parseClassSuper(node){node.superClass=this.eat(81)?this.parseExprSubscripts():null;}},{key:"parseExport",value:function parseExport(node,decorators){var maybeDefaultIdentifier=this.parseMaybeImportPhase(node,true);var hasDefault=this.maybeParseExportDefaultSpecifier(node,maybeDefaultIdentifier);var parseAfterDefault=!hasDefault||this.eat(12);var hasStar=parseAfterDefault&&this.eatExportStar(node);var hasNamespace=hasStar&&this.maybeParseExportNamespaceSpecifier(node);var parseAfterNamespace=parseAfterDefault&&(!hasNamespace||this.eat(12));var isFromRequired=hasDefault||hasStar;if(hasStar&&!hasNamespace){if(hasDefault)this.unexpected();if(decorators){throw this.raise(Errors.UnsupportedDecoratorExport,node);}this.parseExportFrom(node,true);return this.finishNode(node,"ExportAllDeclaration");}var hasSpecifiers=this.maybeParseExportNamedSpecifiers(node);if(hasDefault&&parseAfterDefault&&!hasStar&&!hasSpecifiers){this.unexpected(null,5);}if(hasNamespace&&parseAfterNamespace){this.unexpected(null,98);}var hasDeclaration;if(isFromRequired||hasSpecifiers){hasDeclaration=false;if(decorators){throw this.raise(Errors.UnsupportedDecoratorExport,node);}this.parseExportFrom(node,isFromRequired);}else {hasDeclaration=this.maybeParseExportDeclaration(node);}if(isFromRequired||hasSpecifiers||hasDeclaration){var _node2$declaration;var node2=node;this.checkExport(node2,true,false,!!node2.source);if(((_node2$declaration=node2.declaration)==null?void 0:_node2$declaration.type)==="ClassDeclaration"){this.maybeTakeDecorators(decorators,node2.declaration,node2);}else if(decorators){throw this.raise(Errors.UnsupportedDecoratorExport,node);}return this.finishNode(node2,"ExportNamedDeclaration");}if(this.eat(65)){var _node15=node;var decl=this.parseExportDefaultExpression();_node15.declaration=decl;if(decl.type==="ClassDeclaration"){this.maybeTakeDecorators(decorators,decl,_node15);}else if(decorators){throw this.raise(Errors.UnsupportedDecoratorExport,node);}this.checkExport(_node15,true,true);return this.finishNode(_node15,"ExportDefaultDeclaration");}this.unexpected(null,5);}},{key:"eatExportStar",value:function eatExportStar(node){return this.eat(55);}},{key:"maybeParseExportDefaultSpecifier",value:function maybeParseExportDefaultSpecifier(node,maybeDefaultIdentifier){if(maybeDefaultIdentifier||this.isExportDefaultSpecifier()){this.expectPlugin("exportDefaultFrom",maybeDefaultIdentifier==null?void 0:maybeDefaultIdentifier.loc.start);var id=maybeDefaultIdentifier||this.parseIdentifier(true);var specifier=this.startNodeAtNode(id);specifier.exported=id;node.specifiers=[this.finishNode(specifier,"ExportDefaultSpecifier")];return true;}return false;}},{key:"maybeParseExportNamespaceSpecifier",value:function maybeParseExportNamespaceSpecifier(node){if(this.isContextual(93)){var _ref,_ref$specifiers;(_ref$specifiers=(_ref=node).specifiers)!=null?_ref$specifiers:_ref.specifiers=[];var specifier=this.startNodeAt(this.state.lastTokStartLoc);this.next();specifier.exported=this.parseModuleExportName();node.specifiers.push(this.finishNode(specifier,"ExportNamespaceSpecifier"));return true;}return false;}},{key:"maybeParseExportNamedSpecifiers",value:function maybeParseExportNamedSpecifiers(node){if(this.match(5)){var _node2$specifiers;var node2=node;if(!node2.specifiers)node2.specifiers=[];var isTypeExport=node2.exportKind==="type";(_node2$specifiers=node2.specifiers).push.apply(_node2$specifiers,_toConsumableArray(this.parseExportSpecifiers(isTypeExport)));node2.source=null;node2.declaration=null;if(this.hasPlugin("importAssertions")){node2.assertions=[];}return true;}return false;}},{key:"maybeParseExportDeclaration",value:function maybeParseExportDeclaration(node){if(this.shouldParseExportDeclaration()){node.specifiers=[];node.source=null;if(this.hasPlugin("importAssertions")){node.assertions=[];}node.declaration=this.parseExportDeclaration(node);return true;}return false;}},{key:"isAsyncFunction",value:function isAsyncFunction(){if(!this.isContextual(95))return false;var next=this.nextTokenInLineStart();return this.isUnparsedContextual(next,"function");}},{key:"parseExportDefaultExpression",value:function parseExportDefaultExpression(){var expr=this.startNode();if(this.match(68)){this.next();return this.parseFunction(expr,1|4);}else if(this.isAsyncFunction()){this.next();this.next();return this.parseFunction(expr,1|4|8);}if(this.match(80)){return this.parseClass(expr,true,true);}if(this.match(26)){if(this.hasPlugin("decorators")&&this.getPluginOption("decorators","decoratorsBeforeExport")===true){this.raise(Errors.DecoratorBeforeExport,this.state.startLoc);}return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false),this.startNode()),true,true);}if(this.match(75)||this.match(74)||this.isLet()){throw this.raise(Errors.UnsupportedDefaultExport,this.state.startLoc);}var res=this.parseMaybeAssignAllowIn();this.semicolon();return res;}},{key:"parseExportDeclaration",value:function parseExportDeclaration(node){if(this.match(80)){var _node16=this.parseClass(this.startNode(),true,false);return _node16;}return this.parseStatementListItem();}},{key:"isExportDefaultSpecifier",value:function isExportDefaultSpecifier(){var type=this.state.type;if(tokenIsIdentifier(type)){if(type===95&&!this.state.containsEsc||type===100){return false;}if((type===130||type===129)&&!this.state.containsEsc){var _this$lookahead2=this.lookahead(),nextType=_this$lookahead2.type;if(tokenIsIdentifier(nextType)&&nextType!==98||nextType===5){this.expectOnePlugin(["flow","typescript"]);return false;}}}else if(!this.match(65)){return false;}var next=this.nextTokenStart();var hasFrom=this.isUnparsedContextual(next,"from");if(this.input.charCodeAt(next)===44||tokenIsIdentifier(this.state.type)&&hasFrom){return true;}if(this.match(65)&&hasFrom){var nextAfterFrom=this.input.charCodeAt(this.nextTokenStartSince(next+4));return nextAfterFrom===34||nextAfterFrom===39;}return false;}},{key:"parseExportFrom",value:function parseExportFrom(node,expect){if(this.eatContextual(98)){node.source=this.parseImportSource();this.checkExport(node);this.maybeParseImportAttributes(node);this.checkJSONModuleImport(node);}else if(expect){this.unexpected();}this.semicolon();}},{key:"shouldParseExportDeclaration",value:function shouldParseExportDeclaration(){var type=this.state.type;if(type===26){this.expectOnePlugin(["decorators","decorators-legacy"]);if(this.hasPlugin("decorators")){if(this.getPluginOption("decorators","decoratorsBeforeExport")===true){this.raise(Errors.DecoratorBeforeExport,this.state.startLoc);}return true;}}if(this.isContextual(107)){this.raise(Errors.UsingDeclarationExport,this.state.startLoc);return true;}if(this.isContextual(96)&&this.startsAwaitUsing()){this.raise(Errors.UsingDeclarationExport,this.state.startLoc);return true;}return type===74||type===75||type===68||type===80||this.isLet()||this.isAsyncFunction();}},{key:"checkExport",value:function checkExport(node,checkNames,isDefault,isFrom){if(checkNames){var _node$specifiers;if(isDefault){this.checkDuplicateExports(node,"default");if(this.hasPlugin("exportDefaultFrom")){var _declaration$extra;var declaration=node.declaration;if(declaration.type==="Identifier"&&declaration.name==="from"&&declaration.end-declaration.start===4&&!((_declaration$extra=declaration.extra)!=null&&_declaration$extra.parenthesized)){this.raise(Errors.ExportDefaultFromAsIdentifier,declaration);}}}else if((_node$specifiers=node.specifiers)!=null&&_node$specifiers.length){var _iterator14=_createForOfIteratorHelper(node.specifiers),_step14;try{for(_iterator14.s();!(_step14=_iterator14.n()).done;){var specifier=_step14.value;var exported=specifier.exported;var exportName=exported.type==="Identifier"?exported.name:exported.value;this.checkDuplicateExports(specifier,exportName);if(!isFrom&&specifier.local){var local=specifier.local;if(local.type!=="Identifier"){this.raise(Errors.ExportBindingIsString,specifier,{localName:local.value,exportName:exportName});}else {this.checkReservedWord(local.name,local.loc.start,true,false);this.scope.checkLocalExport(local);}}}}catch(err){_iterator14.e(err);}finally{_iterator14.f();}}else if(node.declaration){var decl=node.declaration;if(decl.type==="FunctionDeclaration"||decl.type==="ClassDeclaration"){var id=decl.id;if(!id)throw new Error("Assertion failure");this.checkDuplicateExports(node,id.name);}else if(decl.type==="VariableDeclaration"){var _iterator15=_createForOfIteratorHelper(decl.declarations),_step15;try{for(_iterator15.s();!(_step15=_iterator15.n()).done;){var _declaration=_step15.value;this.checkDeclaration(_declaration.id);}}catch(err){_iterator15.e(err);}finally{_iterator15.f();}}}}}},{key:"checkDeclaration",value:function checkDeclaration(node){if(node.type==="Identifier"){this.checkDuplicateExports(node,node.name);}else if(node.type==="ObjectPattern"){var _iterator16=_createForOfIteratorHelper(node.properties),_step16;try{for(_iterator16.s();!(_step16=_iterator16.n()).done;){var prop=_step16.value;this.checkDeclaration(prop);}}catch(err){_iterator16.e(err);}finally{_iterator16.f();}}else if(node.type==="ArrayPattern"){var _iterator17=_createForOfIteratorHelper(node.elements),_step17;try{for(_iterator17.s();!(_step17=_iterator17.n()).done;){var elem=_step17.value;if(elem){this.checkDeclaration(elem);}}}catch(err){_iterator17.e(err);}finally{_iterator17.f();}}else if(node.type==="ObjectProperty"){this.checkDeclaration(node.value);}else if(node.type==="RestElement"){this.checkDeclaration(node.argument);}else if(node.type==="AssignmentPattern"){this.checkDeclaration(node.left);}}},{key:"checkDuplicateExports",value:function checkDuplicateExports(node,exportName){if(this.exportedIdentifiers.has(exportName)){if(exportName==="default"){this.raise(Errors.DuplicateDefaultExport,node);}else {this.raise(Errors.DuplicateExport,node,{exportName:exportName});}}this.exportedIdentifiers.add(exportName);}},{key:"parseExportSpecifiers",value:function parseExportSpecifiers(isInTypeExport){var nodes=[];var first=true;this.expect(5);while(!this.eat(8)){if(first){first=false;}else {this.expect(12);if(this.eat(8))break;}var isMaybeTypeOnly=this.isContextual(130);var isString=this.match(134);var node=this.startNode();node.local=this.parseModuleExportName();nodes.push(this.parseExportSpecifier(node,isString,isInTypeExport,isMaybeTypeOnly));}return nodes;}},{key:"parseExportSpecifier",value:function parseExportSpecifier(node,isString,isInTypeExport,isMaybeTypeOnly){if(this.eatContextual(93)){node.exported=this.parseModuleExportName();}else if(isString){node.exported=cloneStringLiteral(node.local);}else if(!node.exported){node.exported=cloneIdentifier(node.local);}return this.finishNode(node,"ExportSpecifier");}},{key:"parseModuleExportName",value:function parseModuleExportName(){if(this.match(134)){var result=this.parseStringLiteral(this.state.value);var surrogate=loneSurrogate.exec(result.value);if(surrogate){this.raise(Errors.ModuleExportNameHasLoneSurrogate,result,{surrogateCharCode:surrogate[0].charCodeAt(0)});}return result;}return this.parseIdentifier(true);}},{key:"isJSONModuleImport",value:function isJSONModuleImport(node){if(node.assertions!=null){return node.assertions.some(function(_ref81){var key=_ref81.key,value=_ref81.value;return value.value==="json"&&(key.type==="Identifier"?key.name==="type":key.value==="type");});}return false;}},{key:"checkImportReflection",value:function checkImportReflection(node){var specifiers=node.specifiers;var singleBindingType=specifiers.length===1?specifiers[0].type:null;if(node.phase==="source"){if(singleBindingType!=="ImportDefaultSpecifier"){this.raise(Errors.SourcePhaseImportRequiresDefault,specifiers[0].loc.start);}}else if(node.phase==="defer"){if(singleBindingType!=="ImportNamespaceSpecifier"){this.raise(Errors.DeferImportRequiresNamespace,specifiers[0].loc.start);}}else if(node.module){var _node$assertions;if(singleBindingType!=="ImportDefaultSpecifier"){this.raise(Errors.ImportReflectionNotBinding,specifiers[0].loc.start);}if(((_node$assertions=node.assertions)==null?void 0:_node$assertions.length)>0){this.raise(Errors.ImportReflectionHasAssertion,specifiers[0].loc.start);}}}},{key:"checkJSONModuleImport",value:function checkJSONModuleImport(node){if(this.isJSONModuleImport(node)&&node.type!=="ExportAllDeclaration"){var specifiers=node.specifiers;if(specifiers!=null){var nonDefaultNamedSpecifier=specifiers.find(function(specifier){var imported;if(specifier.type==="ExportSpecifier"){imported=specifier.local;}else if(specifier.type==="ImportSpecifier"){imported=specifier.imported;}if(imported!==undefined){return imported.type==="Identifier"?imported.name!=="default":imported.value!=="default";}});if(nonDefaultNamedSpecifier!==undefined){this.raise(Errors.ImportJSONBindingNotDefault,nonDefaultNamedSpecifier.loc.start);}}}}},{key:"isPotentialImportPhase",value:function isPotentialImportPhase(isExport){if(isExport)return false;return this.isContextual(105)||this.isContextual(97)||this.isContextual(127);}},{key:"applyImportPhase",value:function applyImportPhase(node,isExport,phase,loc){if(isExport){return;}if(phase==="module"){this.expectPlugin("importReflection",loc);node.module=true;}else if(this.hasPlugin("importReflection")){node.module=false;}if(phase==="source"){this.expectPlugin("sourcePhaseImports",loc);node.phase="source";}else if(phase==="defer"){this.expectPlugin("deferredImportEvaluation",loc);node.phase="defer";}else if(this.hasPlugin("sourcePhaseImports")){node.phase=null;}}},{key:"parseMaybeImportPhase",value:function parseMaybeImportPhase(node,isExport){if(!this.isPotentialImportPhase(isExport)){this.applyImportPhase(node,isExport,null);return null;}var phaseIdentifier=this.parseIdentifier(true);var type=this.state.type;var isImportPhase=tokenIsKeywordOrIdentifier(type)?type!==98||this.lookaheadCharCode()===102:type!==12;if(isImportPhase){this.resetPreviousIdentifierLeadingComments(phaseIdentifier);this.applyImportPhase(node,isExport,phaseIdentifier.name,phaseIdentifier.loc.start);return null;}else {this.applyImportPhase(node,isExport,null);return phaseIdentifier;}}},{key:"isPrecedingIdImportPhase",value:function isPrecedingIdImportPhase(phase){var type=this.state.type;return tokenIsIdentifier(type)?type!==98||this.lookaheadCharCode()===102:type!==12;}},{key:"parseImport",value:function parseImport(node){if(this.match(134)){return this.parseImportSourceAndAttributes(node);}return this.parseImportSpecifiersAndAfter(node,this.parseMaybeImportPhase(node,false));}},{key:"parseImportSpecifiersAndAfter",value:function parseImportSpecifiersAndAfter(node,maybeDefaultIdentifier){node.specifiers=[];var hasDefault=this.maybeParseDefaultImportSpecifier(node,maybeDefaultIdentifier);var parseNext=!hasDefault||this.eat(12);var hasStar=parseNext&&this.maybeParseStarImportSpecifier(node);if(parseNext&&!hasStar)this.parseNamedImportSpecifiers(node);this.expectContextual(98);return this.parseImportSourceAndAttributes(node);}},{key:"parseImportSourceAndAttributes",value:function parseImportSourceAndAttributes(node){var _node$specifiers2;(_node$specifiers2=node.specifiers)!=null?_node$specifiers2:node.specifiers=[];node.source=this.parseImportSource();this.maybeParseImportAttributes(node);this.checkImportReflection(node);this.checkJSONModuleImport(node);this.semicolon();return this.finishNode(node,"ImportDeclaration");}},{key:"parseImportSource",value:function parseImportSource(){if(!this.match(134))this.unexpected();return this.parseExprAtom();}},{key:"parseImportSpecifierLocal",value:function parseImportSpecifierLocal(node,specifier,type){specifier.local=this.parseIdentifier();node.specifiers.push(this.finishImportSpecifier(specifier,type));}},{key:"finishImportSpecifier",value:function finishImportSpecifier(specifier,type){var bindingType=arguments.length>2&&arguments[2]!==undefined?arguments[2]:8201;this.checkLVal(specifier.local,{type:type},bindingType);return this.finishNode(specifier,type);}},{key:"parseImportAttributes",value:function parseImportAttributes(){this.expect(5);var attrs=[];var attrNames=new Set();do{if(this.match(8)){break;}var node=this.startNode();var keyName=this.state.value;if(attrNames.has(keyName)){this.raise(Errors.ModuleAttributesWithDuplicateKeys,this.state.startLoc,{key:keyName});}attrNames.add(keyName);if(this.match(134)){node.key=this.parseStringLiteral(keyName);}else {node.key=this.parseIdentifier(true);}this.expect(14);if(!this.match(134)){throw this.raise(Errors.ModuleAttributeInvalidValue,this.state.startLoc);}node.value=this.parseStringLiteral(this.state.value);attrs.push(this.finishNode(node,"ImportAttribute"));}while(this.eat(12));this.expect(8);return attrs;}},{key:"parseModuleAttributes",value:function parseModuleAttributes(){var attrs=[];var attributes=new Set();do{var node=this.startNode();node.key=this.parseIdentifier(true);if(node.key.name!=="type"){this.raise(Errors.ModuleAttributeDifferentFromType,node.key);}if(attributes.has(node.key.name)){this.raise(Errors.ModuleAttributesWithDuplicateKeys,node.key,{key:node.key.name});}attributes.add(node.key.name);this.expect(14);if(!this.match(134)){throw this.raise(Errors.ModuleAttributeInvalidValue,this.state.startLoc);}node.value=this.parseStringLiteral(this.state.value);attrs.push(this.finishNode(node,"ImportAttribute"));}while(this.eat(12));return attrs;}},{key:"maybeParseImportAttributes",value:function maybeParseImportAttributes(node){var attributes;{var useWith=false;}if(this.match(76)){if(this.hasPrecedingLineBreak()&&this.lookaheadCharCode()===40){return;}this.next();if(this.hasPlugin("moduleAttributes")){attributes=this.parseModuleAttributes();}else {attributes=this.parseImportAttributes();}{useWith=true;}}else if(this.isContextual(94)&&!this.hasPrecedingLineBreak()){if(!this.hasPlugin("deprecatedImportAssert")&&!this.hasPlugin("importAssertions")){this.raise(Errors.ImportAttributesUseAssert,this.state.startLoc);}if(!this.hasPlugin("importAssertions")){this.addExtra(node,"deprecatedAssertSyntax",true);}this.next();attributes=this.parseImportAttributes();}else {attributes=[];}if(!useWith&&this.hasPlugin("importAssertions")){node.assertions=attributes;}else {node.attributes=attributes;}}},{key:"maybeParseDefaultImportSpecifier",value:function maybeParseDefaultImportSpecifier(node,maybeDefaultIdentifier){if(maybeDefaultIdentifier){var specifier=this.startNodeAtNode(maybeDefaultIdentifier);specifier.local=maybeDefaultIdentifier;node.specifiers.push(this.finishImportSpecifier(specifier,"ImportDefaultSpecifier"));return true;}else if(tokenIsKeywordOrIdentifier(this.state.type)){this.parseImportSpecifierLocal(node,this.startNode(),"ImportDefaultSpecifier");return true;}return false;}},{key:"maybeParseStarImportSpecifier",value:function maybeParseStarImportSpecifier(node){if(this.match(55)){var specifier=this.startNode();this.next();this.expectContextual(93);this.parseImportSpecifierLocal(node,specifier,"ImportNamespaceSpecifier");return true;}return false;}},{key:"parseNamedImportSpecifiers",value:function parseNamedImportSpecifiers(node){var first=true;this.expect(5);while(!this.eat(8)){if(first){first=false;}else {if(this.eat(14)){throw this.raise(Errors.DestructureNamedImport,this.state.startLoc);}this.expect(12);if(this.eat(8))break;}var specifier=this.startNode();var importedIsString=this.match(134);var isMaybeTypeOnly=this.isContextual(130);specifier.imported=this.parseModuleExportName();var importSpecifier=this.parseImportSpecifier(specifier,importedIsString,node.importKind==="type"||node.importKind==="typeof",isMaybeTypeOnly,undefined);node.specifiers.push(importSpecifier);}}},{key:"parseImportSpecifier",value:function parseImportSpecifier(specifier,importedIsString,isInTypeOnlyImport,isMaybeTypeOnly,bindingType){if(this.eatContextual(93)){specifier.local=this.parseIdentifier();}else {var imported=specifier.imported;if(importedIsString){throw this.raise(Errors.ImportBindingIsString,specifier,{importName:imported.value});}this.checkReservedWord(imported.name,specifier.loc.start,true,true);if(!specifier.local){specifier.local=cloneIdentifier(imported);}}return this.finishImportSpecifier(specifier,"ImportSpecifier",bindingType);}},{key:"isThisParam",value:function isThisParam(param){return param.type==="Identifier"&&param.name==="this";}}]);}(ExpressionParser);var Parser=/*#__PURE__*/function(_StatementParser){function Parser(options,input,pluginsMap){var _this68;_classCallCheck(this,Parser);options=getOptions(options);_this68=_callSuper(this,Parser,[options,input]);_this68.options=options;_this68.initializeScopes();_this68.plugins=pluginsMap;_this68.filename=options.sourceFilename;_this68.startIndex=options.startIndex;var optionFlags=0;if(options.allowAwaitOutsideFunction){optionFlags|=1;}if(options.allowReturnOutsideFunction){optionFlags|=2;}if(options.allowImportExportEverywhere){optionFlags|=8;}if(options.allowSuperOutsideMethod){optionFlags|=16;}if(options.allowUndeclaredExports){optionFlags|=32;}if(options.allowNewTargetOutsideFunction){optionFlags|=4;}if(options.ranges){optionFlags|=64;}if(options.tokens){optionFlags|=128;}if(options.createImportExpressions){optionFlags|=256;}if(options.createParenthesizedExpressions){optionFlags|=512;}if(options.errorRecovery){optionFlags|=1024;}if(options.attachComment){optionFlags|=2048;}if(options.annexB){optionFlags|=4096;}_this68.optionFlags=optionFlags;return _this68;}_inherits(Parser,_StatementParser);return _createClass(Parser,[{key:"getScopeHandler",value:function getScopeHandler(){return ScopeHandler;}},{key:"parse",value:function parse(){this.enterInitialScopes();var file=this.startNode();var program=this.startNode();this.nextToken();file.errors=null;this.parseTopLevel(file,program);file.errors=this.state.errors;file.comments.length=this.state.commentsLen;return file;}}]);}(StatementParser);function parse(input,options){var _options;if(((_options=options)==null?void 0:_options.sourceType)==="unambiguous"){options=Object.assign({},options);try{options.sourceType="module";var parser=getParser(options,input);var ast=parser.parse();if(parser.sawUnambiguousESM){return ast;}if(parser.ambiguousScriptDifferentAst){try{options.sourceType="script";return getParser(options,input).parse();}catch(_unused){}}else {ast.program.sourceType="script";}return ast;}catch(moduleError){try{options.sourceType="script";return getParser(options,input).parse();}catch(_unused2){}throw moduleError;}}else {return getParser(options,input).parse();}}function parseExpression(input,options){var parser=getParser(options,input);if(parser.options.strictMode){parser.state.strict=true;}return parser.getExpression();}function generateExportedTokenTypes(internalTokenTypes){var tokenTypes={};for(var _i6=0,_Object$keys4=Object.keys(internalTokenTypes);_i6<_Object$keys4.length;_i6++){var typeName=_Object$keys4[_i6];tokenTypes[typeName]=getExportedToken(internalTokenTypes[typeName]);}return tokenTypes;}var tokTypes=generateExportedTokenTypes(tt);function getParser(options,input){var cls=Parser;var pluginsMap=new Map();if(options!=null&&options.plugins){var _iterator18=_createForOfIteratorHelper(options.plugins),_step18;try{for(_iterator18.s();!(_step18=_iterator18.n()).done;){var plugin=_step18.value;var name=void 0,opts=void 0;if(typeof plugin==="string"){name=plugin;}else {var _plugin=_slicedToArray(plugin,2);name=_plugin[0];opts=_plugin[1];}if(!pluginsMap.has(name)){pluginsMap.set(name,opts||{});}}}catch(err){_iterator18.e(err);}finally{_iterator18.f();}validatePlugins(pluginsMap);cls=getParserClass(pluginsMap);}return new cls(options,input,pluginsMap);}var parserClassCache=new Map();function getParserClass(pluginsMap){var pluginList=[];var _iterator19=_createForOfIteratorHelper(mixinPluginNames),_step19;try{for(_iterator19.s();!(_step19=_iterator19.n()).done;){var name=_step19.value;if(pluginsMap.has(name)){pluginList.push(name);}}}catch(err){_iterator19.e(err);}finally{_iterator19.f();}var key=pluginList.join("|");var cls=parserClassCache.get(key);if(!cls){cls=Parser;var _iterator20=_createForOfIteratorHelper(pluginList),_step20;try{for(_iterator20.s();!(_step20=_iterator20.n()).done;){var plugin=_step20.value;cls=mixinPlugins[plugin](cls);}}catch(err){_iterator20.e(err);}finally{_iterator20.f();}parserClassCache.set(key,cls);}return cls;}lib$7.parse=parse;lib$7.parseExpression=parseExpression;lib$7.tokTypes=tokTypes;return lib$7;}

var libExports$3 = requireLib$7();

var lib$6 = {};

var context$1 = {};

var traverseNode = {};

var context = {};

var path = {};

var virtualTypes = {};

var hasRequiredVirtualTypes;
function requireVirtualTypes() {
  if (hasRequiredVirtualTypes) return virtualTypes;
  hasRequiredVirtualTypes = 1;
  Object.defineProperty(virtualTypes, "__esModule", {
    value: true
  });
  virtualTypes.Var = virtualTypes.User = virtualTypes.Statement = virtualTypes.SpreadProperty = virtualTypes.Scope = virtualTypes.RestProperty = virtualTypes.ReferencedMemberExpression = virtualTypes.ReferencedIdentifier = virtualTypes.Referenced = virtualTypes.Pure = virtualTypes.NumericLiteralTypeAnnotation = virtualTypes.Generated = virtualTypes.ForAwaitStatement = virtualTypes.Flow = virtualTypes.Expression = virtualTypes.ExistentialTypeParam = virtualTypes.BlockScoped = virtualTypes.BindingIdentifier = void 0;
  virtualTypes.ReferencedIdentifier = ["Identifier", "JSXIdentifier"];
  virtualTypes.ReferencedMemberExpression = ["MemberExpression"];
  virtualTypes.BindingIdentifier = ["Identifier"];
  virtualTypes.Statement = ["Statement"];
  virtualTypes.Expression = ["Expression"];
  virtualTypes.Scope = ["Scopable", "Pattern"];
  virtualTypes.Referenced = null;
  virtualTypes.BlockScoped = null;
  virtualTypes.Var = ["VariableDeclaration"];
  virtualTypes.User = null;
  virtualTypes.Generated = null;
  virtualTypes.Pure = null;
  virtualTypes.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"];
  virtualTypes.RestProperty = ["RestElement"];
  virtualTypes.SpreadProperty = ["RestElement"];
  virtualTypes.ExistentialTypeParam = ["ExistsTypeAnnotation"];
  virtualTypes.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"];
  virtualTypes.ForAwaitStatement = ["ForOfStatement"];
  return virtualTypes;
}

var src = {exports: {}};

var browser$1 = {exports: {}};

var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;

  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} [options]
   * @throws {Error} throw an error if val is not a non-empty string or a number
   * @return {String|Number}
   * @api public
   */

  ms = function ms(val, options) {
    options = options || {};
    var type = _typeof(val);
    if (type === 'string' && val.length > 0) {
      return parse(val);
    } else if (type === 'number' && isFinite(val)) {
      return options["long"] ? fmtLong(val) : fmtShort(val);
    }
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
  };

  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */

  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'weeks':
      case 'week':
      case 'w':
        return n * w;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
      default:
        return undefined;
    }
  }

  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + 'd';
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + 'h';
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + 'm';
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
  }

  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, 'second');
    }
    return ms + ' ms';
  }

  /**
   * Pluralization helper.
   */

  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
  }
  return ms;
}

var common;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  /**
   * This is the common logic for both the Node.js and web browser
   * implementations of `debug()`.
   */

  function setup(env) {
    createDebug.debug = createDebug;
    createDebug["default"] = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy;
    Object.keys(env).forEach(function (key) {
      createDebug[key] = env[key];
    });

    /**
    * The currently active debug mode names, and names to skip.
    */

    createDebug.names = [];
    createDebug.skips = [];

    /**
    * Map of special "%n" handling functions, for the debug "format" argument.
    *
    * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
    */
    createDebug.formatters = {};

    /**
    * Selects a color for a debug namespace
    * @param {String} namespace The namespace string for the debug instance to be colored
    * @return {Number|String} An ANSI color code for the given namespace
    * @api private
    */
    function selectColor(namespace) {
      var hash = 0;
      for (var i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0; // Convert to 32bit integer
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;

    /**
    * Create a debugger with the given `namespace`.
    *
    * @param {String} namespace
    * @return {Function}
    * @api public
    */
    function createDebug(namespace) {
      var prevTime;
      var enableOverride = null;
      var namespacesCache;
      var enabledCache;
      function debug() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        // Disabled?
        if (!debug.enabled) {
          return;
        }
        var self = debug;

        // Set `diff` timestamp
        var curr = Number(new Date());
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== 'string') {
          // Anything else let's inspect with %O
          args.unshift('%O');
        }

        // Apply any `formatters` transformations
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
          // If we encounter an escaped % then don't increase the array index
          if (match === '%%') {
            return '%';
          }
          index++;
          var formatter = createDebug.formatters[format];
          if (typeof formatter === 'function') {
            var val = args[index];
            match = formatter.call(self, val);

            // Now we need to remove `args[index]` since it's inlined in the `format`
            args.splice(index, 1);
            index--;
          }
          return match;
        });

        // Apply env-specific formatting (colors, etc.)
        createDebug.formatArgs.call(self, args);
        var logFn = self.log || createDebug.log;
        logFn.apply(self, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

      Object.defineProperty(debug, 'enabled', {
        enumerable: true,
        configurable: false,
        get: function get() {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: function set(v) {
          enableOverride = v;
        }
      });

      // Env-specific initialization logic for debug instances
      if (typeof createDebug.init === 'function') {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }

    /**
    * Enables a debug mode by namespaces. This can include modes
    * separated by a colon and wildcards.
    *
    * @param {String} namespaces
    * @api public
    */
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      var split = (typeof namespaces === 'string' ? namespaces : '').trim().replace(' ', ',').split(',').filter(Boolean);
      var _iterator = _createForOfIteratorHelper(split),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var ns = _step.value;
          if (ns[0] === '-') {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }

    /**
     * Checks if the given string matches a namespace template, honoring
     * asterisks as wildcards.
     *
     * @param {String} search
     * @param {String} template
     * @return {Boolean}
     */
    function matchesTemplate(search, template) {
      var searchIndex = 0;
      var templateIndex = 0;
      var starIndex = -1;
      var matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
          // Match character or proceed with wildcard
          if (template[templateIndex] === '*') {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++; // Skip the '*'
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          // eslint-disable-line no-negated-condition
          // Backtrack to the last '*' and try to match more characters
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false; // No match
        }
      }

      // Handle trailing '*' in template
      while (templateIndex < template.length && template[templateIndex] === '*') {
        templateIndex++;
      }
      return templateIndex === template.length;
    }

    /**
    * Disable debug output.
    *
    * @return {String} namespaces
    * @api public
    */
    function disable() {
      var namespaces = [].concat(_toConsumableArray(createDebug.names), _toConsumableArray(createDebug.skips.map(function (namespace) {
        return '-' + namespace;
      }))).join(',');
      createDebug.enable('');
      return namespaces;
    }

    /**
    * Returns true if the given mode name is enabled, false otherwise.
    *
    * @param {String} name
    * @return {Boolean}
    * @api public
    */
    function enabled(name) {
      var _iterator2 = _createForOfIteratorHelper(createDebug.skips),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var skip = _step2.value;
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      var _iterator3 = _createForOfIteratorHelper(createDebug.names),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var ns = _step3.value;
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return false;
    }

    /**
    * Coerce `val`.
    *
    * @param {Mixed} val
    * @return {Mixed}
    * @api private
    */
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }

    /**
    * XXX DO NOT USE. This is a temporary stub function.
    * XXX It WILL be removed in the next major release.
    */
    function destroy() {
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common = setup;
  return common;
}

/* eslint-env browser */
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser$1.exports;
  hasRequiredBrowser = 1;
  (function (module, exports) {
    /**
     * This is the web browser implementation of `debug()`.
     */

    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = function () {
      var warned = false;
      return function () {
        if (!warned) {
          warned = true;
          console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        }
      };
    }();

    /**
     * Colors.
     */

    exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */

    // eslint-disable-next-line complexity
    function useColors() {
      // NB: In an Electron preload script, document will be defined but not fully
      // initialized. Since we know we're in Chrome, we'll just detect this case
      // explicitly
      if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
        return true;
      }

      // Internet Explorer and Edge do not support colors.
      if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      var m;

      // Is webkit? http://stackoverflow.com/a/16459606/376773
      // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
      // eslint-disable-next-line no-return-assign
      return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
      // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) ||
      // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 ||
      // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }

    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      var c = 'color: ' + this.color;
      args.splice(1, 0, c, 'color: inherit');

      // The final "%c" is somewhat tricky, because there could be other
      // arguments passed either before or after the %c, so we need to
      // figure out the correct index to insert the CSS into
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function (match) {
        if (match === '%%') {
          return;
        }
        index++;
        if (match === '%c') {
          // We only are interested in the *last* %c
          // (the user may have provided their own)
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }

    /**
     * Invokes `console.debug()` when available.
     * No-op when `console.debug` is not a "function".
     * If `console.debug` is not available, falls back
     * to `console.log`.
     *
     * @api public
     */
    exports.log = console.debug || console.log || function () {};

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem('debug', namespaces);
        } else {
          exports.storage.removeItem('debug');
        }
      } catch (error) {
        // Swallow
        // XXX (@Qix-) should we be logging these?
      }
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */
    function load() {
      var r;
      try {
        r = exports.storage.getItem('debug');
      } catch (error) {
        // Swallow
        // XXX (@Qix-) should we be logging these?
      }

      // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
      if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
      }
      return r;
    }

    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage() {
      try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
      } catch (error) {
        // Swallow
        // XXX (@Qix-) should we be logging these?
      }
    }
    module.exports = requireCommon()(exports);
    var formatters = module.exports.formatters;

    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    formatters.j = function (v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
      }
    };
  })(browser$1, browser$1.exports);
  return browser$1.exports;
}

var node$2 = {exports: {}};

var supportsColor;
var hasRequiredSupportsColor;
function requireSupportsColor() {
  if (hasRequiredSupportsColor) return supportsColor;
  hasRequiredSupportsColor = 1;
  var argv = process.argv;
  var terminator = argv.indexOf('--');
  var hasFlag = function hasFlag(flag) {
    flag = '--' + flag;
    var pos = argv.indexOf(flag);
    return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
  };
  supportsColor = function () {
    if ('FORCE_COLOR' in process.env) {
      return true;
    }
    if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {
      return false;
    }
    if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
      return true;
    }
    if (process.stdout && !process.stdout.isTTY) {
      return false;
    }
    if (process.platform === 'win32') {
      return true;
    }
    if ('COLORTERM' in process.env) {
      return true;
    }
    if (process.env.TERM === 'dumb') {
      return false;
    }
    if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
      return true;
    }
    return false;
  }();
  return supportsColor;
}

/**
 * Module dependencies.
 */
var hasRequiredNode$1;
function requireNode$1() {
  if (hasRequiredNode$1) return node$2.exports;
  hasRequiredNode$1 = 1;
  (function (module, exports) {
    var tty = require$$0$1;
    var util = require$$1;

    /**
     * This is the Node.js implementation of `debug()`.
     */

    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(function () {}, 'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');

    /**
     * Colors.
     */

    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
      // eslint-disable-next-line import/no-extraneous-dependencies
      var supportsColor = requireSupportsColor();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];
      }
    } catch (error) {
      // Swallow - we only care if `supports-color` is available; it doesn't have to be.
    }

    /**
     * Build up the default `inspectOpts` object from the environment variables.
     *
     *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
     */

    exports.inspectOpts = Object.keys(process.env).filter(function (key) {
      return /^debug_/i.test(key);
    }).reduce(function (obj, key) {
      // Camel-case
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {
        return k.toUpperCase();
      });

      // Coerce string value into JS value
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === 'null') {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});

    /**
     * Is stdout a TTY? Colored output is enabled when `true`.
     */

    function useColors() {
      return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }

    /**
     * Adds ANSI color escape codes if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      var name = this.namespace,
        useColors = this.useColors;
      if (useColors) {
        var c = this.color;
        var colorCode = "\x1B[3" + (c < 8 ? c : '8;5;' + c);
        var prefix = "  ".concat(colorCode, ";1m").concat(name, " \x1B[0m");
        args[0] = prefix + args[0].split('\n').join('\n' + prefix);
        args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + ' ' + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return '';
      }
      return new Date().toISOString() + ' ';
    }

    /**
     * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
     */

    function log() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return process.stderr.write(util.formatWithOptions.apply(util, [exports.inspectOpts].concat(args)) + '\n');
    }

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
      }
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

    function load() {
      return process.env.DEBUG;
    }

    /**
     * Init logic for `debug` instances.
     *
     * Create a new `inspectOpts` object in case `useColors` is set
     * differently for a particular `debug` instance.
     */

    function init(debug) {
      debug.inspectOpts = {};
      var keys = Object.keys(exports.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module.exports = requireCommon()(exports);
    var formatters = module.exports.formatters;

    /**
     * Map %o to `util.inspect()`, all on a single line.
     */

    formatters.o = function (v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split('\n').map(function (str) {
        return str.trim();
      }).join(' ');
    };

    /**
     * Map %O to `util.inspect()`, allowing multiple lines if needed.
     */

    formatters.O = function (v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  })(node$2, node$2.exports);
  return node$2.exports;
}

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc) return src.exports;
  hasRequiredSrc = 1;
  if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
    src.exports = requireBrowser();
  } else {
    src.exports = requireNode$1();
  }
  return src.exports;
}

var scope = {};

var renamer = {};

var lib$5 = {};

var isReactComponent = {};

var buildMatchMemberExpression = {};

var matchesPattern = {};

var generated$3 = {};

var shallowEqual = {};

var hasRequiredShallowEqual;
function requireShallowEqual() {
  if (hasRequiredShallowEqual) return shallowEqual;
  hasRequiredShallowEqual = 1;
  Object.defineProperty(shallowEqual, "__esModule", {
    value: true
  });
  shallowEqual["default"] = shallowEqual$1;
  function shallowEqual$1(actual, expected) {
    var keys = Object.keys(expected);
    for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
      var key = _keys[_i];
      if (actual[key] !== expected[key]) {
        return false;
      }
    }
    return true;
  }
  return shallowEqual;
}

var deprecationWarning = {};

var hasRequiredDeprecationWarning;
function requireDeprecationWarning() {
  if (hasRequiredDeprecationWarning) return deprecationWarning;
  hasRequiredDeprecationWarning = 1;
  Object.defineProperty(deprecationWarning, "__esModule", {
    value: true
  });
  deprecationWarning["default"] = deprecationWarning$1;
  var warnings = new Set();
  function deprecationWarning$1(oldName, newName) {
    var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
    if (warnings.has(oldName)) return;
    warnings.add(oldName);
    var _captureShortStackTra = captureShortStackTrace(1, 2),
      internal = _captureShortStackTra.internal,
      trace = _captureShortStackTra.trace;
    if (internal) {
      return;
    }
    console.warn("".concat(prefix, "`").concat(oldName, "` has been deprecated, please migrate to `").concat(newName, "`\n").concat(trace));
  }
  function captureShortStackTrace(skip, length) {
    var stackTraceLimit = Error.stackTraceLimit,
      prepareStackTrace = Error.prepareStackTrace;
    var stackTrace;
    Error.stackTraceLimit = 1 + skip + length;
    Error.prepareStackTrace = function (err, stack) {
      stackTrace = stack;
    };
    new Error().stack;
    Error.stackTraceLimit = stackTraceLimit;
    Error.prepareStackTrace = prepareStackTrace;
    if (!stackTrace) return {
      internal: false,
      trace: ""
    };
    var shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length);
    return {
      internal: /[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()),
      trace: shortStackTrace.map(function (frame) {
        return "    at ".concat(frame);
      }).join("\n")
    };
  }
  return deprecationWarning;
}

var hasRequiredGenerated$3;
function requireGenerated$3() {
  if (hasRequiredGenerated$3) return generated$3;
  hasRequiredGenerated$3 = 1;
  Object.defineProperty(generated$3, "__esModule", {
    value: true
  });
  generated$3.isAccessor = isAccessor;
  generated$3.isAnyTypeAnnotation = isAnyTypeAnnotation;
  generated$3.isArgumentPlaceholder = isArgumentPlaceholder;
  generated$3.isArrayExpression = isArrayExpression;
  generated$3.isArrayPattern = isArrayPattern;
  generated$3.isArrayTypeAnnotation = isArrayTypeAnnotation;
  generated$3.isArrowFunctionExpression = isArrowFunctionExpression;
  generated$3.isAssignmentExpression = isAssignmentExpression;
  generated$3.isAssignmentPattern = isAssignmentPattern;
  generated$3.isAwaitExpression = isAwaitExpression;
  generated$3.isBigIntLiteral = isBigIntLiteral;
  generated$3.isBinary = isBinary;
  generated$3.isBinaryExpression = isBinaryExpression;
  generated$3.isBindExpression = isBindExpression;
  generated$3.isBlock = isBlock;
  generated$3.isBlockParent = isBlockParent;
  generated$3.isBlockStatement = isBlockStatement;
  generated$3.isBooleanLiteral = isBooleanLiteral;
  generated$3.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
  generated$3.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
  generated$3.isBreakStatement = isBreakStatement;
  generated$3.isCallExpression = isCallExpression;
  generated$3.isCatchClause = isCatchClause;
  generated$3.isClass = isClass;
  generated$3.isClassAccessorProperty = isClassAccessorProperty;
  generated$3.isClassBody = isClassBody;
  generated$3.isClassDeclaration = isClassDeclaration;
  generated$3.isClassExpression = isClassExpression;
  generated$3.isClassImplements = isClassImplements;
  generated$3.isClassMethod = isClassMethod;
  generated$3.isClassPrivateMethod = isClassPrivateMethod;
  generated$3.isClassPrivateProperty = isClassPrivateProperty;
  generated$3.isClassProperty = isClassProperty;
  generated$3.isCompletionStatement = isCompletionStatement;
  generated$3.isConditional = isConditional;
  generated$3.isConditionalExpression = isConditionalExpression;
  generated$3.isContinueStatement = isContinueStatement;
  generated$3.isDebuggerStatement = isDebuggerStatement;
  generated$3.isDecimalLiteral = isDecimalLiteral;
  generated$3.isDeclaration = isDeclaration;
  generated$3.isDeclareClass = isDeclareClass;
  generated$3.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
  generated$3.isDeclareExportDeclaration = isDeclareExportDeclaration;
  generated$3.isDeclareFunction = isDeclareFunction;
  generated$3.isDeclareInterface = isDeclareInterface;
  generated$3.isDeclareModule = isDeclareModule;
  generated$3.isDeclareModuleExports = isDeclareModuleExports;
  generated$3.isDeclareOpaqueType = isDeclareOpaqueType;
  generated$3.isDeclareTypeAlias = isDeclareTypeAlias;
  generated$3.isDeclareVariable = isDeclareVariable;
  generated$3.isDeclaredPredicate = isDeclaredPredicate;
  generated$3.isDecorator = isDecorator;
  generated$3.isDirective = isDirective;
  generated$3.isDirectiveLiteral = isDirectiveLiteral;
  generated$3.isDoExpression = isDoExpression;
  generated$3.isDoWhileStatement = isDoWhileStatement;
  generated$3.isEmptyStatement = isEmptyStatement;
  generated$3.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
  generated$3.isEnumBody = isEnumBody;
  generated$3.isEnumBooleanBody = isEnumBooleanBody;
  generated$3.isEnumBooleanMember = isEnumBooleanMember;
  generated$3.isEnumDeclaration = isEnumDeclaration;
  generated$3.isEnumDefaultedMember = isEnumDefaultedMember;
  generated$3.isEnumMember = isEnumMember;
  generated$3.isEnumNumberBody = isEnumNumberBody;
  generated$3.isEnumNumberMember = isEnumNumberMember;
  generated$3.isEnumStringBody = isEnumStringBody;
  generated$3.isEnumStringMember = isEnumStringMember;
  generated$3.isEnumSymbolBody = isEnumSymbolBody;
  generated$3.isExistsTypeAnnotation = isExistsTypeAnnotation;
  generated$3.isExportAllDeclaration = isExportAllDeclaration;
  generated$3.isExportDeclaration = isExportDeclaration;
  generated$3.isExportDefaultDeclaration = isExportDefaultDeclaration;
  generated$3.isExportDefaultSpecifier = isExportDefaultSpecifier;
  generated$3.isExportNamedDeclaration = isExportNamedDeclaration;
  generated$3.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
  generated$3.isExportSpecifier = isExportSpecifier;
  generated$3.isExpression = isExpression;
  generated$3.isExpressionStatement = isExpressionStatement;
  generated$3.isExpressionWrapper = isExpressionWrapper;
  generated$3.isFile = isFile;
  generated$3.isFlow = isFlow;
  generated$3.isFlowBaseAnnotation = isFlowBaseAnnotation;
  generated$3.isFlowDeclaration = isFlowDeclaration;
  generated$3.isFlowPredicate = isFlowPredicate;
  generated$3.isFlowType = isFlowType;
  generated$3.isFor = isFor;
  generated$3.isForInStatement = isForInStatement;
  generated$3.isForOfStatement = isForOfStatement;
  generated$3.isForStatement = isForStatement;
  generated$3.isForXStatement = isForXStatement;
  generated$3.isFunction = isFunction;
  generated$3.isFunctionDeclaration = isFunctionDeclaration;
  generated$3.isFunctionExpression = isFunctionExpression;
  generated$3.isFunctionParent = isFunctionParent;
  generated$3.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
  generated$3.isFunctionTypeParam = isFunctionTypeParam;
  generated$3.isGenericTypeAnnotation = isGenericTypeAnnotation;
  generated$3.isIdentifier = isIdentifier;
  generated$3.isIfStatement = isIfStatement;
  generated$3.isImmutable = isImmutable;
  generated$3.isImport = isImport;
  generated$3.isImportAttribute = isImportAttribute;
  generated$3.isImportDeclaration = isImportDeclaration;
  generated$3.isImportDefaultSpecifier = isImportDefaultSpecifier;
  generated$3.isImportExpression = isImportExpression;
  generated$3.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
  generated$3.isImportOrExportDeclaration = isImportOrExportDeclaration;
  generated$3.isImportSpecifier = isImportSpecifier;
  generated$3.isIndexedAccessType = isIndexedAccessType;
  generated$3.isInferredPredicate = isInferredPredicate;
  generated$3.isInterfaceDeclaration = isInterfaceDeclaration;
  generated$3.isInterfaceExtends = isInterfaceExtends;
  generated$3.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
  generated$3.isInterpreterDirective = isInterpreterDirective;
  generated$3.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
  generated$3.isJSX = isJSX;
  generated$3.isJSXAttribute = isJSXAttribute;
  generated$3.isJSXClosingElement = isJSXClosingElement;
  generated$3.isJSXClosingFragment = isJSXClosingFragment;
  generated$3.isJSXElement = isJSXElement;
  generated$3.isJSXEmptyExpression = isJSXEmptyExpression;
  generated$3.isJSXExpressionContainer = isJSXExpressionContainer;
  generated$3.isJSXFragment = isJSXFragment;
  generated$3.isJSXIdentifier = isJSXIdentifier;
  generated$3.isJSXMemberExpression = isJSXMemberExpression;
  generated$3.isJSXNamespacedName = isJSXNamespacedName;
  generated$3.isJSXOpeningElement = isJSXOpeningElement;
  generated$3.isJSXOpeningFragment = isJSXOpeningFragment;
  generated$3.isJSXSpreadAttribute = isJSXSpreadAttribute;
  generated$3.isJSXSpreadChild = isJSXSpreadChild;
  generated$3.isJSXText = isJSXText;
  generated$3.isLVal = isLVal;
  generated$3.isLabeledStatement = isLabeledStatement;
  generated$3.isLiteral = isLiteral;
  generated$3.isLogicalExpression = isLogicalExpression;
  generated$3.isLoop = isLoop;
  generated$3.isMemberExpression = isMemberExpression;
  generated$3.isMetaProperty = isMetaProperty;
  generated$3.isMethod = isMethod;
  generated$3.isMiscellaneous = isMiscellaneous;
  generated$3.isMixedTypeAnnotation = isMixedTypeAnnotation;
  generated$3.isModuleDeclaration = isModuleDeclaration;
  generated$3.isModuleExpression = isModuleExpression;
  generated$3.isModuleSpecifier = isModuleSpecifier;
  generated$3.isNewExpression = isNewExpression;
  generated$3.isNoop = isNoop;
  generated$3.isNullLiteral = isNullLiteral;
  generated$3.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
  generated$3.isNullableTypeAnnotation = isNullableTypeAnnotation;
  generated$3.isNumberLiteral = isNumberLiteral;
  generated$3.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
  generated$3.isNumberTypeAnnotation = isNumberTypeAnnotation;
  generated$3.isNumericLiteral = isNumericLiteral;
  generated$3.isObjectExpression = isObjectExpression;
  generated$3.isObjectMember = isObjectMember;
  generated$3.isObjectMethod = isObjectMethod;
  generated$3.isObjectPattern = isObjectPattern;
  generated$3.isObjectProperty = isObjectProperty;
  generated$3.isObjectTypeAnnotation = isObjectTypeAnnotation;
  generated$3.isObjectTypeCallProperty = isObjectTypeCallProperty;
  generated$3.isObjectTypeIndexer = isObjectTypeIndexer;
  generated$3.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
  generated$3.isObjectTypeProperty = isObjectTypeProperty;
  generated$3.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
  generated$3.isOpaqueType = isOpaqueType;
  generated$3.isOptionalCallExpression = isOptionalCallExpression;
  generated$3.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
  generated$3.isOptionalMemberExpression = isOptionalMemberExpression;
  generated$3.isParenthesizedExpression = isParenthesizedExpression;
  generated$3.isPattern = isPattern;
  generated$3.isPatternLike = isPatternLike;
  generated$3.isPipelineBareFunction = isPipelineBareFunction;
  generated$3.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
  generated$3.isPipelineTopicExpression = isPipelineTopicExpression;
  generated$3.isPlaceholder = isPlaceholder;
  generated$3.isPrivate = isPrivate;
  generated$3.isPrivateName = isPrivateName;
  generated$3.isProgram = isProgram;
  generated$3.isProperty = isProperty;
  generated$3.isPureish = isPureish;
  generated$3.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
  generated$3.isRecordExpression = isRecordExpression;
  generated$3.isRegExpLiteral = isRegExpLiteral;
  generated$3.isRegexLiteral = isRegexLiteral;
  generated$3.isRestElement = isRestElement;
  generated$3.isRestProperty = isRestProperty;
  generated$3.isReturnStatement = isReturnStatement;
  generated$3.isScopable = isScopable;
  generated$3.isSequenceExpression = isSequenceExpression;
  generated$3.isSpreadElement = isSpreadElement;
  generated$3.isSpreadProperty = isSpreadProperty;
  generated$3.isStandardized = isStandardized;
  generated$3.isStatement = isStatement;
  generated$3.isStaticBlock = isStaticBlock;
  generated$3.isStringLiteral = isStringLiteral;
  generated$3.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
  generated$3.isStringTypeAnnotation = isStringTypeAnnotation;
  generated$3.isSuper = isSuper;
  generated$3.isSwitchCase = isSwitchCase;
  generated$3.isSwitchStatement = isSwitchStatement;
  generated$3.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
  generated$3.isTSAnyKeyword = isTSAnyKeyword;
  generated$3.isTSArrayType = isTSArrayType;
  generated$3.isTSAsExpression = isTSAsExpression;
  generated$3.isTSBaseType = isTSBaseType;
  generated$3.isTSBigIntKeyword = isTSBigIntKeyword;
  generated$3.isTSBooleanKeyword = isTSBooleanKeyword;
  generated$3.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
  generated$3.isTSConditionalType = isTSConditionalType;
  generated$3.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
  generated$3.isTSConstructorType = isTSConstructorType;
  generated$3.isTSDeclareFunction = isTSDeclareFunction;
  generated$3.isTSDeclareMethod = isTSDeclareMethod;
  generated$3.isTSEntityName = isTSEntityName;
  generated$3.isTSEnumBody = isTSEnumBody;
  generated$3.isTSEnumDeclaration = isTSEnumDeclaration;
  generated$3.isTSEnumMember = isTSEnumMember;
  generated$3.isTSExportAssignment = isTSExportAssignment;
  generated$3.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
  generated$3.isTSExternalModuleReference = isTSExternalModuleReference;
  generated$3.isTSFunctionType = isTSFunctionType;
  generated$3.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
  generated$3.isTSImportType = isTSImportType;
  generated$3.isTSIndexSignature = isTSIndexSignature;
  generated$3.isTSIndexedAccessType = isTSIndexedAccessType;
  generated$3.isTSInferType = isTSInferType;
  generated$3.isTSInstantiationExpression = isTSInstantiationExpression;
  generated$3.isTSInterfaceBody = isTSInterfaceBody;
  generated$3.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
  generated$3.isTSIntersectionType = isTSIntersectionType;
  generated$3.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
  generated$3.isTSLiteralType = isTSLiteralType;
  generated$3.isTSMappedType = isTSMappedType;
  generated$3.isTSMethodSignature = isTSMethodSignature;
  generated$3.isTSModuleBlock = isTSModuleBlock;
  generated$3.isTSModuleDeclaration = isTSModuleDeclaration;
  generated$3.isTSNamedTupleMember = isTSNamedTupleMember;
  generated$3.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
  generated$3.isTSNeverKeyword = isTSNeverKeyword;
  generated$3.isTSNonNullExpression = isTSNonNullExpression;
  generated$3.isTSNullKeyword = isTSNullKeyword;
  generated$3.isTSNumberKeyword = isTSNumberKeyword;
  generated$3.isTSObjectKeyword = isTSObjectKeyword;
  generated$3.isTSOptionalType = isTSOptionalType;
  generated$3.isTSParameterProperty = isTSParameterProperty;
  generated$3.isTSParenthesizedType = isTSParenthesizedType;
  generated$3.isTSPropertySignature = isTSPropertySignature;
  generated$3.isTSQualifiedName = isTSQualifiedName;
  generated$3.isTSRestType = isTSRestType;
  generated$3.isTSSatisfiesExpression = isTSSatisfiesExpression;
  generated$3.isTSStringKeyword = isTSStringKeyword;
  generated$3.isTSSymbolKeyword = isTSSymbolKeyword;
  generated$3.isTSTemplateLiteralType = isTSTemplateLiteralType;
  generated$3.isTSThisType = isTSThisType;
  generated$3.isTSTupleType = isTSTupleType;
  generated$3.isTSType = isTSType;
  generated$3.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
  generated$3.isTSTypeAnnotation = isTSTypeAnnotation;
  generated$3.isTSTypeAssertion = isTSTypeAssertion;
  generated$3.isTSTypeElement = isTSTypeElement;
  generated$3.isTSTypeLiteral = isTSTypeLiteral;
  generated$3.isTSTypeOperator = isTSTypeOperator;
  generated$3.isTSTypeParameter = isTSTypeParameter;
  generated$3.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
  generated$3.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
  generated$3.isTSTypePredicate = isTSTypePredicate;
  generated$3.isTSTypeQuery = isTSTypeQuery;
  generated$3.isTSTypeReference = isTSTypeReference;
  generated$3.isTSUndefinedKeyword = isTSUndefinedKeyword;
  generated$3.isTSUnionType = isTSUnionType;
  generated$3.isTSUnknownKeyword = isTSUnknownKeyword;
  generated$3.isTSVoidKeyword = isTSVoidKeyword;
  generated$3.isTaggedTemplateExpression = isTaggedTemplateExpression;
  generated$3.isTemplateElement = isTemplateElement;
  generated$3.isTemplateLiteral = isTemplateLiteral;
  generated$3.isTerminatorless = isTerminatorless;
  generated$3.isThisExpression = isThisExpression;
  generated$3.isThisTypeAnnotation = isThisTypeAnnotation;
  generated$3.isThrowStatement = isThrowStatement;
  generated$3.isTopicReference = isTopicReference;
  generated$3.isTryStatement = isTryStatement;
  generated$3.isTupleExpression = isTupleExpression;
  generated$3.isTupleTypeAnnotation = isTupleTypeAnnotation;
  generated$3.isTypeAlias = isTypeAlias;
  generated$3.isTypeAnnotation = isTypeAnnotation;
  generated$3.isTypeCastExpression = isTypeCastExpression;
  generated$3.isTypeParameter = isTypeParameter;
  generated$3.isTypeParameterDeclaration = isTypeParameterDeclaration;
  generated$3.isTypeParameterInstantiation = isTypeParameterInstantiation;
  generated$3.isTypeScript = isTypeScript;
  generated$3.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
  generated$3.isUnaryExpression = isUnaryExpression;
  generated$3.isUnaryLike = isUnaryLike;
  generated$3.isUnionTypeAnnotation = isUnionTypeAnnotation;
  generated$3.isUpdateExpression = isUpdateExpression;
  generated$3.isUserWhitespacable = isUserWhitespacable;
  generated$3.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
  generated$3.isVariableDeclaration = isVariableDeclaration;
  generated$3.isVariableDeclarator = isVariableDeclarator;
  generated$3.isVariance = isVariance;
  generated$3.isVoidTypeAnnotation = isVoidTypeAnnotation;
  generated$3.isWhile = isWhile;
  generated$3.isWhileStatement = isWhileStatement;
  generated$3.isWithStatement = isWithStatement;
  generated$3.isYieldExpression = isYieldExpression;
  var _shallowEqual = requireShallowEqual();
  var _deprecationWarning = requireDeprecationWarning();
  function isArrayExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "ArrayExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isAssignmentExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "AssignmentExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isBinaryExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "BinaryExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isInterpreterDirective(node, opts) {
    if (!node) return false;
    if (node.type !== "InterpreterDirective") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isDirective(node, opts) {
    if (!node) return false;
    if (node.type !== "Directive") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isDirectiveLiteral(node, opts) {
    if (!node) return false;
    if (node.type !== "DirectiveLiteral") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isBlockStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "BlockStatement") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isBreakStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "BreakStatement") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isCallExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "CallExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isCatchClause(node, opts) {
    if (!node) return false;
    if (node.type !== "CatchClause") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isConditionalExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "ConditionalExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isContinueStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "ContinueStatement") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isDebuggerStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "DebuggerStatement") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isDoWhileStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "DoWhileStatement") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isEmptyStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "EmptyStatement") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isExpressionStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "ExpressionStatement") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isFile(node, opts) {
    if (!node) return false;
    if (node.type !== "File") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isForInStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "ForInStatement") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isForStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "ForStatement") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isFunctionDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "FunctionDeclaration") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isFunctionExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "FunctionExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isIdentifier(node, opts) {
    if (!node) return false;
    if (node.type !== "Identifier") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isIfStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "IfStatement") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isLabeledStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "LabeledStatement") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isStringLiteral(node, opts) {
    if (!node) return false;
    if (node.type !== "StringLiteral") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isNumericLiteral(node, opts) {
    if (!node) return false;
    if (node.type !== "NumericLiteral") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isNullLiteral(node, opts) {
    if (!node) return false;
    if (node.type !== "NullLiteral") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isBooleanLiteral(node, opts) {
    if (!node) return false;
    if (node.type !== "BooleanLiteral") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isRegExpLiteral(node, opts) {
    if (!node) return false;
    if (node.type !== "RegExpLiteral") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isLogicalExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "LogicalExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isMemberExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "MemberExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isNewExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "NewExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isProgram(node, opts) {
    if (!node) return false;
    if (node.type !== "Program") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isObjectExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isObjectMethod(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectMethod") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isObjectProperty(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectProperty") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isRestElement(node, opts) {
    if (!node) return false;
    if (node.type !== "RestElement") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isReturnStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "ReturnStatement") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isSequenceExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "SequenceExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isParenthesizedExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "ParenthesizedExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isSwitchCase(node, opts) {
    if (!node) return false;
    if (node.type !== "SwitchCase") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isSwitchStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "SwitchStatement") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isThisExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "ThisExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isThrowStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "ThrowStatement") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTryStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "TryStatement") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isUnaryExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "UnaryExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isUpdateExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "UpdateExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isVariableDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "VariableDeclaration") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isVariableDeclarator(node, opts) {
    if (!node) return false;
    if (node.type !== "VariableDeclarator") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isWhileStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "WhileStatement") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isWithStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "WithStatement") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isAssignmentPattern(node, opts) {
    if (!node) return false;
    if (node.type !== "AssignmentPattern") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isArrayPattern(node, opts) {
    if (!node) return false;
    if (node.type !== "ArrayPattern") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isArrowFunctionExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "ArrowFunctionExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isClassBody(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassBody") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isClassExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isClassDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassDeclaration") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isExportAllDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "ExportAllDeclaration") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isExportDefaultDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "ExportDefaultDeclaration") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isExportNamedDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "ExportNamedDeclaration") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isExportSpecifier(node, opts) {
    if (!node) return false;
    if (node.type !== "ExportSpecifier") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isForOfStatement(node, opts) {
    if (!node) return false;
    if (node.type !== "ForOfStatement") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isImportDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "ImportDeclaration") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isImportDefaultSpecifier(node, opts) {
    if (!node) return false;
    if (node.type !== "ImportDefaultSpecifier") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isImportNamespaceSpecifier(node, opts) {
    if (!node) return false;
    if (node.type !== "ImportNamespaceSpecifier") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isImportSpecifier(node, opts) {
    if (!node) return false;
    if (node.type !== "ImportSpecifier") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isImportExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "ImportExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isMetaProperty(node, opts) {
    if (!node) return false;
    if (node.type !== "MetaProperty") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isClassMethod(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassMethod") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isObjectPattern(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectPattern") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isSpreadElement(node, opts) {
    if (!node) return false;
    if (node.type !== "SpreadElement") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isSuper(node, opts) {
    if (!node) return false;
    if (node.type !== "Super") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTaggedTemplateExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "TaggedTemplateExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTemplateElement(node, opts) {
    if (!node) return false;
    if (node.type !== "TemplateElement") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTemplateLiteral(node, opts) {
    if (!node) return false;
    if (node.type !== "TemplateLiteral") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isYieldExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "YieldExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isAwaitExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "AwaitExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isImport(node, opts) {
    if (!node) return false;
    if (node.type !== "Import") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isBigIntLiteral(node, opts) {
    if (!node) return false;
    if (node.type !== "BigIntLiteral") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isExportNamespaceSpecifier(node, opts) {
    if (!node) return false;
    if (node.type !== "ExportNamespaceSpecifier") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isOptionalMemberExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "OptionalMemberExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isOptionalCallExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "OptionalCallExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isClassProperty(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassProperty") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isClassAccessorProperty(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassAccessorProperty") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isClassPrivateProperty(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassPrivateProperty") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isClassPrivateMethod(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassPrivateMethod") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isPrivateName(node, opts) {
    if (!node) return false;
    if (node.type !== "PrivateName") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isStaticBlock(node, opts) {
    if (!node) return false;
    if (node.type !== "StaticBlock") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isAnyTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "AnyTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isArrayTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "ArrayTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isBooleanTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "BooleanTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isBooleanLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "BooleanLiteralTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isNullLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "NullLiteralTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isClassImplements(node, opts) {
    if (!node) return false;
    if (node.type !== "ClassImplements") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isDeclareClass(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareClass") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isDeclareFunction(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareFunction") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isDeclareInterface(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareInterface") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isDeclareModule(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareModule") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isDeclareModuleExports(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareModuleExports") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isDeclareTypeAlias(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareTypeAlias") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isDeclareOpaqueType(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareOpaqueType") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isDeclareVariable(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareVariable") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isDeclareExportDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareExportDeclaration") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isDeclareExportAllDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclareExportAllDeclaration") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isDeclaredPredicate(node, opts) {
    if (!node) return false;
    if (node.type !== "DeclaredPredicate") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isExistsTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "ExistsTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isFunctionTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "FunctionTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isFunctionTypeParam(node, opts) {
    if (!node) return false;
    if (node.type !== "FunctionTypeParam") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isGenericTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "GenericTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isInferredPredicate(node, opts) {
    if (!node) return false;
    if (node.type !== "InferredPredicate") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isInterfaceExtends(node, opts) {
    if (!node) return false;
    if (node.type !== "InterfaceExtends") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isInterfaceDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "InterfaceDeclaration") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isInterfaceTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "InterfaceTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isIntersectionTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "IntersectionTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isMixedTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "MixedTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isEmptyTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "EmptyTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isNullableTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "NullableTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isNumberLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "NumberLiteralTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isNumberTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "NumberTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isObjectTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isObjectTypeInternalSlot(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectTypeInternalSlot") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isObjectTypeCallProperty(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectTypeCallProperty") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isObjectTypeIndexer(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectTypeIndexer") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isObjectTypeProperty(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectTypeProperty") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isObjectTypeSpreadProperty(node, opts) {
    if (!node) return false;
    if (node.type !== "ObjectTypeSpreadProperty") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isOpaqueType(node, opts) {
    if (!node) return false;
    if (node.type !== "OpaqueType") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isQualifiedTypeIdentifier(node, opts) {
    if (!node) return false;
    if (node.type !== "QualifiedTypeIdentifier") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isStringLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "StringLiteralTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isStringTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "StringTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isSymbolTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "SymbolTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isThisTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "ThisTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTupleTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "TupleTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTypeofTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "TypeofTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTypeAlias(node, opts) {
    if (!node) return false;
    if (node.type !== "TypeAlias") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "TypeAnnotation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTypeCastExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "TypeCastExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTypeParameter(node, opts) {
    if (!node) return false;
    if (node.type !== "TypeParameter") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTypeParameterDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TypeParameterDeclaration") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTypeParameterInstantiation(node, opts) {
    if (!node) return false;
    if (node.type !== "TypeParameterInstantiation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isUnionTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "UnionTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isVariance(node, opts) {
    if (!node) return false;
    if (node.type !== "Variance") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isVoidTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "VoidTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isEnumDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumDeclaration") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isEnumBooleanBody(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumBooleanBody") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isEnumNumberBody(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumNumberBody") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isEnumStringBody(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumStringBody") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isEnumSymbolBody(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumSymbolBody") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isEnumBooleanMember(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumBooleanMember") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isEnumNumberMember(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumNumberMember") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isEnumStringMember(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumStringMember") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isEnumDefaultedMember(node, opts) {
    if (!node) return false;
    if (node.type !== "EnumDefaultedMember") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isIndexedAccessType(node, opts) {
    if (!node) return false;
    if (node.type !== "IndexedAccessType") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isOptionalIndexedAccessType(node, opts) {
    if (!node) return false;
    if (node.type !== "OptionalIndexedAccessType") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isJSXAttribute(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXAttribute") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isJSXClosingElement(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXClosingElement") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isJSXElement(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXElement") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isJSXEmptyExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXEmptyExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isJSXExpressionContainer(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXExpressionContainer") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isJSXSpreadChild(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXSpreadChild") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isJSXIdentifier(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXIdentifier") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isJSXMemberExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXMemberExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isJSXNamespacedName(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXNamespacedName") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isJSXOpeningElement(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXOpeningElement") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isJSXSpreadAttribute(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXSpreadAttribute") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isJSXText(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXText") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isJSXFragment(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXFragment") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isJSXOpeningFragment(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXOpeningFragment") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isJSXClosingFragment(node, opts) {
    if (!node) return false;
    if (node.type !== "JSXClosingFragment") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isNoop(node, opts) {
    if (!node) return false;
    if (node.type !== "Noop") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isPlaceholder(node, opts) {
    if (!node) return false;
    if (node.type !== "Placeholder") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isV8IntrinsicIdentifier(node, opts) {
    if (!node) return false;
    if (node.type !== "V8IntrinsicIdentifier") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isArgumentPlaceholder(node, opts) {
    if (!node) return false;
    if (node.type !== "ArgumentPlaceholder") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isBindExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "BindExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isImportAttribute(node, opts) {
    if (!node) return false;
    if (node.type !== "ImportAttribute") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isDecorator(node, opts) {
    if (!node) return false;
    if (node.type !== "Decorator") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isDoExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "DoExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isExportDefaultSpecifier(node, opts) {
    if (!node) return false;
    if (node.type !== "ExportDefaultSpecifier") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isRecordExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "RecordExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTupleExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "TupleExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isDecimalLiteral(node, opts) {
    if (!node) return false;
    if (node.type !== "DecimalLiteral") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isModuleExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "ModuleExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTopicReference(node, opts) {
    if (!node) return false;
    if (node.type !== "TopicReference") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isPipelineTopicExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "PipelineTopicExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isPipelineBareFunction(node, opts) {
    if (!node) return false;
    if (node.type !== "PipelineBareFunction") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isPipelinePrimaryTopicReference(node, opts) {
    if (!node) return false;
    if (node.type !== "PipelinePrimaryTopicReference") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSParameterProperty(node, opts) {
    if (!node) return false;
    if (node.type !== "TSParameterProperty") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSDeclareFunction(node, opts) {
    if (!node) return false;
    if (node.type !== "TSDeclareFunction") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSDeclareMethod(node, opts) {
    if (!node) return false;
    if (node.type !== "TSDeclareMethod") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSQualifiedName(node, opts) {
    if (!node) return false;
    if (node.type !== "TSQualifiedName") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSCallSignatureDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSCallSignatureDeclaration") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSConstructSignatureDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSConstructSignatureDeclaration") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSPropertySignature(node, opts) {
    if (!node) return false;
    if (node.type !== "TSPropertySignature") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSMethodSignature(node, opts) {
    if (!node) return false;
    if (node.type !== "TSMethodSignature") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSIndexSignature(node, opts) {
    if (!node) return false;
    if (node.type !== "TSIndexSignature") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSAnyKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSAnyKeyword") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSBooleanKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSBooleanKeyword") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSBigIntKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSBigIntKeyword") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSIntrinsicKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSIntrinsicKeyword") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSNeverKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSNeverKeyword") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSNullKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSNullKeyword") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSNumberKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSNumberKeyword") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSObjectKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSObjectKeyword") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSStringKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSStringKeyword") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSSymbolKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSSymbolKeyword") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSUndefinedKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSUndefinedKeyword") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSUnknownKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSUnknownKeyword") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSVoidKeyword(node, opts) {
    if (!node) return false;
    if (node.type !== "TSVoidKeyword") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSThisType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSThisType") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSFunctionType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSFunctionType") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSConstructorType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSConstructorType") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSTypeReference(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeReference") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSTypePredicate(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypePredicate") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSTypeQuery(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeQuery") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSTypeLiteral(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeLiteral") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSArrayType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSArrayType") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSTupleType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTupleType") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSOptionalType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSOptionalType") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSRestType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSRestType") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSNamedTupleMember(node, opts) {
    if (!node) return false;
    if (node.type !== "TSNamedTupleMember") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSUnionType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSUnionType") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSIntersectionType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSIntersectionType") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSConditionalType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSConditionalType") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSInferType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSInferType") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSParenthesizedType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSParenthesizedType") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSTypeOperator(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeOperator") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSIndexedAccessType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSIndexedAccessType") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSMappedType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSMappedType") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSTemplateLiteralType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTemplateLiteralType") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSLiteralType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSLiteralType") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSExpressionWithTypeArguments(node, opts) {
    if (!node) return false;
    if (node.type !== "TSExpressionWithTypeArguments") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSInterfaceDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSInterfaceDeclaration") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSInterfaceBody(node, opts) {
    if (!node) return false;
    if (node.type !== "TSInterfaceBody") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSTypeAliasDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeAliasDeclaration") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSInstantiationExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "TSInstantiationExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSAsExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "TSAsExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSSatisfiesExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "TSSatisfiesExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSTypeAssertion(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeAssertion") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSEnumBody(node, opts) {
    if (!node) return false;
    if (node.type !== "TSEnumBody") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSEnumDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSEnumDeclaration") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSEnumMember(node, opts) {
    if (!node) return false;
    if (node.type !== "TSEnumMember") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSModuleDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSModuleDeclaration") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSModuleBlock(node, opts) {
    if (!node) return false;
    if (node.type !== "TSModuleBlock") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSImportType(node, opts) {
    if (!node) return false;
    if (node.type !== "TSImportType") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSImportEqualsDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSImportEqualsDeclaration") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSExternalModuleReference(node, opts) {
    if (!node) return false;
    if (node.type !== "TSExternalModuleReference") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSNonNullExpression(node, opts) {
    if (!node) return false;
    if (node.type !== "TSNonNullExpression") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSExportAssignment(node, opts) {
    if (!node) return false;
    if (node.type !== "TSExportAssignment") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSNamespaceExportDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSNamespaceExportDeclaration") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSTypeAnnotation(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeAnnotation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSTypeParameterInstantiation(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeParameterInstantiation") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSTypeParameterDeclaration(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeParameterDeclaration") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSTypeParameter(node, opts) {
    if (!node) return false;
    if (node.type !== "TSTypeParameter") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isStandardized(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportExpression":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
        break;
      case "Placeholder":
        switch (node.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isExpression(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ImportExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (node.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isBinary(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isScopable(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (node.expectedNode === "BlockStatement") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isBlockParent(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (node.expectedNode === "BlockStatement") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isBlock(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (node.expectedNode === "BlockStatement") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isStatement(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (node.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTerminatorless(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isCompletionStatement(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isConditional(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isLoop(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isWhile(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isExpressionWrapper(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isFor(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isForXStatement(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isFunction(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isFunctionParent(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isPureish(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (node.expectedNode === "StringLiteral") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isDeclaration(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
        break;
      case "Placeholder":
        if (node.expectedNode === "Declaration") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isPatternLike(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (node.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isLVal(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (node.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return false;
        }
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSEntityName(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if (node.expectedNode === "Identifier") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isLiteral(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (node.expectedNode === "StringLiteral") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isImmutable(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "BigIntLiteral":
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXOpeningElement":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (node.expectedNode === "StringLiteral") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isUserWhitespacable(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isMethod(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isObjectMember(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isProperty(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isUnaryLike(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isPattern(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
        break;
      case "Placeholder":
        if (node.expectedNode === "Pattern") break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isClass(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isImportOrExportDeclaration(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isExportDeclaration(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isModuleSpecifier(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isAccessor(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ClassAccessorProperty":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isPrivate(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isFlow(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isFlowType(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isFlowBaseAnnotation(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isFlowDeclaration(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isFlowPredicate(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isEnumBody(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isEnumMember(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isJSX(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isMiscellaneous(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTypeScript(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumBody":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSTypeElement(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSType(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isTSBaseType(node, opts) {
    if (!node) return false;
    switch (node.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
        break;
      default:
        return false;
    }
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isNumberLiteral(node, opts) {
    (0, _deprecationWarning["default"])("isNumberLiteral", "isNumericLiteral");
    if (!node) return false;
    if (node.type !== "NumberLiteral") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isRegexLiteral(node, opts) {
    (0, _deprecationWarning["default"])("isRegexLiteral", "isRegExpLiteral");
    if (!node) return false;
    if (node.type !== "RegexLiteral") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isRestProperty(node, opts) {
    (0, _deprecationWarning["default"])("isRestProperty", "isRestElement");
    if (!node) return false;
    if (node.type !== "RestProperty") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isSpreadProperty(node, opts) {
    (0, _deprecationWarning["default"])("isSpreadProperty", "isSpreadElement");
    if (!node) return false;
    if (node.type !== "SpreadProperty") return false;
    return opts == null || (0, _shallowEqual["default"])(node, opts);
  }
  function isModuleDeclaration(node, opts) {
    (0, _deprecationWarning["default"])("isModuleDeclaration", "isImportOrExportDeclaration");
    return isImportOrExportDeclaration(node, opts);
  }
  return generated$3;
}

var hasRequiredMatchesPattern;
function requireMatchesPattern() {
  if (hasRequiredMatchesPattern) return matchesPattern;
  hasRequiredMatchesPattern = 1;
  Object.defineProperty(matchesPattern, "__esModule", {
    value: true
  });
  matchesPattern["default"] = matchesPattern$1;
  var _index = requireGenerated$3();
  function matchesPattern$1(member, match, allowPartial) {
    if (!(0, _index.isMemberExpression)(member)) return false;
    var parts = Array.isArray(match) ? match : match.split(".");
    var nodes = [];
    var node;
    for (node = member; (0, _index.isMemberExpression)(node); node = node.object) {
      nodes.push(node.property);
    }
    nodes.push(node);
    if (nodes.length < parts.length) return false;
    if (!allowPartial && nodes.length > parts.length) return false;
    for (var i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
      var _node = nodes[j];
      var value = void 0;
      if ((0, _index.isIdentifier)(_node)) {
        value = _node.name;
      } else if ((0, _index.isStringLiteral)(_node)) {
        value = _node.value;
      } else if ((0, _index.isThisExpression)(_node)) {
        value = "this";
      } else {
        return false;
      }
      if (parts[i] !== value) return false;
    }
    return true;
  }
  return matchesPattern;
}

var hasRequiredBuildMatchMemberExpression;
function requireBuildMatchMemberExpression() {
  if (hasRequiredBuildMatchMemberExpression) return buildMatchMemberExpression;
  hasRequiredBuildMatchMemberExpression = 1;
  Object.defineProperty(buildMatchMemberExpression, "__esModule", {
    value: true
  });
  buildMatchMemberExpression["default"] = buildMatchMemberExpression$1;
  var _matchesPattern = requireMatchesPattern();
  function buildMatchMemberExpression$1(match, allowPartial) {
    var parts = match.split(".");
    return function (member) {
      return (0, _matchesPattern["default"])(member, parts, allowPartial);
    };
  }
  return buildMatchMemberExpression;
}

var hasRequiredIsReactComponent;
function requireIsReactComponent() {
  if (hasRequiredIsReactComponent) return isReactComponent;
  hasRequiredIsReactComponent = 1;
  Object.defineProperty(isReactComponent, "__esModule", {
    value: true
  });
  isReactComponent["default"] = void 0;
  var _buildMatchMemberExpression = requireBuildMatchMemberExpression();
  var isReactComponent$1 = (0, _buildMatchMemberExpression["default"])("React.Component");
  isReactComponent["default"] = isReactComponent$1;
  return isReactComponent;
}

var isCompatTag = {};

var hasRequiredIsCompatTag;
function requireIsCompatTag() {
  if (hasRequiredIsCompatTag) return isCompatTag;
  hasRequiredIsCompatTag = 1;
  Object.defineProperty(isCompatTag, "__esModule", {
    value: true
  });
  isCompatTag["default"] = isCompatTag$1;
  function isCompatTag$1(tagName) {
    return !!tagName && /^[a-z]/.test(tagName);
  }
  return isCompatTag;
}

var buildChildren = {};

var cleanJSXElementLiteralChild = {};

var generated$2 = {};

var lowercase = {};

var validate = {};

var definitions = {};

var core = {};

var is = {};

var isType = {};

var hasRequiredIsType;
function requireIsType() {
  if (hasRequiredIsType) return isType;
  hasRequiredIsType = 1;
  Object.defineProperty(isType, "__esModule", {
    value: true
  });
  isType["default"] = isType$1;
  var _index = requireDefinitions();
  function isType$1(nodeType, targetType) {
    if (nodeType === targetType) return true;
    if (nodeType == null) return false;
    if (_index.ALIAS_KEYS[targetType]) return false;
    var aliases = _index.FLIPPED_ALIAS_KEYS[targetType];
    if (aliases) {
      if (aliases[0] === nodeType) return true;
      var _iterator = _createForOfIteratorHelper(aliases),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var alias = _step.value;
          if (nodeType === alias) return true;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    return false;
  }
  return isType;
}

var isPlaceholderType = {};

var hasRequiredIsPlaceholderType;
function requireIsPlaceholderType() {
  if (hasRequiredIsPlaceholderType) return isPlaceholderType;
  hasRequiredIsPlaceholderType = 1;
  Object.defineProperty(isPlaceholderType, "__esModule", {
    value: true
  });
  isPlaceholderType["default"] = isPlaceholderType$1;
  var _index = requireDefinitions();
  function isPlaceholderType$1(placeholderType, targetType) {
    if (placeholderType === targetType) return true;
    var aliases = _index.PLACEHOLDERS_ALIAS[placeholderType];
    if (aliases) {
      var _iterator = _createForOfIteratorHelper(aliases),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var alias = _step.value;
          if (targetType === alias) return true;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    return false;
  }
  return isPlaceholderType;
}

var hasRequiredIs;
function requireIs() {
  if (hasRequiredIs) return is;
  hasRequiredIs = 1;
  Object.defineProperty(is, "__esModule", {
    value: true
  });
  is["default"] = is$1;
  var _shallowEqual = requireShallowEqual();
  var _isType = requireIsType();
  var _isPlaceholderType = requireIsPlaceholderType();
  var _index = requireDefinitions();
  function is$1(type, node, opts) {
    if (!node) return false;
    var matches = (0, _isType["default"])(node.type, type);
    if (!matches) {
      if (!opts && node.type === "Placeholder" && type in _index.FLIPPED_ALIAS_KEYS) {
        return (0, _isPlaceholderType["default"])(node.expectedNode, type);
      }
      return false;
    }
    if (opts === undefined) {
      return true;
    } else {
      return (0, _shallowEqual["default"])(node, opts);
    }
  }
  return is;
}

var isValidIdentifier = {};

var lib$4 = {};

var identifier = {};

var hasRequiredIdentifier;
function requireIdentifier() {
  if (hasRequiredIdentifier) return identifier;
  hasRequiredIdentifier = 1;
  Object.defineProperty(identifier, "__esModule", {
    value: true
  });
  identifier.isIdentifierChar = isIdentifierChar;
  identifier.isIdentifierName = isIdentifierName;
  identifier.isIdentifierStart = isIdentifierStart;
  var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
  var nonASCIIidentifierChars = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function isInAstralSet(code, set) {
    var pos = 0x10000;
    for (var i = 0, length = set.length; i < length; i += 2) {
      pos += set[i];
      if (pos > code) return false;
      pos += set[i + 1];
      if (pos >= code) return true;
    }
    return false;
  }
  function isIdentifierStart(code) {
    if (code < 65) return code === 36;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;
    if (code <= 0xffff) {
      return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
    }
    return isInAstralSet(code, astralIdentifierStartCodes);
  }
  function isIdentifierChar(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;
    if (code <= 0xffff) {
      return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
    }
    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
  }
  function isIdentifierName(name) {
    var isFirst = true;
    for (var i = 0; i < name.length; i++) {
      var cp = name.charCodeAt(i);
      if ((cp & 0xfc00) === 0xd800 && i + 1 < name.length) {
        var trail = name.charCodeAt(++i);
        if ((trail & 0xfc00) === 0xdc00) {
          cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);
        }
      }
      if (isFirst) {
        isFirst = false;
        if (!isIdentifierStart(cp)) {
          return false;
        }
      } else if (!isIdentifierChar(cp)) {
        return false;
      }
    }
    return !isFirst;
  }
  return identifier;
}

var keyword = {};

var hasRequiredKeyword;
function requireKeyword() {
  if (hasRequiredKeyword) return keyword;
  hasRequiredKeyword = 1;
  Object.defineProperty(keyword, "__esModule", {
    value: true
  });
  keyword.isKeyword = isKeyword;
  keyword.isReservedWord = isReservedWord;
  keyword.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
  keyword.isStrictBindReservedWord = isStrictBindReservedWord;
  keyword.isStrictReservedWord = isStrictReservedWord;
  var reservedWords = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  };
  var keywords = new Set(reservedWords.keyword);
  var reservedWordsStrictSet = new Set(reservedWords.strict);
  var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
  function isReservedWord(word, inModule) {
    return inModule && word === "await" || word === "enum";
  }
  function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
  }
  function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
  }
  function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
  }
  function isKeyword(word) {
    return keywords.has(word);
  }
  return keyword;
}

var hasRequiredLib$6;
function requireLib$6() {
  if (hasRequiredLib$6) return lib$4;
  hasRequiredLib$6 = 1;
  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isIdentifierChar", {
      enumerable: true,
      get: function get() {
        return _identifier.isIdentifierChar;
      }
    });
    Object.defineProperty(exports, "isIdentifierName", {
      enumerable: true,
      get: function get() {
        return _identifier.isIdentifierName;
      }
    });
    Object.defineProperty(exports, "isIdentifierStart", {
      enumerable: true,
      get: function get() {
        return _identifier.isIdentifierStart;
      }
    });
    Object.defineProperty(exports, "isKeyword", {
      enumerable: true,
      get: function get() {
        return _keyword.isKeyword;
      }
    });
    Object.defineProperty(exports, "isReservedWord", {
      enumerable: true,
      get: function get() {
        return _keyword.isReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictBindOnlyReservedWord", {
      enumerable: true,
      get: function get() {
        return _keyword.isStrictBindOnlyReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictBindReservedWord", {
      enumerable: true,
      get: function get() {
        return _keyword.isStrictBindReservedWord;
      }
    });
    Object.defineProperty(exports, "isStrictReservedWord", {
      enumerable: true,
      get: function get() {
        return _keyword.isStrictReservedWord;
      }
    });
    var _identifier = requireIdentifier();
    var _keyword = requireKeyword();
  })(lib$4);
  return lib$4;
}

var hasRequiredIsValidIdentifier;
function requireIsValidIdentifier() {
  if (hasRequiredIsValidIdentifier) return isValidIdentifier;
  hasRequiredIsValidIdentifier = 1;
  Object.defineProperty(isValidIdentifier, "__esModule", {
    value: true
  });
  isValidIdentifier["default"] = isValidIdentifier$1;
  var _helperValidatorIdentifier = requireLib$6();
  function isValidIdentifier$1(name) {
    var reserved = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    if (typeof name !== "string") return false;
    if (reserved) {
      if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)) {
        return false;
      }
    }
    return (0, _helperValidatorIdentifier.isIdentifierName)(name);
  }
  return isValidIdentifier;
}

var lib$3 = {};

var hasRequiredLib$5;
function requireLib$5() {
  if (hasRequiredLib$5) return lib$3;
  hasRequiredLib$5 = 1;
  Object.defineProperty(lib$3, "__esModule", {
    value: true
  });
  lib$3.readCodePoint = readCodePoint;
  lib$3.readInt = readInt;
  lib$3.readStringContents = readStringContents;
  var _isDigit = function isDigit(code) {
    return code >= 48 && code <= 57;
  };
  var forbiddenNumericSeparatorSiblings = {
    decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: new Set([46, 88, 95, 120])
  };
  var isAllowedNumericSeparatorSibling = {
    bin: function bin(ch) {
      return ch === 48 || ch === 49;
    },
    oct: function oct(ch) {
      return ch >= 48 && ch <= 55;
    },
    dec: function dec(ch) {
      return ch >= 48 && ch <= 57;
    },
    hex: function hex(ch) {
      return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
    }
  };
  function readStringContents(type, input, pos, lineStart, curLine, errors) {
    var initialPos = pos;
    var initialLineStart = lineStart;
    var initialCurLine = curLine;
    var out = "";
    var firstInvalidLoc = null;
    var chunkStart = pos;
    var length = input.length;
    for (;;) {
      if (pos >= length) {
        errors.unterminated(initialPos, initialLineStart, initialCurLine);
        out += input.slice(chunkStart, pos);
        break;
      }
      var ch = input.charCodeAt(pos);
      if (isStringEnd(type, ch, input, pos)) {
        out += input.slice(chunkStart, pos);
        break;
      }
      if (ch === 92) {
        out += input.slice(chunkStart, pos);
        var res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
        if (res.ch === null && !firstInvalidLoc) {
          firstInvalidLoc = {
            pos: pos,
            lineStart: lineStart,
            curLine: curLine
          };
        } else {
          out += res.ch;
        }
        pos = res.pos;
        lineStart = res.lineStart;
        curLine = res.curLine;
        chunkStart = pos;
      } else if (ch === 8232 || ch === 8233) {
        ++pos;
        ++curLine;
        lineStart = pos;
      } else if (ch === 10 || ch === 13) {
        if (type === "template") {
          out += input.slice(chunkStart, pos) + "\n";
          ++pos;
          if (ch === 13 && input.charCodeAt(pos) === 10) {
            ++pos;
          }
          ++curLine;
          chunkStart = lineStart = pos;
        } else {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
        }
      } else {
        ++pos;
      }
    }
    return {
      pos: pos,
      str: out,
      firstInvalidLoc: firstInvalidLoc,
      lineStart: lineStart,
      curLine: curLine,
      containsInvalid: !!firstInvalidLoc
    };
  }
  function isStringEnd(type, ch, input, pos) {
    if (type === "template") {
      return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
    }
    return ch === (type === "double" ? 34 : 39);
  }
  function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
    var throwOnInvalid = !inTemplate;
    pos++;
    var res = function res(ch) {
      return {
        pos: pos,
        ch: ch,
        lineStart: lineStart,
        curLine: curLine
      };
    };
    var ch = input.charCodeAt(pos++);
    switch (ch) {
      case 110:
        return res("\n");
      case 114:
        return res("\r");
      case 120:
        {
          var code;
          var _readHexChar = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors);
          code = _readHexChar.code;
          pos = _readHexChar.pos;
          return res(code === null ? null : String.fromCharCode(code));
        }
      case 117:
        {
          var _code;
          var _readCodePoint = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors);
          _code = _readCodePoint.code;
          pos = _readCodePoint.pos;
          return res(_code === null ? null : String.fromCodePoint(_code));
        }
      case 116:
        return res("\t");
      case 98:
        return res("\b");
      case 118:
        return res("\x0B");
      case 102:
        return res("\f");
      case 13:
        if (input.charCodeAt(pos) === 10) {
          ++pos;
        }
      case 10:
        lineStart = pos;
        ++curLine;
      case 8232:
      case 8233:
        return res("");
      case 56:
      case 57:
        if (inTemplate) {
          return res(null);
        } else {
          errors.strictNumericEscape(pos - 1, lineStart, curLine);
        }
      default:
        if (ch >= 48 && ch <= 55) {
          var startPos = pos - 1;
          var match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));
          var octalStr = match[0];
          var octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          pos += octalStr.length - 1;
          var next = input.charCodeAt(pos);
          if (octalStr !== "0" || next === 56 || next === 57) {
            if (inTemplate) {
              return res(null);
            } else {
              errors.strictNumericEscape(startPos, lineStart, curLine);
            }
          }
          return res(String.fromCharCode(octal));
        }
        return res(String.fromCharCode(ch));
    }
  }
  function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
    var initialPos = pos;
    var n;
    var _readInt = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid);
    n = _readInt.n;
    pos = _readInt.pos;
    if (n === null) {
      if (throwOnInvalid) {
        errors.invalidEscapeSequence(initialPos, lineStart, curLine);
      } else {
        pos = initialPos - 1;
      }
    }
    return {
      code: n,
      pos: pos
    };
  }
  function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
    var start = pos;
    var forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
    var isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
    var invalid = false;
    var total = 0;
    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      var code = input.charCodeAt(pos);
      var val = void 0;
      if (code === 95 && allowNumSeparator !== "bail") {
        var prev = input.charCodeAt(pos - 1);
        var next = input.charCodeAt(pos + 1);
        if (!allowNumSeparator) {
          if (bailOnError) return {
            n: null,
            pos: pos
          };
          errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
        } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
          if (bailOnError) return {
            n: null,
            pos: pos
          };
          errors.unexpectedNumericSeparator(pos, lineStart, curLine);
        }
        ++pos;
        continue;
      }
      if (code >= 97) {
        val = code - 97 + 10;
      } else if (code >= 65) {
        val = code - 65 + 10;
      } else if (_isDigit(code)) {
        val = code - 48;
      } else {
        val = Infinity;
      }
      if (val >= radix) {
        if (val <= 9 && bailOnError) {
          return {
            n: null,
            pos: pos
          };
        } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
          val = 0;
        } else if (forceLen) {
          val = 0;
          invalid = true;
        } else {
          break;
        }
      }
      ++pos;
      total = total * radix + val;
    }
    if (pos === start || len != null && pos - start !== len || invalid) {
      return {
        n: null,
        pos: pos
      };
    }
    return {
      n: total,
      pos: pos
    };
  }
  function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
    var ch = input.charCodeAt(pos);
    var code;
    if (ch === 123) {
      ++pos;
      var _readHexChar2 = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors);
      code = _readHexChar2.code;
      pos = _readHexChar2.pos;
      ++pos;
      if (code !== null && code > 0x10ffff) {
        if (throwOnInvalid) {
          errors.invalidCodePoint(pos, lineStart, curLine);
        } else {
          return {
            code: null,
            pos: pos
          };
        }
      }
    } else {
      var _readHexChar3 = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors);
      code = _readHexChar3.code;
      pos = _readHexChar3.pos;
    }
    return {
      code: code,
      pos: pos
    };
  }
  return lib$3;
}

var constants = {};

var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  Object.defineProperty(constants, "__esModule", {
    value: true
  });
  constants.UPDATE_OPERATORS = constants.UNARY_OPERATORS = constants.STRING_UNARY_OPERATORS = constants.STATEMENT_OR_BLOCK_KEYS = constants.NUMBER_UNARY_OPERATORS = constants.NUMBER_BINARY_OPERATORS = constants.NOT_LOCAL_BINDING = constants.LOGICAL_OPERATORS = constants.INHERIT_KEYS = constants.FOR_INIT_KEYS = constants.FLATTENABLE_KEYS = constants.EQUALITY_BINARY_OPERATORS = constants.COMPARISON_BINARY_OPERATORS = constants.COMMENT_KEYS = constants.BOOLEAN_UNARY_OPERATORS = constants.BOOLEAN_NUMBER_BINARY_OPERATORS = constants.BOOLEAN_BINARY_OPERATORS = constants.BLOCK_SCOPED_SYMBOL = constants.BINARY_OPERATORS = constants.ASSIGNMENT_OPERATORS = void 0;
  constants.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
  constants.FLATTENABLE_KEYS = ["body", "expressions"];
  constants.FOR_INIT_KEYS = ["left", "init"];
  constants.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
  var LOGICAL_OPERATORS = constants.LOGICAL_OPERATORS = ["||", "&&", "??"];
  constants.UPDATE_OPERATORS = ["++", "--"];
  var BOOLEAN_NUMBER_BINARY_OPERATORS = constants.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
  var EQUALITY_BINARY_OPERATORS = constants.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
  var COMPARISON_BINARY_OPERATORS = constants.COMPARISON_BINARY_OPERATORS = [].concat(EQUALITY_BINARY_OPERATORS, ["in", "instanceof"]);
  var BOOLEAN_BINARY_OPERATORS = constants.BOOLEAN_BINARY_OPERATORS = [].concat(_toConsumableArray(COMPARISON_BINARY_OPERATORS), BOOLEAN_NUMBER_BINARY_OPERATORS);
  var NUMBER_BINARY_OPERATORS = constants.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
  constants.BINARY_OPERATORS = ["+"].concat(NUMBER_BINARY_OPERATORS, _toConsumableArray(BOOLEAN_BINARY_OPERATORS), ["|>"]);
  constants.ASSIGNMENT_OPERATORS = ["=", "+="].concat(_toConsumableArray(NUMBER_BINARY_OPERATORS.map(function (op) {
    return op + "=";
  })), _toConsumableArray(LOGICAL_OPERATORS.map(function (op) {
    return op + "=";
  })));
  var BOOLEAN_UNARY_OPERATORS = constants.BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
  var NUMBER_UNARY_OPERATORS = constants.NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
  var STRING_UNARY_OPERATORS = constants.STRING_UNARY_OPERATORS = ["typeof"];
  constants.UNARY_OPERATORS = ["void", "throw"].concat(BOOLEAN_UNARY_OPERATORS, NUMBER_UNARY_OPERATORS, STRING_UNARY_OPERATORS);
  constants.INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  };
  constants.BLOCK_SCOPED_SYMBOL = Symbol["for"]("var used to be block scoped");
  constants.NOT_LOCAL_BINDING = Symbol["for"]("should not be considered a local binding");
  return constants;
}

var utils = {};

var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  Object.defineProperty(utils, "__esModule", {
    value: true
  });
  utils.VISITOR_KEYS = utils.NODE_PARENT_VALIDATIONS = utils.NODE_FIELDS = utils.FLIPPED_ALIAS_KEYS = utils.DEPRECATED_KEYS = utils.BUILDER_KEYS = utils.ALIAS_KEYS = void 0;
  utils.arrayOf = arrayOf;
  utils.arrayOfType = arrayOfType;
  utils.assertEach = assertEach;
  utils.assertNodeOrValueType = assertNodeOrValueType;
  utils.assertNodeType = assertNodeType;
  utils.assertOneOf = assertOneOf;
  utils.assertOptionalChainStart = assertOptionalChainStart;
  utils.assertShape = assertShape;
  utils.assertValueType = assertValueType;
  utils.chain = chain;
  utils["default"] = defineType;
  utils.defineAliasedType = defineAliasedType;
  utils.validate = validate;
  utils.validateArrayOfType = validateArrayOfType;
  utils.validateOptional = validateOptional;
  utils.validateOptionalType = validateOptionalType;
  utils.validateType = validateType;
  var _is = requireIs();
  var _validate = requireValidate();
  var VISITOR_KEYS = utils.VISITOR_KEYS = {};
  var ALIAS_KEYS = utils.ALIAS_KEYS = {};
  var FLIPPED_ALIAS_KEYS = utils.FLIPPED_ALIAS_KEYS = {};
  var NODE_FIELDS = utils.NODE_FIELDS = {};
  var BUILDER_KEYS = utils.BUILDER_KEYS = {};
  var DEPRECATED_KEYS = utils.DEPRECATED_KEYS = {};
  var NODE_PARENT_VALIDATIONS = utils.NODE_PARENT_VALIDATIONS = {};
  function getType(val) {
    if (Array.isArray(val)) {
      return "array";
    } else if (val === null) {
      return "null";
    } else {
      return _typeof(val);
    }
  }
  function validate(validate) {
    return {
      validate: validate
    };
  }
  function validateType() {
    return validate(assertNodeType.apply(void 0, arguments));
  }
  function validateOptional(validate) {
    return {
      validate: validate,
      optional: true
    };
  }
  function validateOptionalType() {
    return {
      validate: assertNodeType.apply(void 0, arguments),
      optional: true
    };
  }
  function arrayOf(elementType) {
    return chain(assertValueType("array"), assertEach(elementType));
  }
  function arrayOfType() {
    return arrayOf(assertNodeType.apply(void 0, arguments));
  }
  function validateArrayOfType() {
    return validate(arrayOfType.apply(void 0, arguments));
  }
  function assertEach(callback) {
    var childValidator = process.env.BABEL_TYPES_8_BREAKING ? _validate.validateChild : function () {};
    function validator(node, key, val) {
      if (!Array.isArray(val)) return;
      for (var i = 0; i < val.length; i++) {
        var subkey = "".concat(key, "[").concat(i, "]");
        var v = val[i];
        callback(node, subkey, v);
        childValidator(node, subkey, v);
      }
    }
    validator.each = callback;
    return validator;
  }
  function assertOneOf() {
    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
      values[_key] = arguments[_key];
    }
    function validate(node, key, val) {
      if (!values.includes(val)) {
        throw new TypeError("Property ".concat(key, " expected value to be one of ").concat(JSON.stringify(values), " but got ").concat(JSON.stringify(val)));
      }
    }
    validate.oneOf = values;
    return validate;
  }
  function assertNodeType() {
    for (var _len2 = arguments.length, types = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      types[_key2] = arguments[_key2];
    }
    function validate(node, key, val) {
      var _iterator = _createForOfIteratorHelper(types),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var type = _step.value;
          if ((0, _is["default"])(type, val)) {
            (0, _validate.validateChild)(node, key, val);
            return;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      throw new TypeError("Property ".concat(key, " of ").concat(node.type, " expected node to be of a type ").concat(JSON.stringify(types), " but instead got ").concat(JSON.stringify(val == null ? void 0 : val.type)));
    }
    validate.oneOfNodeTypes = types;
    return validate;
  }
  function assertNodeOrValueType() {
    for (var _len3 = arguments.length, types = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      types[_key3] = arguments[_key3];
    }
    function validate(node, key, val) {
      var _iterator2 = _createForOfIteratorHelper(types),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var type = _step2.value;
          if (getType(val) === type || (0, _is["default"])(type, val)) {
            (0, _validate.validateChild)(node, key, val);
            return;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      throw new TypeError("Property ".concat(key, " of ").concat(node.type, " expected node to be of a type ").concat(JSON.stringify(types), " but instead got ").concat(JSON.stringify(val == null ? void 0 : val.type)));
    }
    validate.oneOfNodeOrValueTypes = types;
    return validate;
  }
  function assertValueType(type) {
    function validate(node, key, val) {
      var valid = getType(val) === type;
      if (!valid) {
        throw new TypeError("Property ".concat(key, " expected type of ").concat(type, " but got ").concat(getType(val)));
      }
    }
    validate.type = type;
    return validate;
  }
  function assertShape(shape) {
    function validate(node, key, val) {
      var errors = [];
      for (var _i = 0, _Object$keys = Object.keys(shape); _i < _Object$keys.length; _i++) {
        var property = _Object$keys[_i];
        try {
          (0, _validate.validateField)(node, property, val[property], shape[property]);
        } catch (error) {
          if (error instanceof TypeError) {
            errors.push(error.message);
            continue;
          }
          throw error;
        }
      }
      if (errors.length) {
        throw new TypeError("Property ".concat(key, " of ").concat(node.type, " expected to have the following:\n").concat(errors.join("\n")));
      }
    }
    validate.shapeOf = shape;
    return validate;
  }
  function assertOptionalChainStart() {
    function validate(node) {
      var _current;
      var current = node;
      while (node) {
        var _current2 = current,
          type = _current2.type;
        if (type === "OptionalCallExpression") {
          if (current.optional) return;
          current = current.callee;
          continue;
        }
        if (type === "OptionalMemberExpression") {
          if (current.optional) return;
          current = current.object;
          continue;
        }
        break;
      }
      throw new TypeError("Non-optional ".concat(node.type, " must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ").concat((_current = current) == null ? void 0 : _current.type));
    }
    return validate;
  }
  function chain() {
    for (var _len4 = arguments.length, fns = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      fns[_key4] = arguments[_key4];
    }
    function validate() {
      var _iterator3 = _createForOfIteratorHelper(fns),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var fn = _step3.value;
          fn.apply(void 0, arguments);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
    validate.chainOf = fns;
    if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) {
      throw new Error("An assertValueType(\"array\") validator can only be followed by an assertEach(...) validator.");
    }
    return validate;
  }
  var validTypeOpts = new Set(["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"]);
  var validFieldKeys = new Set(["default", "optional", "deprecated", "validate"]);
  var store = {};
  function defineAliasedType() {
    for (var _len5 = arguments.length, aliases = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      aliases[_key5] = arguments[_key5];
    }
    return function (type) {
      var _defined2;
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var defined = opts.aliases;
      if (!defined) {
        var _store$opts$inherits$, _defined;
        if (opts.inherits) defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();
        (_defined = defined) != null ? _defined : defined = [];
        opts.aliases = defined;
      }
      var additional = aliases.filter(function (a) {
        return !defined.includes(a);
      });
      (_defined2 = defined).unshift.apply(_defined2, _toConsumableArray(additional));
      defineType(type, opts);
    };
  }
  function defineType(type) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var inherits = opts.inherits && store[opts.inherits] || {};
    var fields = opts.fields;
    if (!fields) {
      fields = {};
      if (inherits.fields) {
        var keys = Object.getOwnPropertyNames(inherits.fields);
        var _iterator4 = _createForOfIteratorHelper(keys),
          _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var key = _step4.value;
            var field = inherits.fields[key];
            var def = field["default"];
            if (Array.isArray(def) ? def.length > 0 : def && _typeof(def) === "object") {
              throw new Error("field defaults can only be primitives or empty arrays currently");
            }
            fields[key] = {
              "default": Array.isArray(def) ? [] : def,
              optional: field.optional,
              deprecated: field.deprecated,
              validate: field.validate
            };
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      }
    }
    var visitor = opts.visitor || inherits.visitor || [];
    var aliases = opts.aliases || inherits.aliases || [];
    var builder = opts.builder || inherits.builder || opts.visitor || [];
    for (var _i2 = 0, _Object$keys2 = Object.keys(opts); _i2 < _Object$keys2.length; _i2++) {
      var k = _Object$keys2[_i2];
      if (!validTypeOpts.has(k)) {
        throw new Error("Unknown type option \"".concat(k, "\" on ").concat(type));
      }
    }
    if (opts.deprecatedAlias) {
      DEPRECATED_KEYS[opts.deprecatedAlias] = type;
    }
    var _iterator5 = _createForOfIteratorHelper(visitor.concat(builder)),
      _step5;
    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var _key7 = _step5.value;
        fields[_key7] = fields[_key7] || {};
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }
    for (var _i3 = 0, _Object$keys3 = Object.keys(fields); _i3 < _Object$keys3.length; _i3++) {
      var _key6 = _Object$keys3[_i3];
      var _field = fields[_key6];
      if (_field["default"] !== undefined && !builder.includes(_key6)) {
        _field.optional = true;
      }
      if (_field["default"] === undefined) {
        _field["default"] = null;
      } else if (!_field.validate && _field["default"] != null) {
        _field.validate = assertValueType(getType(_field["default"]));
      }
      for (var _i4 = 0, _Object$keys4 = Object.keys(_field); _i4 < _Object$keys4.length; _i4++) {
        var _k = _Object$keys4[_i4];
        if (!validFieldKeys.has(_k)) {
          throw new Error("Unknown field key \"".concat(_k, "\" on ").concat(type, ".").concat(_key6));
        }
      }
    }
    VISITOR_KEYS[type] = opts.visitor = visitor;
    BUILDER_KEYS[type] = opts.builder = builder;
    NODE_FIELDS[type] = opts.fields = fields;
    ALIAS_KEYS[type] = opts.aliases = aliases;
    aliases.forEach(function (alias) {
      FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
      FLIPPED_ALIAS_KEYS[alias].push(type);
    });
    if (opts.validate) {
      NODE_PARENT_VALIDATIONS[type] = opts.validate;
    }
    store[type] = opts;
  }
  return utils;
}

var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore) return core;
  hasRequiredCore = 1;
  Object.defineProperty(core, "__esModule", {
    value: true
  });
  core.patternLikeCommon = core.importAttributes = core.functionTypeAnnotationCommon = core.functionDeclarationCommon = core.functionCommon = core.classMethodOrPropertyCommon = core.classMethodOrDeclareMethodCommon = void 0;
  var _is = requireIs();
  var _isValidIdentifier = requireIsValidIdentifier();
  var _helperValidatorIdentifier = requireLib$6();
  var _helperStringParser = requireLib$5();
  var _index = requireConstants();
  var _utils = requireUtils();
  var defineType = (0, _utils.defineAliasedType)("Standardized");
  defineType("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, _utils.arrayOf)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement")),
        "default": !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  defineType("AssignmentExpression", {
    fields: {
      operator: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("string") : Object.assign(function () {
          var identifier = (_utils.assertOneOf).apply(void 0, _toConsumableArray(_index.ASSIGNMENT_OPERATORS));
          var pattern = (0, _utils.assertOneOf)("=");
          return function (node, key, val) {
            var validator = (0, _is["default"])("Pattern", node.left) ? pattern : identifier;
            validator(node, key, val);
          };
        }(), {
          type: "string"
        })
      },
      left: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal", "OptionalMemberExpression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  });
  defineType("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (_utils.assertOneOf).apply(void 0, _toConsumableArray(_index.BINARY_OPERATORS))
      },
      left: {
        validate: function () {
          var expression = (0, _utils.assertNodeType)("Expression");
          var inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
          var validator = Object.assign(function (node, key, val) {
            var validator = node.operator === "in" ? inOp : expression;
            validator(node, key, val);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
          return validator;
        }()
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  });
  defineType("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  defineType("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertNodeType)("DirectiveLiteral")
      }
    }
  });
  defineType("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  defineType("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, _utils.arrayOfType)("Directive"),
        "default": []
      },
      body: (0, _utils.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  });
  defineType("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  defineType("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, _utils.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: (0, _utils.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
      typeArguments: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
        optional: true
      }
    }, {
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
        optional: true
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      }
    })
  });
  defineType("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  defineType("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  });
  defineType("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  defineType("DebuggerStatement", {
    aliases: ["Statement"]
  });
  defineType("DoWhileStatement", {
    builder: ["test", "body"],
    visitor: ["body", "test"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  });
  defineType("EmptyStatement", {
    aliases: ["Statement"]
  });
  defineType("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  });
  defineType("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: (0, _utils.assertNodeType)("Program")
      },
      comments: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(function () {}, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),
        optional: true
      },
      tokens: {
        validate: (0, _utils.assertEach)(Object.assign(function () {}, {
          type: "any"
        })),
        optional: true
      }
    }
  });
  defineType("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
        optional: true
      },
      test: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      update: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  var functionCommon = function functionCommon() {
    return {
      params: (0, _utils.validateArrayOfType)("Identifier", "Pattern", "RestElement"),
      generator: {
        "default": false
      },
      async: {
        "default": false
      }
    };
  };
  core.functionCommon = functionCommon;
  var functionTypeAnnotationCommon = function functionTypeAnnotationCommon() {
    return {
      returnType: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      }
    };
  };
  core.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
  var functionDeclarationCommon = function functionDeclarationCommon() {
    return Object.assign({}, functionCommon(), {
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      }
    });
  };
  core.functionDeclarationCommon = functionDeclarationCommon;
  defineType("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "typeParameters", "params", "predicate", "returnType", "body"],
    fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: true
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: !process.env.BABEL_TYPES_8_BREAKING ? undefined : function () {
      var identifier = (0, _utils.assertNodeType)("Identifier");
      return function (parent, key, node) {
        if (!(0, _is["default"])("ExportDefaultDeclaration", parent)) {
          identifier(node, "id", node.id);
        }
      };
    }()
  });
  defineType("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: true
      }
    })
  });
  var patternLikeCommon = function patternLikeCommon() {
    return {
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      }
    };
  };
  core.patternLikeCommon = patternLikeCommon;
  defineType("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, patternLikeCommon(), {
      name: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function (node, key, val) {
          if (!(0, _isValidIdentifier["default"])(val, false)) {
            throw new TypeError("\"".concat(val, "\" is not a valid identifier name"));
          }
        }, {
          type: "string"
        })) : (0, _utils.assertValueType)("string")
      }
    }),
    validate: process.env.BABEL_TYPES_8_BREAKING ? function (parent, key, node) {
      var match = /\.(\w+)$/.exec(key);
      if (!match) return;
      var _match = _slicedToArray(match, 2),
        parentKey = _match[1];
      var nonComp = {
        computed: false
      };
      if (parentKey === "property") {
        if ((0, _is["default"])("MemberExpression", parent, nonComp)) return;
        if ((0, _is["default"])("OptionalMemberExpression", parent, nonComp)) return;
      } else if (parentKey === "key") {
        if ((0, _is["default"])("Property", parent, nonComp)) return;
        if ((0, _is["default"])("Method", parent, nonComp)) return;
      } else if (parentKey === "exported") {
        if ((0, _is["default"])("ExportSpecifier", parent)) return;
      } else if (parentKey === "imported") {
        if ((0, _is["default"])("ImportSpecifier", parent, {
          imported: node
        })) return;
      } else if (parentKey === "meta") {
        if ((0, _is["default"])("MetaProperty", parent, {
          meta: node
        })) return;
      }
      if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== "this") {
        throw new TypeError("\"".concat(node.name, "\" is not a valid identifier"));
      }
    } : undefined
  });
  defineType("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, _utils.assertNodeType)("Statement")
      },
      alternate: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("number"), Object.assign(function (node, key, val) {
        }, {
          type: "number"
        }))
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: (0, _utils.assertValueType)("string")
      },
      flags: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function (node, key, val) {
          var invalid = /[^gimsuy]/.exec(val);
          if (invalid) {
            throw new TypeError("\"".concat(invalid[0], "\" is not a valid RegExp flag"));
          }
        }, {
          type: "string"
        })) : (0, _utils.assertValueType)("string"),
        "default": ""
      }
    }
  });
  defineType("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (_utils.assertOneOf).apply(void 0, _toConsumableArray(_index.LOGICAL_OPERATORS))
      },
      left: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("MemberExpression", {
    builder: ["object", "property", "computed"].concat(_toConsumableArray(!process.env.BABEL_TYPES_8_BREAKING ? ["optional"] : [])),
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign({
      object: {
        validate: (0, _utils.assertNodeType)("Expression", "Super")
      },
      property: {
        validate: function () {
          var normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
          var computed = (0, _utils.assertNodeType)("Expression");
          var validator = function validator(node, key, val) {
            var validator = node.computed ? computed : normal;
            validator(node, key, val);
          };
          validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
          return validator;
        }()
      },
      computed: {
        "default": false
      }
    }, !process.env.BABEL_TYPES_8_BREAKING ? {
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      }
    } : {})
  });
  defineType("NewExpression", {
    inherits: "CallExpression"
  });
  defineType("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceType: {
        validate: (0, _utils.assertOneOf)("script", "module"),
        "default": "script"
      },
      interpreter: {
        validate: (0, _utils.assertNodeType)("InterpreterDirective"),
        "default": null,
        optional: true
      },
      directives: {
        validate: (0, _utils.arrayOfType)("Directive"),
        "default": []
      },
      body: (0, _utils.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  });
  defineType("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: (0, _utils.validateArrayOfType)("ObjectMethod", "ObjectProperty", "SpreadElement")
    }
  });
  defineType("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
      kind: Object.assign({
        validate: (0, _utils.assertOneOf)("method", "get", "set")
      }, !process.env.BABEL_TYPES_8_BREAKING ? {
        "default": "method"
      } : {}),
      computed: {
        "default": false
      },
      key: {
        validate: function () {
          var normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
          var computed = (0, _utils.assertNodeType)("Expression");
          var validator = function validator(node, key, val) {
            var validator = node.computed ? computed : normal;
            validator(node, key, val);
          };
          validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"];
          return validator;
        }()
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    }),
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  });
  defineType("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand"].concat(_toConsumableArray(!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : [])),
    fields: {
      computed: {
        "default": false
      },
      key: {
        validate: function () {
          var normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");
          var computed = (0, _utils.assertNodeType)("Expression");
          var validator = Object.assign(function (node, key, val) {
            var validator = node.computed ? computed : normal;
            validator(node, key, val);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
          return validator;
        }()
      },
      value: {
        validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function (node, key, shorthand) {
          if (!shorthand) return;
          if (node.computed) {
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
          }
          if (!(0, _is["default"])("Identifier", node.key)) {
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
          }
        }, {
          type: "boolean"
        })) : (0, _utils.assertValueType)("boolean"),
        "default": false
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      }
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: !process.env.BABEL_TYPES_8_BREAKING ? undefined : function () {
      var pattern = (0, _utils.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion");
      var expression = (0, _utils.assertNodeType)("Expression");
      return function (parent, key, node) {
        var validator = (0, _is["default"])("ObjectPattern", parent) ? pattern : expression;
        validator(node, "value", node.value);
      };
    }()
  });
  defineType("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, patternLikeCommon(), {
      argument: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      }
    }),
    validate: process.env.BABEL_TYPES_8_BREAKING ? function (parent, key) {
      var match = /(\w+)\[(\d+)\]/.exec(key);
      if (!match) throw new Error("Internal Babel error: malformed key.");
      var _match2 = _slicedToArray(match, 3),
        listKey = _match2[1],
        index = _match2[2];
      if (parent[listKey].length > +index + 1) {
        throw new TypeError("RestElement must be last element of ".concat(listKey));
      }
    } : undefined
  });
  defineType("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      }
    }
  });
  defineType("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: (0, _utils.validateArrayOfType)("Expression")
    },
    aliases: ["Expression"]
  });
  defineType("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      consequent: (0, _utils.validateArrayOfType)("Statement")
    }
  });
  defineType("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      cases: (0, _utils.validateArrayOfType)("SwitchCase")
    }
  });
  defineType("ThisExpression", {
    aliases: ["Expression"]
  });
  defineType("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function (node) {
          if (!node.handler && !node.finalizer) {
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
          }
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        })) : (0, _utils.assertNodeType)("BlockStatement")
      },
      handler: {
        optional: true,
        validate: (0, _utils.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: true,
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    }
  });
  defineType("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        "default": true
      },
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      operator: {
        validate: (_utils.assertOneOf).apply(void 0, _toConsumableArray(_index.UNARY_OPERATORS))
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  });
  defineType("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        "default": false
      },
      argument: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Expression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression")
      },
      operator: {
        validate: (_utils.assertOneOf).apply(void 0, _toConsumableArray(_index.UPDATE_OPERATORS))
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  defineType("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      kind: {
        validate: (0, _utils.assertOneOf)("var", "let", "const", "using", "await using")
      },
      declarations: (0, _utils.validateArrayOfType)("VariableDeclarator")
    },
    validate: process.env.BABEL_TYPES_8_BREAKING ? function () {
      var withoutInit = (0, _utils.assertNodeType)("Identifier");
      return function (parent, key, node) {
        if ((0, _is["default"])("ForXStatement", parent, {
          left: node
        })) {
          if (node.declarations.length !== 1) {
            throw new TypeError("Exactly one VariableDeclarator is required in the VariableDeclaration of a ".concat(parent.type));
          }
        } else {
          node.declarations.forEach(function (decl) {
            if (!decl.init) withoutInit(decl, "id", decl.id);
          });
        }
      };
    }() : undefined
  });
  defineType("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern")
      },
      definite: {
        optional: true,
        validate: (0, _utils.assertValueType)("boolean")
      },
      init: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      }
    }
  });
  defineType("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      left: {
        validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      }
    })
  });
  defineType("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      elements: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike", "LVal")))
      }
    })
  });
  defineType("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["typeParameters", "params", "predicate", "returnType", "body"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
      expression: {
        validate: (0, _utils.assertValueType)("boolean")
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
      },
      predicate: {
        validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: true
      }
    })
  });
  defineType("ClassBody", {
    visitor: ["body"],
    fields: {
      body: (0, _utils.validateArrayOfType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")
    }
  });
  defineType("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "mixins", "implements", "body"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: _defineProperty(_defineProperty(_defineProperty(_defineProperty({
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }, "superTypeParameters", {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
    }), "implements", {
      validate: (0, _utils.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
      optional: true
    }), "decorators", {
      validate: (0, _utils.arrayOfType)("Decorator"),
      optional: true
    }), "mixins", {
      validate: (0, _utils.assertNodeType)("InterfaceExtends"),
      optional: true
    })
  });
  defineType("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      },
      body: {
        validate: (0, _utils.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }, "superTypeParameters", {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
    }), "implements", {
      validate: (0, _utils.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
      optional: true
    }), "decorators", {
      validate: (0, _utils.arrayOfType)("Decorator"),
      optional: true
    }), "mixins", {
      validate: (0, _utils.assertNodeType)("InterfaceExtends"),
      optional: true
    }), "declare", {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    }), "abstract", {
      validate: (0, _utils.assertValueType)("boolean"),
      optional: true
    }),
    validate: !process.env.BABEL_TYPES_8_BREAKING ? undefined : function () {
      var identifier = (0, _utils.assertNodeType)("Identifier");
      return function (parent, key, node) {
        if (!(0, _is["default"])("ExportDefaultDeclaration", parent)) {
          identifier(node, "id", node.id);
        }
      };
    }()
  });
  var importAttributes = core.importAttributes = {
    attributes: {
      optional: true,
      validate: (0, _utils.arrayOfType)("ImportAttribute")
    },
    assertions: {
      deprecated: true,
      optional: true,
      validate: (0, _utils.arrayOfType)("ImportAttribute")
    }
  };
  defineType("ExportAllDeclaration", {
    builder: ["source"],
    visitor: ["source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: Object.assign({
      source: {
        validate: (0, _utils.assertNodeType)("StringLiteral")
      },
      exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    }, importAttributes)
  });
  defineType("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: (0, _utils.validateType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression"),
      exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
    }
  });
  defineType("ExportNamedDeclaration", {
    builder: ["declaration", "specifiers", "source"],
    visitor: process.env ? ["declaration", "specifiers", "source", "attributes"] : ["declaration", "specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: Object.assign({
      declaration: {
        optional: true,
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function (node, key, val) {
          if (val && node.specifiers.length) {
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
          }
          if (val && node.source) {
            throw new TypeError("Cannot export a declaration from a source");
          }
        }, {
          oneOfNodeTypes: ["Declaration"]
        })) : (0, _utils.assertNodeType)("Declaration")
      }
    }, importAttributes, {
      specifiers: {
        "default": [],
        validate: (0, _utils.arrayOf)(function () {
          var sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
          var sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
          if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;
          return Object.assign(function (node, key, val) {
            var validator = node.source ? sourced : sourceless;
            validator(node, key, val);
          }, {
            oneOfNodeTypes: ["ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"]
          });
        }())
      },
      source: {
        validate: (0, _utils.assertNodeType)("StringLiteral"),
        optional: true
      },
      exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    })
  });
  defineType("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: (0, _utils.assertOneOf)("type", "value"),
        optional: true
      }
    }
  });
  defineType("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function () {
          if (!process.env.BABEL_TYPES_8_BREAKING) {
            return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
          }
          var declaration = (0, _utils.assertNodeType)("VariableDeclaration");
          var lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return Object.assign(function (node, key, val) {
            if ((0, _is["default"])("VariableDeclaration", val)) {
              declaration(node, key, val);
            } else {
              lval(node, key, val);
            }
          }, {
            oneOfNodeTypes: ["VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression"]
          });
        }()
      },
      right: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      body: {
        validate: (0, _utils.assertNodeType)("Statement")
      },
      "await": {
        "default": false
      }
    }
  });
  defineType("ImportDeclaration", {
    builder: ["specifiers", "source"],
    visitor: ["specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    fields: Object.assign({}, importAttributes, {
      module: {
        optional: true,
        validate: (0, _utils.assertValueType)("boolean")
      },
      phase: {
        "default": null,
        validate: (0, _utils.assertOneOf)("source", "defer")
      },
      specifiers: (0, _utils.validateArrayOfType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"),
      source: {
        validate: (0, _utils.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
        optional: true
      }
    })
  });
  defineType("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  defineType("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  defineType("ImportSpecifier", {
    visitor: ["imported", "local"],
    builder: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
      },
      importKind: {
        validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
        optional: true
      }
    }
  });
  defineType("ImportExpression", {
    visitor: ["source", "options"],
    aliases: ["Expression"],
    fields: {
      phase: {
        "default": null,
        validate: (0, _utils.assertOneOf)("source", "defer")
      },
      source: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      options: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      }
    }
  });
  defineType("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function (node, key, val) {
          var property;
          switch (val.name) {
            case "function":
              property = "sent";
              break;
            case "new":
              property = "target";
              break;
            case "import":
              property = "meta";
              break;
          }
          if (!(0, _is["default"])("Identifier", node.property, {
            name: property
          })) {
            throw new TypeError("Unrecognised MetaProperty");
          }
        }, {
          oneOfNodeTypes: ["Identifier"]
        })) : (0, _utils.assertNodeType)("Identifier")
      },
      property: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  var classMethodOrPropertyCommon = function classMethodOrPropertyCommon() {
    return {
      "abstract": {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      accessibility: {
        validate: (0, _utils.assertOneOf)("public", "private", "protected"),
        optional: true
      },
      "static": {
        "default": false
      },
      override: {
        "default": false
      },
      computed: {
        "default": false
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      key: {
        validate: (0, _utils.chain)(function () {
          var normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
          var computed = (0, _utils.assertNodeType)("Expression");
          return function (node, key, val) {
            var validator = node.computed ? computed : normal;
            validator(node, key, val);
          };
        }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
      }
    };
  };
  core.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
  var classMethodOrDeclareMethodCommon = function classMethodOrDeclareMethodCommon() {
    return Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
      params: (0, _utils.validateArrayOfType)("Identifier", "Pattern", "RestElement", "TSParameterProperty"),
      kind: {
        validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
        "default": "method"
      },
      access: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      }
    });
  };
  core.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
  defineType("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    })
  });
  defineType("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon(), {
      properties: (0, _utils.validateArrayOfType)("RestElement", "ObjectProperty")
    })
  });
  defineType("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("Super", {
    aliases: ["Expression"]
  });
  defineType("TaggedTemplateExpression", {
    visitor: ["tag", "typeParameters", "quasi"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: _defineProperty({
      tag: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, _utils.assertNodeType)("TemplateLiteral")
      }
    }, "typeParameters", {
      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
      optional: true
    })
  });
  defineType("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, _utils.chain)((0, _utils.assertShape)({
          raw: {
            validate: (0, _utils.assertValueType)("string")
          },
          cooked: {
            validate: (0, _utils.assertValueType)("string"),
            optional: true
          }
        }), function templateElementCookedValidator(node) {
          var raw = node.value.raw;
          var unterminatedCalled = false;
          var error = function error() {
            throw new Error("Internal @babel/types error.");
          };
          var _ref = (0, _helperStringParser.readStringContents)("template", raw, 0, 0, 0, {
              unterminated: function unterminated() {
                unterminatedCalled = true;
              },
              strictNumericEscape: error,
              invalidEscapeSequence: error,
              numericSeparatorInEscapeSequence: error,
              unexpectedNumericSeparator: error,
              invalidDigit: error,
              invalidCodePoint: error
            }),
            str = _ref.str,
            firstInvalidLoc = _ref.firstInvalidLoc;
          if (!unterminatedCalled) throw new Error("Invalid raw");
          node.value.cooked = firstInvalidLoc ? null : str;
        })
      },
      tail: {
        "default": false
      }
    }
  });
  defineType("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: (0, _utils.validateArrayOfType)("TemplateElement"),
      expressions: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function (node, key, val) {
          if (node.quasis.length !== val.length + 1) {
            throw new TypeError("Number of ".concat(node.type, " quasis should be exactly one more than the number of expressions.\nExpected ").concat(val.length + 1, " quasis but got ").concat(node.quasis.length));
          }
        })
      }
    }
  });
  defineType("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function (node, key, val) {
          if (val && !node.argument) {
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
          }
        }, {
          type: "boolean"
        })) : (0, _utils.assertValueType)("boolean"),
        "default": false
      },
      argument: {
        optional: true,
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("Import", {
    aliases: ["Expression"]
  });
  defineType("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  defineType("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      property: {
        validate: function () {
          var normal = (0, _utils.assertNodeType)("Identifier");
          var computed = (0, _utils.assertNodeType)("Expression");
          var validator = Object.assign(function (node, key, val) {
            var validator = node.computed ? computed : normal;
            validator(node, key, val);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
          return validator;
        }()
      },
      computed: {
        "default": false
      },
      optional: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
      }
    }
  });
  defineType("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      arguments: (0, _utils.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
      optional: {
        validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
      },
      typeArguments: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
        optional: true
      }
    }, {
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
        optional: true
      }
    })
  });
  defineType("ClassProperty", {
    visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, classMethodOrPropertyCommon(), {
      value: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      definite: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      variance: {
        validate: (0, _utils.assertNodeType)("Variance"),
        optional: true
      }
    })
  });
  defineType("ClassAccessorProperty", {
    visitor: ["decorators", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"],
    fields: Object.assign({}, classMethodOrPropertyCommon(), {
      key: {
        validate: (0, _utils.chain)(function () {
          var normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");
          var computed = (0, _utils.assertNodeType)("Expression");
          return function (node, key, val) {
            var validator = node.computed ? computed : normal;
            validator(node, key, val);
          };
        }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      definite: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      variance: {
        validate: (0, _utils.assertNodeType)("Variance"),
        optional: true
      }
    })
  });
  defineType("ClassPrivateProperty", {
    visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: (0, _utils.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, _utils.assertNodeType)("Expression"),
        optional: true
      },
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      },
      "static": {
        validate: (0, _utils.assertValueType)("boolean"),
        "default": false
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      definite: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      variance: {
        validate: (0, _utils.assertNodeType)("Variance"),
        optional: true
      }
    }
  });
  defineType("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
      kind: {
        validate: (0, _utils.assertOneOf)("get", "set", "method"),
        "default": "method"
      },
      key: {
        validate: (0, _utils.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      }
    })
  });
  defineType("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  defineType("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: (0, _utils.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  });
  return core;
}

var flow$1 = {};

var hasRequiredFlow$1;
function requireFlow$1() {
  if (hasRequiredFlow$1) return flow$1;
  hasRequiredFlow$1 = 1;
  var _core = requireCore();
  var _utils = requireUtils();
  var defineType = (0, _utils.defineAliasedType)("Flow");
  var defineInterfaceishType = function defineInterfaceishType(name) {
    var isDeclareClass = name === "DeclareClass";
    defineType(name, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends"].concat(_toConsumableArray(isDeclareClass ? ["mixins", "implements"] : []), ["body"]),
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        "extends": (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends"))
      }, isDeclareClass ? {
        mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
        "implements": (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements"))
      } : {}, {
        body: (0, _utils.validateType)("ObjectTypeAnnotation")
      })
    });
  };
  defineType("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  defineInterfaceishType("DeclareClass");
  defineType("DeclareFunction", {
    builder: ["id"],
    visitor: ["id", "predicate"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
    }
  });
  defineInterfaceishType("DeclareInterface");
  defineType("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier", "StringLiteral"),
      body: (0, _utils.validateType)("BlockStatement"),
      kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
    }
  });
  defineType("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
    }
  });
  defineType("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, _utils.validateOptionalType)("FlowType"),
      impltype: (0, _utils.validateOptionalType)("FlowType")
    }
  });
  defineType("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier")
    }
  });
  defineType("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source", "attributes"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: Object.assign({
      declaration: (0, _utils.validateOptionalType)("Flow"),
      specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ExportSpecifier", "ExportNamespaceSpecifier")),
      source: (0, _utils.validateOptionalType)("StringLiteral"),
      "default": (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }, _core.importAttributes)
  });
  defineType("DeclareExportAllDeclaration", {
    visitor: ["source", "attributes"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: Object.assign({
      source: (0, _utils.validateType)("StringLiteral"),
      exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
    }, _core.importAttributes)
  });
  defineType("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: (0, _utils.validateType)("Flow")
    }
  });
  defineType("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  });
  defineType("FunctionTypeAnnotation", {
    builder: ["typeParameters", "params", "rest", "returnType"],
    visitor: ["typeParameters", "this", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, _utils.validateArrayOfType)("FunctionTypeParam"),
      rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
      "this": (0, _utils.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, _utils.validateOptionalType)("Identifier"),
      typeAnnotation: (0, _utils.validateType)("FlowType"),
      optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  defineType("InferredPredicate", {
    aliases: ["FlowPredicate"]
  });
  defineType("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  defineInterfaceishType("InterfaceDeclaration");
  defineType("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      "extends": (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
      body: (0, _utils.validateType)("ObjectTypeAnnotation")
    }
  });
  defineType("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  });
  defineType("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
    }
  });
  defineType("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: (0, _utils.validate)((0, _utils.arrayOfType)("ObjectTypeProperty", "ObjectTypeSpreadProperty")),
      indexers: {
        validate: (0, _utils.arrayOfType)("ObjectTypeIndexer"),
        optional: true,
        "default": []
      },
      callProperties: {
        validate: (0, _utils.arrayOfType)("ObjectTypeCallProperty"),
        optional: true,
        "default": []
      },
      internalSlots: {
        validate: (0, _utils.arrayOfType)("ObjectTypeInternalSlot"),
        optional: true,
        "default": []
      },
      exact: {
        validate: (0, _utils.assertValueType)("boolean"),
        "default": false
      },
      inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("ObjectTypeInternalSlot", {
    visitor: ["id", "value"],
    builder: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      value: (0, _utils.validateType)("FlowType"),
      optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      "static": (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, _utils.validateType)("FlowType"),
      "static": (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("ObjectTypeIndexer", {
    visitor: ["variance", "id", "key", "value"],
    builder: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, _utils.validateOptionalType)("Identifier"),
      key: (0, _utils.validateType)("FlowType"),
      value: (0, _utils.validateType)("FlowType"),
      "static": (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      variance: (0, _utils.validateOptionalType)("Variance")
    }
  });
  defineType("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, _utils.validateType)("Identifier", "StringLiteral"),
      value: (0, _utils.validateType)("FlowType"),
      kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
      "static": (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      variance: (0, _utils.validateOptionalType)("Variance"),
      method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, _utils.validateOptionalType)("FlowType"),
      impltype: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("QualifiedTypeIdentifier", {
    visitor: ["qualification", "id"],
    builder: ["id", "qualification"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      qualification: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier")
    }
  });
  defineType("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
    }
  });
  defineType("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  });
  defineType("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, _utils.validateType)("Expression"),
      typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
    }
  });
  defineType("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
      bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
      "default": (0, _utils.validateOptionalType)("FlowType"),
      variance: (0, _utils.validateOptionalType)("Variance")
    }
  });
  defineType("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
    }
  });
  defineType("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  });
  defineType("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
    }
  });
  defineType("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
    }
  });
  defineType("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  defineType("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      body: (0, _utils.validateType)("EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody")
    }
  });
  defineType("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
      members: (0, _utils.validateArrayOfType)("EnumStringMember", "EnumDefaultedMember"),
      hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  defineType("EnumBooleanMember", {
    aliases: ["EnumMember"],
    builder: ["id"],
    visitor: ["id", "init"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("BooleanLiteral")
    }
  });
  defineType("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("NumericLiteral")
    }
  });
  defineType("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, _utils.validateType)("Identifier"),
      init: (0, _utils.validateType)("StringLiteral")
    }
  });
  defineType("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, _utils.validateType)("Identifier")
    }
  });
  defineType("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, _utils.validateType)("FlowType"),
      indexType: (0, _utils.validateType)("FlowType")
    }
  });
  defineType("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, _utils.validateType)("FlowType"),
      indexType: (0, _utils.validateType)("FlowType"),
      optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
    }
  });
  return flow$1;
}

var jsx$1 = {};

var hasRequiredJsx$1;
function requireJsx$1() {
  if (hasRequiredJsx$1) return jsx$1;
  hasRequiredJsx$1 = 1;
  var _utils = requireUtils();
  var defineType = (0, _utils.defineAliasedType)("JSX");
  defineType("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: true,
        validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  defineType("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  });
  defineType("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: (0, _utils.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: true,
        validate: (0, _utils.assertNodeType)("JSXClosingElement")
      },
      children: (0, _utils.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
    }, {
      selfClosing: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      }
    })
  });
  defineType("JSXEmptyExpression", {});
  defineType("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  });
  defineType("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  defineType("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier")
      }
    }
  });
  defineType("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier")
      }
    }
  });
  defineType("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "typeParameters", "typeArguments", "attributes"],
    aliases: ["Immutable"],
    fields: Object.assign({
      name: {
        validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        "default": false
      },
      attributes: (0, _utils.validateArrayOfType)("JSXAttribute", "JSXSpreadAttribute"),
      typeArguments: {
        validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
        optional: true
      }
    }, {
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
        optional: true
      }
    })
  });
  defineType("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  defineType("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  defineType("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, _utils.assertNodeType)("JSXClosingFragment")
      },
      children: (0, _utils.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
    }
  });
  defineType("JSXOpeningFragment", {
    aliases: ["Immutable"]
  });
  defineType("JSXClosingFragment", {
    aliases: ["Immutable"]
  });
  return jsx$1;
}

var misc = {};

var placeholders = {};

var hasRequiredPlaceholders;
function requirePlaceholders() {
  if (hasRequiredPlaceholders) return placeholders;
  hasRequiredPlaceholders = 1;
  Object.defineProperty(placeholders, "__esModule", {
    value: true
  });
  placeholders.PLACEHOLDERS_FLIPPED_ALIAS = placeholders.PLACEHOLDERS_ALIAS = placeholders.PLACEHOLDERS = void 0;
  var _utils = requireUtils();
  var PLACEHOLDERS = placeholders.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
  var PLACEHOLDERS_ALIAS = placeholders.PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  for (var _i = 0, _PLACEHOLDERS = PLACEHOLDERS; _i < _PLACEHOLDERS.length; _i++) {
    var type = _PLACEHOLDERS[_i];
    var alias = _utils.ALIAS_KEYS[type];
    if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type] = alias;
  }
  var PLACEHOLDERS_FLIPPED_ALIAS = placeholders.PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(PLACEHOLDERS_ALIAS).forEach(function (type) {
    PLACEHOLDERS_ALIAS[type].forEach(function (alias) {
      if (!hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
        PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
      }
      PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
    });
  });
  return placeholders;
}

var hasRequiredMisc;
function requireMisc() {
  if (hasRequiredMisc) return misc;
  hasRequiredMisc = 1;
  var _utils = requireUtils();
  var _placeholders = requirePlaceholders();
  var _core = requireCore();
  var defineType = (0, _utils.defineAliasedType)("Miscellaneous");
  {
    defineType("Noop", {
      visitor: []
    });
  }
  defineType("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: Object.assign({
      name: {
        validate: (0, _utils.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (_utils.assertOneOf).apply(void 0, _toConsumableArray(_placeholders.PLACEHOLDERS))
      }
    }, (0, _core.patternLikeCommon)())
  });
  defineType("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, _utils.assertValueType)("string")
      }
    }
  });
  return misc;
}

var experimental = {};

var hasRequiredExperimental;
function requireExperimental() {
  if (hasRequiredExperimental) return experimental;
  hasRequiredExperimental = 1;
  var _utils = requireUtils();
  (0, _utils["default"])("ArgumentPlaceholder", {});
  (0, _utils["default"])("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: !process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: Object.assign(function () {}, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(function () {}, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    } : {
      object: {
        validate: (0, _utils.assertNodeType)("Expression")
      },
      callee: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  (0, _utils["default"])("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
      },
      value: {
        validate: (0, _utils.assertNodeType)("StringLiteral")
      }
    }
  });
  (0, _utils["default"])("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    }
  });
  (0, _utils["default"])("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: (0, _utils.assertNodeType)("BlockStatement")
      },
      async: {
        validate: (0, _utils.assertValueType)("boolean"),
        "default": false
      }
    }
  });
  (0, _utils["default"])("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, _utils.assertNodeType)("Identifier")
      }
    }
  });
  (0, _utils["default"])("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: (0, _utils.validateArrayOfType)("ObjectProperty", "SpreadElement")
    }
  });
  (0, _utils["default"])("TupleExpression", {
    fields: {
      elements: {
        validate: (0, _utils.arrayOfType)("Expression", "SpreadElement"),
        "default": []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  {
    (0, _utils["default"])("DecimalLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
  }
  (0, _utils["default"])("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, _utils.assertNodeType)("Program")
      }
    },
    aliases: ["Expression"]
  });
  (0, _utils["default"])("TopicReference", {
    aliases: ["Expression"]
  });
  (0, _utils["default"])("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, _utils["default"])("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: (0, _utils.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, _utils["default"])("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  });
  return experimental;
}

var typescript$1 = {};

var hasRequiredTypescript$1;
function requireTypescript$1() {
  if (hasRequiredTypescript$1) return typescript$1;
  hasRequiredTypescript$1 = 1;
  var _utils = requireUtils();
  var _core = requireCore();
  var _is = requireIs();
  var defineType = (0, _utils.defineAliasedType)("TypeScript");
  var bool = (0, _utils.assertValueType)("boolean");
  var tSFunctionTypeAnnotationCommon = function tSFunctionTypeAnnotationCommon() {
    return {
      returnType: {
        validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
        optional: true
      }
    };
  };
  defineType("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, _utils.assertOneOf)("public", "private", "protected"),
        optional: true
      },
      readonly: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      parameter: {
        validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
      },
      override: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      }
    }
  });
  defineType("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, _core.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())
  });
  defineType("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, _core.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())
  });
  defineType("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, _utils.validateType)("TSEntityName"),
      right: (0, _utils.validateType)("Identifier")
    }
  });
  var signatureDeclarationCommon = function signatureDeclarationCommon() {
    return _defineProperty(_defineProperty({
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration")
    }, "parameters", (0, _utils.validateArrayOfType)("ArrayPattern", "Identifier", "ObjectPattern", "RestElement")), "typeAnnotation", (0, _utils.validateOptionalType)("TSTypeAnnotation"));
  };
  var callConstructSignatureDeclaration = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: signatureDeclarationCommon()
  };
  defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
  defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
  var namedTypeElementCommon = function namedTypeElementCommon() {
    return {
      key: (0, _utils.validateType)("Expression"),
      computed: {
        "default": false
      },
      optional: (0, _utils.validateOptional)(bool)
    };
  };
  defineType("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation"],
    fields: Object.assign({}, namedTypeElementCommon(), {
      readonly: (0, _utils.validateOptional)(bool),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
      kind: {
        optional: true,
        validate: (0, _utils.assertOneOf)("get", "set")
      }
    })
  });
  defineType("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {
      kind: {
        validate: (0, _utils.assertOneOf)("method", "get", "set")
      }
    })
  });
  defineType("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, _utils.validateOptional)(bool),
      "static": (0, _utils.validateOptional)(bool),
      parameters: (0, _utils.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
    }
  });
  var tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (var _i = 0, _tsKeywordTypes = tsKeywordTypes; _i < _tsKeywordTypes.length; _i++) {
    var type = _tsKeywordTypes[_i];
    defineType(type, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  }
  defineType("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  var fnOrCtrBase = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
    fields: signatureDeclarationCommon()
  }));
  defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
    fields: Object.assign({}, signatureDeclarationCommon(), {
      "abstract": (0, _utils.validateOptional)(bool)
    })
  }));
  defineType("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: _defineProperty({
      typeName: (0, _utils.validateType)("TSEntityName")
    }, "typeParameters", (0, _utils.validateOptionalType)("TSTypeParameterInstantiation"))
  });
  defineType("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, _utils.validateType)("Identifier", "TSThisType"),
      typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, _utils.validateOptional)(bool)
    }
  });
  defineType("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: _defineProperty({
      exprName: (0, _utils.validateType)("TSEntityName", "TSImportType")
    }, "typeParameters", (0, _utils.validateOptionalType)("TSTypeParameterInstantiation"))
  });
  defineType("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: (0, _utils.validateArrayOfType)("TSTypeElement")
    }
  });
  defineType("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, _utils.validateArrayOfType)("TSType", "TSNamedTupleMember")
    }
  });
  defineType("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, _utils.validateType)("Identifier"),
      optional: {
        validate: bool,
        "default": false
      },
      elementType: (0, _utils.validateType)("TSType")
    }
  });
  var unionOrIntersection = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: (0, _utils.validateArrayOfType)("TSType")
    }
  };
  defineType("TSUnionType", unionOrIntersection);
  defineType("TSIntersectionType", unionOrIntersection);
  defineType("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, _utils.validateType)("TSType"),
      extendsType: (0, _utils.validateType)("TSType"),
      trueType: (0, _utils.validateType)("TSType"),
      falseType: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: (0, _utils.validateType)("TSTypeParameter")
    }
  });
  defineType("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, _utils.validateType)("TSType"),
      indexType: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "nameType", "typeAnnotation"],
    builder: ["typeParameter", "typeAnnotation", "nameType"],
    fields: Object.assign({}, {
      typeParameter: (0, _utils.validateType)("TSTypeParameter")
    }, {
      readonly: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
      optional: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
      typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
      nameType: (0, _utils.validateOptionalType)("TSType")
    })
  });
  defineType("TSTemplateLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["quasis", "types"],
    fields: {
      quasis: (0, _utils.validateArrayOfType)("TemplateElement"),
      types: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")), function (node, key, val) {
          if (node.quasis.length !== val.length + 1) {
            throw new TypeError("Number of ".concat(node.type, " quasis should be exactly one more than the number of types.\nExpected ").concat(val.length + 1, " quasis but got ").concat(node.quasis.length));
          }
        })
      }
    }
  });
  defineType("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: function () {
          var unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral");
          var unaryOperator = (0, _utils.assertOneOf)("-");
          var literal = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function validator(parent, key, node) {
            if ((0, _is["default"])("UnaryExpression", node)) {
              unaryOperator(node, "operator", node.operator);
              unaryExpression(node, "argument", node.argument);
            } else {
              literal(parent, key, node);
            }
          }
          validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"];
          return validator;
        }()
      }
    }
  });
  {
    defineType("TSExpressionWithTypeArguments", {
      aliases: ["TSType"],
      visitor: ["expression", "typeParameters"],
      fields: {
        expression: (0, _utils.validateType)("TSEntityName"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
  }
  defineType("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
      "extends": (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, _utils.validateType)("TSInterfaceBody")
    }
  });
  defineType("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: (0, _utils.validateArrayOfType)("TSTypeElement")
    }
  });
  defineType("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, _utils.validateOptional)(bool),
      id: (0, _utils.validateType)("Identifier"),
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  });
  defineType("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: _defineProperty({
      expression: (0, _utils.validateType)("Expression")
    }, "typeParameters", (0, _utils.validateOptionalType)("TSTypeParameterInstantiation"))
  });
  var TSTypeExpression = {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, _utils.validateType)("Expression"),
      typeAnnotation: (0, _utils.validateType)("TSType")
    }
  };
  defineType("TSAsExpression", TSTypeExpression);
  defineType("TSSatisfiesExpression", TSTypeExpression);
  defineType("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, _utils.validateType)("TSType"),
      expression: (0, _utils.validateType)("Expression")
    }
  });
  defineType("TSEnumBody", {
    visitor: ["members"],
    fields: {
      members: (0, _utils.validateArrayOfType)("TSEnumMember")
    }
  });
  {
    defineType("TSEnumDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "members"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        "const": (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        members: (0, _utils.validateArrayOfType)("TSEnumMember"),
        initializer: (0, _utils.validateOptionalType)("Expression"),
        body: (0, _utils.validateOptionalType)("TSEnumBody")
      }
    });
  }
  defineType("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, _utils.validateType)("Identifier", "StringLiteral"),
      initializer: (0, _utils.validateOptionalType)("Expression")
    }
  });
  defineType("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: Object.assign({
      kind: {
        validate: (0, _utils.assertOneOf)("global", "module", "namespace")
      },
      declare: (0, _utils.validateOptional)(bool)
    }, {
      global: (0, _utils.validateOptional)(bool)
    }, {
      id: (0, _utils.validateType)("Identifier", "StringLiteral"),
      body: (0, _utils.validateType)("TSModuleBlock", "TSModuleDeclaration")
    })
  });
  defineType("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    visitor: ["body"],
    fields: {
      body: (0, _utils.validateArrayOfType)("Statement")
    }
  });
  defineType("TSImportType", {
    aliases: ["TSType"],
    builder: ["argument", "qualifier", "typeParameters"],
    visitor: ["argument", "options", "qualifier", "typeParameters"],
    fields: _defineProperty(_defineProperty({
      argument: (0, _utils.validateType)("StringLiteral"),
      qualifier: (0, _utils.validateOptionalType)("TSEntityName")
    }, "typeParameters", (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")), "options", {
      validate: (0, _utils.assertNodeType)("Expression"),
      optional: true
    })
  });
  defineType("TSImportEqualsDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "moduleReference"],
    fields: Object.assign({}, {
      isExport: (0, _utils.validate)(bool)
    }, {
      id: (0, _utils.validateType)("Identifier"),
      moduleReference: (0, _utils.validateType)("TSEntityName", "TSExternalModuleReference"),
      importKind: {
        validate: (0, _utils.assertOneOf)("type", "value"),
        optional: true
      }
    })
  });
  defineType("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: (0, _utils.validateType)("StringLiteral")
    }
  });
  defineType("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: (0, _utils.validateType)("Expression")
    }
  });
  defineType("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: (0, _utils.validateType)("Expression")
    }
  });
  defineType("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: (0, _utils.validateType)("Identifier")
    }
  });
  defineType("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TSType")
      }
    }
  });
  defineType("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, _utils.validateArrayOfType)("TSType")
    }
  });
  defineType("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, _utils.validateArrayOfType)("TSTypeParameter")
    }
  });
  defineType("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: (0, _utils.assertValueType)("string")
      },
      "in": {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      out: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      "const": {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      constraint: {
        validate: (0, _utils.assertNodeType)("TSType"),
        optional: true
      },
      "default": {
        validate: (0, _utils.assertNodeType)("TSType"),
        optional: true
      }
    }
  });
  return typescript$1;
}

var deprecatedAliases = {};

var hasRequiredDeprecatedAliases;
function requireDeprecatedAliases() {
  if (hasRequiredDeprecatedAliases) return deprecatedAliases;
  hasRequiredDeprecatedAliases = 1;
  Object.defineProperty(deprecatedAliases, "__esModule", {
    value: true
  });
  deprecatedAliases.DEPRECATED_ALIASES = void 0;
  deprecatedAliases.DEPRECATED_ALIASES = {
    ModuleDeclaration: "ImportOrExportDeclaration"
  };
  return deprecatedAliases;
}

var hasRequiredDefinitions;
function requireDefinitions() {
  if (hasRequiredDefinitions) return definitions;
  hasRequiredDefinitions = 1;
  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "ALIAS_KEYS", {
      enumerable: true,
      get: function get() {
        return _utils.ALIAS_KEYS;
      }
    });
    Object.defineProperty(exports, "BUILDER_KEYS", {
      enumerable: true,
      get: function get() {
        return _utils.BUILDER_KEYS;
      }
    });
    Object.defineProperty(exports, "DEPRECATED_ALIASES", {
      enumerable: true,
      get: function get() {
        return _deprecatedAliases.DEPRECATED_ALIASES;
      }
    });
    Object.defineProperty(exports, "DEPRECATED_KEYS", {
      enumerable: true,
      get: function get() {
        return _utils.DEPRECATED_KEYS;
      }
    });
    Object.defineProperty(exports, "FLIPPED_ALIAS_KEYS", {
      enumerable: true,
      get: function get() {
        return _utils.FLIPPED_ALIAS_KEYS;
      }
    });
    Object.defineProperty(exports, "NODE_FIELDS", {
      enumerable: true,
      get: function get() {
        return _utils.NODE_FIELDS;
      }
    });
    Object.defineProperty(exports, "NODE_PARENT_VALIDATIONS", {
      enumerable: true,
      get: function get() {
        return _utils.NODE_PARENT_VALIDATIONS;
      }
    });
    Object.defineProperty(exports, "PLACEHOLDERS", {
      enumerable: true,
      get: function get() {
        return _placeholders.PLACEHOLDERS;
      }
    });
    Object.defineProperty(exports, "PLACEHOLDERS_ALIAS", {
      enumerable: true,
      get: function get() {
        return _placeholders.PLACEHOLDERS_ALIAS;
      }
    });
    Object.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", {
      enumerable: true,
      get: function get() {
        return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
      }
    });
    exports.TYPES = void 0;
    Object.defineProperty(exports, "VISITOR_KEYS", {
      enumerable: true,
      get: function get() {
        return _utils.VISITOR_KEYS;
      }
    });
    requireCore();
    requireFlow$1();
    requireJsx$1();
    requireMisc();
    requireExperimental();
    requireTypescript$1();
    var _utils = requireUtils();
    var _placeholders = requirePlaceholders();
    var _deprecatedAliases = requireDeprecatedAliases();
    Object.keys(_deprecatedAliases.DEPRECATED_ALIASES).forEach(function (deprecatedAlias) {
      _utils.FLIPPED_ALIAS_KEYS[deprecatedAlias] = _utils.FLIPPED_ALIAS_KEYS[_deprecatedAliases.DEPRECATED_ALIASES[deprecatedAlias]];
    });
    exports.TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));
  })(definitions);
  return definitions;
}

var hasRequiredValidate;
function requireValidate() {
  if (hasRequiredValidate) return validate;
  hasRequiredValidate = 1;
  Object.defineProperty(validate, "__esModule", {
    value: true
  });
  validate["default"] = validate$1;
  validate.validateChild = validateChild;
  validate.validateField = validateField;
  validate.validateInternal = validateInternal;
  var _index = requireDefinitions();
  function validate$1(node, key, val) {
    if (!node) return;
    var fields = _index.NODE_FIELDS[node.type];
    if (!fields) return;
    var field = fields[key];
    validateField(node, key, val, field);
    validateChild(node, key, val);
  }
  function validateInternal(field, node, key, val, maybeNode) {
    if (!(field != null && field.validate)) return;
    if (field.optional && val == null) return;
    field.validate(node, key, val);
    if (maybeNode) {
      var _NODE_PARENT_VALIDATI;
      var type = val.type;
      if (type == null) return;
      (_NODE_PARENT_VALIDATI = _index.NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI.call(_index.NODE_PARENT_VALIDATIONS, node, key, val);
    }
  }
  function validateField(node, key, val, field) {
    if (!(field != null && field.validate)) return;
    if (field.optional && val == null) return;
    field.validate(node, key, val);
  }
  function validateChild(node, key, val) {
    var _NODE_PARENT_VALIDATI2;
    var type = val == null ? void 0 : val.type;
    if (type == null) return;
    (_NODE_PARENT_VALIDATI2 = _index.NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI2.call(_index.NODE_PARENT_VALIDATIONS, node, key, val);
  }
  return validate;
}

var hasRequiredLowercase;
function requireLowercase() {
  if (hasRequiredLowercase) return lowercase;
  hasRequiredLowercase = 1;
  Object.defineProperty(lowercase, "__esModule", {
    value: true
  });
  lowercase.anyTypeAnnotation = anyTypeAnnotation;
  lowercase.argumentPlaceholder = argumentPlaceholder;
  lowercase.arrayExpression = arrayExpression;
  lowercase.arrayPattern = arrayPattern;
  lowercase.arrayTypeAnnotation = arrayTypeAnnotation;
  lowercase.arrowFunctionExpression = arrowFunctionExpression;
  lowercase.assignmentExpression = assignmentExpression;
  lowercase.assignmentPattern = assignmentPattern;
  lowercase.awaitExpression = awaitExpression;
  lowercase.bigIntLiteral = bigIntLiteral;
  lowercase.binaryExpression = binaryExpression;
  lowercase.bindExpression = bindExpression;
  lowercase.blockStatement = blockStatement;
  lowercase.booleanLiteral = booleanLiteral;
  lowercase.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
  lowercase.booleanTypeAnnotation = booleanTypeAnnotation;
  lowercase.breakStatement = breakStatement;
  lowercase.callExpression = callExpression;
  lowercase.catchClause = catchClause;
  lowercase.classAccessorProperty = classAccessorProperty;
  lowercase.classBody = classBody;
  lowercase.classDeclaration = classDeclaration;
  lowercase.classExpression = classExpression;
  lowercase.classImplements = classImplements;
  lowercase.classMethod = classMethod;
  lowercase.classPrivateMethod = classPrivateMethod;
  lowercase.classPrivateProperty = classPrivateProperty;
  lowercase.classProperty = classProperty;
  lowercase.conditionalExpression = conditionalExpression;
  lowercase.continueStatement = continueStatement;
  lowercase.debuggerStatement = debuggerStatement;
  lowercase.decimalLiteral = decimalLiteral;
  lowercase.declareClass = declareClass;
  lowercase.declareExportAllDeclaration = declareExportAllDeclaration;
  lowercase.declareExportDeclaration = declareExportDeclaration;
  lowercase.declareFunction = declareFunction;
  lowercase.declareInterface = declareInterface;
  lowercase.declareModule = declareModule;
  lowercase.declareModuleExports = declareModuleExports;
  lowercase.declareOpaqueType = declareOpaqueType;
  lowercase.declareTypeAlias = declareTypeAlias;
  lowercase.declareVariable = declareVariable;
  lowercase.declaredPredicate = declaredPredicate;
  lowercase.decorator = decorator;
  lowercase.directive = directive;
  lowercase.directiveLiteral = directiveLiteral;
  lowercase.doExpression = doExpression;
  lowercase.doWhileStatement = doWhileStatement;
  lowercase.emptyStatement = emptyStatement;
  lowercase.emptyTypeAnnotation = emptyTypeAnnotation;
  lowercase.enumBooleanBody = enumBooleanBody;
  lowercase.enumBooleanMember = enumBooleanMember;
  lowercase.enumDeclaration = enumDeclaration;
  lowercase.enumDefaultedMember = enumDefaultedMember;
  lowercase.enumNumberBody = enumNumberBody;
  lowercase.enumNumberMember = enumNumberMember;
  lowercase.enumStringBody = enumStringBody;
  lowercase.enumStringMember = enumStringMember;
  lowercase.enumSymbolBody = enumSymbolBody;
  lowercase.existsTypeAnnotation = existsTypeAnnotation;
  lowercase.exportAllDeclaration = exportAllDeclaration;
  lowercase.exportDefaultDeclaration = exportDefaultDeclaration;
  lowercase.exportDefaultSpecifier = exportDefaultSpecifier;
  lowercase.exportNamedDeclaration = exportNamedDeclaration;
  lowercase.exportNamespaceSpecifier = exportNamespaceSpecifier;
  lowercase.exportSpecifier = exportSpecifier;
  lowercase.expressionStatement = expressionStatement;
  lowercase.file = file;
  lowercase.forInStatement = forInStatement;
  lowercase.forOfStatement = forOfStatement;
  lowercase.forStatement = forStatement;
  lowercase.functionDeclaration = functionDeclaration;
  lowercase.functionExpression = functionExpression;
  lowercase.functionTypeAnnotation = functionTypeAnnotation;
  lowercase.functionTypeParam = functionTypeParam;
  lowercase.genericTypeAnnotation = genericTypeAnnotation;
  lowercase.identifier = identifier;
  lowercase.ifStatement = ifStatement;
  lowercase["import"] = _import;
  lowercase.importAttribute = importAttribute;
  lowercase.importDeclaration = importDeclaration;
  lowercase.importDefaultSpecifier = importDefaultSpecifier;
  lowercase.importExpression = importExpression;
  lowercase.importNamespaceSpecifier = importNamespaceSpecifier;
  lowercase.importSpecifier = importSpecifier;
  lowercase.indexedAccessType = indexedAccessType;
  lowercase.inferredPredicate = inferredPredicate;
  lowercase.interfaceDeclaration = interfaceDeclaration;
  lowercase.interfaceExtends = interfaceExtends;
  lowercase.interfaceTypeAnnotation = interfaceTypeAnnotation;
  lowercase.interpreterDirective = interpreterDirective;
  lowercase.intersectionTypeAnnotation = intersectionTypeAnnotation;
  lowercase.jSXAttribute = lowercase.jsxAttribute = jsxAttribute;
  lowercase.jSXClosingElement = lowercase.jsxClosingElement = jsxClosingElement;
  lowercase.jSXClosingFragment = lowercase.jsxClosingFragment = jsxClosingFragment;
  lowercase.jSXElement = lowercase.jsxElement = jsxElement;
  lowercase.jSXEmptyExpression = lowercase.jsxEmptyExpression = jsxEmptyExpression;
  lowercase.jSXExpressionContainer = lowercase.jsxExpressionContainer = jsxExpressionContainer;
  lowercase.jSXFragment = lowercase.jsxFragment = jsxFragment;
  lowercase.jSXIdentifier = lowercase.jsxIdentifier = jsxIdentifier;
  lowercase.jSXMemberExpression = lowercase.jsxMemberExpression = jsxMemberExpression;
  lowercase.jSXNamespacedName = lowercase.jsxNamespacedName = jsxNamespacedName;
  lowercase.jSXOpeningElement = lowercase.jsxOpeningElement = jsxOpeningElement;
  lowercase.jSXOpeningFragment = lowercase.jsxOpeningFragment = jsxOpeningFragment;
  lowercase.jSXSpreadAttribute = lowercase.jsxSpreadAttribute = jsxSpreadAttribute;
  lowercase.jSXSpreadChild = lowercase.jsxSpreadChild = jsxSpreadChild;
  lowercase.jSXText = lowercase.jsxText = jsxText;
  lowercase.labeledStatement = labeledStatement;
  lowercase.logicalExpression = logicalExpression;
  lowercase.memberExpression = memberExpression;
  lowercase.metaProperty = metaProperty;
  lowercase.mixedTypeAnnotation = mixedTypeAnnotation;
  lowercase.moduleExpression = moduleExpression;
  lowercase.newExpression = newExpression;
  lowercase.noop = noop;
  lowercase.nullLiteral = nullLiteral;
  lowercase.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
  lowercase.nullableTypeAnnotation = nullableTypeAnnotation;
  lowercase.numberLiteral = NumberLiteral;
  lowercase.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
  lowercase.numberTypeAnnotation = numberTypeAnnotation;
  lowercase.numericLiteral = numericLiteral;
  lowercase.objectExpression = objectExpression;
  lowercase.objectMethod = objectMethod;
  lowercase.objectPattern = objectPattern;
  lowercase.objectProperty = objectProperty;
  lowercase.objectTypeAnnotation = objectTypeAnnotation;
  lowercase.objectTypeCallProperty = objectTypeCallProperty;
  lowercase.objectTypeIndexer = objectTypeIndexer;
  lowercase.objectTypeInternalSlot = objectTypeInternalSlot;
  lowercase.objectTypeProperty = objectTypeProperty;
  lowercase.objectTypeSpreadProperty = objectTypeSpreadProperty;
  lowercase.opaqueType = opaqueType;
  lowercase.optionalCallExpression = optionalCallExpression;
  lowercase.optionalIndexedAccessType = optionalIndexedAccessType;
  lowercase.optionalMemberExpression = optionalMemberExpression;
  lowercase.parenthesizedExpression = parenthesizedExpression;
  lowercase.pipelineBareFunction = pipelineBareFunction;
  lowercase.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
  lowercase.pipelineTopicExpression = pipelineTopicExpression;
  lowercase.placeholder = placeholder;
  lowercase.privateName = privateName;
  lowercase.program = program;
  lowercase.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
  lowercase.recordExpression = recordExpression;
  lowercase.regExpLiteral = regExpLiteral;
  lowercase.regexLiteral = RegexLiteral;
  lowercase.restElement = restElement;
  lowercase.restProperty = RestProperty;
  lowercase.returnStatement = returnStatement;
  lowercase.sequenceExpression = sequenceExpression;
  lowercase.spreadElement = spreadElement;
  lowercase.spreadProperty = SpreadProperty;
  lowercase.staticBlock = staticBlock;
  lowercase.stringLiteral = stringLiteral;
  lowercase.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
  lowercase.stringTypeAnnotation = stringTypeAnnotation;
  lowercase["super"] = _super;
  lowercase.switchCase = switchCase;
  lowercase.switchStatement = switchStatement;
  lowercase.symbolTypeAnnotation = symbolTypeAnnotation;
  lowercase.taggedTemplateExpression = taggedTemplateExpression;
  lowercase.templateElement = templateElement;
  lowercase.templateLiteral = templateLiteral;
  lowercase.thisExpression = thisExpression;
  lowercase.thisTypeAnnotation = thisTypeAnnotation;
  lowercase.throwStatement = throwStatement;
  lowercase.topicReference = topicReference;
  lowercase.tryStatement = tryStatement;
  lowercase.tSAnyKeyword = lowercase.tsAnyKeyword = tsAnyKeyword;
  lowercase.tSArrayType = lowercase.tsArrayType = tsArrayType;
  lowercase.tSAsExpression = lowercase.tsAsExpression = tsAsExpression;
  lowercase.tSBigIntKeyword = lowercase.tsBigIntKeyword = tsBigIntKeyword;
  lowercase.tSBooleanKeyword = lowercase.tsBooleanKeyword = tsBooleanKeyword;
  lowercase.tSCallSignatureDeclaration = lowercase.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
  lowercase.tSConditionalType = lowercase.tsConditionalType = tsConditionalType;
  lowercase.tSConstructSignatureDeclaration = lowercase.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
  lowercase.tSConstructorType = lowercase.tsConstructorType = tsConstructorType;
  lowercase.tSDeclareFunction = lowercase.tsDeclareFunction = tsDeclareFunction;
  lowercase.tSDeclareMethod = lowercase.tsDeclareMethod = tsDeclareMethod;
  lowercase.tSEnumBody = lowercase.tsEnumBody = tsEnumBody;
  lowercase.tSEnumDeclaration = lowercase.tsEnumDeclaration = tsEnumDeclaration;
  lowercase.tSEnumMember = lowercase.tsEnumMember = tsEnumMember;
  lowercase.tSExportAssignment = lowercase.tsExportAssignment = tsExportAssignment;
  lowercase.tSExpressionWithTypeArguments = lowercase.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
  lowercase.tSExternalModuleReference = lowercase.tsExternalModuleReference = tsExternalModuleReference;
  lowercase.tSFunctionType = lowercase.tsFunctionType = tsFunctionType;
  lowercase.tSImportEqualsDeclaration = lowercase.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
  lowercase.tSImportType = lowercase.tsImportType = tsImportType;
  lowercase.tSIndexSignature = lowercase.tsIndexSignature = tsIndexSignature;
  lowercase.tSIndexedAccessType = lowercase.tsIndexedAccessType = tsIndexedAccessType;
  lowercase.tSInferType = lowercase.tsInferType = tsInferType;
  lowercase.tSInstantiationExpression = lowercase.tsInstantiationExpression = tsInstantiationExpression;
  lowercase.tSInterfaceBody = lowercase.tsInterfaceBody = tsInterfaceBody;
  lowercase.tSInterfaceDeclaration = lowercase.tsInterfaceDeclaration = tsInterfaceDeclaration;
  lowercase.tSIntersectionType = lowercase.tsIntersectionType = tsIntersectionType;
  lowercase.tSIntrinsicKeyword = lowercase.tsIntrinsicKeyword = tsIntrinsicKeyword;
  lowercase.tSLiteralType = lowercase.tsLiteralType = tsLiteralType;
  lowercase.tSMappedType = lowercase.tsMappedType = tsMappedType;
  lowercase.tSMethodSignature = lowercase.tsMethodSignature = tsMethodSignature;
  lowercase.tSModuleBlock = lowercase.tsModuleBlock = tsModuleBlock;
  lowercase.tSModuleDeclaration = lowercase.tsModuleDeclaration = tsModuleDeclaration;
  lowercase.tSNamedTupleMember = lowercase.tsNamedTupleMember = tsNamedTupleMember;
  lowercase.tSNamespaceExportDeclaration = lowercase.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
  lowercase.tSNeverKeyword = lowercase.tsNeverKeyword = tsNeverKeyword;
  lowercase.tSNonNullExpression = lowercase.tsNonNullExpression = tsNonNullExpression;
  lowercase.tSNullKeyword = lowercase.tsNullKeyword = tsNullKeyword;
  lowercase.tSNumberKeyword = lowercase.tsNumberKeyword = tsNumberKeyword;
  lowercase.tSObjectKeyword = lowercase.tsObjectKeyword = tsObjectKeyword;
  lowercase.tSOptionalType = lowercase.tsOptionalType = tsOptionalType;
  lowercase.tSParameterProperty = lowercase.tsParameterProperty = tsParameterProperty;
  lowercase.tSParenthesizedType = lowercase.tsParenthesizedType = tsParenthesizedType;
  lowercase.tSPropertySignature = lowercase.tsPropertySignature = tsPropertySignature;
  lowercase.tSQualifiedName = lowercase.tsQualifiedName = tsQualifiedName;
  lowercase.tSRestType = lowercase.tsRestType = tsRestType;
  lowercase.tSSatisfiesExpression = lowercase.tsSatisfiesExpression = tsSatisfiesExpression;
  lowercase.tSStringKeyword = lowercase.tsStringKeyword = tsStringKeyword;
  lowercase.tSSymbolKeyword = lowercase.tsSymbolKeyword = tsSymbolKeyword;
  lowercase.tSTemplateLiteralType = lowercase.tsTemplateLiteralType = tsTemplateLiteralType;
  lowercase.tSThisType = lowercase.tsThisType = tsThisType;
  lowercase.tSTupleType = lowercase.tsTupleType = tsTupleType;
  lowercase.tSTypeAliasDeclaration = lowercase.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
  lowercase.tSTypeAnnotation = lowercase.tsTypeAnnotation = tsTypeAnnotation;
  lowercase.tSTypeAssertion = lowercase.tsTypeAssertion = tsTypeAssertion;
  lowercase.tSTypeLiteral = lowercase.tsTypeLiteral = tsTypeLiteral;
  lowercase.tSTypeOperator = lowercase.tsTypeOperator = tsTypeOperator;
  lowercase.tSTypeParameter = lowercase.tsTypeParameter = tsTypeParameter;
  lowercase.tSTypeParameterDeclaration = lowercase.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
  lowercase.tSTypeParameterInstantiation = lowercase.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
  lowercase.tSTypePredicate = lowercase.tsTypePredicate = tsTypePredicate;
  lowercase.tSTypeQuery = lowercase.tsTypeQuery = tsTypeQuery;
  lowercase.tSTypeReference = lowercase.tsTypeReference = tsTypeReference;
  lowercase.tSUndefinedKeyword = lowercase.tsUndefinedKeyword = tsUndefinedKeyword;
  lowercase.tSUnionType = lowercase.tsUnionType = tsUnionType;
  lowercase.tSUnknownKeyword = lowercase.tsUnknownKeyword = tsUnknownKeyword;
  lowercase.tSVoidKeyword = lowercase.tsVoidKeyword = tsVoidKeyword;
  lowercase.tupleExpression = tupleExpression;
  lowercase.tupleTypeAnnotation = tupleTypeAnnotation;
  lowercase.typeAlias = typeAlias;
  lowercase.typeAnnotation = typeAnnotation;
  lowercase.typeCastExpression = typeCastExpression;
  lowercase.typeParameter = typeParameter;
  lowercase.typeParameterDeclaration = typeParameterDeclaration;
  lowercase.typeParameterInstantiation = typeParameterInstantiation;
  lowercase.typeofTypeAnnotation = typeofTypeAnnotation;
  lowercase.unaryExpression = unaryExpression;
  lowercase.unionTypeAnnotation = unionTypeAnnotation;
  lowercase.updateExpression = updateExpression;
  lowercase.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
  lowercase.variableDeclaration = variableDeclaration;
  lowercase.variableDeclarator = variableDeclarator;
  lowercase.variance = variance;
  lowercase.voidTypeAnnotation = voidTypeAnnotation;
  lowercase.whileStatement = whileStatement;
  lowercase.withStatement = withStatement;
  lowercase.yieldExpression = yieldExpression;
  var _validate = requireValidate();
  var _deprecationWarning = requireDeprecationWarning();
  var utils = requireUtils();
  var validate = _validate.validateInternal;
  var NODE_FIELDS = utils.NODE_FIELDS;
  function arrayExpression() {
    var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var node = {
      type: "ArrayExpression",
      elements: elements
    };
    var defs = NODE_FIELDS.ArrayExpression;
    validate(defs.elements, node, "elements", elements, 1);
    return node;
  }
  function assignmentExpression(operator, left, right) {
    var node = {
      type: "AssignmentExpression",
      operator: operator,
      left: left,
      right: right
    };
    var defs = NODE_FIELDS.AssignmentExpression;
    validate(defs.operator, node, "operator", operator);
    validate(defs.left, node, "left", left, 1);
    validate(defs.right, node, "right", right, 1);
    return node;
  }
  function binaryExpression(operator, left, right) {
    var node = {
      type: "BinaryExpression",
      operator: operator,
      left: left,
      right: right
    };
    var defs = NODE_FIELDS.BinaryExpression;
    validate(defs.operator, node, "operator", operator);
    validate(defs.left, node, "left", left, 1);
    validate(defs.right, node, "right", right, 1);
    return node;
  }
  function interpreterDirective(value) {
    var node = {
      type: "InterpreterDirective",
      value: value
    };
    var defs = NODE_FIELDS.InterpreterDirective;
    validate(defs.value, node, "value", value);
    return node;
  }
  function directive(value) {
    var node = {
      type: "Directive",
      value: value
    };
    var defs = NODE_FIELDS.Directive;
    validate(defs.value, node, "value", value, 1);
    return node;
  }
  function directiveLiteral(value) {
    var node = {
      type: "DirectiveLiteral",
      value: value
    };
    var defs = NODE_FIELDS.DirectiveLiteral;
    validate(defs.value, node, "value", value);
    return node;
  }
  function blockStatement(body) {
    var directives = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var node = {
      type: "BlockStatement",
      body: body,
      directives: directives
    };
    var defs = NODE_FIELDS.BlockStatement;
    validate(defs.body, node, "body", body, 1);
    validate(defs.directives, node, "directives", directives, 1);
    return node;
  }
  function breakStatement() {
    var label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var node = {
      type: "BreakStatement",
      label: label
    };
    var defs = NODE_FIELDS.BreakStatement;
    validate(defs.label, node, "label", label, 1);
    return node;
  }
  function callExpression(callee, _arguments) {
    var node = {
      type: "CallExpression",
      callee: callee,
      arguments: _arguments
    };
    var defs = NODE_FIELDS.CallExpression;
    validate(defs.callee, node, "callee", callee, 1);
    validate(defs.arguments, node, "arguments", _arguments, 1);
    return node;
  }
  function catchClause() {
    var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var body = arguments.length > 1 ? arguments[1] : undefined;
    var node = {
      type: "CatchClause",
      param: param,
      body: body
    };
    var defs = NODE_FIELDS.CatchClause;
    validate(defs.param, node, "param", param, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function conditionalExpression(test, consequent, alternate) {
    var node = {
      type: "ConditionalExpression",
      test: test,
      consequent: consequent,
      alternate: alternate
    };
    var defs = NODE_FIELDS.ConditionalExpression;
    validate(defs.test, node, "test", test, 1);
    validate(defs.consequent, node, "consequent", consequent, 1);
    validate(defs.alternate, node, "alternate", alternate, 1);
    return node;
  }
  function continueStatement() {
    var label = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var node = {
      type: "ContinueStatement",
      label: label
    };
    var defs = NODE_FIELDS.ContinueStatement;
    validate(defs.label, node, "label", label, 1);
    return node;
  }
  function debuggerStatement() {
    return {
      type: "DebuggerStatement"
    };
  }
  function doWhileStatement(test, body) {
    var node = {
      type: "DoWhileStatement",
      test: test,
      body: body
    };
    var defs = NODE_FIELDS.DoWhileStatement;
    validate(defs.test, node, "test", test, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function emptyStatement() {
    return {
      type: "EmptyStatement"
    };
  }
  function expressionStatement(expression) {
    var node = {
      type: "ExpressionStatement",
      expression: expression
    };
    var defs = NODE_FIELDS.ExpressionStatement;
    validate(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function file(program) {
    var comments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var tokens = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var node = {
      type: "File",
      program: program,
      comments: comments,
      tokens: tokens
    };
    var defs = NODE_FIELDS.File;
    validate(defs.program, node, "program", program, 1);
    validate(defs.comments, node, "comments", comments, 1);
    validate(defs.tokens, node, "tokens", tokens);
    return node;
  }
  function forInStatement(left, right, body) {
    var node = {
      type: "ForInStatement",
      left: left,
      right: right,
      body: body
    };
    var defs = NODE_FIELDS.ForInStatement;
    validate(defs.left, node, "left", left, 1);
    validate(defs.right, node, "right", right, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function forStatement() {
    var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var test = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var body = arguments.length > 3 ? arguments[3] : undefined;
    var node = {
      type: "ForStatement",
      init: init,
      test: test,
      update: update,
      body: body
    };
    var defs = NODE_FIELDS.ForStatement;
    validate(defs.init, node, "init", init, 1);
    validate(defs.test, node, "test", test, 1);
    validate(defs.update, node, "update", update, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function functionDeclaration() {
    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var params = arguments.length > 1 ? arguments[1] : undefined;
    var body = arguments.length > 2 ? arguments[2] : undefined;
    var generator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var async = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var node = {
      type: "FunctionDeclaration",
      id: id,
      params: params,
      body: body,
      generator: generator,
      async: async
    };
    var defs = NODE_FIELDS.FunctionDeclaration;
    validate(defs.id, node, "id", id, 1);
    validate(defs.params, node, "params", params, 1);
    validate(defs.body, node, "body", body, 1);
    validate(defs.generator, node, "generator", generator);
    validate(defs.async, node, "async", async);
    return node;
  }
  function functionExpression() {
    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var params = arguments.length > 1 ? arguments[1] : undefined;
    var body = arguments.length > 2 ? arguments[2] : undefined;
    var generator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var async = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var node = {
      type: "FunctionExpression",
      id: id,
      params: params,
      body: body,
      generator: generator,
      async: async
    };
    var defs = NODE_FIELDS.FunctionExpression;
    validate(defs.id, node, "id", id, 1);
    validate(defs.params, node, "params", params, 1);
    validate(defs.body, node, "body", body, 1);
    validate(defs.generator, node, "generator", generator);
    validate(defs.async, node, "async", async);
    return node;
  }
  function identifier(name) {
    var node = {
      type: "Identifier",
      name: name
    };
    var defs = NODE_FIELDS.Identifier;
    validate(defs.name, node, "name", name);
    return node;
  }
  function ifStatement(test, consequent) {
    var alternate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var node = {
      type: "IfStatement",
      test: test,
      consequent: consequent,
      alternate: alternate
    };
    var defs = NODE_FIELDS.IfStatement;
    validate(defs.test, node, "test", test, 1);
    validate(defs.consequent, node, "consequent", consequent, 1);
    validate(defs.alternate, node, "alternate", alternate, 1);
    return node;
  }
  function labeledStatement(label, body) {
    var node = {
      type: "LabeledStatement",
      label: label,
      body: body
    };
    var defs = NODE_FIELDS.LabeledStatement;
    validate(defs.label, node, "label", label, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function stringLiteral(value) {
    var node = {
      type: "StringLiteral",
      value: value
    };
    var defs = NODE_FIELDS.StringLiteral;
    validate(defs.value, node, "value", value);
    return node;
  }
  function numericLiteral(value) {
    var node = {
      type: "NumericLiteral",
      value: value
    };
    var defs = NODE_FIELDS.NumericLiteral;
    validate(defs.value, node, "value", value);
    return node;
  }
  function nullLiteral() {
    return {
      type: "NullLiteral"
    };
  }
  function booleanLiteral(value) {
    var node = {
      type: "BooleanLiteral",
      value: value
    };
    var defs = NODE_FIELDS.BooleanLiteral;
    validate(defs.value, node, "value", value);
    return node;
  }
  function regExpLiteral(pattern) {
    var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    var node = {
      type: "RegExpLiteral",
      pattern: pattern,
      flags: flags
    };
    var defs = NODE_FIELDS.RegExpLiteral;
    validate(defs.pattern, node, "pattern", pattern);
    validate(defs.flags, node, "flags", flags);
    return node;
  }
  function logicalExpression(operator, left, right) {
    var node = {
      type: "LogicalExpression",
      operator: operator,
      left: left,
      right: right
    };
    var defs = NODE_FIELDS.LogicalExpression;
    validate(defs.operator, node, "operator", operator);
    validate(defs.left, node, "left", left, 1);
    validate(defs.right, node, "right", right, 1);
    return node;
  }
  function memberExpression(object, property) {
    var computed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var optional = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var node = {
      type: "MemberExpression",
      object: object,
      property: property,
      computed: computed,
      optional: optional
    };
    var defs = NODE_FIELDS.MemberExpression;
    validate(defs.object, node, "object", object, 1);
    validate(defs.property, node, "property", property, 1);
    validate(defs.computed, node, "computed", computed);
    validate(defs.optional, node, "optional", optional);
    return node;
  }
  function newExpression(callee, _arguments) {
    var node = {
      type: "NewExpression",
      callee: callee,
      arguments: _arguments
    };
    var defs = NODE_FIELDS.NewExpression;
    validate(defs.callee, node, "callee", callee, 1);
    validate(defs.arguments, node, "arguments", _arguments, 1);
    return node;
  }
  function program(body) {
    var directives = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var sourceType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "script";
    var interpreter = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var node = {
      type: "Program",
      body: body,
      directives: directives,
      sourceType: sourceType,
      interpreter: interpreter
    };
    var defs = NODE_FIELDS.Program;
    validate(defs.body, node, "body", body, 1);
    validate(defs.directives, node, "directives", directives, 1);
    validate(defs.sourceType, node, "sourceType", sourceType);
    validate(defs.interpreter, node, "interpreter", interpreter, 1);
    return node;
  }
  function objectExpression(properties) {
    var node = {
      type: "ObjectExpression",
      properties: properties
    };
    var defs = NODE_FIELDS.ObjectExpression;
    validate(defs.properties, node, "properties", properties, 1);
    return node;
  }
  function objectMethod() {
    var kind = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "method";
    var key = arguments.length > 1 ? arguments[1] : undefined;
    var params = arguments.length > 2 ? arguments[2] : undefined;
    var body = arguments.length > 3 ? arguments[3] : undefined;
    var computed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var generator = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    var async = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
    var node = {
      type: "ObjectMethod",
      kind: kind,
      key: key,
      params: params,
      body: body,
      computed: computed,
      generator: generator,
      async: async
    };
    var defs = NODE_FIELDS.ObjectMethod;
    validate(defs.kind, node, "kind", kind);
    validate(defs.key, node, "key", key, 1);
    validate(defs.params, node, "params", params, 1);
    validate(defs.body, node, "body", body, 1);
    validate(defs.computed, node, "computed", computed);
    validate(defs.generator, node, "generator", generator);
    validate(defs.async, node, "async", async);
    return node;
  }
  function objectProperty(key, value) {
    var computed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var shorthand = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var decorators = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var node = {
      type: "ObjectProperty",
      key: key,
      value: value,
      computed: computed,
      shorthand: shorthand,
      decorators: decorators
    };
    var defs = NODE_FIELDS.ObjectProperty;
    validate(defs.key, node, "key", key, 1);
    validate(defs.value, node, "value", value, 1);
    validate(defs.computed, node, "computed", computed);
    validate(defs.shorthand, node, "shorthand", shorthand);
    validate(defs.decorators, node, "decorators", decorators, 1);
    return node;
  }
  function restElement(argument) {
    var node = {
      type: "RestElement",
      argument: argument
    };
    var defs = NODE_FIELDS.RestElement;
    validate(defs.argument, node, "argument", argument, 1);
    return node;
  }
  function returnStatement() {
    var argument = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var node = {
      type: "ReturnStatement",
      argument: argument
    };
    var defs = NODE_FIELDS.ReturnStatement;
    validate(defs.argument, node, "argument", argument, 1);
    return node;
  }
  function sequenceExpression(expressions) {
    var node = {
      type: "SequenceExpression",
      expressions: expressions
    };
    var defs = NODE_FIELDS.SequenceExpression;
    validate(defs.expressions, node, "expressions", expressions, 1);
    return node;
  }
  function parenthesizedExpression(expression) {
    var node = {
      type: "ParenthesizedExpression",
      expression: expression
    };
    var defs = NODE_FIELDS.ParenthesizedExpression;
    validate(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function switchCase() {
    var test = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var consequent = arguments.length > 1 ? arguments[1] : undefined;
    var node = {
      type: "SwitchCase",
      test: test,
      consequent: consequent
    };
    var defs = NODE_FIELDS.SwitchCase;
    validate(defs.test, node, "test", test, 1);
    validate(defs.consequent, node, "consequent", consequent, 1);
    return node;
  }
  function switchStatement(discriminant, cases) {
    var node = {
      type: "SwitchStatement",
      discriminant: discriminant,
      cases: cases
    };
    var defs = NODE_FIELDS.SwitchStatement;
    validate(defs.discriminant, node, "discriminant", discriminant, 1);
    validate(defs.cases, node, "cases", cases, 1);
    return node;
  }
  function thisExpression() {
    return {
      type: "ThisExpression"
    };
  }
  function throwStatement(argument) {
    var node = {
      type: "ThrowStatement",
      argument: argument
    };
    var defs = NODE_FIELDS.ThrowStatement;
    validate(defs.argument, node, "argument", argument, 1);
    return node;
  }
  function tryStatement(block) {
    var handler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var finalizer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var node = {
      type: "TryStatement",
      block: block,
      handler: handler,
      finalizer: finalizer
    };
    var defs = NODE_FIELDS.TryStatement;
    validate(defs.block, node, "block", block, 1);
    validate(defs.handler, node, "handler", handler, 1);
    validate(defs.finalizer, node, "finalizer", finalizer, 1);
    return node;
  }
  function unaryExpression(operator, argument) {
    var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    var node = {
      type: "UnaryExpression",
      operator: operator,
      argument: argument,
      prefix: prefix
    };
    var defs = NODE_FIELDS.UnaryExpression;
    validate(defs.operator, node, "operator", operator);
    validate(defs.argument, node, "argument", argument, 1);
    validate(defs.prefix, node, "prefix", prefix);
    return node;
  }
  function updateExpression(operator, argument) {
    var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var node = {
      type: "UpdateExpression",
      operator: operator,
      argument: argument,
      prefix: prefix
    };
    var defs = NODE_FIELDS.UpdateExpression;
    validate(defs.operator, node, "operator", operator);
    validate(defs.argument, node, "argument", argument, 1);
    validate(defs.prefix, node, "prefix", prefix);
    return node;
  }
  function variableDeclaration(kind, declarations) {
    var node = {
      type: "VariableDeclaration",
      kind: kind,
      declarations: declarations
    };
    var defs = NODE_FIELDS.VariableDeclaration;
    validate(defs.kind, node, "kind", kind);
    validate(defs.declarations, node, "declarations", declarations, 1);
    return node;
  }
  function variableDeclarator(id) {
    var init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var node = {
      type: "VariableDeclarator",
      id: id,
      init: init
    };
    var defs = NODE_FIELDS.VariableDeclarator;
    validate(defs.id, node, "id", id, 1);
    validate(defs.init, node, "init", init, 1);
    return node;
  }
  function whileStatement(test, body) {
    var node = {
      type: "WhileStatement",
      test: test,
      body: body
    };
    var defs = NODE_FIELDS.WhileStatement;
    validate(defs.test, node, "test", test, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function withStatement(object, body) {
    var node = {
      type: "WithStatement",
      object: object,
      body: body
    };
    var defs = NODE_FIELDS.WithStatement;
    validate(defs.object, node, "object", object, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function assignmentPattern(left, right) {
    var node = {
      type: "AssignmentPattern",
      left: left,
      right: right
    };
    var defs = NODE_FIELDS.AssignmentPattern;
    validate(defs.left, node, "left", left, 1);
    validate(defs.right, node, "right", right, 1);
    return node;
  }
  function arrayPattern(elements) {
    var node = {
      type: "ArrayPattern",
      elements: elements
    };
    var defs = NODE_FIELDS.ArrayPattern;
    validate(defs.elements, node, "elements", elements, 1);
    return node;
  }
  function arrowFunctionExpression(params, body) {
    var async = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var node = {
      type: "ArrowFunctionExpression",
      params: params,
      body: body,
      async: async,
      expression: null
    };
    var defs = NODE_FIELDS.ArrowFunctionExpression;
    validate(defs.params, node, "params", params, 1);
    validate(defs.body, node, "body", body, 1);
    validate(defs.async, node, "async", async);
    return node;
  }
  function classBody(body) {
    var node = {
      type: "ClassBody",
      body: body
    };
    var defs = NODE_FIELDS.ClassBody;
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function classExpression() {
    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var superClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var body = arguments.length > 2 ? arguments[2] : undefined;
    var decorators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var node = {
      type: "ClassExpression",
      id: id,
      superClass: superClass,
      body: body,
      decorators: decorators
    };
    var defs = NODE_FIELDS.ClassExpression;
    validate(defs.id, node, "id", id, 1);
    validate(defs.superClass, node, "superClass", superClass, 1);
    validate(defs.body, node, "body", body, 1);
    validate(defs.decorators, node, "decorators", decorators, 1);
    return node;
  }
  function classDeclaration() {
    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var superClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var body = arguments.length > 2 ? arguments[2] : undefined;
    var decorators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var node = {
      type: "ClassDeclaration",
      id: id,
      superClass: superClass,
      body: body,
      decorators: decorators
    };
    var defs = NODE_FIELDS.ClassDeclaration;
    validate(defs.id, node, "id", id, 1);
    validate(defs.superClass, node, "superClass", superClass, 1);
    validate(defs.body, node, "body", body, 1);
    validate(defs.decorators, node, "decorators", decorators, 1);
    return node;
  }
  function exportAllDeclaration(source) {
    var node = {
      type: "ExportAllDeclaration",
      source: source
    };
    var defs = NODE_FIELDS.ExportAllDeclaration;
    validate(defs.source, node, "source", source, 1);
    return node;
  }
  function exportDefaultDeclaration(declaration) {
    var node = {
      type: "ExportDefaultDeclaration",
      declaration: declaration
    };
    var defs = NODE_FIELDS.ExportDefaultDeclaration;
    validate(defs.declaration, node, "declaration", declaration, 1);
    return node;
  }
  function exportNamedDeclaration() {
    var declaration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var specifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var node = {
      type: "ExportNamedDeclaration",
      declaration: declaration,
      specifiers: specifiers,
      source: source
    };
    var defs = NODE_FIELDS.ExportNamedDeclaration;
    validate(defs.declaration, node, "declaration", declaration, 1);
    validate(defs.specifiers, node, "specifiers", specifiers, 1);
    validate(defs.source, node, "source", source, 1);
    return node;
  }
  function exportSpecifier(local, exported) {
    var node = {
      type: "ExportSpecifier",
      local: local,
      exported: exported
    };
    var defs = NODE_FIELDS.ExportSpecifier;
    validate(defs.local, node, "local", local, 1);
    validate(defs.exported, node, "exported", exported, 1);
    return node;
  }
  function forOfStatement(left, right, body) {
    var _await = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var node = {
      type: "ForOfStatement",
      left: left,
      right: right,
      body: body,
      "await": _await
    };
    var defs = NODE_FIELDS.ForOfStatement;
    validate(defs.left, node, "left", left, 1);
    validate(defs.right, node, "right", right, 1);
    validate(defs.body, node, "body", body, 1);
    validate(defs["await"], node, "await", _await);
    return node;
  }
  function importDeclaration(specifiers, source) {
    var node = {
      type: "ImportDeclaration",
      specifiers: specifiers,
      source: source
    };
    var defs = NODE_FIELDS.ImportDeclaration;
    validate(defs.specifiers, node, "specifiers", specifiers, 1);
    validate(defs.source, node, "source", source, 1);
    return node;
  }
  function importDefaultSpecifier(local) {
    var node = {
      type: "ImportDefaultSpecifier",
      local: local
    };
    var defs = NODE_FIELDS.ImportDefaultSpecifier;
    validate(defs.local, node, "local", local, 1);
    return node;
  }
  function importNamespaceSpecifier(local) {
    var node = {
      type: "ImportNamespaceSpecifier",
      local: local
    };
    var defs = NODE_FIELDS.ImportNamespaceSpecifier;
    validate(defs.local, node, "local", local, 1);
    return node;
  }
  function importSpecifier(local, imported) {
    var node = {
      type: "ImportSpecifier",
      local: local,
      imported: imported
    };
    var defs = NODE_FIELDS.ImportSpecifier;
    validate(defs.local, node, "local", local, 1);
    validate(defs.imported, node, "imported", imported, 1);
    return node;
  }
  function importExpression(source) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var node = {
      type: "ImportExpression",
      source: source,
      options: options
    };
    var defs = NODE_FIELDS.ImportExpression;
    validate(defs.source, node, "source", source, 1);
    validate(defs.options, node, "options", options, 1);
    return node;
  }
  function metaProperty(meta, property) {
    var node = {
      type: "MetaProperty",
      meta: meta,
      property: property
    };
    var defs = NODE_FIELDS.MetaProperty;
    validate(defs.meta, node, "meta", meta, 1);
    validate(defs.property, node, "property", property, 1);
    return node;
  }
  function classMethod() {
    var kind = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "method";
    var key = arguments.length > 1 ? arguments[1] : undefined;
    var params = arguments.length > 2 ? arguments[2] : undefined;
    var body = arguments.length > 3 ? arguments[3] : undefined;
    var computed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var _static = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    var generator = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
    var async = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
    var node = {
      type: "ClassMethod",
      kind: kind,
      key: key,
      params: params,
      body: body,
      computed: computed,
      "static": _static,
      generator: generator,
      async: async
    };
    var defs = NODE_FIELDS.ClassMethod;
    validate(defs.kind, node, "kind", kind);
    validate(defs.key, node, "key", key, 1);
    validate(defs.params, node, "params", params, 1);
    validate(defs.body, node, "body", body, 1);
    validate(defs.computed, node, "computed", computed);
    validate(defs["static"], node, "static", _static);
    validate(defs.generator, node, "generator", generator);
    validate(defs.async, node, "async", async);
    return node;
  }
  function objectPattern(properties) {
    var node = {
      type: "ObjectPattern",
      properties: properties
    };
    var defs = NODE_FIELDS.ObjectPattern;
    validate(defs.properties, node, "properties", properties, 1);
    return node;
  }
  function spreadElement(argument) {
    var node = {
      type: "SpreadElement",
      argument: argument
    };
    var defs = NODE_FIELDS.SpreadElement;
    validate(defs.argument, node, "argument", argument, 1);
    return node;
  }
  function _super() {
    return {
      type: "Super"
    };
  }
  function taggedTemplateExpression(tag, quasi) {
    var node = {
      type: "TaggedTemplateExpression",
      tag: tag,
      quasi: quasi
    };
    var defs = NODE_FIELDS.TaggedTemplateExpression;
    validate(defs.tag, node, "tag", tag, 1);
    validate(defs.quasi, node, "quasi", quasi, 1);
    return node;
  }
  function templateElement(value) {
    var tail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var node = {
      type: "TemplateElement",
      value: value,
      tail: tail
    };
    var defs = NODE_FIELDS.TemplateElement;
    validate(defs.value, node, "value", value);
    validate(defs.tail, node, "tail", tail);
    return node;
  }
  function templateLiteral(quasis, expressions) {
    var node = {
      type: "TemplateLiteral",
      quasis: quasis,
      expressions: expressions
    };
    var defs = NODE_FIELDS.TemplateLiteral;
    validate(defs.quasis, node, "quasis", quasis, 1);
    validate(defs.expressions, node, "expressions", expressions, 1);
    return node;
  }
  function yieldExpression() {
    var argument = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var delegate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var node = {
      type: "YieldExpression",
      argument: argument,
      delegate: delegate
    };
    var defs = NODE_FIELDS.YieldExpression;
    validate(defs.argument, node, "argument", argument, 1);
    validate(defs.delegate, node, "delegate", delegate);
    return node;
  }
  function awaitExpression(argument) {
    var node = {
      type: "AwaitExpression",
      argument: argument
    };
    var defs = NODE_FIELDS.AwaitExpression;
    validate(defs.argument, node, "argument", argument, 1);
    return node;
  }
  function _import() {
    return {
      type: "Import"
    };
  }
  function bigIntLiteral(value) {
    var node = {
      type: "BigIntLiteral",
      value: value
    };
    var defs = NODE_FIELDS.BigIntLiteral;
    validate(defs.value, node, "value", value);
    return node;
  }
  function exportNamespaceSpecifier(exported) {
    var node = {
      type: "ExportNamespaceSpecifier",
      exported: exported
    };
    var defs = NODE_FIELDS.ExportNamespaceSpecifier;
    validate(defs.exported, node, "exported", exported, 1);
    return node;
  }
  function optionalMemberExpression(object, property) {
    var computed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var optional = arguments.length > 3 ? arguments[3] : undefined;
    var node = {
      type: "OptionalMemberExpression",
      object: object,
      property: property,
      computed: computed,
      optional: optional
    };
    var defs = NODE_FIELDS.OptionalMemberExpression;
    validate(defs.object, node, "object", object, 1);
    validate(defs.property, node, "property", property, 1);
    validate(defs.computed, node, "computed", computed);
    validate(defs.optional, node, "optional", optional);
    return node;
  }
  function optionalCallExpression(callee, _arguments, optional) {
    var node = {
      type: "OptionalCallExpression",
      callee: callee,
      arguments: _arguments,
      optional: optional
    };
    var defs = NODE_FIELDS.OptionalCallExpression;
    validate(defs.callee, node, "callee", callee, 1);
    validate(defs.arguments, node, "arguments", _arguments, 1);
    validate(defs.optional, node, "optional", optional);
    return node;
  }
  function classProperty(key) {
    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var decorators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var computed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var _static = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    var node = {
      type: "ClassProperty",
      key: key,
      value: value,
      typeAnnotation: typeAnnotation,
      decorators: decorators,
      computed: computed,
      "static": _static
    };
    var defs = NODE_FIELDS.ClassProperty;
    validate(defs.key, node, "key", key, 1);
    validate(defs.value, node, "value", value, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    validate(defs.decorators, node, "decorators", decorators, 1);
    validate(defs.computed, node, "computed", computed);
    validate(defs["static"], node, "static", _static);
    return node;
  }
  function classAccessorProperty(key) {
    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var decorators = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var computed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var _static = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
    var node = {
      type: "ClassAccessorProperty",
      key: key,
      value: value,
      typeAnnotation: typeAnnotation,
      decorators: decorators,
      computed: computed,
      "static": _static
    };
    var defs = NODE_FIELDS.ClassAccessorProperty;
    validate(defs.key, node, "key", key, 1);
    validate(defs.value, node, "value", value, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    validate(defs.decorators, node, "decorators", decorators, 1);
    validate(defs.computed, node, "computed", computed);
    validate(defs["static"], node, "static", _static);
    return node;
  }
  function classPrivateProperty(key) {
    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var decorators = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var _static = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var node = {
      type: "ClassPrivateProperty",
      key: key,
      value: value,
      decorators: decorators,
      "static": _static
    };
    var defs = NODE_FIELDS.ClassPrivateProperty;
    validate(defs.key, node, "key", key, 1);
    validate(defs.value, node, "value", value, 1);
    validate(defs.decorators, node, "decorators", decorators, 1);
    validate(defs["static"], node, "static", _static);
    return node;
  }
  function classPrivateMethod() {
    var kind = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "method";
    var key = arguments.length > 1 ? arguments[1] : undefined;
    var params = arguments.length > 2 ? arguments[2] : undefined;
    var body = arguments.length > 3 ? arguments[3] : undefined;
    var _static = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var node = {
      type: "ClassPrivateMethod",
      kind: kind,
      key: key,
      params: params,
      body: body,
      "static": _static
    };
    var defs = NODE_FIELDS.ClassPrivateMethod;
    validate(defs.kind, node, "kind", kind);
    validate(defs.key, node, "key", key, 1);
    validate(defs.params, node, "params", params, 1);
    validate(defs.body, node, "body", body, 1);
    validate(defs["static"], node, "static", _static);
    return node;
  }
  function privateName(id) {
    var node = {
      type: "PrivateName",
      id: id
    };
    var defs = NODE_FIELDS.PrivateName;
    validate(defs.id, node, "id", id, 1);
    return node;
  }
  function staticBlock(body) {
    var node = {
      type: "StaticBlock",
      body: body
    };
    var defs = NODE_FIELDS.StaticBlock;
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function anyTypeAnnotation() {
    return {
      type: "AnyTypeAnnotation"
    };
  }
  function arrayTypeAnnotation(elementType) {
    var node = {
      type: "ArrayTypeAnnotation",
      elementType: elementType
    };
    var defs = NODE_FIELDS.ArrayTypeAnnotation;
    validate(defs.elementType, node, "elementType", elementType, 1);
    return node;
  }
  function booleanTypeAnnotation() {
    return {
      type: "BooleanTypeAnnotation"
    };
  }
  function booleanLiteralTypeAnnotation(value) {
    var node = {
      type: "BooleanLiteralTypeAnnotation",
      value: value
    };
    var defs = NODE_FIELDS.BooleanLiteralTypeAnnotation;
    validate(defs.value, node, "value", value);
    return node;
  }
  function nullLiteralTypeAnnotation() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  }
  function classImplements(id) {
    var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var node = {
      type: "ClassImplements",
      id: id,
      typeParameters: typeParameters
    };
    var defs = NODE_FIELDS.ClassImplements;
    validate(defs.id, node, "id", id, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    return node;
  }
  function declareClass(id) {
    var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var _extends = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var body = arguments.length > 3 ? arguments[3] : undefined;
    var node = {
      type: "DeclareClass",
      id: id,
      typeParameters: typeParameters,
      "extends": _extends,
      body: body
    };
    var defs = NODE_FIELDS.DeclareClass;
    validate(defs.id, node, "id", id, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs["extends"], node, "extends", _extends, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function declareFunction(id) {
    var node = {
      type: "DeclareFunction",
      id: id
    };
    var defs = NODE_FIELDS.DeclareFunction;
    validate(defs.id, node, "id", id, 1);
    return node;
  }
  function declareInterface(id) {
    var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var _extends = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var body = arguments.length > 3 ? arguments[3] : undefined;
    var node = {
      type: "DeclareInterface",
      id: id,
      typeParameters: typeParameters,
      "extends": _extends,
      body: body
    };
    var defs = NODE_FIELDS.DeclareInterface;
    validate(defs.id, node, "id", id, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs["extends"], node, "extends", _extends, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function declareModule(id, body) {
    var kind = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var node = {
      type: "DeclareModule",
      id: id,
      body: body,
      kind: kind
    };
    var defs = NODE_FIELDS.DeclareModule;
    validate(defs.id, node, "id", id, 1);
    validate(defs.body, node, "body", body, 1);
    validate(defs.kind, node, "kind", kind);
    return node;
  }
  function declareModuleExports(typeAnnotation) {
    var node = {
      type: "DeclareModuleExports",
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.DeclareModuleExports;
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function declareTypeAlias(id) {
    var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var right = arguments.length > 2 ? arguments[2] : undefined;
    var node = {
      type: "DeclareTypeAlias",
      id: id,
      typeParameters: typeParameters,
      right: right
    };
    var defs = NODE_FIELDS.DeclareTypeAlias;
    validate(defs.id, node, "id", id, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.right, node, "right", right, 1);
    return node;
  }
  function declareOpaqueType(id) {
    var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var supertype = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var node = {
      type: "DeclareOpaqueType",
      id: id,
      typeParameters: typeParameters,
      supertype: supertype
    };
    var defs = NODE_FIELDS.DeclareOpaqueType;
    validate(defs.id, node, "id", id, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.supertype, node, "supertype", supertype, 1);
    return node;
  }
  function declareVariable(id) {
    var node = {
      type: "DeclareVariable",
      id: id
    };
    var defs = NODE_FIELDS.DeclareVariable;
    validate(defs.id, node, "id", id, 1);
    return node;
  }
  function declareExportDeclaration() {
    var declaration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var specifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var attributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var node = {
      type: "DeclareExportDeclaration",
      declaration: declaration,
      specifiers: specifiers,
      source: source,
      attributes: attributes
    };
    var defs = NODE_FIELDS.DeclareExportDeclaration;
    validate(defs.declaration, node, "declaration", declaration, 1);
    validate(defs.specifiers, node, "specifiers", specifiers, 1);
    validate(defs.source, node, "source", source, 1);
    validate(defs.attributes, node, "attributes", attributes, 1);
    return node;
  }
  function declareExportAllDeclaration(source) {
    var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var node = {
      type: "DeclareExportAllDeclaration",
      source: source,
      attributes: attributes
    };
    var defs = NODE_FIELDS.DeclareExportAllDeclaration;
    validate(defs.source, node, "source", source, 1);
    validate(defs.attributes, node, "attributes", attributes, 1);
    return node;
  }
  function declaredPredicate(value) {
    var node = {
      type: "DeclaredPredicate",
      value: value
    };
    var defs = NODE_FIELDS.DeclaredPredicate;
    validate(defs.value, node, "value", value, 1);
    return node;
  }
  function existsTypeAnnotation() {
    return {
      type: "ExistsTypeAnnotation"
    };
  }
  function functionTypeAnnotation() {
    var typeParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var params = arguments.length > 1 ? arguments[1] : undefined;
    var rest = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var returnType = arguments.length > 3 ? arguments[3] : undefined;
    var node = {
      type: "FunctionTypeAnnotation",
      typeParameters: typeParameters,
      params: params,
      rest: rest,
      returnType: returnType
    };
    var defs = NODE_FIELDS.FunctionTypeAnnotation;
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.params, node, "params", params, 1);
    validate(defs.rest, node, "rest", rest, 1);
    validate(defs.returnType, node, "returnType", returnType, 1);
    return node;
  }
  function functionTypeParam() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var typeAnnotation = arguments.length > 1 ? arguments[1] : undefined;
    var node = {
      type: "FunctionTypeParam",
      name: name,
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.FunctionTypeParam;
    validate(defs.name, node, "name", name, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function genericTypeAnnotation(id) {
    var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var node = {
      type: "GenericTypeAnnotation",
      id: id,
      typeParameters: typeParameters
    };
    var defs = NODE_FIELDS.GenericTypeAnnotation;
    validate(defs.id, node, "id", id, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    return node;
  }
  function inferredPredicate() {
    return {
      type: "InferredPredicate"
    };
  }
  function interfaceExtends(id) {
    var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var node = {
      type: "InterfaceExtends",
      id: id,
      typeParameters: typeParameters
    };
    var defs = NODE_FIELDS.InterfaceExtends;
    validate(defs.id, node, "id", id, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    return node;
  }
  function interfaceDeclaration(id) {
    var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var _extends = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var body = arguments.length > 3 ? arguments[3] : undefined;
    var node = {
      type: "InterfaceDeclaration",
      id: id,
      typeParameters: typeParameters,
      "extends": _extends,
      body: body
    };
    var defs = NODE_FIELDS.InterfaceDeclaration;
    validate(defs.id, node, "id", id, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs["extends"], node, "extends", _extends, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function interfaceTypeAnnotation() {
    var _extends = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var body = arguments.length > 1 ? arguments[1] : undefined;
    var node = {
      type: "InterfaceTypeAnnotation",
      "extends": _extends,
      body: body
    };
    var defs = NODE_FIELDS.InterfaceTypeAnnotation;
    validate(defs["extends"], node, "extends", _extends, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function intersectionTypeAnnotation(types) {
    var node = {
      type: "IntersectionTypeAnnotation",
      types: types
    };
    var defs = NODE_FIELDS.IntersectionTypeAnnotation;
    validate(defs.types, node, "types", types, 1);
    return node;
  }
  function mixedTypeAnnotation() {
    return {
      type: "MixedTypeAnnotation"
    };
  }
  function emptyTypeAnnotation() {
    return {
      type: "EmptyTypeAnnotation"
    };
  }
  function nullableTypeAnnotation(typeAnnotation) {
    var node = {
      type: "NullableTypeAnnotation",
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.NullableTypeAnnotation;
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function numberLiteralTypeAnnotation(value) {
    var node = {
      type: "NumberLiteralTypeAnnotation",
      value: value
    };
    var defs = NODE_FIELDS.NumberLiteralTypeAnnotation;
    validate(defs.value, node, "value", value);
    return node;
  }
  function numberTypeAnnotation() {
    return {
      type: "NumberTypeAnnotation"
    };
  }
  function objectTypeAnnotation(properties) {
    var indexers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var callProperties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var internalSlots = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
    var exact = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var node = {
      type: "ObjectTypeAnnotation",
      properties: properties,
      indexers: indexers,
      callProperties: callProperties,
      internalSlots: internalSlots,
      exact: exact
    };
    var defs = NODE_FIELDS.ObjectTypeAnnotation;
    validate(defs.properties, node, "properties", properties, 1);
    validate(defs.indexers, node, "indexers", indexers, 1);
    validate(defs.callProperties, node, "callProperties", callProperties, 1);
    validate(defs.internalSlots, node, "internalSlots", internalSlots, 1);
    validate(defs.exact, node, "exact", exact);
    return node;
  }
  function objectTypeInternalSlot(id, value, optional, _static, method) {
    var node = {
      type: "ObjectTypeInternalSlot",
      id: id,
      value: value,
      optional: optional,
      "static": _static,
      method: method
    };
    var defs = NODE_FIELDS.ObjectTypeInternalSlot;
    validate(defs.id, node, "id", id, 1);
    validate(defs.value, node, "value", value, 1);
    validate(defs.optional, node, "optional", optional);
    validate(defs["static"], node, "static", _static);
    validate(defs.method, node, "method", method);
    return node;
  }
  function objectTypeCallProperty(value) {
    var node = {
      type: "ObjectTypeCallProperty",
      value: value,
      "static": null
    };
    var defs = NODE_FIELDS.ObjectTypeCallProperty;
    validate(defs.value, node, "value", value, 1);
    return node;
  }
  function objectTypeIndexer() {
    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var key = arguments.length > 1 ? arguments[1] : undefined;
    var value = arguments.length > 2 ? arguments[2] : undefined;
    var variance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var node = {
      type: "ObjectTypeIndexer",
      id: id,
      key: key,
      value: value,
      variance: variance,
      "static": null
    };
    var defs = NODE_FIELDS.ObjectTypeIndexer;
    validate(defs.id, node, "id", id, 1);
    validate(defs.key, node, "key", key, 1);
    validate(defs.value, node, "value", value, 1);
    validate(defs.variance, node, "variance", variance, 1);
    return node;
  }
  function objectTypeProperty(key, value) {
    var variance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var node = {
      type: "ObjectTypeProperty",
      key: key,
      value: value,
      variance: variance,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      "static": null
    };
    var defs = NODE_FIELDS.ObjectTypeProperty;
    validate(defs.key, node, "key", key, 1);
    validate(defs.value, node, "value", value, 1);
    validate(defs.variance, node, "variance", variance, 1);
    return node;
  }
  function objectTypeSpreadProperty(argument) {
    var node = {
      type: "ObjectTypeSpreadProperty",
      argument: argument
    };
    var defs = NODE_FIELDS.ObjectTypeSpreadProperty;
    validate(defs.argument, node, "argument", argument, 1);
    return node;
  }
  function opaqueType(id) {
    var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var supertype = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var impltype = arguments.length > 3 ? arguments[3] : undefined;
    var node = {
      type: "OpaqueType",
      id: id,
      typeParameters: typeParameters,
      supertype: supertype,
      impltype: impltype
    };
    var defs = NODE_FIELDS.OpaqueType;
    validate(defs.id, node, "id", id, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.supertype, node, "supertype", supertype, 1);
    validate(defs.impltype, node, "impltype", impltype, 1);
    return node;
  }
  function qualifiedTypeIdentifier(id, qualification) {
    var node = {
      type: "QualifiedTypeIdentifier",
      id: id,
      qualification: qualification
    };
    var defs = NODE_FIELDS.QualifiedTypeIdentifier;
    validate(defs.id, node, "id", id, 1);
    validate(defs.qualification, node, "qualification", qualification, 1);
    return node;
  }
  function stringLiteralTypeAnnotation(value) {
    var node = {
      type: "StringLiteralTypeAnnotation",
      value: value
    };
    var defs = NODE_FIELDS.StringLiteralTypeAnnotation;
    validate(defs.value, node, "value", value);
    return node;
  }
  function stringTypeAnnotation() {
    return {
      type: "StringTypeAnnotation"
    };
  }
  function symbolTypeAnnotation() {
    return {
      type: "SymbolTypeAnnotation"
    };
  }
  function thisTypeAnnotation() {
    return {
      type: "ThisTypeAnnotation"
    };
  }
  function tupleTypeAnnotation(types) {
    var node = {
      type: "TupleTypeAnnotation",
      types: types
    };
    var defs = NODE_FIELDS.TupleTypeAnnotation;
    validate(defs.types, node, "types", types, 1);
    return node;
  }
  function typeofTypeAnnotation(argument) {
    var node = {
      type: "TypeofTypeAnnotation",
      argument: argument
    };
    var defs = NODE_FIELDS.TypeofTypeAnnotation;
    validate(defs.argument, node, "argument", argument, 1);
    return node;
  }
  function typeAlias(id) {
    var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var right = arguments.length > 2 ? arguments[2] : undefined;
    var node = {
      type: "TypeAlias",
      id: id,
      typeParameters: typeParameters,
      right: right
    };
    var defs = NODE_FIELDS.TypeAlias;
    validate(defs.id, node, "id", id, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.right, node, "right", right, 1);
    return node;
  }
  function typeAnnotation(typeAnnotation) {
    var node = {
      type: "TypeAnnotation",
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TypeAnnotation;
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function typeCastExpression(expression, typeAnnotation) {
    var node = {
      type: "TypeCastExpression",
      expression: expression,
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TypeCastExpression;
    validate(defs.expression, node, "expression", expression, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function typeParameter() {
    var bound = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var _default = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var variance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var node = {
      type: "TypeParameter",
      bound: bound,
      "default": _default,
      variance: variance,
      name: null
    };
    var defs = NODE_FIELDS.TypeParameter;
    validate(defs.bound, node, "bound", bound, 1);
    validate(defs["default"], node, "default", _default, 1);
    validate(defs.variance, node, "variance", variance, 1);
    return node;
  }
  function typeParameterDeclaration(params) {
    var node = {
      type: "TypeParameterDeclaration",
      params: params
    };
    var defs = NODE_FIELDS.TypeParameterDeclaration;
    validate(defs.params, node, "params", params, 1);
    return node;
  }
  function typeParameterInstantiation(params) {
    var node = {
      type: "TypeParameterInstantiation",
      params: params
    };
    var defs = NODE_FIELDS.TypeParameterInstantiation;
    validate(defs.params, node, "params", params, 1);
    return node;
  }
  function unionTypeAnnotation(types) {
    var node = {
      type: "UnionTypeAnnotation",
      types: types
    };
    var defs = NODE_FIELDS.UnionTypeAnnotation;
    validate(defs.types, node, "types", types, 1);
    return node;
  }
  function variance(kind) {
    var node = {
      type: "Variance",
      kind: kind
    };
    var defs = NODE_FIELDS.Variance;
    validate(defs.kind, node, "kind", kind);
    return node;
  }
  function voidTypeAnnotation() {
    return {
      type: "VoidTypeAnnotation"
    };
  }
  function enumDeclaration(id, body) {
    var node = {
      type: "EnumDeclaration",
      id: id,
      body: body
    };
    var defs = NODE_FIELDS.EnumDeclaration;
    validate(defs.id, node, "id", id, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function enumBooleanBody(members) {
    var node = {
      type: "EnumBooleanBody",
      members: members,
      explicitType: null,
      hasUnknownMembers: null
    };
    var defs = NODE_FIELDS.EnumBooleanBody;
    validate(defs.members, node, "members", members, 1);
    return node;
  }
  function enumNumberBody(members) {
    var node = {
      type: "EnumNumberBody",
      members: members,
      explicitType: null,
      hasUnknownMembers: null
    };
    var defs = NODE_FIELDS.EnumNumberBody;
    validate(defs.members, node, "members", members, 1);
    return node;
  }
  function enumStringBody(members) {
    var node = {
      type: "EnumStringBody",
      members: members,
      explicitType: null,
      hasUnknownMembers: null
    };
    var defs = NODE_FIELDS.EnumStringBody;
    validate(defs.members, node, "members", members, 1);
    return node;
  }
  function enumSymbolBody(members) {
    var node = {
      type: "EnumSymbolBody",
      members: members,
      hasUnknownMembers: null
    };
    var defs = NODE_FIELDS.EnumSymbolBody;
    validate(defs.members, node, "members", members, 1);
    return node;
  }
  function enumBooleanMember(id) {
    var node = {
      type: "EnumBooleanMember",
      id: id,
      init: null
    };
    var defs = NODE_FIELDS.EnumBooleanMember;
    validate(defs.id, node, "id", id, 1);
    return node;
  }
  function enumNumberMember(id, init) {
    var node = {
      type: "EnumNumberMember",
      id: id,
      init: init
    };
    var defs = NODE_FIELDS.EnumNumberMember;
    validate(defs.id, node, "id", id, 1);
    validate(defs.init, node, "init", init, 1);
    return node;
  }
  function enumStringMember(id, init) {
    var node = {
      type: "EnumStringMember",
      id: id,
      init: init
    };
    var defs = NODE_FIELDS.EnumStringMember;
    validate(defs.id, node, "id", id, 1);
    validate(defs.init, node, "init", init, 1);
    return node;
  }
  function enumDefaultedMember(id) {
    var node = {
      type: "EnumDefaultedMember",
      id: id
    };
    var defs = NODE_FIELDS.EnumDefaultedMember;
    validate(defs.id, node, "id", id, 1);
    return node;
  }
  function indexedAccessType(objectType, indexType) {
    var node = {
      type: "IndexedAccessType",
      objectType: objectType,
      indexType: indexType
    };
    var defs = NODE_FIELDS.IndexedAccessType;
    validate(defs.objectType, node, "objectType", objectType, 1);
    validate(defs.indexType, node, "indexType", indexType, 1);
    return node;
  }
  function optionalIndexedAccessType(objectType, indexType) {
    var node = {
      type: "OptionalIndexedAccessType",
      objectType: objectType,
      indexType: indexType,
      optional: null
    };
    var defs = NODE_FIELDS.OptionalIndexedAccessType;
    validate(defs.objectType, node, "objectType", objectType, 1);
    validate(defs.indexType, node, "indexType", indexType, 1);
    return node;
  }
  function jsxAttribute(name) {
    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var node = {
      type: "JSXAttribute",
      name: name,
      value: value
    };
    var defs = NODE_FIELDS.JSXAttribute;
    validate(defs.name, node, "name", name, 1);
    validate(defs.value, node, "value", value, 1);
    return node;
  }
  function jsxClosingElement(name) {
    var node = {
      type: "JSXClosingElement",
      name: name
    };
    var defs = NODE_FIELDS.JSXClosingElement;
    validate(defs.name, node, "name", name, 1);
    return node;
  }
  function jsxElement(openingElement) {
    var closingElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var children = arguments.length > 2 ? arguments[2] : undefined;
    var selfClosing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var node = {
      type: "JSXElement",
      openingElement: openingElement,
      closingElement: closingElement,
      children: children,
      selfClosing: selfClosing
    };
    var defs = NODE_FIELDS.JSXElement;
    validate(defs.openingElement, node, "openingElement", openingElement, 1);
    validate(defs.closingElement, node, "closingElement", closingElement, 1);
    validate(defs.children, node, "children", children, 1);
    validate(defs.selfClosing, node, "selfClosing", selfClosing);
    return node;
  }
  function jsxEmptyExpression() {
    return {
      type: "JSXEmptyExpression"
    };
  }
  function jsxExpressionContainer(expression) {
    var node = {
      type: "JSXExpressionContainer",
      expression: expression
    };
    var defs = NODE_FIELDS.JSXExpressionContainer;
    validate(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function jsxSpreadChild(expression) {
    var node = {
      type: "JSXSpreadChild",
      expression: expression
    };
    var defs = NODE_FIELDS.JSXSpreadChild;
    validate(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function jsxIdentifier(name) {
    var node = {
      type: "JSXIdentifier",
      name: name
    };
    var defs = NODE_FIELDS.JSXIdentifier;
    validate(defs.name, node, "name", name);
    return node;
  }
  function jsxMemberExpression(object, property) {
    var node = {
      type: "JSXMemberExpression",
      object: object,
      property: property
    };
    var defs = NODE_FIELDS.JSXMemberExpression;
    validate(defs.object, node, "object", object, 1);
    validate(defs.property, node, "property", property, 1);
    return node;
  }
  function jsxNamespacedName(namespace, name) {
    var node = {
      type: "JSXNamespacedName",
      namespace: namespace,
      name: name
    };
    var defs = NODE_FIELDS.JSXNamespacedName;
    validate(defs.namespace, node, "namespace", namespace, 1);
    validate(defs.name, node, "name", name, 1);
    return node;
  }
  function jsxOpeningElement(name, attributes) {
    var selfClosing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var node = {
      type: "JSXOpeningElement",
      name: name,
      attributes: attributes,
      selfClosing: selfClosing
    };
    var defs = NODE_FIELDS.JSXOpeningElement;
    validate(defs.name, node, "name", name, 1);
    validate(defs.attributes, node, "attributes", attributes, 1);
    validate(defs.selfClosing, node, "selfClosing", selfClosing);
    return node;
  }
  function jsxSpreadAttribute(argument) {
    var node = {
      type: "JSXSpreadAttribute",
      argument: argument
    };
    var defs = NODE_FIELDS.JSXSpreadAttribute;
    validate(defs.argument, node, "argument", argument, 1);
    return node;
  }
  function jsxText(value) {
    var node = {
      type: "JSXText",
      value: value
    };
    var defs = NODE_FIELDS.JSXText;
    validate(defs.value, node, "value", value);
    return node;
  }
  function jsxFragment(openingFragment, closingFragment, children) {
    var node = {
      type: "JSXFragment",
      openingFragment: openingFragment,
      closingFragment: closingFragment,
      children: children
    };
    var defs = NODE_FIELDS.JSXFragment;
    validate(defs.openingFragment, node, "openingFragment", openingFragment, 1);
    validate(defs.closingFragment, node, "closingFragment", closingFragment, 1);
    validate(defs.children, node, "children", children, 1);
    return node;
  }
  function jsxOpeningFragment() {
    return {
      type: "JSXOpeningFragment"
    };
  }
  function jsxClosingFragment() {
    return {
      type: "JSXClosingFragment"
    };
  }
  function noop() {
    return {
      type: "Noop"
    };
  }
  function placeholder(expectedNode, name) {
    var node = {
      type: "Placeholder",
      expectedNode: expectedNode,
      name: name
    };
    var defs = NODE_FIELDS.Placeholder;
    validate(defs.expectedNode, node, "expectedNode", expectedNode);
    validate(defs.name, node, "name", name, 1);
    return node;
  }
  function v8IntrinsicIdentifier(name) {
    var node = {
      type: "V8IntrinsicIdentifier",
      name: name
    };
    var defs = NODE_FIELDS.V8IntrinsicIdentifier;
    validate(defs.name, node, "name", name);
    return node;
  }
  function argumentPlaceholder() {
    return {
      type: "ArgumentPlaceholder"
    };
  }
  function bindExpression(object, callee) {
    var node = {
      type: "BindExpression",
      object: object,
      callee: callee
    };
    var defs = NODE_FIELDS.BindExpression;
    validate(defs.object, node, "object", object, 1);
    validate(defs.callee, node, "callee", callee, 1);
    return node;
  }
  function importAttribute(key, value) {
    var node = {
      type: "ImportAttribute",
      key: key,
      value: value
    };
    var defs = NODE_FIELDS.ImportAttribute;
    validate(defs.key, node, "key", key, 1);
    validate(defs.value, node, "value", value, 1);
    return node;
  }
  function decorator(expression) {
    var node = {
      type: "Decorator",
      expression: expression
    };
    var defs = NODE_FIELDS.Decorator;
    validate(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function doExpression(body) {
    var async = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var node = {
      type: "DoExpression",
      body: body,
      async: async
    };
    var defs = NODE_FIELDS.DoExpression;
    validate(defs.body, node, "body", body, 1);
    validate(defs.async, node, "async", async);
    return node;
  }
  function exportDefaultSpecifier(exported) {
    var node = {
      type: "ExportDefaultSpecifier",
      exported: exported
    };
    var defs = NODE_FIELDS.ExportDefaultSpecifier;
    validate(defs.exported, node, "exported", exported, 1);
    return node;
  }
  function recordExpression(properties) {
    var node = {
      type: "RecordExpression",
      properties: properties
    };
    var defs = NODE_FIELDS.RecordExpression;
    validate(defs.properties, node, "properties", properties, 1);
    return node;
  }
  function tupleExpression() {
    var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var node = {
      type: "TupleExpression",
      elements: elements
    };
    var defs = NODE_FIELDS.TupleExpression;
    validate(defs.elements, node, "elements", elements, 1);
    return node;
  }
  function decimalLiteral(value) {
    var node = {
      type: "DecimalLiteral",
      value: value
    };
    var defs = NODE_FIELDS.DecimalLiteral;
    validate(defs.value, node, "value", value);
    return node;
  }
  function moduleExpression(body) {
    var node = {
      type: "ModuleExpression",
      body: body
    };
    var defs = NODE_FIELDS.ModuleExpression;
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function topicReference() {
    return {
      type: "TopicReference"
    };
  }
  function pipelineTopicExpression(expression) {
    var node = {
      type: "PipelineTopicExpression",
      expression: expression
    };
    var defs = NODE_FIELDS.PipelineTopicExpression;
    validate(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function pipelineBareFunction(callee) {
    var node = {
      type: "PipelineBareFunction",
      callee: callee
    };
    var defs = NODE_FIELDS.PipelineBareFunction;
    validate(defs.callee, node, "callee", callee, 1);
    return node;
  }
  function pipelinePrimaryTopicReference() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  }
  function tsParameterProperty(parameter) {
    var node = {
      type: "TSParameterProperty",
      parameter: parameter
    };
    var defs = NODE_FIELDS.TSParameterProperty;
    validate(defs.parameter, node, "parameter", parameter, 1);
    return node;
  }
  function tsDeclareFunction() {
    var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var params = arguments.length > 2 ? arguments[2] : undefined;
    var returnType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var node = {
      type: "TSDeclareFunction",
      id: id,
      typeParameters: typeParameters,
      params: params,
      returnType: returnType
    };
    var defs = NODE_FIELDS.TSDeclareFunction;
    validate(defs.id, node, "id", id, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.params, node, "params", params, 1);
    validate(defs.returnType, node, "returnType", returnType, 1);
    return node;
  }
  function tsDeclareMethod() {
    var decorators = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var key = arguments.length > 1 ? arguments[1] : undefined;
    var typeParameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var params = arguments.length > 3 ? arguments[3] : undefined;
    var returnType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var node = {
      type: "TSDeclareMethod",
      decorators: decorators,
      key: key,
      typeParameters: typeParameters,
      params: params,
      returnType: returnType
    };
    var defs = NODE_FIELDS.TSDeclareMethod;
    validate(defs.decorators, node, "decorators", decorators, 1);
    validate(defs.key, node, "key", key, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.params, node, "params", params, 1);
    validate(defs.returnType, node, "returnType", returnType, 1);
    return node;
  }
  function tsQualifiedName(left, right) {
    var node = {
      type: "TSQualifiedName",
      left: left,
      right: right
    };
    var defs = NODE_FIELDS.TSQualifiedName;
    validate(defs.left, node, "left", left, 1);
    validate(defs.right, node, "right", right, 1);
    return node;
  }
  function tsCallSignatureDeclaration() {
    var typeParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var parameters = arguments.length > 1 ? arguments[1] : undefined;
    var typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var node = {
      type: "TSCallSignatureDeclaration",
      typeParameters: typeParameters,
      parameters: parameters,
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TSCallSignatureDeclaration;
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.parameters, node, "parameters", parameters, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsConstructSignatureDeclaration() {
    var typeParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var parameters = arguments.length > 1 ? arguments[1] : undefined;
    var typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var node = {
      type: "TSConstructSignatureDeclaration",
      typeParameters: typeParameters,
      parameters: parameters,
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TSConstructSignatureDeclaration;
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.parameters, node, "parameters", parameters, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsPropertySignature(key) {
    var typeAnnotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var node = {
      type: "TSPropertySignature",
      key: key,
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TSPropertySignature;
    validate(defs.key, node, "key", key, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsMethodSignature(key) {
    var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var parameters = arguments.length > 2 ? arguments[2] : undefined;
    var typeAnnotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var node = {
      type: "TSMethodSignature",
      key: key,
      typeParameters: typeParameters,
      parameters: parameters,
      typeAnnotation: typeAnnotation,
      kind: null
    };
    var defs = NODE_FIELDS.TSMethodSignature;
    validate(defs.key, node, "key", key, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.parameters, node, "parameters", parameters, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsIndexSignature(parameters) {
    var typeAnnotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var node = {
      type: "TSIndexSignature",
      parameters: parameters,
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TSIndexSignature;
    validate(defs.parameters, node, "parameters", parameters, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsAnyKeyword() {
    return {
      type: "TSAnyKeyword"
    };
  }
  function tsBooleanKeyword() {
    return {
      type: "TSBooleanKeyword"
    };
  }
  function tsBigIntKeyword() {
    return {
      type: "TSBigIntKeyword"
    };
  }
  function tsIntrinsicKeyword() {
    return {
      type: "TSIntrinsicKeyword"
    };
  }
  function tsNeverKeyword() {
    return {
      type: "TSNeverKeyword"
    };
  }
  function tsNullKeyword() {
    return {
      type: "TSNullKeyword"
    };
  }
  function tsNumberKeyword() {
    return {
      type: "TSNumberKeyword"
    };
  }
  function tsObjectKeyword() {
    return {
      type: "TSObjectKeyword"
    };
  }
  function tsStringKeyword() {
    return {
      type: "TSStringKeyword"
    };
  }
  function tsSymbolKeyword() {
    return {
      type: "TSSymbolKeyword"
    };
  }
  function tsUndefinedKeyword() {
    return {
      type: "TSUndefinedKeyword"
    };
  }
  function tsUnknownKeyword() {
    return {
      type: "TSUnknownKeyword"
    };
  }
  function tsVoidKeyword() {
    return {
      type: "TSVoidKeyword"
    };
  }
  function tsThisType() {
    return {
      type: "TSThisType"
    };
  }
  function tsFunctionType() {
    var typeParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var parameters = arguments.length > 1 ? arguments[1] : undefined;
    var typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var node = {
      type: "TSFunctionType",
      typeParameters: typeParameters,
      parameters: parameters,
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TSFunctionType;
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.parameters, node, "parameters", parameters, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsConstructorType() {
    var typeParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var parameters = arguments.length > 1 ? arguments[1] : undefined;
    var typeAnnotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var node = {
      type: "TSConstructorType",
      typeParameters: typeParameters,
      parameters: parameters,
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TSConstructorType;
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.parameters, node, "parameters", parameters, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsTypeReference(typeName) {
    var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var node = {
      type: "TSTypeReference",
      typeName: typeName,
      typeParameters: typeParameters
    };
    var defs = NODE_FIELDS.TSTypeReference;
    validate(defs.typeName, node, "typeName", typeName, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    return node;
  }
  function tsTypePredicate(parameterName) {
    var typeAnnotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var asserts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var node = {
      type: "TSTypePredicate",
      parameterName: parameterName,
      typeAnnotation: typeAnnotation,
      asserts: asserts
    };
    var defs = NODE_FIELDS.TSTypePredicate;
    validate(defs.parameterName, node, "parameterName", parameterName, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    validate(defs.asserts, node, "asserts", asserts);
    return node;
  }
  function tsTypeQuery(exprName) {
    var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var node = {
      type: "TSTypeQuery",
      exprName: exprName,
      typeParameters: typeParameters
    };
    var defs = NODE_FIELDS.TSTypeQuery;
    validate(defs.exprName, node, "exprName", exprName, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    return node;
  }
  function tsTypeLiteral(members) {
    var node = {
      type: "TSTypeLiteral",
      members: members
    };
    var defs = NODE_FIELDS.TSTypeLiteral;
    validate(defs.members, node, "members", members, 1);
    return node;
  }
  function tsArrayType(elementType) {
    var node = {
      type: "TSArrayType",
      elementType: elementType
    };
    var defs = NODE_FIELDS.TSArrayType;
    validate(defs.elementType, node, "elementType", elementType, 1);
    return node;
  }
  function tsTupleType(elementTypes) {
    var node = {
      type: "TSTupleType",
      elementTypes: elementTypes
    };
    var defs = NODE_FIELDS.TSTupleType;
    validate(defs.elementTypes, node, "elementTypes", elementTypes, 1);
    return node;
  }
  function tsOptionalType(typeAnnotation) {
    var node = {
      type: "TSOptionalType",
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TSOptionalType;
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsRestType(typeAnnotation) {
    var node = {
      type: "TSRestType",
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TSRestType;
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsNamedTupleMember(label, elementType) {
    var optional = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var node = {
      type: "TSNamedTupleMember",
      label: label,
      elementType: elementType,
      optional: optional
    };
    var defs = NODE_FIELDS.TSNamedTupleMember;
    validate(defs.label, node, "label", label, 1);
    validate(defs.elementType, node, "elementType", elementType, 1);
    validate(defs.optional, node, "optional", optional);
    return node;
  }
  function tsUnionType(types) {
    var node = {
      type: "TSUnionType",
      types: types
    };
    var defs = NODE_FIELDS.TSUnionType;
    validate(defs.types, node, "types", types, 1);
    return node;
  }
  function tsIntersectionType(types) {
    var node = {
      type: "TSIntersectionType",
      types: types
    };
    var defs = NODE_FIELDS.TSIntersectionType;
    validate(defs.types, node, "types", types, 1);
    return node;
  }
  function tsConditionalType(checkType, extendsType, trueType, falseType) {
    var node = {
      type: "TSConditionalType",
      checkType: checkType,
      extendsType: extendsType,
      trueType: trueType,
      falseType: falseType
    };
    var defs = NODE_FIELDS.TSConditionalType;
    validate(defs.checkType, node, "checkType", checkType, 1);
    validate(defs.extendsType, node, "extendsType", extendsType, 1);
    validate(defs.trueType, node, "trueType", trueType, 1);
    validate(defs.falseType, node, "falseType", falseType, 1);
    return node;
  }
  function tsInferType(typeParameter) {
    var node = {
      type: "TSInferType",
      typeParameter: typeParameter
    };
    var defs = NODE_FIELDS.TSInferType;
    validate(defs.typeParameter, node, "typeParameter", typeParameter, 1);
    return node;
  }
  function tsParenthesizedType(typeAnnotation) {
    var node = {
      type: "TSParenthesizedType",
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TSParenthesizedType;
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsTypeOperator(typeAnnotation) {
    var node = {
      type: "TSTypeOperator",
      typeAnnotation: typeAnnotation,
      operator: null
    };
    var defs = NODE_FIELDS.TSTypeOperator;
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsIndexedAccessType(objectType, indexType) {
    var node = {
      type: "TSIndexedAccessType",
      objectType: objectType,
      indexType: indexType
    };
    var defs = NODE_FIELDS.TSIndexedAccessType;
    validate(defs.objectType, node, "objectType", objectType, 1);
    validate(defs.indexType, node, "indexType", indexType, 1);
    return node;
  }
  function tsMappedType(typeParameter) {
    var typeAnnotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var nameType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var node = {
      type: "TSMappedType",
      typeParameter: typeParameter,
      typeAnnotation: typeAnnotation,
      nameType: nameType
    };
    var defs = NODE_FIELDS.TSMappedType;
    validate(defs.typeParameter, node, "typeParameter", typeParameter, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    validate(defs.nameType, node, "nameType", nameType, 1);
    return node;
  }
  function tsTemplateLiteralType(quasis, types) {
    var node = {
      type: "TSTemplateLiteralType",
      quasis: quasis,
      types: types
    };
    var defs = NODE_FIELDS.TSTemplateLiteralType;
    validate(defs.quasis, node, "quasis", quasis, 1);
    validate(defs.types, node, "types", types, 1);
    return node;
  }
  function tsLiteralType(literal) {
    var node = {
      type: "TSLiteralType",
      literal: literal
    };
    var defs = NODE_FIELDS.TSLiteralType;
    validate(defs.literal, node, "literal", literal, 1);
    return node;
  }
  function tsExpressionWithTypeArguments(expression) {
    var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var node = {
      type: "TSExpressionWithTypeArguments",
      expression: expression,
      typeParameters: typeParameters
    };
    var defs = NODE_FIELDS.TSExpressionWithTypeArguments;
    validate(defs.expression, node, "expression", expression, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    return node;
  }
  function tsInterfaceDeclaration(id) {
    var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var _extends = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var body = arguments.length > 3 ? arguments[3] : undefined;
    var node = {
      type: "TSInterfaceDeclaration",
      id: id,
      typeParameters: typeParameters,
      "extends": _extends,
      body: body
    };
    var defs = NODE_FIELDS.TSInterfaceDeclaration;
    validate(defs.id, node, "id", id, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs["extends"], node, "extends", _extends, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function tsInterfaceBody(body) {
    var node = {
      type: "TSInterfaceBody",
      body: body
    };
    var defs = NODE_FIELDS.TSInterfaceBody;
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function tsTypeAliasDeclaration(id) {
    var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var typeAnnotation = arguments.length > 2 ? arguments[2] : undefined;
    var node = {
      type: "TSTypeAliasDeclaration",
      id: id,
      typeParameters: typeParameters,
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TSTypeAliasDeclaration;
    validate(defs.id, node, "id", id, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsInstantiationExpression(expression) {
    var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var node = {
      type: "TSInstantiationExpression",
      expression: expression,
      typeParameters: typeParameters
    };
    var defs = NODE_FIELDS.TSInstantiationExpression;
    validate(defs.expression, node, "expression", expression, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    return node;
  }
  function tsAsExpression(expression, typeAnnotation) {
    var node = {
      type: "TSAsExpression",
      expression: expression,
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TSAsExpression;
    validate(defs.expression, node, "expression", expression, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsSatisfiesExpression(expression, typeAnnotation) {
    var node = {
      type: "TSSatisfiesExpression",
      expression: expression,
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TSSatisfiesExpression;
    validate(defs.expression, node, "expression", expression, 1);
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsTypeAssertion(typeAnnotation, expression) {
    var node = {
      type: "TSTypeAssertion",
      typeAnnotation: typeAnnotation,
      expression: expression
    };
    var defs = NODE_FIELDS.TSTypeAssertion;
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    validate(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function tsEnumBody(members) {
    var node = {
      type: "TSEnumBody",
      members: members
    };
    var defs = NODE_FIELDS.TSEnumBody;
    validate(defs.members, node, "members", members, 1);
    return node;
  }
  function tsEnumDeclaration(id, members) {
    var node = {
      type: "TSEnumDeclaration",
      id: id,
      members: members
    };
    var defs = NODE_FIELDS.TSEnumDeclaration;
    validate(defs.id, node, "id", id, 1);
    validate(defs.members, node, "members", members, 1);
    return node;
  }
  function tsEnumMember(id) {
    var initializer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var node = {
      type: "TSEnumMember",
      id: id,
      initializer: initializer
    };
    var defs = NODE_FIELDS.TSEnumMember;
    validate(defs.id, node, "id", id, 1);
    validate(defs.initializer, node, "initializer", initializer, 1);
    return node;
  }
  function tsModuleDeclaration(id, body) {
    var node = {
      type: "TSModuleDeclaration",
      id: id,
      body: body,
      kind: null
    };
    var defs = NODE_FIELDS.TSModuleDeclaration;
    validate(defs.id, node, "id", id, 1);
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function tsModuleBlock(body) {
    var node = {
      type: "TSModuleBlock",
      body: body
    };
    var defs = NODE_FIELDS.TSModuleBlock;
    validate(defs.body, node, "body", body, 1);
    return node;
  }
  function tsImportType(argument) {
    var qualifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var typeParameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var node = {
      type: "TSImportType",
      argument: argument,
      qualifier: qualifier,
      typeParameters: typeParameters
    };
    var defs = NODE_FIELDS.TSImportType;
    validate(defs.argument, node, "argument", argument, 1);
    validate(defs.qualifier, node, "qualifier", qualifier, 1);
    validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);
    return node;
  }
  function tsImportEqualsDeclaration(id, moduleReference) {
    var node = {
      type: "TSImportEqualsDeclaration",
      id: id,
      moduleReference: moduleReference,
      isExport: null
    };
    var defs = NODE_FIELDS.TSImportEqualsDeclaration;
    validate(defs.id, node, "id", id, 1);
    validate(defs.moduleReference, node, "moduleReference", moduleReference, 1);
    return node;
  }
  function tsExternalModuleReference(expression) {
    var node = {
      type: "TSExternalModuleReference",
      expression: expression
    };
    var defs = NODE_FIELDS.TSExternalModuleReference;
    validate(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function tsNonNullExpression(expression) {
    var node = {
      type: "TSNonNullExpression",
      expression: expression
    };
    var defs = NODE_FIELDS.TSNonNullExpression;
    validate(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function tsExportAssignment(expression) {
    var node = {
      type: "TSExportAssignment",
      expression: expression
    };
    var defs = NODE_FIELDS.TSExportAssignment;
    validate(defs.expression, node, "expression", expression, 1);
    return node;
  }
  function tsNamespaceExportDeclaration(id) {
    var node = {
      type: "TSNamespaceExportDeclaration",
      id: id
    };
    var defs = NODE_FIELDS.TSNamespaceExportDeclaration;
    validate(defs.id, node, "id", id, 1);
    return node;
  }
  function tsTypeAnnotation(typeAnnotation) {
    var node = {
      type: "TSTypeAnnotation",
      typeAnnotation: typeAnnotation
    };
    var defs = NODE_FIELDS.TSTypeAnnotation;
    validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);
    return node;
  }
  function tsTypeParameterInstantiation(params) {
    var node = {
      type: "TSTypeParameterInstantiation",
      params: params
    };
    var defs = NODE_FIELDS.TSTypeParameterInstantiation;
    validate(defs.params, node, "params", params, 1);
    return node;
  }
  function tsTypeParameterDeclaration(params) {
    var node = {
      type: "TSTypeParameterDeclaration",
      params: params
    };
    var defs = NODE_FIELDS.TSTypeParameterDeclaration;
    validate(defs.params, node, "params", params, 1);
    return node;
  }
  function tsTypeParameter() {
    var constraint = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var _default = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var name = arguments.length > 2 ? arguments[2] : undefined;
    var node = {
      type: "TSTypeParameter",
      constraint: constraint,
      "default": _default,
      name: name
    };
    var defs = NODE_FIELDS.TSTypeParameter;
    validate(defs.constraint, node, "constraint", constraint, 1);
    validate(defs["default"], node, "default", _default, 1);
    validate(defs.name, node, "name", name);
    return node;
  }
  function NumberLiteral(value) {
    (0, _deprecationWarning["default"])("NumberLiteral", "NumericLiteral", "The node type ");
    return numericLiteral(value);
  }
  function RegexLiteral(pattern) {
    var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    (0, _deprecationWarning["default"])("RegexLiteral", "RegExpLiteral", "The node type ");
    return regExpLiteral(pattern, flags);
  }
  function RestProperty(argument) {
    (0, _deprecationWarning["default"])("RestProperty", "RestElement", "The node type ");
    return restElement(argument);
  }
  function SpreadProperty(argument) {
    (0, _deprecationWarning["default"])("SpreadProperty", "SpreadElement", "The node type ");
    return spreadElement(argument);
  }
  return lowercase;
}

var uppercase = {};

var hasRequiredUppercase;
function requireUppercase() {
  if (hasRequiredUppercase) return uppercase;
  hasRequiredUppercase = 1;
  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "AnyTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _lowercase.anyTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ArgumentPlaceholder", {
      enumerable: true,
      get: function get() {
        return _lowercase.argumentPlaceholder;
      }
    });
    Object.defineProperty(exports, "ArrayExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.arrayExpression;
      }
    });
    Object.defineProperty(exports, "ArrayPattern", {
      enumerable: true,
      get: function get() {
        return _lowercase.arrayPattern;
      }
    });
    Object.defineProperty(exports, "ArrayTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _lowercase.arrayTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ArrowFunctionExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.arrowFunctionExpression;
      }
    });
    Object.defineProperty(exports, "AssignmentExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.assignmentExpression;
      }
    });
    Object.defineProperty(exports, "AssignmentPattern", {
      enumerable: true,
      get: function get() {
        return _lowercase.assignmentPattern;
      }
    });
    Object.defineProperty(exports, "AwaitExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.awaitExpression;
      }
    });
    Object.defineProperty(exports, "BigIntLiteral", {
      enumerable: true,
      get: function get() {
        return _lowercase.bigIntLiteral;
      }
    });
    Object.defineProperty(exports, "BinaryExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.binaryExpression;
      }
    });
    Object.defineProperty(exports, "BindExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.bindExpression;
      }
    });
    Object.defineProperty(exports, "BlockStatement", {
      enumerable: true,
      get: function get() {
        return _lowercase.blockStatement;
      }
    });
    Object.defineProperty(exports, "BooleanLiteral", {
      enumerable: true,
      get: function get() {
        return _lowercase.booleanLiteral;
      }
    });
    Object.defineProperty(exports, "BooleanLiteralTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _lowercase.booleanLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "BooleanTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _lowercase.booleanTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "BreakStatement", {
      enumerable: true,
      get: function get() {
        return _lowercase.breakStatement;
      }
    });
    Object.defineProperty(exports, "CallExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.callExpression;
      }
    });
    Object.defineProperty(exports, "CatchClause", {
      enumerable: true,
      get: function get() {
        return _lowercase.catchClause;
      }
    });
    Object.defineProperty(exports, "ClassAccessorProperty", {
      enumerable: true,
      get: function get() {
        return _lowercase.classAccessorProperty;
      }
    });
    Object.defineProperty(exports, "ClassBody", {
      enumerable: true,
      get: function get() {
        return _lowercase.classBody;
      }
    });
    Object.defineProperty(exports, "ClassDeclaration", {
      enumerable: true,
      get: function get() {
        return _lowercase.classDeclaration;
      }
    });
    Object.defineProperty(exports, "ClassExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.classExpression;
      }
    });
    Object.defineProperty(exports, "ClassImplements", {
      enumerable: true,
      get: function get() {
        return _lowercase.classImplements;
      }
    });
    Object.defineProperty(exports, "ClassMethod", {
      enumerable: true,
      get: function get() {
        return _lowercase.classMethod;
      }
    });
    Object.defineProperty(exports, "ClassPrivateMethod", {
      enumerable: true,
      get: function get() {
        return _lowercase.classPrivateMethod;
      }
    });
    Object.defineProperty(exports, "ClassPrivateProperty", {
      enumerable: true,
      get: function get() {
        return _lowercase.classPrivateProperty;
      }
    });
    Object.defineProperty(exports, "ClassProperty", {
      enumerable: true,
      get: function get() {
        return _lowercase.classProperty;
      }
    });
    Object.defineProperty(exports, "ConditionalExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.conditionalExpression;
      }
    });
    Object.defineProperty(exports, "ContinueStatement", {
      enumerable: true,
      get: function get() {
        return _lowercase.continueStatement;
      }
    });
    Object.defineProperty(exports, "DebuggerStatement", {
      enumerable: true,
      get: function get() {
        return _lowercase.debuggerStatement;
      }
    });
    Object.defineProperty(exports, "DecimalLiteral", {
      enumerable: true,
      get: function get() {
        return _lowercase.decimalLiteral;
      }
    });
    Object.defineProperty(exports, "DeclareClass", {
      enumerable: true,
      get: function get() {
        return _lowercase.declareClass;
      }
    });
    Object.defineProperty(exports, "DeclareExportAllDeclaration", {
      enumerable: true,
      get: function get() {
        return _lowercase.declareExportAllDeclaration;
      }
    });
    Object.defineProperty(exports, "DeclareExportDeclaration", {
      enumerable: true,
      get: function get() {
        return _lowercase.declareExportDeclaration;
      }
    });
    Object.defineProperty(exports, "DeclareFunction", {
      enumerable: true,
      get: function get() {
        return _lowercase.declareFunction;
      }
    });
    Object.defineProperty(exports, "DeclareInterface", {
      enumerable: true,
      get: function get() {
        return _lowercase.declareInterface;
      }
    });
    Object.defineProperty(exports, "DeclareModule", {
      enumerable: true,
      get: function get() {
        return _lowercase.declareModule;
      }
    });
    Object.defineProperty(exports, "DeclareModuleExports", {
      enumerable: true,
      get: function get() {
        return _lowercase.declareModuleExports;
      }
    });
    Object.defineProperty(exports, "DeclareOpaqueType", {
      enumerable: true,
      get: function get() {
        return _lowercase.declareOpaqueType;
      }
    });
    Object.defineProperty(exports, "DeclareTypeAlias", {
      enumerable: true,
      get: function get() {
        return _lowercase.declareTypeAlias;
      }
    });
    Object.defineProperty(exports, "DeclareVariable", {
      enumerable: true,
      get: function get() {
        return _lowercase.declareVariable;
      }
    });
    Object.defineProperty(exports, "DeclaredPredicate", {
      enumerable: true,
      get: function get() {
        return _lowercase.declaredPredicate;
      }
    });
    Object.defineProperty(exports, "Decorator", {
      enumerable: true,
      get: function get() {
        return _lowercase.decorator;
      }
    });
    Object.defineProperty(exports, "Directive", {
      enumerable: true,
      get: function get() {
        return _lowercase.directive;
      }
    });
    Object.defineProperty(exports, "DirectiveLiteral", {
      enumerable: true,
      get: function get() {
        return _lowercase.directiveLiteral;
      }
    });
    Object.defineProperty(exports, "DoExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.doExpression;
      }
    });
    Object.defineProperty(exports, "DoWhileStatement", {
      enumerable: true,
      get: function get() {
        return _lowercase.doWhileStatement;
      }
    });
    Object.defineProperty(exports, "EmptyStatement", {
      enumerable: true,
      get: function get() {
        return _lowercase.emptyStatement;
      }
    });
    Object.defineProperty(exports, "EmptyTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _lowercase.emptyTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "EnumBooleanBody", {
      enumerable: true,
      get: function get() {
        return _lowercase.enumBooleanBody;
      }
    });
    Object.defineProperty(exports, "EnumBooleanMember", {
      enumerable: true,
      get: function get() {
        return _lowercase.enumBooleanMember;
      }
    });
    Object.defineProperty(exports, "EnumDeclaration", {
      enumerable: true,
      get: function get() {
        return _lowercase.enumDeclaration;
      }
    });
    Object.defineProperty(exports, "EnumDefaultedMember", {
      enumerable: true,
      get: function get() {
        return _lowercase.enumDefaultedMember;
      }
    });
    Object.defineProperty(exports, "EnumNumberBody", {
      enumerable: true,
      get: function get() {
        return _lowercase.enumNumberBody;
      }
    });
    Object.defineProperty(exports, "EnumNumberMember", {
      enumerable: true,
      get: function get() {
        return _lowercase.enumNumberMember;
      }
    });
    Object.defineProperty(exports, "EnumStringBody", {
      enumerable: true,
      get: function get() {
        return _lowercase.enumStringBody;
      }
    });
    Object.defineProperty(exports, "EnumStringMember", {
      enumerable: true,
      get: function get() {
        return _lowercase.enumStringMember;
      }
    });
    Object.defineProperty(exports, "EnumSymbolBody", {
      enumerable: true,
      get: function get() {
        return _lowercase.enumSymbolBody;
      }
    });
    Object.defineProperty(exports, "ExistsTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _lowercase.existsTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ExportAllDeclaration", {
      enumerable: true,
      get: function get() {
        return _lowercase.exportAllDeclaration;
      }
    });
    Object.defineProperty(exports, "ExportDefaultDeclaration", {
      enumerable: true,
      get: function get() {
        return _lowercase.exportDefaultDeclaration;
      }
    });
    Object.defineProperty(exports, "ExportDefaultSpecifier", {
      enumerable: true,
      get: function get() {
        return _lowercase.exportDefaultSpecifier;
      }
    });
    Object.defineProperty(exports, "ExportNamedDeclaration", {
      enumerable: true,
      get: function get() {
        return _lowercase.exportNamedDeclaration;
      }
    });
    Object.defineProperty(exports, "ExportNamespaceSpecifier", {
      enumerable: true,
      get: function get() {
        return _lowercase.exportNamespaceSpecifier;
      }
    });
    Object.defineProperty(exports, "ExportSpecifier", {
      enumerable: true,
      get: function get() {
        return _lowercase.exportSpecifier;
      }
    });
    Object.defineProperty(exports, "ExpressionStatement", {
      enumerable: true,
      get: function get() {
        return _lowercase.expressionStatement;
      }
    });
    Object.defineProperty(exports, "File", {
      enumerable: true,
      get: function get() {
        return _lowercase.file;
      }
    });
    Object.defineProperty(exports, "ForInStatement", {
      enumerable: true,
      get: function get() {
        return _lowercase.forInStatement;
      }
    });
    Object.defineProperty(exports, "ForOfStatement", {
      enumerable: true,
      get: function get() {
        return _lowercase.forOfStatement;
      }
    });
    Object.defineProperty(exports, "ForStatement", {
      enumerable: true,
      get: function get() {
        return _lowercase.forStatement;
      }
    });
    Object.defineProperty(exports, "FunctionDeclaration", {
      enumerable: true,
      get: function get() {
        return _lowercase.functionDeclaration;
      }
    });
    Object.defineProperty(exports, "FunctionExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.functionExpression;
      }
    });
    Object.defineProperty(exports, "FunctionTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _lowercase.functionTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "FunctionTypeParam", {
      enumerable: true,
      get: function get() {
        return _lowercase.functionTypeParam;
      }
    });
    Object.defineProperty(exports, "GenericTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _lowercase.genericTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "Identifier", {
      enumerable: true,
      get: function get() {
        return _lowercase.identifier;
      }
    });
    Object.defineProperty(exports, "IfStatement", {
      enumerable: true,
      get: function get() {
        return _lowercase.ifStatement;
      }
    });
    Object.defineProperty(exports, "Import", {
      enumerable: true,
      get: function get() {
        return _lowercase["import"];
      }
    });
    Object.defineProperty(exports, "ImportAttribute", {
      enumerable: true,
      get: function get() {
        return _lowercase.importAttribute;
      }
    });
    Object.defineProperty(exports, "ImportDeclaration", {
      enumerable: true,
      get: function get() {
        return _lowercase.importDeclaration;
      }
    });
    Object.defineProperty(exports, "ImportDefaultSpecifier", {
      enumerable: true,
      get: function get() {
        return _lowercase.importDefaultSpecifier;
      }
    });
    Object.defineProperty(exports, "ImportExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.importExpression;
      }
    });
    Object.defineProperty(exports, "ImportNamespaceSpecifier", {
      enumerable: true,
      get: function get() {
        return _lowercase.importNamespaceSpecifier;
      }
    });
    Object.defineProperty(exports, "ImportSpecifier", {
      enumerable: true,
      get: function get() {
        return _lowercase.importSpecifier;
      }
    });
    Object.defineProperty(exports, "IndexedAccessType", {
      enumerable: true,
      get: function get() {
        return _lowercase.indexedAccessType;
      }
    });
    Object.defineProperty(exports, "InferredPredicate", {
      enumerable: true,
      get: function get() {
        return _lowercase.inferredPredicate;
      }
    });
    Object.defineProperty(exports, "InterfaceDeclaration", {
      enumerable: true,
      get: function get() {
        return _lowercase.interfaceDeclaration;
      }
    });
    Object.defineProperty(exports, "InterfaceExtends", {
      enumerable: true,
      get: function get() {
        return _lowercase.interfaceExtends;
      }
    });
    Object.defineProperty(exports, "InterfaceTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _lowercase.interfaceTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "InterpreterDirective", {
      enumerable: true,
      get: function get() {
        return _lowercase.interpreterDirective;
      }
    });
    Object.defineProperty(exports, "IntersectionTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _lowercase.intersectionTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "JSXAttribute", {
      enumerable: true,
      get: function get() {
        return _lowercase.jsxAttribute;
      }
    });
    Object.defineProperty(exports, "JSXClosingElement", {
      enumerable: true,
      get: function get() {
        return _lowercase.jsxClosingElement;
      }
    });
    Object.defineProperty(exports, "JSXClosingFragment", {
      enumerable: true,
      get: function get() {
        return _lowercase.jsxClosingFragment;
      }
    });
    Object.defineProperty(exports, "JSXElement", {
      enumerable: true,
      get: function get() {
        return _lowercase.jsxElement;
      }
    });
    Object.defineProperty(exports, "JSXEmptyExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.jsxEmptyExpression;
      }
    });
    Object.defineProperty(exports, "JSXExpressionContainer", {
      enumerable: true,
      get: function get() {
        return _lowercase.jsxExpressionContainer;
      }
    });
    Object.defineProperty(exports, "JSXFragment", {
      enumerable: true,
      get: function get() {
        return _lowercase.jsxFragment;
      }
    });
    Object.defineProperty(exports, "JSXIdentifier", {
      enumerable: true,
      get: function get() {
        return _lowercase.jsxIdentifier;
      }
    });
    Object.defineProperty(exports, "JSXMemberExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.jsxMemberExpression;
      }
    });
    Object.defineProperty(exports, "JSXNamespacedName", {
      enumerable: true,
      get: function get() {
        return _lowercase.jsxNamespacedName;
      }
    });
    Object.defineProperty(exports, "JSXOpeningElement", {
      enumerable: true,
      get: function get() {
        return _lowercase.jsxOpeningElement;
      }
    });
    Object.defineProperty(exports, "JSXOpeningFragment", {
      enumerable: true,
      get: function get() {
        return _lowercase.jsxOpeningFragment;
      }
    });
    Object.defineProperty(exports, "JSXSpreadAttribute", {
      enumerable: true,
      get: function get() {
        return _lowercase.jsxSpreadAttribute;
      }
    });
    Object.defineProperty(exports, "JSXSpreadChild", {
      enumerable: true,
      get: function get() {
        return _lowercase.jsxSpreadChild;
      }
    });
    Object.defineProperty(exports, "JSXText", {
      enumerable: true,
      get: function get() {
        return _lowercase.jsxText;
      }
    });
    Object.defineProperty(exports, "LabeledStatement", {
      enumerable: true,
      get: function get() {
        return _lowercase.labeledStatement;
      }
    });
    Object.defineProperty(exports, "LogicalExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.logicalExpression;
      }
    });
    Object.defineProperty(exports, "MemberExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.memberExpression;
      }
    });
    Object.defineProperty(exports, "MetaProperty", {
      enumerable: true,
      get: function get() {
        return _lowercase.metaProperty;
      }
    });
    Object.defineProperty(exports, "MixedTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _lowercase.mixedTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ModuleExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.moduleExpression;
      }
    });
    Object.defineProperty(exports, "NewExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.newExpression;
      }
    });
    Object.defineProperty(exports, "Noop", {
      enumerable: true,
      get: function get() {
        return _lowercase.noop;
      }
    });
    Object.defineProperty(exports, "NullLiteral", {
      enumerable: true,
      get: function get() {
        return _lowercase.nullLiteral;
      }
    });
    Object.defineProperty(exports, "NullLiteralTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _lowercase.nullLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "NullableTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _lowercase.nullableTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "NumberLiteral", {
      enumerable: true,
      get: function get() {
        return _lowercase.numberLiteral;
      }
    });
    Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _lowercase.numberLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "NumberTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _lowercase.numberTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "NumericLiteral", {
      enumerable: true,
      get: function get() {
        return _lowercase.numericLiteral;
      }
    });
    Object.defineProperty(exports, "ObjectExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.objectExpression;
      }
    });
    Object.defineProperty(exports, "ObjectMethod", {
      enumerable: true,
      get: function get() {
        return _lowercase.objectMethod;
      }
    });
    Object.defineProperty(exports, "ObjectPattern", {
      enumerable: true,
      get: function get() {
        return _lowercase.objectPattern;
      }
    });
    Object.defineProperty(exports, "ObjectProperty", {
      enumerable: true,
      get: function get() {
        return _lowercase.objectProperty;
      }
    });
    Object.defineProperty(exports, "ObjectTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _lowercase.objectTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ObjectTypeCallProperty", {
      enumerable: true,
      get: function get() {
        return _lowercase.objectTypeCallProperty;
      }
    });
    Object.defineProperty(exports, "ObjectTypeIndexer", {
      enumerable: true,
      get: function get() {
        return _lowercase.objectTypeIndexer;
      }
    });
    Object.defineProperty(exports, "ObjectTypeInternalSlot", {
      enumerable: true,
      get: function get() {
        return _lowercase.objectTypeInternalSlot;
      }
    });
    Object.defineProperty(exports, "ObjectTypeProperty", {
      enumerable: true,
      get: function get() {
        return _lowercase.objectTypeProperty;
      }
    });
    Object.defineProperty(exports, "ObjectTypeSpreadProperty", {
      enumerable: true,
      get: function get() {
        return _lowercase.objectTypeSpreadProperty;
      }
    });
    Object.defineProperty(exports, "OpaqueType", {
      enumerable: true,
      get: function get() {
        return _lowercase.opaqueType;
      }
    });
    Object.defineProperty(exports, "OptionalCallExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.optionalCallExpression;
      }
    });
    Object.defineProperty(exports, "OptionalIndexedAccessType", {
      enumerable: true,
      get: function get() {
        return _lowercase.optionalIndexedAccessType;
      }
    });
    Object.defineProperty(exports, "OptionalMemberExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.optionalMemberExpression;
      }
    });
    Object.defineProperty(exports, "ParenthesizedExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.parenthesizedExpression;
      }
    });
    Object.defineProperty(exports, "PipelineBareFunction", {
      enumerable: true,
      get: function get() {
        return _lowercase.pipelineBareFunction;
      }
    });
    Object.defineProperty(exports, "PipelinePrimaryTopicReference", {
      enumerable: true,
      get: function get() {
        return _lowercase.pipelinePrimaryTopicReference;
      }
    });
    Object.defineProperty(exports, "PipelineTopicExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.pipelineTopicExpression;
      }
    });
    Object.defineProperty(exports, "Placeholder", {
      enumerable: true,
      get: function get() {
        return _lowercase.placeholder;
      }
    });
    Object.defineProperty(exports, "PrivateName", {
      enumerable: true,
      get: function get() {
        return _lowercase.privateName;
      }
    });
    Object.defineProperty(exports, "Program", {
      enumerable: true,
      get: function get() {
        return _lowercase.program;
      }
    });
    Object.defineProperty(exports, "QualifiedTypeIdentifier", {
      enumerable: true,
      get: function get() {
        return _lowercase.qualifiedTypeIdentifier;
      }
    });
    Object.defineProperty(exports, "RecordExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.recordExpression;
      }
    });
    Object.defineProperty(exports, "RegExpLiteral", {
      enumerable: true,
      get: function get() {
        return _lowercase.regExpLiteral;
      }
    });
    Object.defineProperty(exports, "RegexLiteral", {
      enumerable: true,
      get: function get() {
        return _lowercase.regexLiteral;
      }
    });
    Object.defineProperty(exports, "RestElement", {
      enumerable: true,
      get: function get() {
        return _lowercase.restElement;
      }
    });
    Object.defineProperty(exports, "RestProperty", {
      enumerable: true,
      get: function get() {
        return _lowercase.restProperty;
      }
    });
    Object.defineProperty(exports, "ReturnStatement", {
      enumerable: true,
      get: function get() {
        return _lowercase.returnStatement;
      }
    });
    Object.defineProperty(exports, "SequenceExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.sequenceExpression;
      }
    });
    Object.defineProperty(exports, "SpreadElement", {
      enumerable: true,
      get: function get() {
        return _lowercase.spreadElement;
      }
    });
    Object.defineProperty(exports, "SpreadProperty", {
      enumerable: true,
      get: function get() {
        return _lowercase.spreadProperty;
      }
    });
    Object.defineProperty(exports, "StaticBlock", {
      enumerable: true,
      get: function get() {
        return _lowercase.staticBlock;
      }
    });
    Object.defineProperty(exports, "StringLiteral", {
      enumerable: true,
      get: function get() {
        return _lowercase.stringLiteral;
      }
    });
    Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _lowercase.stringLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "StringTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _lowercase.stringTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "Super", {
      enumerable: true,
      get: function get() {
        return _lowercase["super"];
      }
    });
    Object.defineProperty(exports, "SwitchCase", {
      enumerable: true,
      get: function get() {
        return _lowercase.switchCase;
      }
    });
    Object.defineProperty(exports, "SwitchStatement", {
      enumerable: true,
      get: function get() {
        return _lowercase.switchStatement;
      }
    });
    Object.defineProperty(exports, "SymbolTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _lowercase.symbolTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "TSAnyKeyword", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsAnyKeyword;
      }
    });
    Object.defineProperty(exports, "TSArrayType", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsArrayType;
      }
    });
    Object.defineProperty(exports, "TSAsExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsAsExpression;
      }
    });
    Object.defineProperty(exports, "TSBigIntKeyword", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsBigIntKeyword;
      }
    });
    Object.defineProperty(exports, "TSBooleanKeyword", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsBooleanKeyword;
      }
    });
    Object.defineProperty(exports, "TSCallSignatureDeclaration", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsCallSignatureDeclaration;
      }
    });
    Object.defineProperty(exports, "TSConditionalType", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsConditionalType;
      }
    });
    Object.defineProperty(exports, "TSConstructSignatureDeclaration", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsConstructSignatureDeclaration;
      }
    });
    Object.defineProperty(exports, "TSConstructorType", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsConstructorType;
      }
    });
    Object.defineProperty(exports, "TSDeclareFunction", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsDeclareFunction;
      }
    });
    Object.defineProperty(exports, "TSDeclareMethod", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsDeclareMethod;
      }
    });
    Object.defineProperty(exports, "TSEnumBody", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsEnumBody;
      }
    });
    Object.defineProperty(exports, "TSEnumDeclaration", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsEnumDeclaration;
      }
    });
    Object.defineProperty(exports, "TSEnumMember", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsEnumMember;
      }
    });
    Object.defineProperty(exports, "TSExportAssignment", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsExportAssignment;
      }
    });
    Object.defineProperty(exports, "TSExpressionWithTypeArguments", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsExpressionWithTypeArguments;
      }
    });
    Object.defineProperty(exports, "TSExternalModuleReference", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsExternalModuleReference;
      }
    });
    Object.defineProperty(exports, "TSFunctionType", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsFunctionType;
      }
    });
    Object.defineProperty(exports, "TSImportEqualsDeclaration", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsImportEqualsDeclaration;
      }
    });
    Object.defineProperty(exports, "TSImportType", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsImportType;
      }
    });
    Object.defineProperty(exports, "TSIndexSignature", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsIndexSignature;
      }
    });
    Object.defineProperty(exports, "TSIndexedAccessType", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsIndexedAccessType;
      }
    });
    Object.defineProperty(exports, "TSInferType", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsInferType;
      }
    });
    Object.defineProperty(exports, "TSInstantiationExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsInstantiationExpression;
      }
    });
    Object.defineProperty(exports, "TSInterfaceBody", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsInterfaceBody;
      }
    });
    Object.defineProperty(exports, "TSInterfaceDeclaration", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsInterfaceDeclaration;
      }
    });
    Object.defineProperty(exports, "TSIntersectionType", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsIntersectionType;
      }
    });
    Object.defineProperty(exports, "TSIntrinsicKeyword", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsIntrinsicKeyword;
      }
    });
    Object.defineProperty(exports, "TSLiteralType", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsLiteralType;
      }
    });
    Object.defineProperty(exports, "TSMappedType", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsMappedType;
      }
    });
    Object.defineProperty(exports, "TSMethodSignature", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsMethodSignature;
      }
    });
    Object.defineProperty(exports, "TSModuleBlock", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsModuleBlock;
      }
    });
    Object.defineProperty(exports, "TSModuleDeclaration", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsModuleDeclaration;
      }
    });
    Object.defineProperty(exports, "TSNamedTupleMember", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsNamedTupleMember;
      }
    });
    Object.defineProperty(exports, "TSNamespaceExportDeclaration", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsNamespaceExportDeclaration;
      }
    });
    Object.defineProperty(exports, "TSNeverKeyword", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsNeverKeyword;
      }
    });
    Object.defineProperty(exports, "TSNonNullExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsNonNullExpression;
      }
    });
    Object.defineProperty(exports, "TSNullKeyword", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsNullKeyword;
      }
    });
    Object.defineProperty(exports, "TSNumberKeyword", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsNumberKeyword;
      }
    });
    Object.defineProperty(exports, "TSObjectKeyword", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsObjectKeyword;
      }
    });
    Object.defineProperty(exports, "TSOptionalType", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsOptionalType;
      }
    });
    Object.defineProperty(exports, "TSParameterProperty", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsParameterProperty;
      }
    });
    Object.defineProperty(exports, "TSParenthesizedType", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsParenthesizedType;
      }
    });
    Object.defineProperty(exports, "TSPropertySignature", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsPropertySignature;
      }
    });
    Object.defineProperty(exports, "TSQualifiedName", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsQualifiedName;
      }
    });
    Object.defineProperty(exports, "TSRestType", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsRestType;
      }
    });
    Object.defineProperty(exports, "TSSatisfiesExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsSatisfiesExpression;
      }
    });
    Object.defineProperty(exports, "TSStringKeyword", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsStringKeyword;
      }
    });
    Object.defineProperty(exports, "TSSymbolKeyword", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsSymbolKeyword;
      }
    });
    Object.defineProperty(exports, "TSTemplateLiteralType", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsTemplateLiteralType;
      }
    });
    Object.defineProperty(exports, "TSThisType", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsThisType;
      }
    });
    Object.defineProperty(exports, "TSTupleType", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsTupleType;
      }
    });
    Object.defineProperty(exports, "TSTypeAliasDeclaration", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsTypeAliasDeclaration;
      }
    });
    Object.defineProperty(exports, "TSTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "TSTypeAssertion", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsTypeAssertion;
      }
    });
    Object.defineProperty(exports, "TSTypeLiteral", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsTypeLiteral;
      }
    });
    Object.defineProperty(exports, "TSTypeOperator", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsTypeOperator;
      }
    });
    Object.defineProperty(exports, "TSTypeParameter", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsTypeParameter;
      }
    });
    Object.defineProperty(exports, "TSTypeParameterDeclaration", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsTypeParameterDeclaration;
      }
    });
    Object.defineProperty(exports, "TSTypeParameterInstantiation", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsTypeParameterInstantiation;
      }
    });
    Object.defineProperty(exports, "TSTypePredicate", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsTypePredicate;
      }
    });
    Object.defineProperty(exports, "TSTypeQuery", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsTypeQuery;
      }
    });
    Object.defineProperty(exports, "TSTypeReference", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsTypeReference;
      }
    });
    Object.defineProperty(exports, "TSUndefinedKeyword", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsUndefinedKeyword;
      }
    });
    Object.defineProperty(exports, "TSUnionType", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsUnionType;
      }
    });
    Object.defineProperty(exports, "TSUnknownKeyword", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsUnknownKeyword;
      }
    });
    Object.defineProperty(exports, "TSVoidKeyword", {
      enumerable: true,
      get: function get() {
        return _lowercase.tsVoidKeyword;
      }
    });
    Object.defineProperty(exports, "TaggedTemplateExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.taggedTemplateExpression;
      }
    });
    Object.defineProperty(exports, "TemplateElement", {
      enumerable: true,
      get: function get() {
        return _lowercase.templateElement;
      }
    });
    Object.defineProperty(exports, "TemplateLiteral", {
      enumerable: true,
      get: function get() {
        return _lowercase.templateLiteral;
      }
    });
    Object.defineProperty(exports, "ThisExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.thisExpression;
      }
    });
    Object.defineProperty(exports, "ThisTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _lowercase.thisTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "ThrowStatement", {
      enumerable: true,
      get: function get() {
        return _lowercase.throwStatement;
      }
    });
    Object.defineProperty(exports, "TopicReference", {
      enumerable: true,
      get: function get() {
        return _lowercase.topicReference;
      }
    });
    Object.defineProperty(exports, "TryStatement", {
      enumerable: true,
      get: function get() {
        return _lowercase.tryStatement;
      }
    });
    Object.defineProperty(exports, "TupleExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.tupleExpression;
      }
    });
    Object.defineProperty(exports, "TupleTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _lowercase.tupleTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "TypeAlias", {
      enumerable: true,
      get: function get() {
        return _lowercase.typeAlias;
      }
    });
    Object.defineProperty(exports, "TypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _lowercase.typeAnnotation;
      }
    });
    Object.defineProperty(exports, "TypeCastExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.typeCastExpression;
      }
    });
    Object.defineProperty(exports, "TypeParameter", {
      enumerable: true,
      get: function get() {
        return _lowercase.typeParameter;
      }
    });
    Object.defineProperty(exports, "TypeParameterDeclaration", {
      enumerable: true,
      get: function get() {
        return _lowercase.typeParameterDeclaration;
      }
    });
    Object.defineProperty(exports, "TypeParameterInstantiation", {
      enumerable: true,
      get: function get() {
        return _lowercase.typeParameterInstantiation;
      }
    });
    Object.defineProperty(exports, "TypeofTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _lowercase.typeofTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "UnaryExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.unaryExpression;
      }
    });
    Object.defineProperty(exports, "UnionTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _lowercase.unionTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "UpdateExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.updateExpression;
      }
    });
    Object.defineProperty(exports, "V8IntrinsicIdentifier", {
      enumerable: true,
      get: function get() {
        return _lowercase.v8IntrinsicIdentifier;
      }
    });
    Object.defineProperty(exports, "VariableDeclaration", {
      enumerable: true,
      get: function get() {
        return _lowercase.variableDeclaration;
      }
    });
    Object.defineProperty(exports, "VariableDeclarator", {
      enumerable: true,
      get: function get() {
        return _lowercase.variableDeclarator;
      }
    });
    Object.defineProperty(exports, "Variance", {
      enumerable: true,
      get: function get() {
        return _lowercase.variance;
      }
    });
    Object.defineProperty(exports, "VoidTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _lowercase.voidTypeAnnotation;
      }
    });
    Object.defineProperty(exports, "WhileStatement", {
      enumerable: true,
      get: function get() {
        return _lowercase.whileStatement;
      }
    });
    Object.defineProperty(exports, "WithStatement", {
      enumerable: true,
      get: function get() {
        return _lowercase.withStatement;
      }
    });
    Object.defineProperty(exports, "YieldExpression", {
      enumerable: true,
      get: function get() {
        return _lowercase.yieldExpression;
      }
    });
    var _lowercase = requireLowercase();
  })(uppercase);
  return uppercase;
}

var hasRequiredGenerated$2;
function requireGenerated$2() {
  if (hasRequiredGenerated$2) return generated$2;
  hasRequiredGenerated$2 = 1;
  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _lowercase = requireLowercase();
    Object.keys(_lowercase).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _lowercase[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _lowercase[key];
        }
      });
    });
    var _uppercase = requireUppercase();
    Object.keys(_uppercase).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _uppercase[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _uppercase[key];
        }
      });
    });
  })(generated$2);
  return generated$2;
}

var hasRequiredCleanJSXElementLiteralChild;
function requireCleanJSXElementLiteralChild() {
  if (hasRequiredCleanJSXElementLiteralChild) return cleanJSXElementLiteralChild;
  hasRequiredCleanJSXElementLiteralChild = 1;
  Object.defineProperty(cleanJSXElementLiteralChild, "__esModule", {
    value: true
  });
  cleanJSXElementLiteralChild["default"] = cleanJSXElementLiteralChild$1;
  var _index = requireGenerated$2();
  var _index2 = requireLib$4();
  function cleanJSXElementLiteralChild$1(child, args) {
    var lines = child.value.split(/\r\n|\n|\r/);
    var lastNonEmptyLine = 0;
    for (var i = 0; i < lines.length; i++) {
      if (/[^ \t]/.exec(lines[i])) {
        lastNonEmptyLine = i;
      }
    }
    var str = "";
    for (var _i = 0; _i < lines.length; _i++) {
      var line = lines[_i];
      var isFirstLine = _i === 0;
      var isLastLine = _i === lines.length - 1;
      var isLastNonEmptyLine = _i === lastNonEmptyLine;
      var trimmedLine = line.replace(/\t/g, " ");
      if (!isFirstLine) {
        trimmedLine = trimmedLine.replace(/^ +/, "");
      }
      if (!isLastLine) {
        trimmedLine = trimmedLine.replace(/ +$/, "");
      }
      if (trimmedLine) {
        if (!isLastNonEmptyLine) {
          trimmedLine += " ";
        }
        str += trimmedLine;
      }
    }
    if (str) args.push((0, _index2.inherits)((0, _index.stringLiteral)(str), child));
  }
  return cleanJSXElementLiteralChild;
}

var hasRequiredBuildChildren;
function requireBuildChildren() {
  if (hasRequiredBuildChildren) return buildChildren;
  hasRequiredBuildChildren = 1;
  Object.defineProperty(buildChildren, "__esModule", {
    value: true
  });
  buildChildren["default"] = buildChildren$1;
  var _index = requireGenerated$3();
  var _cleanJSXElementLiteralChild = requireCleanJSXElementLiteralChild();
  function buildChildren$1(node) {
    var elements = [];
    for (var i = 0; i < node.children.length; i++) {
      var child = node.children[i];
      if ((0, _index.isJSXText)(child)) {
        (0, _cleanJSXElementLiteralChild["default"])(child, elements);
        continue;
      }
      if ((0, _index.isJSXExpressionContainer)(child)) child = child.expression;
      if ((0, _index.isJSXEmptyExpression)(child)) continue;
      elements.push(child);
    }
    return elements;
  }
  return buildChildren;
}

var assertNode = {};

var isNode = {};

var hasRequiredIsNode;
function requireIsNode() {
  if (hasRequiredIsNode) return isNode;
  hasRequiredIsNode = 1;
  Object.defineProperty(isNode, "__esModule", {
    value: true
  });
  isNode["default"] = isNode$1;
  var _index = requireDefinitions();
  function isNode$1(node) {
    return !!(node && _index.VISITOR_KEYS[node.type]);
  }
  return isNode;
}

var hasRequiredAssertNode;
function requireAssertNode() {
  if (hasRequiredAssertNode) return assertNode;
  hasRequiredAssertNode = 1;
  Object.defineProperty(assertNode, "__esModule", {
    value: true
  });
  assertNode["default"] = assertNode$1;
  var _isNode = requireIsNode();
  function assertNode$1(node) {
    if (!(0, _isNode["default"])(node)) {
      var _node$type;
      var type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);
      throw new TypeError("Not a valid node of type \"".concat(type, "\""));
    }
  }
  return assertNode;
}

var generated$1 = {};

var hasRequiredGenerated$1;
function requireGenerated$1() {
  if (hasRequiredGenerated$1) return generated$1;
  hasRequiredGenerated$1 = 1;
  Object.defineProperty(generated$1, "__esModule", {
    value: true
  });
  generated$1.assertAccessor = assertAccessor;
  generated$1.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
  generated$1.assertArgumentPlaceholder = assertArgumentPlaceholder;
  generated$1.assertArrayExpression = assertArrayExpression;
  generated$1.assertArrayPattern = assertArrayPattern;
  generated$1.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
  generated$1.assertArrowFunctionExpression = assertArrowFunctionExpression;
  generated$1.assertAssignmentExpression = assertAssignmentExpression;
  generated$1.assertAssignmentPattern = assertAssignmentPattern;
  generated$1.assertAwaitExpression = assertAwaitExpression;
  generated$1.assertBigIntLiteral = assertBigIntLiteral;
  generated$1.assertBinary = assertBinary;
  generated$1.assertBinaryExpression = assertBinaryExpression;
  generated$1.assertBindExpression = assertBindExpression;
  generated$1.assertBlock = assertBlock;
  generated$1.assertBlockParent = assertBlockParent;
  generated$1.assertBlockStatement = assertBlockStatement;
  generated$1.assertBooleanLiteral = assertBooleanLiteral;
  generated$1.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
  generated$1.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
  generated$1.assertBreakStatement = assertBreakStatement;
  generated$1.assertCallExpression = assertCallExpression;
  generated$1.assertCatchClause = assertCatchClause;
  generated$1.assertClass = assertClass;
  generated$1.assertClassAccessorProperty = assertClassAccessorProperty;
  generated$1.assertClassBody = assertClassBody;
  generated$1.assertClassDeclaration = assertClassDeclaration;
  generated$1.assertClassExpression = assertClassExpression;
  generated$1.assertClassImplements = assertClassImplements;
  generated$1.assertClassMethod = assertClassMethod;
  generated$1.assertClassPrivateMethod = assertClassPrivateMethod;
  generated$1.assertClassPrivateProperty = assertClassPrivateProperty;
  generated$1.assertClassProperty = assertClassProperty;
  generated$1.assertCompletionStatement = assertCompletionStatement;
  generated$1.assertConditional = assertConditional;
  generated$1.assertConditionalExpression = assertConditionalExpression;
  generated$1.assertContinueStatement = assertContinueStatement;
  generated$1.assertDebuggerStatement = assertDebuggerStatement;
  generated$1.assertDecimalLiteral = assertDecimalLiteral;
  generated$1.assertDeclaration = assertDeclaration;
  generated$1.assertDeclareClass = assertDeclareClass;
  generated$1.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
  generated$1.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
  generated$1.assertDeclareFunction = assertDeclareFunction;
  generated$1.assertDeclareInterface = assertDeclareInterface;
  generated$1.assertDeclareModule = assertDeclareModule;
  generated$1.assertDeclareModuleExports = assertDeclareModuleExports;
  generated$1.assertDeclareOpaqueType = assertDeclareOpaqueType;
  generated$1.assertDeclareTypeAlias = assertDeclareTypeAlias;
  generated$1.assertDeclareVariable = assertDeclareVariable;
  generated$1.assertDeclaredPredicate = assertDeclaredPredicate;
  generated$1.assertDecorator = assertDecorator;
  generated$1.assertDirective = assertDirective;
  generated$1.assertDirectiveLiteral = assertDirectiveLiteral;
  generated$1.assertDoExpression = assertDoExpression;
  generated$1.assertDoWhileStatement = assertDoWhileStatement;
  generated$1.assertEmptyStatement = assertEmptyStatement;
  generated$1.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
  generated$1.assertEnumBody = assertEnumBody;
  generated$1.assertEnumBooleanBody = assertEnumBooleanBody;
  generated$1.assertEnumBooleanMember = assertEnumBooleanMember;
  generated$1.assertEnumDeclaration = assertEnumDeclaration;
  generated$1.assertEnumDefaultedMember = assertEnumDefaultedMember;
  generated$1.assertEnumMember = assertEnumMember;
  generated$1.assertEnumNumberBody = assertEnumNumberBody;
  generated$1.assertEnumNumberMember = assertEnumNumberMember;
  generated$1.assertEnumStringBody = assertEnumStringBody;
  generated$1.assertEnumStringMember = assertEnumStringMember;
  generated$1.assertEnumSymbolBody = assertEnumSymbolBody;
  generated$1.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
  generated$1.assertExportAllDeclaration = assertExportAllDeclaration;
  generated$1.assertExportDeclaration = assertExportDeclaration;
  generated$1.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
  generated$1.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
  generated$1.assertExportNamedDeclaration = assertExportNamedDeclaration;
  generated$1.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
  generated$1.assertExportSpecifier = assertExportSpecifier;
  generated$1.assertExpression = assertExpression;
  generated$1.assertExpressionStatement = assertExpressionStatement;
  generated$1.assertExpressionWrapper = assertExpressionWrapper;
  generated$1.assertFile = assertFile;
  generated$1.assertFlow = assertFlow;
  generated$1.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
  generated$1.assertFlowDeclaration = assertFlowDeclaration;
  generated$1.assertFlowPredicate = assertFlowPredicate;
  generated$1.assertFlowType = assertFlowType;
  generated$1.assertFor = assertFor;
  generated$1.assertForInStatement = assertForInStatement;
  generated$1.assertForOfStatement = assertForOfStatement;
  generated$1.assertForStatement = assertForStatement;
  generated$1.assertForXStatement = assertForXStatement;
  generated$1.assertFunction = assertFunction;
  generated$1.assertFunctionDeclaration = assertFunctionDeclaration;
  generated$1.assertFunctionExpression = assertFunctionExpression;
  generated$1.assertFunctionParent = assertFunctionParent;
  generated$1.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
  generated$1.assertFunctionTypeParam = assertFunctionTypeParam;
  generated$1.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
  generated$1.assertIdentifier = assertIdentifier;
  generated$1.assertIfStatement = assertIfStatement;
  generated$1.assertImmutable = assertImmutable;
  generated$1.assertImport = assertImport;
  generated$1.assertImportAttribute = assertImportAttribute;
  generated$1.assertImportDeclaration = assertImportDeclaration;
  generated$1.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
  generated$1.assertImportExpression = assertImportExpression;
  generated$1.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
  generated$1.assertImportOrExportDeclaration = assertImportOrExportDeclaration;
  generated$1.assertImportSpecifier = assertImportSpecifier;
  generated$1.assertIndexedAccessType = assertIndexedAccessType;
  generated$1.assertInferredPredicate = assertInferredPredicate;
  generated$1.assertInterfaceDeclaration = assertInterfaceDeclaration;
  generated$1.assertInterfaceExtends = assertInterfaceExtends;
  generated$1.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
  generated$1.assertInterpreterDirective = assertInterpreterDirective;
  generated$1.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
  generated$1.assertJSX = assertJSX;
  generated$1.assertJSXAttribute = assertJSXAttribute;
  generated$1.assertJSXClosingElement = assertJSXClosingElement;
  generated$1.assertJSXClosingFragment = assertJSXClosingFragment;
  generated$1.assertJSXElement = assertJSXElement;
  generated$1.assertJSXEmptyExpression = assertJSXEmptyExpression;
  generated$1.assertJSXExpressionContainer = assertJSXExpressionContainer;
  generated$1.assertJSXFragment = assertJSXFragment;
  generated$1.assertJSXIdentifier = assertJSXIdentifier;
  generated$1.assertJSXMemberExpression = assertJSXMemberExpression;
  generated$1.assertJSXNamespacedName = assertJSXNamespacedName;
  generated$1.assertJSXOpeningElement = assertJSXOpeningElement;
  generated$1.assertJSXOpeningFragment = assertJSXOpeningFragment;
  generated$1.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
  generated$1.assertJSXSpreadChild = assertJSXSpreadChild;
  generated$1.assertJSXText = assertJSXText;
  generated$1.assertLVal = assertLVal;
  generated$1.assertLabeledStatement = assertLabeledStatement;
  generated$1.assertLiteral = assertLiteral;
  generated$1.assertLogicalExpression = assertLogicalExpression;
  generated$1.assertLoop = assertLoop;
  generated$1.assertMemberExpression = assertMemberExpression;
  generated$1.assertMetaProperty = assertMetaProperty;
  generated$1.assertMethod = assertMethod;
  generated$1.assertMiscellaneous = assertMiscellaneous;
  generated$1.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
  generated$1.assertModuleDeclaration = assertModuleDeclaration;
  generated$1.assertModuleExpression = assertModuleExpression;
  generated$1.assertModuleSpecifier = assertModuleSpecifier;
  generated$1.assertNewExpression = assertNewExpression;
  generated$1.assertNoop = assertNoop;
  generated$1.assertNullLiteral = assertNullLiteral;
  generated$1.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
  generated$1.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
  generated$1.assertNumberLiteral = assertNumberLiteral;
  generated$1.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
  generated$1.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
  generated$1.assertNumericLiteral = assertNumericLiteral;
  generated$1.assertObjectExpression = assertObjectExpression;
  generated$1.assertObjectMember = assertObjectMember;
  generated$1.assertObjectMethod = assertObjectMethod;
  generated$1.assertObjectPattern = assertObjectPattern;
  generated$1.assertObjectProperty = assertObjectProperty;
  generated$1.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
  generated$1.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
  generated$1.assertObjectTypeIndexer = assertObjectTypeIndexer;
  generated$1.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
  generated$1.assertObjectTypeProperty = assertObjectTypeProperty;
  generated$1.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
  generated$1.assertOpaqueType = assertOpaqueType;
  generated$1.assertOptionalCallExpression = assertOptionalCallExpression;
  generated$1.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
  generated$1.assertOptionalMemberExpression = assertOptionalMemberExpression;
  generated$1.assertParenthesizedExpression = assertParenthesizedExpression;
  generated$1.assertPattern = assertPattern;
  generated$1.assertPatternLike = assertPatternLike;
  generated$1.assertPipelineBareFunction = assertPipelineBareFunction;
  generated$1.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
  generated$1.assertPipelineTopicExpression = assertPipelineTopicExpression;
  generated$1.assertPlaceholder = assertPlaceholder;
  generated$1.assertPrivate = assertPrivate;
  generated$1.assertPrivateName = assertPrivateName;
  generated$1.assertProgram = assertProgram;
  generated$1.assertProperty = assertProperty;
  generated$1.assertPureish = assertPureish;
  generated$1.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
  generated$1.assertRecordExpression = assertRecordExpression;
  generated$1.assertRegExpLiteral = assertRegExpLiteral;
  generated$1.assertRegexLiteral = assertRegexLiteral;
  generated$1.assertRestElement = assertRestElement;
  generated$1.assertRestProperty = assertRestProperty;
  generated$1.assertReturnStatement = assertReturnStatement;
  generated$1.assertScopable = assertScopable;
  generated$1.assertSequenceExpression = assertSequenceExpression;
  generated$1.assertSpreadElement = assertSpreadElement;
  generated$1.assertSpreadProperty = assertSpreadProperty;
  generated$1.assertStandardized = assertStandardized;
  generated$1.assertStatement = assertStatement;
  generated$1.assertStaticBlock = assertStaticBlock;
  generated$1.assertStringLiteral = assertStringLiteral;
  generated$1.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
  generated$1.assertStringTypeAnnotation = assertStringTypeAnnotation;
  generated$1.assertSuper = assertSuper;
  generated$1.assertSwitchCase = assertSwitchCase;
  generated$1.assertSwitchStatement = assertSwitchStatement;
  generated$1.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
  generated$1.assertTSAnyKeyword = assertTSAnyKeyword;
  generated$1.assertTSArrayType = assertTSArrayType;
  generated$1.assertTSAsExpression = assertTSAsExpression;
  generated$1.assertTSBaseType = assertTSBaseType;
  generated$1.assertTSBigIntKeyword = assertTSBigIntKeyword;
  generated$1.assertTSBooleanKeyword = assertTSBooleanKeyword;
  generated$1.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
  generated$1.assertTSConditionalType = assertTSConditionalType;
  generated$1.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
  generated$1.assertTSConstructorType = assertTSConstructorType;
  generated$1.assertTSDeclareFunction = assertTSDeclareFunction;
  generated$1.assertTSDeclareMethod = assertTSDeclareMethod;
  generated$1.assertTSEntityName = assertTSEntityName;
  generated$1.assertTSEnumBody = assertTSEnumBody;
  generated$1.assertTSEnumDeclaration = assertTSEnumDeclaration;
  generated$1.assertTSEnumMember = assertTSEnumMember;
  generated$1.assertTSExportAssignment = assertTSExportAssignment;
  generated$1.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
  generated$1.assertTSExternalModuleReference = assertTSExternalModuleReference;
  generated$1.assertTSFunctionType = assertTSFunctionType;
  generated$1.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
  generated$1.assertTSImportType = assertTSImportType;
  generated$1.assertTSIndexSignature = assertTSIndexSignature;
  generated$1.assertTSIndexedAccessType = assertTSIndexedAccessType;
  generated$1.assertTSInferType = assertTSInferType;
  generated$1.assertTSInstantiationExpression = assertTSInstantiationExpression;
  generated$1.assertTSInterfaceBody = assertTSInterfaceBody;
  generated$1.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
  generated$1.assertTSIntersectionType = assertTSIntersectionType;
  generated$1.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
  generated$1.assertTSLiteralType = assertTSLiteralType;
  generated$1.assertTSMappedType = assertTSMappedType;
  generated$1.assertTSMethodSignature = assertTSMethodSignature;
  generated$1.assertTSModuleBlock = assertTSModuleBlock;
  generated$1.assertTSModuleDeclaration = assertTSModuleDeclaration;
  generated$1.assertTSNamedTupleMember = assertTSNamedTupleMember;
  generated$1.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
  generated$1.assertTSNeverKeyword = assertTSNeverKeyword;
  generated$1.assertTSNonNullExpression = assertTSNonNullExpression;
  generated$1.assertTSNullKeyword = assertTSNullKeyword;
  generated$1.assertTSNumberKeyword = assertTSNumberKeyword;
  generated$1.assertTSObjectKeyword = assertTSObjectKeyword;
  generated$1.assertTSOptionalType = assertTSOptionalType;
  generated$1.assertTSParameterProperty = assertTSParameterProperty;
  generated$1.assertTSParenthesizedType = assertTSParenthesizedType;
  generated$1.assertTSPropertySignature = assertTSPropertySignature;
  generated$1.assertTSQualifiedName = assertTSQualifiedName;
  generated$1.assertTSRestType = assertTSRestType;
  generated$1.assertTSSatisfiesExpression = assertTSSatisfiesExpression;
  generated$1.assertTSStringKeyword = assertTSStringKeyword;
  generated$1.assertTSSymbolKeyword = assertTSSymbolKeyword;
  generated$1.assertTSTemplateLiteralType = assertTSTemplateLiteralType;
  generated$1.assertTSThisType = assertTSThisType;
  generated$1.assertTSTupleType = assertTSTupleType;
  generated$1.assertTSType = assertTSType;
  generated$1.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
  generated$1.assertTSTypeAnnotation = assertTSTypeAnnotation;
  generated$1.assertTSTypeAssertion = assertTSTypeAssertion;
  generated$1.assertTSTypeElement = assertTSTypeElement;
  generated$1.assertTSTypeLiteral = assertTSTypeLiteral;
  generated$1.assertTSTypeOperator = assertTSTypeOperator;
  generated$1.assertTSTypeParameter = assertTSTypeParameter;
  generated$1.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
  generated$1.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
  generated$1.assertTSTypePredicate = assertTSTypePredicate;
  generated$1.assertTSTypeQuery = assertTSTypeQuery;
  generated$1.assertTSTypeReference = assertTSTypeReference;
  generated$1.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
  generated$1.assertTSUnionType = assertTSUnionType;
  generated$1.assertTSUnknownKeyword = assertTSUnknownKeyword;
  generated$1.assertTSVoidKeyword = assertTSVoidKeyword;
  generated$1.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
  generated$1.assertTemplateElement = assertTemplateElement;
  generated$1.assertTemplateLiteral = assertTemplateLiteral;
  generated$1.assertTerminatorless = assertTerminatorless;
  generated$1.assertThisExpression = assertThisExpression;
  generated$1.assertThisTypeAnnotation = assertThisTypeAnnotation;
  generated$1.assertThrowStatement = assertThrowStatement;
  generated$1.assertTopicReference = assertTopicReference;
  generated$1.assertTryStatement = assertTryStatement;
  generated$1.assertTupleExpression = assertTupleExpression;
  generated$1.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
  generated$1.assertTypeAlias = assertTypeAlias;
  generated$1.assertTypeAnnotation = assertTypeAnnotation;
  generated$1.assertTypeCastExpression = assertTypeCastExpression;
  generated$1.assertTypeParameter = assertTypeParameter;
  generated$1.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
  generated$1.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
  generated$1.assertTypeScript = assertTypeScript;
  generated$1.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
  generated$1.assertUnaryExpression = assertUnaryExpression;
  generated$1.assertUnaryLike = assertUnaryLike;
  generated$1.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
  generated$1.assertUpdateExpression = assertUpdateExpression;
  generated$1.assertUserWhitespacable = assertUserWhitespacable;
  generated$1.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
  generated$1.assertVariableDeclaration = assertVariableDeclaration;
  generated$1.assertVariableDeclarator = assertVariableDeclarator;
  generated$1.assertVariance = assertVariance;
  generated$1.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
  generated$1.assertWhile = assertWhile;
  generated$1.assertWhileStatement = assertWhileStatement;
  generated$1.assertWithStatement = assertWithStatement;
  generated$1.assertYieldExpression = assertYieldExpression;
  var _is = requireIs();
  var _deprecationWarning = requireDeprecationWarning();
  function assert(type, node, opts) {
    if (!(0, _is["default"])(type, node, opts)) {
      throw new Error("Expected type \"".concat(type, "\" with option ").concat(JSON.stringify(opts), ", ") + "but instead got \"".concat(node.type, "\"."));
    }
  }
  function assertArrayExpression(node, opts) {
    assert("ArrayExpression", node, opts);
  }
  function assertAssignmentExpression(node, opts) {
    assert("AssignmentExpression", node, opts);
  }
  function assertBinaryExpression(node, opts) {
    assert("BinaryExpression", node, opts);
  }
  function assertInterpreterDirective(node, opts) {
    assert("InterpreterDirective", node, opts);
  }
  function assertDirective(node, opts) {
    assert("Directive", node, opts);
  }
  function assertDirectiveLiteral(node, opts) {
    assert("DirectiveLiteral", node, opts);
  }
  function assertBlockStatement(node, opts) {
    assert("BlockStatement", node, opts);
  }
  function assertBreakStatement(node, opts) {
    assert("BreakStatement", node, opts);
  }
  function assertCallExpression(node, opts) {
    assert("CallExpression", node, opts);
  }
  function assertCatchClause(node, opts) {
    assert("CatchClause", node, opts);
  }
  function assertConditionalExpression(node, opts) {
    assert("ConditionalExpression", node, opts);
  }
  function assertContinueStatement(node, opts) {
    assert("ContinueStatement", node, opts);
  }
  function assertDebuggerStatement(node, opts) {
    assert("DebuggerStatement", node, opts);
  }
  function assertDoWhileStatement(node, opts) {
    assert("DoWhileStatement", node, opts);
  }
  function assertEmptyStatement(node, opts) {
    assert("EmptyStatement", node, opts);
  }
  function assertExpressionStatement(node, opts) {
    assert("ExpressionStatement", node, opts);
  }
  function assertFile(node, opts) {
    assert("File", node, opts);
  }
  function assertForInStatement(node, opts) {
    assert("ForInStatement", node, opts);
  }
  function assertForStatement(node, opts) {
    assert("ForStatement", node, opts);
  }
  function assertFunctionDeclaration(node, opts) {
    assert("FunctionDeclaration", node, opts);
  }
  function assertFunctionExpression(node, opts) {
    assert("FunctionExpression", node, opts);
  }
  function assertIdentifier(node, opts) {
    assert("Identifier", node, opts);
  }
  function assertIfStatement(node, opts) {
    assert("IfStatement", node, opts);
  }
  function assertLabeledStatement(node, opts) {
    assert("LabeledStatement", node, opts);
  }
  function assertStringLiteral(node, opts) {
    assert("StringLiteral", node, opts);
  }
  function assertNumericLiteral(node, opts) {
    assert("NumericLiteral", node, opts);
  }
  function assertNullLiteral(node, opts) {
    assert("NullLiteral", node, opts);
  }
  function assertBooleanLiteral(node, opts) {
    assert("BooleanLiteral", node, opts);
  }
  function assertRegExpLiteral(node, opts) {
    assert("RegExpLiteral", node, opts);
  }
  function assertLogicalExpression(node, opts) {
    assert("LogicalExpression", node, opts);
  }
  function assertMemberExpression(node, opts) {
    assert("MemberExpression", node, opts);
  }
  function assertNewExpression(node, opts) {
    assert("NewExpression", node, opts);
  }
  function assertProgram(node, opts) {
    assert("Program", node, opts);
  }
  function assertObjectExpression(node, opts) {
    assert("ObjectExpression", node, opts);
  }
  function assertObjectMethod(node, opts) {
    assert("ObjectMethod", node, opts);
  }
  function assertObjectProperty(node, opts) {
    assert("ObjectProperty", node, opts);
  }
  function assertRestElement(node, opts) {
    assert("RestElement", node, opts);
  }
  function assertReturnStatement(node, opts) {
    assert("ReturnStatement", node, opts);
  }
  function assertSequenceExpression(node, opts) {
    assert("SequenceExpression", node, opts);
  }
  function assertParenthesizedExpression(node, opts) {
    assert("ParenthesizedExpression", node, opts);
  }
  function assertSwitchCase(node, opts) {
    assert("SwitchCase", node, opts);
  }
  function assertSwitchStatement(node, opts) {
    assert("SwitchStatement", node, opts);
  }
  function assertThisExpression(node, opts) {
    assert("ThisExpression", node, opts);
  }
  function assertThrowStatement(node, opts) {
    assert("ThrowStatement", node, opts);
  }
  function assertTryStatement(node, opts) {
    assert("TryStatement", node, opts);
  }
  function assertUnaryExpression(node, opts) {
    assert("UnaryExpression", node, opts);
  }
  function assertUpdateExpression(node, opts) {
    assert("UpdateExpression", node, opts);
  }
  function assertVariableDeclaration(node, opts) {
    assert("VariableDeclaration", node, opts);
  }
  function assertVariableDeclarator(node, opts) {
    assert("VariableDeclarator", node, opts);
  }
  function assertWhileStatement(node, opts) {
    assert("WhileStatement", node, opts);
  }
  function assertWithStatement(node, opts) {
    assert("WithStatement", node, opts);
  }
  function assertAssignmentPattern(node, opts) {
    assert("AssignmentPattern", node, opts);
  }
  function assertArrayPattern(node, opts) {
    assert("ArrayPattern", node, opts);
  }
  function assertArrowFunctionExpression(node, opts) {
    assert("ArrowFunctionExpression", node, opts);
  }
  function assertClassBody(node, opts) {
    assert("ClassBody", node, opts);
  }
  function assertClassExpression(node, opts) {
    assert("ClassExpression", node, opts);
  }
  function assertClassDeclaration(node, opts) {
    assert("ClassDeclaration", node, opts);
  }
  function assertExportAllDeclaration(node, opts) {
    assert("ExportAllDeclaration", node, opts);
  }
  function assertExportDefaultDeclaration(node, opts) {
    assert("ExportDefaultDeclaration", node, opts);
  }
  function assertExportNamedDeclaration(node, opts) {
    assert("ExportNamedDeclaration", node, opts);
  }
  function assertExportSpecifier(node, opts) {
    assert("ExportSpecifier", node, opts);
  }
  function assertForOfStatement(node, opts) {
    assert("ForOfStatement", node, opts);
  }
  function assertImportDeclaration(node, opts) {
    assert("ImportDeclaration", node, opts);
  }
  function assertImportDefaultSpecifier(node, opts) {
    assert("ImportDefaultSpecifier", node, opts);
  }
  function assertImportNamespaceSpecifier(node, opts) {
    assert("ImportNamespaceSpecifier", node, opts);
  }
  function assertImportSpecifier(node, opts) {
    assert("ImportSpecifier", node, opts);
  }
  function assertImportExpression(node, opts) {
    assert("ImportExpression", node, opts);
  }
  function assertMetaProperty(node, opts) {
    assert("MetaProperty", node, opts);
  }
  function assertClassMethod(node, opts) {
    assert("ClassMethod", node, opts);
  }
  function assertObjectPattern(node, opts) {
    assert("ObjectPattern", node, opts);
  }
  function assertSpreadElement(node, opts) {
    assert("SpreadElement", node, opts);
  }
  function assertSuper(node, opts) {
    assert("Super", node, opts);
  }
  function assertTaggedTemplateExpression(node, opts) {
    assert("TaggedTemplateExpression", node, opts);
  }
  function assertTemplateElement(node, opts) {
    assert("TemplateElement", node, opts);
  }
  function assertTemplateLiteral(node, opts) {
    assert("TemplateLiteral", node, opts);
  }
  function assertYieldExpression(node, opts) {
    assert("YieldExpression", node, opts);
  }
  function assertAwaitExpression(node, opts) {
    assert("AwaitExpression", node, opts);
  }
  function assertImport(node, opts) {
    assert("Import", node, opts);
  }
  function assertBigIntLiteral(node, opts) {
    assert("BigIntLiteral", node, opts);
  }
  function assertExportNamespaceSpecifier(node, opts) {
    assert("ExportNamespaceSpecifier", node, opts);
  }
  function assertOptionalMemberExpression(node, opts) {
    assert("OptionalMemberExpression", node, opts);
  }
  function assertOptionalCallExpression(node, opts) {
    assert("OptionalCallExpression", node, opts);
  }
  function assertClassProperty(node, opts) {
    assert("ClassProperty", node, opts);
  }
  function assertClassAccessorProperty(node, opts) {
    assert("ClassAccessorProperty", node, opts);
  }
  function assertClassPrivateProperty(node, opts) {
    assert("ClassPrivateProperty", node, opts);
  }
  function assertClassPrivateMethod(node, opts) {
    assert("ClassPrivateMethod", node, opts);
  }
  function assertPrivateName(node, opts) {
    assert("PrivateName", node, opts);
  }
  function assertStaticBlock(node, opts) {
    assert("StaticBlock", node, opts);
  }
  function assertAnyTypeAnnotation(node, opts) {
    assert("AnyTypeAnnotation", node, opts);
  }
  function assertArrayTypeAnnotation(node, opts) {
    assert("ArrayTypeAnnotation", node, opts);
  }
  function assertBooleanTypeAnnotation(node, opts) {
    assert("BooleanTypeAnnotation", node, opts);
  }
  function assertBooleanLiteralTypeAnnotation(node, opts) {
    assert("BooleanLiteralTypeAnnotation", node, opts);
  }
  function assertNullLiteralTypeAnnotation(node, opts) {
    assert("NullLiteralTypeAnnotation", node, opts);
  }
  function assertClassImplements(node, opts) {
    assert("ClassImplements", node, opts);
  }
  function assertDeclareClass(node, opts) {
    assert("DeclareClass", node, opts);
  }
  function assertDeclareFunction(node, opts) {
    assert("DeclareFunction", node, opts);
  }
  function assertDeclareInterface(node, opts) {
    assert("DeclareInterface", node, opts);
  }
  function assertDeclareModule(node, opts) {
    assert("DeclareModule", node, opts);
  }
  function assertDeclareModuleExports(node, opts) {
    assert("DeclareModuleExports", node, opts);
  }
  function assertDeclareTypeAlias(node, opts) {
    assert("DeclareTypeAlias", node, opts);
  }
  function assertDeclareOpaqueType(node, opts) {
    assert("DeclareOpaqueType", node, opts);
  }
  function assertDeclareVariable(node, opts) {
    assert("DeclareVariable", node, opts);
  }
  function assertDeclareExportDeclaration(node, opts) {
    assert("DeclareExportDeclaration", node, opts);
  }
  function assertDeclareExportAllDeclaration(node, opts) {
    assert("DeclareExportAllDeclaration", node, opts);
  }
  function assertDeclaredPredicate(node, opts) {
    assert("DeclaredPredicate", node, opts);
  }
  function assertExistsTypeAnnotation(node, opts) {
    assert("ExistsTypeAnnotation", node, opts);
  }
  function assertFunctionTypeAnnotation(node, opts) {
    assert("FunctionTypeAnnotation", node, opts);
  }
  function assertFunctionTypeParam(node, opts) {
    assert("FunctionTypeParam", node, opts);
  }
  function assertGenericTypeAnnotation(node, opts) {
    assert("GenericTypeAnnotation", node, opts);
  }
  function assertInferredPredicate(node, opts) {
    assert("InferredPredicate", node, opts);
  }
  function assertInterfaceExtends(node, opts) {
    assert("InterfaceExtends", node, opts);
  }
  function assertInterfaceDeclaration(node, opts) {
    assert("InterfaceDeclaration", node, opts);
  }
  function assertInterfaceTypeAnnotation(node, opts) {
    assert("InterfaceTypeAnnotation", node, opts);
  }
  function assertIntersectionTypeAnnotation(node, opts) {
    assert("IntersectionTypeAnnotation", node, opts);
  }
  function assertMixedTypeAnnotation(node, opts) {
    assert("MixedTypeAnnotation", node, opts);
  }
  function assertEmptyTypeAnnotation(node, opts) {
    assert("EmptyTypeAnnotation", node, opts);
  }
  function assertNullableTypeAnnotation(node, opts) {
    assert("NullableTypeAnnotation", node, opts);
  }
  function assertNumberLiteralTypeAnnotation(node, opts) {
    assert("NumberLiteralTypeAnnotation", node, opts);
  }
  function assertNumberTypeAnnotation(node, opts) {
    assert("NumberTypeAnnotation", node, opts);
  }
  function assertObjectTypeAnnotation(node, opts) {
    assert("ObjectTypeAnnotation", node, opts);
  }
  function assertObjectTypeInternalSlot(node, opts) {
    assert("ObjectTypeInternalSlot", node, opts);
  }
  function assertObjectTypeCallProperty(node, opts) {
    assert("ObjectTypeCallProperty", node, opts);
  }
  function assertObjectTypeIndexer(node, opts) {
    assert("ObjectTypeIndexer", node, opts);
  }
  function assertObjectTypeProperty(node, opts) {
    assert("ObjectTypeProperty", node, opts);
  }
  function assertObjectTypeSpreadProperty(node, opts) {
    assert("ObjectTypeSpreadProperty", node, opts);
  }
  function assertOpaqueType(node, opts) {
    assert("OpaqueType", node, opts);
  }
  function assertQualifiedTypeIdentifier(node, opts) {
    assert("QualifiedTypeIdentifier", node, opts);
  }
  function assertStringLiteralTypeAnnotation(node, opts) {
    assert("StringLiteralTypeAnnotation", node, opts);
  }
  function assertStringTypeAnnotation(node, opts) {
    assert("StringTypeAnnotation", node, opts);
  }
  function assertSymbolTypeAnnotation(node, opts) {
    assert("SymbolTypeAnnotation", node, opts);
  }
  function assertThisTypeAnnotation(node, opts) {
    assert("ThisTypeAnnotation", node, opts);
  }
  function assertTupleTypeAnnotation(node, opts) {
    assert("TupleTypeAnnotation", node, opts);
  }
  function assertTypeofTypeAnnotation(node, opts) {
    assert("TypeofTypeAnnotation", node, opts);
  }
  function assertTypeAlias(node, opts) {
    assert("TypeAlias", node, opts);
  }
  function assertTypeAnnotation(node, opts) {
    assert("TypeAnnotation", node, opts);
  }
  function assertTypeCastExpression(node, opts) {
    assert("TypeCastExpression", node, opts);
  }
  function assertTypeParameter(node, opts) {
    assert("TypeParameter", node, opts);
  }
  function assertTypeParameterDeclaration(node, opts) {
    assert("TypeParameterDeclaration", node, opts);
  }
  function assertTypeParameterInstantiation(node, opts) {
    assert("TypeParameterInstantiation", node, opts);
  }
  function assertUnionTypeAnnotation(node, opts) {
    assert("UnionTypeAnnotation", node, opts);
  }
  function assertVariance(node, opts) {
    assert("Variance", node, opts);
  }
  function assertVoidTypeAnnotation(node, opts) {
    assert("VoidTypeAnnotation", node, opts);
  }
  function assertEnumDeclaration(node, opts) {
    assert("EnumDeclaration", node, opts);
  }
  function assertEnumBooleanBody(node, opts) {
    assert("EnumBooleanBody", node, opts);
  }
  function assertEnumNumberBody(node, opts) {
    assert("EnumNumberBody", node, opts);
  }
  function assertEnumStringBody(node, opts) {
    assert("EnumStringBody", node, opts);
  }
  function assertEnumSymbolBody(node, opts) {
    assert("EnumSymbolBody", node, opts);
  }
  function assertEnumBooleanMember(node, opts) {
    assert("EnumBooleanMember", node, opts);
  }
  function assertEnumNumberMember(node, opts) {
    assert("EnumNumberMember", node, opts);
  }
  function assertEnumStringMember(node, opts) {
    assert("EnumStringMember", node, opts);
  }
  function assertEnumDefaultedMember(node, opts) {
    assert("EnumDefaultedMember", node, opts);
  }
  function assertIndexedAccessType(node, opts) {
    assert("IndexedAccessType", node, opts);
  }
  function assertOptionalIndexedAccessType(node, opts) {
    assert("OptionalIndexedAccessType", node, opts);
  }
  function assertJSXAttribute(node, opts) {
    assert("JSXAttribute", node, opts);
  }
  function assertJSXClosingElement(node, opts) {
    assert("JSXClosingElement", node, opts);
  }
  function assertJSXElement(node, opts) {
    assert("JSXElement", node, opts);
  }
  function assertJSXEmptyExpression(node, opts) {
    assert("JSXEmptyExpression", node, opts);
  }
  function assertJSXExpressionContainer(node, opts) {
    assert("JSXExpressionContainer", node, opts);
  }
  function assertJSXSpreadChild(node, opts) {
    assert("JSXSpreadChild", node, opts);
  }
  function assertJSXIdentifier(node, opts) {
    assert("JSXIdentifier", node, opts);
  }
  function assertJSXMemberExpression(node, opts) {
    assert("JSXMemberExpression", node, opts);
  }
  function assertJSXNamespacedName(node, opts) {
    assert("JSXNamespacedName", node, opts);
  }
  function assertJSXOpeningElement(node, opts) {
    assert("JSXOpeningElement", node, opts);
  }
  function assertJSXSpreadAttribute(node, opts) {
    assert("JSXSpreadAttribute", node, opts);
  }
  function assertJSXText(node, opts) {
    assert("JSXText", node, opts);
  }
  function assertJSXFragment(node, opts) {
    assert("JSXFragment", node, opts);
  }
  function assertJSXOpeningFragment(node, opts) {
    assert("JSXOpeningFragment", node, opts);
  }
  function assertJSXClosingFragment(node, opts) {
    assert("JSXClosingFragment", node, opts);
  }
  function assertNoop(node, opts) {
    assert("Noop", node, opts);
  }
  function assertPlaceholder(node, opts) {
    assert("Placeholder", node, opts);
  }
  function assertV8IntrinsicIdentifier(node, opts) {
    assert("V8IntrinsicIdentifier", node, opts);
  }
  function assertArgumentPlaceholder(node, opts) {
    assert("ArgumentPlaceholder", node, opts);
  }
  function assertBindExpression(node, opts) {
    assert("BindExpression", node, opts);
  }
  function assertImportAttribute(node, opts) {
    assert("ImportAttribute", node, opts);
  }
  function assertDecorator(node, opts) {
    assert("Decorator", node, opts);
  }
  function assertDoExpression(node, opts) {
    assert("DoExpression", node, opts);
  }
  function assertExportDefaultSpecifier(node, opts) {
    assert("ExportDefaultSpecifier", node, opts);
  }
  function assertRecordExpression(node, opts) {
    assert("RecordExpression", node, opts);
  }
  function assertTupleExpression(node, opts) {
    assert("TupleExpression", node, opts);
  }
  function assertDecimalLiteral(node, opts) {
    assert("DecimalLiteral", node, opts);
  }
  function assertModuleExpression(node, opts) {
    assert("ModuleExpression", node, opts);
  }
  function assertTopicReference(node, opts) {
    assert("TopicReference", node, opts);
  }
  function assertPipelineTopicExpression(node, opts) {
    assert("PipelineTopicExpression", node, opts);
  }
  function assertPipelineBareFunction(node, opts) {
    assert("PipelineBareFunction", node, opts);
  }
  function assertPipelinePrimaryTopicReference(node, opts) {
    assert("PipelinePrimaryTopicReference", node, opts);
  }
  function assertTSParameterProperty(node, opts) {
    assert("TSParameterProperty", node, opts);
  }
  function assertTSDeclareFunction(node, opts) {
    assert("TSDeclareFunction", node, opts);
  }
  function assertTSDeclareMethod(node, opts) {
    assert("TSDeclareMethod", node, opts);
  }
  function assertTSQualifiedName(node, opts) {
    assert("TSQualifiedName", node, opts);
  }
  function assertTSCallSignatureDeclaration(node, opts) {
    assert("TSCallSignatureDeclaration", node, opts);
  }
  function assertTSConstructSignatureDeclaration(node, opts) {
    assert("TSConstructSignatureDeclaration", node, opts);
  }
  function assertTSPropertySignature(node, opts) {
    assert("TSPropertySignature", node, opts);
  }
  function assertTSMethodSignature(node, opts) {
    assert("TSMethodSignature", node, opts);
  }
  function assertTSIndexSignature(node, opts) {
    assert("TSIndexSignature", node, opts);
  }
  function assertTSAnyKeyword(node, opts) {
    assert("TSAnyKeyword", node, opts);
  }
  function assertTSBooleanKeyword(node, opts) {
    assert("TSBooleanKeyword", node, opts);
  }
  function assertTSBigIntKeyword(node, opts) {
    assert("TSBigIntKeyword", node, opts);
  }
  function assertTSIntrinsicKeyword(node, opts) {
    assert("TSIntrinsicKeyword", node, opts);
  }
  function assertTSNeverKeyword(node, opts) {
    assert("TSNeverKeyword", node, opts);
  }
  function assertTSNullKeyword(node, opts) {
    assert("TSNullKeyword", node, opts);
  }
  function assertTSNumberKeyword(node, opts) {
    assert("TSNumberKeyword", node, opts);
  }
  function assertTSObjectKeyword(node, opts) {
    assert("TSObjectKeyword", node, opts);
  }
  function assertTSStringKeyword(node, opts) {
    assert("TSStringKeyword", node, opts);
  }
  function assertTSSymbolKeyword(node, opts) {
    assert("TSSymbolKeyword", node, opts);
  }
  function assertTSUndefinedKeyword(node, opts) {
    assert("TSUndefinedKeyword", node, opts);
  }
  function assertTSUnknownKeyword(node, opts) {
    assert("TSUnknownKeyword", node, opts);
  }
  function assertTSVoidKeyword(node, opts) {
    assert("TSVoidKeyword", node, opts);
  }
  function assertTSThisType(node, opts) {
    assert("TSThisType", node, opts);
  }
  function assertTSFunctionType(node, opts) {
    assert("TSFunctionType", node, opts);
  }
  function assertTSConstructorType(node, opts) {
    assert("TSConstructorType", node, opts);
  }
  function assertTSTypeReference(node, opts) {
    assert("TSTypeReference", node, opts);
  }
  function assertTSTypePredicate(node, opts) {
    assert("TSTypePredicate", node, opts);
  }
  function assertTSTypeQuery(node, opts) {
    assert("TSTypeQuery", node, opts);
  }
  function assertTSTypeLiteral(node, opts) {
    assert("TSTypeLiteral", node, opts);
  }
  function assertTSArrayType(node, opts) {
    assert("TSArrayType", node, opts);
  }
  function assertTSTupleType(node, opts) {
    assert("TSTupleType", node, opts);
  }
  function assertTSOptionalType(node, opts) {
    assert("TSOptionalType", node, opts);
  }
  function assertTSRestType(node, opts) {
    assert("TSRestType", node, opts);
  }
  function assertTSNamedTupleMember(node, opts) {
    assert("TSNamedTupleMember", node, opts);
  }
  function assertTSUnionType(node, opts) {
    assert("TSUnionType", node, opts);
  }
  function assertTSIntersectionType(node, opts) {
    assert("TSIntersectionType", node, opts);
  }
  function assertTSConditionalType(node, opts) {
    assert("TSConditionalType", node, opts);
  }
  function assertTSInferType(node, opts) {
    assert("TSInferType", node, opts);
  }
  function assertTSParenthesizedType(node, opts) {
    assert("TSParenthesizedType", node, opts);
  }
  function assertTSTypeOperator(node, opts) {
    assert("TSTypeOperator", node, opts);
  }
  function assertTSIndexedAccessType(node, opts) {
    assert("TSIndexedAccessType", node, opts);
  }
  function assertTSMappedType(node, opts) {
    assert("TSMappedType", node, opts);
  }
  function assertTSTemplateLiteralType(node, opts) {
    assert("TSTemplateLiteralType", node, opts);
  }
  function assertTSLiteralType(node, opts) {
    assert("TSLiteralType", node, opts);
  }
  function assertTSExpressionWithTypeArguments(node, opts) {
    assert("TSExpressionWithTypeArguments", node, opts);
  }
  function assertTSInterfaceDeclaration(node, opts) {
    assert("TSInterfaceDeclaration", node, opts);
  }
  function assertTSInterfaceBody(node, opts) {
    assert("TSInterfaceBody", node, opts);
  }
  function assertTSTypeAliasDeclaration(node, opts) {
    assert("TSTypeAliasDeclaration", node, opts);
  }
  function assertTSInstantiationExpression(node, opts) {
    assert("TSInstantiationExpression", node, opts);
  }
  function assertTSAsExpression(node, opts) {
    assert("TSAsExpression", node, opts);
  }
  function assertTSSatisfiesExpression(node, opts) {
    assert("TSSatisfiesExpression", node, opts);
  }
  function assertTSTypeAssertion(node, opts) {
    assert("TSTypeAssertion", node, opts);
  }
  function assertTSEnumBody(node, opts) {
    assert("TSEnumBody", node, opts);
  }
  function assertTSEnumDeclaration(node, opts) {
    assert("TSEnumDeclaration", node, opts);
  }
  function assertTSEnumMember(node, opts) {
    assert("TSEnumMember", node, opts);
  }
  function assertTSModuleDeclaration(node, opts) {
    assert("TSModuleDeclaration", node, opts);
  }
  function assertTSModuleBlock(node, opts) {
    assert("TSModuleBlock", node, opts);
  }
  function assertTSImportType(node, opts) {
    assert("TSImportType", node, opts);
  }
  function assertTSImportEqualsDeclaration(node, opts) {
    assert("TSImportEqualsDeclaration", node, opts);
  }
  function assertTSExternalModuleReference(node, opts) {
    assert("TSExternalModuleReference", node, opts);
  }
  function assertTSNonNullExpression(node, opts) {
    assert("TSNonNullExpression", node, opts);
  }
  function assertTSExportAssignment(node, opts) {
    assert("TSExportAssignment", node, opts);
  }
  function assertTSNamespaceExportDeclaration(node, opts) {
    assert("TSNamespaceExportDeclaration", node, opts);
  }
  function assertTSTypeAnnotation(node, opts) {
    assert("TSTypeAnnotation", node, opts);
  }
  function assertTSTypeParameterInstantiation(node, opts) {
    assert("TSTypeParameterInstantiation", node, opts);
  }
  function assertTSTypeParameterDeclaration(node, opts) {
    assert("TSTypeParameterDeclaration", node, opts);
  }
  function assertTSTypeParameter(node, opts) {
    assert("TSTypeParameter", node, opts);
  }
  function assertStandardized(node, opts) {
    assert("Standardized", node, opts);
  }
  function assertExpression(node, opts) {
    assert("Expression", node, opts);
  }
  function assertBinary(node, opts) {
    assert("Binary", node, opts);
  }
  function assertScopable(node, opts) {
    assert("Scopable", node, opts);
  }
  function assertBlockParent(node, opts) {
    assert("BlockParent", node, opts);
  }
  function assertBlock(node, opts) {
    assert("Block", node, opts);
  }
  function assertStatement(node, opts) {
    assert("Statement", node, opts);
  }
  function assertTerminatorless(node, opts) {
    assert("Terminatorless", node, opts);
  }
  function assertCompletionStatement(node, opts) {
    assert("CompletionStatement", node, opts);
  }
  function assertConditional(node, opts) {
    assert("Conditional", node, opts);
  }
  function assertLoop(node, opts) {
    assert("Loop", node, opts);
  }
  function assertWhile(node, opts) {
    assert("While", node, opts);
  }
  function assertExpressionWrapper(node, opts) {
    assert("ExpressionWrapper", node, opts);
  }
  function assertFor(node, opts) {
    assert("For", node, opts);
  }
  function assertForXStatement(node, opts) {
    assert("ForXStatement", node, opts);
  }
  function assertFunction(node, opts) {
    assert("Function", node, opts);
  }
  function assertFunctionParent(node, opts) {
    assert("FunctionParent", node, opts);
  }
  function assertPureish(node, opts) {
    assert("Pureish", node, opts);
  }
  function assertDeclaration(node, opts) {
    assert("Declaration", node, opts);
  }
  function assertPatternLike(node, opts) {
    assert("PatternLike", node, opts);
  }
  function assertLVal(node, opts) {
    assert("LVal", node, opts);
  }
  function assertTSEntityName(node, opts) {
    assert("TSEntityName", node, opts);
  }
  function assertLiteral(node, opts) {
    assert("Literal", node, opts);
  }
  function assertImmutable(node, opts) {
    assert("Immutable", node, opts);
  }
  function assertUserWhitespacable(node, opts) {
    assert("UserWhitespacable", node, opts);
  }
  function assertMethod(node, opts) {
    assert("Method", node, opts);
  }
  function assertObjectMember(node, opts) {
    assert("ObjectMember", node, opts);
  }
  function assertProperty(node, opts) {
    assert("Property", node, opts);
  }
  function assertUnaryLike(node, opts) {
    assert("UnaryLike", node, opts);
  }
  function assertPattern(node, opts) {
    assert("Pattern", node, opts);
  }
  function assertClass(node, opts) {
    assert("Class", node, opts);
  }
  function assertImportOrExportDeclaration(node, opts) {
    assert("ImportOrExportDeclaration", node, opts);
  }
  function assertExportDeclaration(node, opts) {
    assert("ExportDeclaration", node, opts);
  }
  function assertModuleSpecifier(node, opts) {
    assert("ModuleSpecifier", node, opts);
  }
  function assertAccessor(node, opts) {
    assert("Accessor", node, opts);
  }
  function assertPrivate(node, opts) {
    assert("Private", node, opts);
  }
  function assertFlow(node, opts) {
    assert("Flow", node, opts);
  }
  function assertFlowType(node, opts) {
    assert("FlowType", node, opts);
  }
  function assertFlowBaseAnnotation(node, opts) {
    assert("FlowBaseAnnotation", node, opts);
  }
  function assertFlowDeclaration(node, opts) {
    assert("FlowDeclaration", node, opts);
  }
  function assertFlowPredicate(node, opts) {
    assert("FlowPredicate", node, opts);
  }
  function assertEnumBody(node, opts) {
    assert("EnumBody", node, opts);
  }
  function assertEnumMember(node, opts) {
    assert("EnumMember", node, opts);
  }
  function assertJSX(node, opts) {
    assert("JSX", node, opts);
  }
  function assertMiscellaneous(node, opts) {
    assert("Miscellaneous", node, opts);
  }
  function assertTypeScript(node, opts) {
    assert("TypeScript", node, opts);
  }
  function assertTSTypeElement(node, opts) {
    assert("TSTypeElement", node, opts);
  }
  function assertTSType(node, opts) {
    assert("TSType", node, opts);
  }
  function assertTSBaseType(node, opts) {
    assert("TSBaseType", node, opts);
  }
  function assertNumberLiteral(node, opts) {
    (0, _deprecationWarning["default"])("assertNumberLiteral", "assertNumericLiteral");
    assert("NumberLiteral", node, opts);
  }
  function assertRegexLiteral(node, opts) {
    (0, _deprecationWarning["default"])("assertRegexLiteral", "assertRegExpLiteral");
    assert("RegexLiteral", node, opts);
  }
  function assertRestProperty(node, opts) {
    (0, _deprecationWarning["default"])("assertRestProperty", "assertRestElement");
    assert("RestProperty", node, opts);
  }
  function assertSpreadProperty(node, opts) {
    (0, _deprecationWarning["default"])("assertSpreadProperty", "assertSpreadElement");
    assert("SpreadProperty", node, opts);
  }
  function assertModuleDeclaration(node, opts) {
    (0, _deprecationWarning["default"])("assertModuleDeclaration", "assertImportOrExportDeclaration");
    assert("ModuleDeclaration", node, opts);
  }
  return generated$1;
}

var createTypeAnnotationBasedOnTypeof = {};

var hasRequiredCreateTypeAnnotationBasedOnTypeof;
function requireCreateTypeAnnotationBasedOnTypeof() {
  if (hasRequiredCreateTypeAnnotationBasedOnTypeof) return createTypeAnnotationBasedOnTypeof;
  hasRequiredCreateTypeAnnotationBasedOnTypeof = 1;
  Object.defineProperty(createTypeAnnotationBasedOnTypeof, "__esModule", {
    value: true
  });
  createTypeAnnotationBasedOnTypeof["default"] = void 0;
  var _index = requireGenerated$2();
  createTypeAnnotationBasedOnTypeof["default"] = createTypeAnnotationBasedOnTypeof$1;
  function createTypeAnnotationBasedOnTypeof$1(type) {
    switch (type) {
      case "string":
        return (0, _index.stringTypeAnnotation)();
      case "number":
        return (0, _index.numberTypeAnnotation)();
      case "undefined":
        return (0, _index.voidTypeAnnotation)();
      case "boolean":
        return (0, _index.booleanTypeAnnotation)();
      case "function":
        return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Function"));
      case "object":
        return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Object"));
      case "symbol":
        return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Symbol"));
      case "bigint":
        return (0, _index.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + type);
  }
  return createTypeAnnotationBasedOnTypeof;
}

var createFlowUnionType = {};

var removeTypeDuplicates$1 = {};

var hasRequiredRemoveTypeDuplicates$1;
function requireRemoveTypeDuplicates$1() {
  if (hasRequiredRemoveTypeDuplicates$1) return removeTypeDuplicates$1;
  hasRequiredRemoveTypeDuplicates$1 = 1;
  Object.defineProperty(removeTypeDuplicates$1, "__esModule", {
    value: true
  });
  removeTypeDuplicates$1["default"] = removeTypeDuplicates;
  var _index = requireGenerated$3();
  function getQualifiedName(node) {
    return (0, _index.isIdentifier)(node) ? node.name : "".concat(node.id.name, ".").concat(getQualifiedName(node.qualification));
  }
  function removeTypeDuplicates(nodesIn) {
    var nodes = Array.from(nodesIn);
    var generics = new Map();
    var bases = new Map();
    var typeGroups = new Set();
    var types = [];
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (!node) continue;
      if (types.includes(node)) {
        continue;
      }
      if ((0, _index.isAnyTypeAnnotation)(node)) {
        return [node];
      }
      if ((0, _index.isFlowBaseAnnotation)(node)) {
        bases.set(node.type, node);
        continue;
      }
      if ((0, _index.isUnionTypeAnnotation)(node)) {
        if (!typeGroups.has(node.types)) {
          nodes.push.apply(nodes, _toConsumableArray(node.types));
          typeGroups.add(node.types);
        }
        continue;
      }
      if ((0, _index.isGenericTypeAnnotation)(node)) {
        var name = getQualifiedName(node.id);
        if (generics.has(name)) {
          var existing = generics.get(name);
          if (existing.typeParameters) {
            if (node.typeParameters) {
              var _existing$typeParamet;
              (_existing$typeParamet = existing.typeParameters.params).push.apply(_existing$typeParamet, _toConsumableArray(node.typeParameters.params));
              existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);
            }
          } else {
            existing = node.typeParameters;
          }
        } else {
          generics.set(name, node);
        }
        continue;
      }
      types.push(node);
    }
    var _iterator = _createForOfIteratorHelper(bases),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = _slicedToArray(_step.value, 2),
          baseType = _step$value[1];
        types.push(baseType);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var _iterator2 = _createForOfIteratorHelper(generics),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _step2$value = _slicedToArray(_step2.value, 2),
          genericName = _step2$value[1];
        types.push(genericName);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return types;
  }
  return removeTypeDuplicates$1;
}

var hasRequiredCreateFlowUnionType;
function requireCreateFlowUnionType() {
  if (hasRequiredCreateFlowUnionType) return createFlowUnionType;
  hasRequiredCreateFlowUnionType = 1;
  Object.defineProperty(createFlowUnionType, "__esModule", {
    value: true
  });
  createFlowUnionType["default"] = createFlowUnionType$1;
  var _index = requireGenerated$2();
  var _removeTypeDuplicates = requireRemoveTypeDuplicates$1();
  function createFlowUnionType$1(types) {
    var flattened = (0, _removeTypeDuplicates["default"])(types);
    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return (0, _index.unionTypeAnnotation)(flattened);
    }
  }
  return createFlowUnionType;
}

var createTSUnionType = {};

var removeTypeDuplicates = {};

var hasRequiredRemoveTypeDuplicates;
function requireRemoveTypeDuplicates() {
  if (hasRequiredRemoveTypeDuplicates) return removeTypeDuplicates;
  hasRequiredRemoveTypeDuplicates = 1;
  Object.defineProperty(removeTypeDuplicates, "__esModule", {
    value: true
  });
  removeTypeDuplicates["default"] = removeTypeDuplicates$1;
  var _index = requireGenerated$3();
  function getQualifiedName(node) {
    return (0, _index.isIdentifier)(node) ? node.name : (0, _index.isThisExpression)(node) ? "this" : "".concat(node.right.name, ".").concat(getQualifiedName(node.left));
  }
  function removeTypeDuplicates$1(nodesIn) {
    var nodes = Array.from(nodesIn);
    var generics = new Map();
    var bases = new Map();
    var typeGroups = new Set();
    var types = [];
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (!node) continue;
      if (types.includes(node)) {
        continue;
      }
      if ((0, _index.isTSAnyKeyword)(node)) {
        return [node];
      }
      if ((0, _index.isTSBaseType)(node)) {
        bases.set(node.type, node);
        continue;
      }
      if ((0, _index.isTSUnionType)(node)) {
        if (!typeGroups.has(node.types)) {
          nodes.push.apply(nodes, _toConsumableArray(node.types));
          typeGroups.add(node.types);
        }
        continue;
      }
      var typeArgumentsKey = "typeParameters";
      if ((0, _index.isTSTypeReference)(node) && node[typeArgumentsKey]) {
        var typeArguments = node[typeArgumentsKey];
        var name = getQualifiedName(node.typeName);
        if (generics.has(name)) {
          var existing = generics.get(name);
          var existingTypeArguments = existing[typeArgumentsKey];
          if (existingTypeArguments) {
            var _existingTypeArgument;
            (_existingTypeArgument = existingTypeArguments.params).push.apply(_existingTypeArgument, _toConsumableArray(typeArguments.params));
            existingTypeArguments.params = removeTypeDuplicates$1(existingTypeArguments.params);
          } else {
            existing = typeArguments;
          }
        } else {
          generics.set(name, node);
        }
        continue;
      }
      types.push(node);
    }
    var _iterator = _createForOfIteratorHelper(bases),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = _slicedToArray(_step.value, 2),
          baseType = _step$value[1];
        types.push(baseType);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var _iterator2 = _createForOfIteratorHelper(generics),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _step2$value = _slicedToArray(_step2.value, 2),
          genericName = _step2$value[1];
        types.push(genericName);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return types;
  }
  return removeTypeDuplicates;
}

var hasRequiredCreateTSUnionType;
function requireCreateTSUnionType() {
  if (hasRequiredCreateTSUnionType) return createTSUnionType;
  hasRequiredCreateTSUnionType = 1;
  Object.defineProperty(createTSUnionType, "__esModule", {
    value: true
  });
  createTSUnionType["default"] = createTSUnionType$1;
  var _index = requireGenerated$2();
  var _removeTypeDuplicates = requireRemoveTypeDuplicates();
  var _index2 = requireGenerated$3();
  function createTSUnionType$1(typeAnnotations) {
    var types = typeAnnotations.map(function (type) {
      return (0, _index2.isTSTypeAnnotation)(type) ? type.typeAnnotation : type;
    });
    var flattened = (0, _removeTypeDuplicates["default"])(types);
    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return (0, _index.tsUnionType)(flattened);
    }
  }
  return createTSUnionType;
}

var productions = {};

var hasRequiredProductions;
function requireProductions() {
  if (hasRequiredProductions) return productions;
  hasRequiredProductions = 1;
  Object.defineProperty(productions, "__esModule", {
    value: true
  });
  productions.buildUndefinedNode = buildUndefinedNode;
  var _index = requireGenerated$2();
  function buildUndefinedNode() {
    return (0, _index.unaryExpression)("void", (0, _index.numericLiteral)(0), true);
  }
  return productions;
}

var cloneNode = {};

var hasRequiredCloneNode;
function requireCloneNode() {
  if (hasRequiredCloneNode) return cloneNode;
  hasRequiredCloneNode = 1;
  Object.defineProperty(cloneNode, "__esModule", {
    value: true
  });
  cloneNode["default"] = cloneNode$1;
  var _index = requireDefinitions();
  var _index2 = requireGenerated$3();
  var _hasOwn = {
      hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
    },
    hasOwn = _hasOwn.hasOwn;
  function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
    if (obj && typeof obj.type === "string") {
      return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
    }
    return obj;
  }
  function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
    if (Array.isArray(obj)) {
      return obj.map(function (node) {
        return cloneIfNode(node, deep, withoutLoc, commentsCache);
      });
    }
    return cloneIfNode(obj, deep, withoutLoc, commentsCache);
  }
  function cloneNode$1(node) {
    var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var withoutLoc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    return cloneNodeInternal(node, deep, withoutLoc, new Map());
  }
  function cloneNodeInternal(node) {
    var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var withoutLoc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var commentsCache = arguments.length > 3 ? arguments[3] : undefined;
    if (!node) return node;
    var type = node.type;
    var newNode = {
      type: node.type
    };
    if ((0, _index2.isIdentifier)(node)) {
      newNode.name = node.name;
      if (hasOwn(node, "optional") && typeof node.optional === "boolean") {
        newNode.optional = node.optional;
      }
      if (hasOwn(node, "typeAnnotation")) {
        newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc, commentsCache) : node.typeAnnotation;
      }
      if (hasOwn(node, "decorators")) {
        newNode.decorators = deep ? cloneIfNodeOrArray(node.decorators, true, withoutLoc, commentsCache) : node.decorators;
      }
    } else if (!hasOwn(_index.NODE_FIELDS, type)) {
      throw new Error("Unknown node type: \"".concat(type, "\""));
    } else {
      for (var _i = 0, _Object$keys = Object.keys(_index.NODE_FIELDS[type]); _i < _Object$keys.length; _i++) {
        var field = _Object$keys[_i];
        if (hasOwn(node, field)) {
          if (deep) {
            newNode[field] = (0, _index2.isFile)(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node[field], true, withoutLoc, commentsCache);
          } else {
            newNode[field] = node[field];
          }
        }
      }
    }
    if (hasOwn(node, "loc")) {
      if (withoutLoc) {
        newNode.loc = null;
      } else {
        newNode.loc = node.loc;
      }
    }
    if (hasOwn(node, "leadingComments")) {
      newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache);
    }
    if (hasOwn(node, "innerComments")) {
      newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache);
    }
    if (hasOwn(node, "trailingComments")) {
      newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache);
    }
    if (hasOwn(node, "extra")) {
      newNode.extra = Object.assign({}, node.extra);
    }
    return newNode;
  }
  function maybeCloneComments(comments, deep, withoutLoc, commentsCache) {
    if (!comments || !deep) {
      return comments;
    }
    return comments.map(function (comment) {
      var cache = commentsCache.get(comment);
      if (cache) return cache;
      var type = comment.type,
        value = comment.value,
        loc = comment.loc;
      var ret = {
        type: type,
        value: value,
        loc: loc
      };
      if (withoutLoc) {
        ret.loc = null;
      }
      commentsCache.set(comment, ret);
      return ret;
    });
  }
  return cloneNode;
}

var clone = {};

var hasRequiredClone;
function requireClone() {
  if (hasRequiredClone) return clone;
  hasRequiredClone = 1;
  Object.defineProperty(clone, "__esModule", {
    value: true
  });
  clone["default"] = clone$1;
  var _cloneNode = requireCloneNode();
  function clone$1(node) {
    return (0, _cloneNode["default"])(node, false);
  }
  return clone;
}

var cloneDeep = {};

var hasRequiredCloneDeep;
function requireCloneDeep() {
  if (hasRequiredCloneDeep) return cloneDeep;
  hasRequiredCloneDeep = 1;
  Object.defineProperty(cloneDeep, "__esModule", {
    value: true
  });
  cloneDeep["default"] = cloneDeep$1;
  var _cloneNode = requireCloneNode();
  function cloneDeep$1(node) {
    return (0, _cloneNode["default"])(node);
  }
  return cloneDeep;
}

var cloneDeepWithoutLoc = {};

var hasRequiredCloneDeepWithoutLoc;
function requireCloneDeepWithoutLoc() {
  if (hasRequiredCloneDeepWithoutLoc) return cloneDeepWithoutLoc;
  hasRequiredCloneDeepWithoutLoc = 1;
  Object.defineProperty(cloneDeepWithoutLoc, "__esModule", {
    value: true
  });
  cloneDeepWithoutLoc["default"] = cloneDeepWithoutLoc$1;
  var _cloneNode = requireCloneNode();
  function cloneDeepWithoutLoc$1(node) {
    return (0, _cloneNode["default"])(node, true, true);
  }
  return cloneDeepWithoutLoc;
}

var cloneWithoutLoc = {};

var hasRequiredCloneWithoutLoc;
function requireCloneWithoutLoc() {
  if (hasRequiredCloneWithoutLoc) return cloneWithoutLoc;
  hasRequiredCloneWithoutLoc = 1;
  Object.defineProperty(cloneWithoutLoc, "__esModule", {
    value: true
  });
  cloneWithoutLoc["default"] = cloneWithoutLoc$1;
  var _cloneNode = requireCloneNode();
  function cloneWithoutLoc$1(node) {
    return (0, _cloneNode["default"])(node, false, true);
  }
  return cloneWithoutLoc;
}

var addComment = {};

var addComments = {};

var hasRequiredAddComments;
function requireAddComments() {
  if (hasRequiredAddComments) return addComments;
  hasRequiredAddComments = 1;
  Object.defineProperty(addComments, "__esModule", {
    value: true
  });
  addComments["default"] = addComments$1;
  function addComments$1(node, type, comments) {
    if (!comments || !node) return node;
    var key = "".concat(type, "Comments");
    if (node[key]) {
      if (type === "leading") {
        node[key] = comments.concat(node[key]);
      } else {
        var _node$key;
        (_node$key = node[key]).push.apply(_node$key, _toConsumableArray(comments));
      }
    } else {
      node[key] = comments;
    }
    return node;
  }
  return addComments;
}

var hasRequiredAddComment;
function requireAddComment() {
  if (hasRequiredAddComment) return addComment;
  hasRequiredAddComment = 1;
  Object.defineProperty(addComment, "__esModule", {
    value: true
  });
  addComment["default"] = addComment$1;
  var _addComments = requireAddComments();
  function addComment$1(node, type, content, line) {
    return (0, _addComments["default"])(node, type, [{
      type: line ? "CommentLine" : "CommentBlock",
      value: content
    }]);
  }
  return addComment;
}

var inheritInnerComments = {};

var inherit = {};

var hasRequiredInherit;
function requireInherit() {
  if (hasRequiredInherit) return inherit;
  hasRequiredInherit = 1;
  Object.defineProperty(inherit, "__esModule", {
    value: true
  });
  inherit["default"] = inherit$1;
  function inherit$1(key, child, parent) {
    if (child && parent) {
      child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
    }
  }
  return inherit;
}

var hasRequiredInheritInnerComments;
function requireInheritInnerComments() {
  if (hasRequiredInheritInnerComments) return inheritInnerComments;
  hasRequiredInheritInnerComments = 1;
  Object.defineProperty(inheritInnerComments, "__esModule", {
    value: true
  });
  inheritInnerComments["default"] = inheritInnerComments$1;
  var _inherit = requireInherit();
  function inheritInnerComments$1(child, parent) {
    (0, _inherit["default"])("innerComments", child, parent);
  }
  return inheritInnerComments;
}

var inheritLeadingComments = {};

var hasRequiredInheritLeadingComments;
function requireInheritLeadingComments() {
  if (hasRequiredInheritLeadingComments) return inheritLeadingComments;
  hasRequiredInheritLeadingComments = 1;
  Object.defineProperty(inheritLeadingComments, "__esModule", {
    value: true
  });
  inheritLeadingComments["default"] = inheritLeadingComments$1;
  var _inherit = requireInherit();
  function inheritLeadingComments$1(child, parent) {
    (0, _inherit["default"])("leadingComments", child, parent);
  }
  return inheritLeadingComments;
}

var inheritsComments = {};

var inheritTrailingComments = {};

var hasRequiredInheritTrailingComments;
function requireInheritTrailingComments() {
  if (hasRequiredInheritTrailingComments) return inheritTrailingComments;
  hasRequiredInheritTrailingComments = 1;
  Object.defineProperty(inheritTrailingComments, "__esModule", {
    value: true
  });
  inheritTrailingComments["default"] = inheritTrailingComments$1;
  var _inherit = requireInherit();
  function inheritTrailingComments$1(child, parent) {
    (0, _inherit["default"])("trailingComments", child, parent);
  }
  return inheritTrailingComments;
}

var hasRequiredInheritsComments;
function requireInheritsComments() {
  if (hasRequiredInheritsComments) return inheritsComments;
  hasRequiredInheritsComments = 1;
  Object.defineProperty(inheritsComments, "__esModule", {
    value: true
  });
  inheritsComments["default"] = inheritsComments$1;
  var _inheritTrailingComments = requireInheritTrailingComments();
  var _inheritLeadingComments = requireInheritLeadingComments();
  var _inheritInnerComments = requireInheritInnerComments();
  function inheritsComments$1(child, parent) {
    (0, _inheritTrailingComments["default"])(child, parent);
    (0, _inheritLeadingComments["default"])(child, parent);
    (0, _inheritInnerComments["default"])(child, parent);
    return child;
  }
  return inheritsComments;
}

var removeComments = {};

var hasRequiredRemoveComments;
function requireRemoveComments() {
  if (hasRequiredRemoveComments) return removeComments;
  hasRequiredRemoveComments = 1;
  Object.defineProperty(removeComments, "__esModule", {
    value: true
  });
  removeComments["default"] = removeComments$1;
  var _index = requireConstants();
  function removeComments$1(node) {
    _index.COMMENT_KEYS.forEach(function (key) {
      node[key] = null;
    });
    return node;
  }
  return removeComments;
}

var generated = {};

var hasRequiredGenerated;
function requireGenerated() {
  if (hasRequiredGenerated) return generated;
  hasRequiredGenerated = 1;
  Object.defineProperty(generated, "__esModule", {
    value: true
  });
  generated.WHILE_TYPES = generated.USERWHITESPACABLE_TYPES = generated.UNARYLIKE_TYPES = generated.TYPESCRIPT_TYPES = generated.TSTYPE_TYPES = generated.TSTYPEELEMENT_TYPES = generated.TSENTITYNAME_TYPES = generated.TSBASETYPE_TYPES = generated.TERMINATORLESS_TYPES = generated.STATEMENT_TYPES = generated.STANDARDIZED_TYPES = generated.SCOPABLE_TYPES = generated.PUREISH_TYPES = generated.PROPERTY_TYPES = generated.PRIVATE_TYPES = generated.PATTERN_TYPES = generated.PATTERNLIKE_TYPES = generated.OBJECTMEMBER_TYPES = generated.MODULESPECIFIER_TYPES = generated.MODULEDECLARATION_TYPES = generated.MISCELLANEOUS_TYPES = generated.METHOD_TYPES = generated.LVAL_TYPES = generated.LOOP_TYPES = generated.LITERAL_TYPES = generated.JSX_TYPES = generated.IMPORTOREXPORTDECLARATION_TYPES = generated.IMMUTABLE_TYPES = generated.FUNCTION_TYPES = generated.FUNCTIONPARENT_TYPES = generated.FOR_TYPES = generated.FORXSTATEMENT_TYPES = generated.FLOW_TYPES = generated.FLOWTYPE_TYPES = generated.FLOWPREDICATE_TYPES = generated.FLOWDECLARATION_TYPES = generated.FLOWBASEANNOTATION_TYPES = generated.EXPRESSION_TYPES = generated.EXPRESSIONWRAPPER_TYPES = generated.EXPORTDECLARATION_TYPES = generated.ENUMMEMBER_TYPES = generated.ENUMBODY_TYPES = generated.DECLARATION_TYPES = generated.CONDITIONAL_TYPES = generated.COMPLETIONSTATEMENT_TYPES = generated.CLASS_TYPES = generated.BLOCK_TYPES = generated.BLOCKPARENT_TYPES = generated.BINARY_TYPES = generated.ACCESSOR_TYPES = void 0;
  var _index = requireDefinitions();
  generated.STANDARDIZED_TYPES = _index.FLIPPED_ALIAS_KEYS["Standardized"];
  generated.EXPRESSION_TYPES = _index.FLIPPED_ALIAS_KEYS["Expression"];
  generated.BINARY_TYPES = _index.FLIPPED_ALIAS_KEYS["Binary"];
  generated.SCOPABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Scopable"];
  generated.BLOCKPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["BlockParent"];
  generated.BLOCK_TYPES = _index.FLIPPED_ALIAS_KEYS["Block"];
  generated.STATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["Statement"];
  generated.TERMINATORLESS_TYPES = _index.FLIPPED_ALIAS_KEYS["Terminatorless"];
  generated.COMPLETIONSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["CompletionStatement"];
  generated.CONDITIONAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Conditional"];
  generated.LOOP_TYPES = _index.FLIPPED_ALIAS_KEYS["Loop"];
  generated.WHILE_TYPES = _index.FLIPPED_ALIAS_KEYS["While"];
  generated.EXPRESSIONWRAPPER_TYPES = _index.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
  generated.FOR_TYPES = _index.FLIPPED_ALIAS_KEYS["For"];
  generated.FORXSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["ForXStatement"];
  generated.FUNCTION_TYPES = _index.FLIPPED_ALIAS_KEYS["Function"];
  generated.FUNCTIONPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["FunctionParent"];
  generated.PUREISH_TYPES = _index.FLIPPED_ALIAS_KEYS["Pureish"];
  generated.DECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["Declaration"];
  generated.PATTERNLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["PatternLike"];
  generated.LVAL_TYPES = _index.FLIPPED_ALIAS_KEYS["LVal"];
  generated.TSENTITYNAME_TYPES = _index.FLIPPED_ALIAS_KEYS["TSEntityName"];
  generated.LITERAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Literal"];
  generated.IMMUTABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Immutable"];
  generated.USERWHITESPACABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
  generated.METHOD_TYPES = _index.FLIPPED_ALIAS_KEYS["Method"];
  generated.OBJECTMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["ObjectMember"];
  generated.PROPERTY_TYPES = _index.FLIPPED_ALIAS_KEYS["Property"];
  generated.UNARYLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["UnaryLike"];
  generated.PATTERN_TYPES = _index.FLIPPED_ALIAS_KEYS["Pattern"];
  generated.CLASS_TYPES = _index.FLIPPED_ALIAS_KEYS["Class"];
  var IMPORTOREXPORTDECLARATION_TYPES = generated.IMPORTOREXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ImportOrExportDeclaration"];
  generated.EXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
  generated.MODULESPECIFIER_TYPES = _index.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
  generated.ACCESSOR_TYPES = _index.FLIPPED_ALIAS_KEYS["Accessor"];
  generated.PRIVATE_TYPES = _index.FLIPPED_ALIAS_KEYS["Private"];
  generated.FLOW_TYPES = _index.FLIPPED_ALIAS_KEYS["Flow"];
  generated.FLOWTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowType"];
  generated.FLOWBASEANNOTATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
  generated.FLOWDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
  generated.FLOWPREDICATE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowPredicate"];
  generated.ENUMBODY_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumBody"];
  generated.ENUMMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumMember"];
  generated.JSX_TYPES = _index.FLIPPED_ALIAS_KEYS["JSX"];
  generated.MISCELLANEOUS_TYPES = _index.FLIPPED_ALIAS_KEYS["Miscellaneous"];
  generated.TYPESCRIPT_TYPES = _index.FLIPPED_ALIAS_KEYS["TypeScript"];
  generated.TSTYPEELEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["TSTypeElement"];
  generated.TSTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSType"];
  generated.TSBASETYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSBaseType"];
  generated.MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
  return generated;
}

var ensureBlock = {};

var toBlock = {};

var hasRequiredToBlock;
function requireToBlock() {
  if (hasRequiredToBlock) return toBlock;
  hasRequiredToBlock = 1;
  Object.defineProperty(toBlock, "__esModule", {
    value: true
  });
  toBlock["default"] = toBlock$1;
  var _index = requireGenerated$3();
  var _index2 = requireGenerated$2();
  function toBlock$1(node, parent) {
    if ((0, _index.isBlockStatement)(node)) {
      return node;
    }
    var blockNodes = [];
    if ((0, _index.isEmptyStatement)(node)) {
      blockNodes = [];
    } else {
      if (!(0, _index.isStatement)(node)) {
        if ((0, _index.isFunction)(parent)) {
          node = (0, _index2.returnStatement)(node);
        } else {
          node = (0, _index2.expressionStatement)(node);
        }
      }
      blockNodes = [node];
    }
    return (0, _index2.blockStatement)(blockNodes);
  }
  return toBlock;
}

var hasRequiredEnsureBlock;
function requireEnsureBlock() {
  if (hasRequiredEnsureBlock) return ensureBlock;
  hasRequiredEnsureBlock = 1;
  Object.defineProperty(ensureBlock, "__esModule", {
    value: true
  });
  ensureBlock["default"] = ensureBlock$1;
  var _toBlock = requireToBlock();
  function ensureBlock$1(node) {
    var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "body";
    var result = (0, _toBlock["default"])(node[key], node);
    node[key] = result;
    return result;
  }
  return ensureBlock;
}

var toBindingIdentifierName = {};

var toIdentifier = {};

var hasRequiredToIdentifier;
function requireToIdentifier() {
  if (hasRequiredToIdentifier) return toIdentifier;
  hasRequiredToIdentifier = 1;
  Object.defineProperty(toIdentifier, "__esModule", {
    value: true
  });
  toIdentifier["default"] = toIdentifier$1;
  var _isValidIdentifier = requireIsValidIdentifier();
  var _helperValidatorIdentifier = requireLib$6();
  function toIdentifier$1(input) {
    input = input + "";
    var name = "";
    var _iterator = _createForOfIteratorHelper(input),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var c = _step.value;
        name += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : "-";
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    name = name.replace(/^[-0-9]+/, "");
    name = name.replace(/[-\s]+(.)?/g, function (match, c) {
      return c ? c.toUpperCase() : "";
    });
    if (!(0, _isValidIdentifier["default"])(name)) {
      name = "_".concat(name);
    }
    return name || "_";
  }
  return toIdentifier;
}

var hasRequiredToBindingIdentifierName;
function requireToBindingIdentifierName() {
  if (hasRequiredToBindingIdentifierName) return toBindingIdentifierName;
  hasRequiredToBindingIdentifierName = 1;
  Object.defineProperty(toBindingIdentifierName, "__esModule", {
    value: true
  });
  toBindingIdentifierName["default"] = toBindingIdentifierName$1;
  var _toIdentifier = requireToIdentifier();
  function toBindingIdentifierName$1(name) {
    name = (0, _toIdentifier["default"])(name);
    if (name === "eval" || name === "arguments") name = "_" + name;
    return name;
  }
  return toBindingIdentifierName;
}

var toComputedKey = {};

var hasRequiredToComputedKey;
function requireToComputedKey() {
  if (hasRequiredToComputedKey) return toComputedKey;
  hasRequiredToComputedKey = 1;
  Object.defineProperty(toComputedKey, "__esModule", {
    value: true
  });
  toComputedKey["default"] = toComputedKey$1;
  var _index = requireGenerated$3();
  var _index2 = requireGenerated$2();
  function toComputedKey$1(node) {
    var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node.key || node.property;
    if (!node.computed && (0, _index.isIdentifier)(key)) key = (0, _index2.stringLiteral)(key.name);
    return key;
  }
  return toComputedKey;
}

var toExpression = {};

var hasRequiredToExpression;
function requireToExpression() {
  if (hasRequiredToExpression) return toExpression;
  hasRequiredToExpression = 1;
  Object.defineProperty(toExpression, "__esModule", {
    value: true
  });
  toExpression["default"] = void 0;
  var _index = requireGenerated$3();
  toExpression["default"] = toExpression$1;
  function toExpression$1(node) {
    if ((0, _index.isExpressionStatement)(node)) {
      node = node.expression;
    }
    if ((0, _index.isExpression)(node)) {
      return node;
    }
    if ((0, _index.isClass)(node)) {
      node.type = "ClassExpression";
    } else if ((0, _index.isFunction)(node)) {
      node.type = "FunctionExpression";
    }
    if (!(0, _index.isExpression)(node)) {
      throw new Error("cannot turn ".concat(node.type, " to an expression"));
    }
    return node;
  }
  return toExpression;
}

var toKeyAlias = {};

var removePropertiesDeep = {};

var traverseFast = {};

var hasRequiredTraverseFast;
function requireTraverseFast() {
  if (hasRequiredTraverseFast) return traverseFast;
  hasRequiredTraverseFast = 1;
  Object.defineProperty(traverseFast, "__esModule", {
    value: true
  });
  traverseFast["default"] = traverseFast$1;
  var _index = requireDefinitions();
  function traverseFast$1(node, enter, opts) {
    if (!node) return;
    var keys = _index.VISITOR_KEYS[node.type];
    if (!keys) return;
    opts = opts || {};
    enter(node, opts);
    var _iterator = _createForOfIteratorHelper(keys),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var key = _step.value;
        var subNode = node[key];
        if (Array.isArray(subNode)) {
          var _iterator2 = _createForOfIteratorHelper(subNode),
            _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var _node = _step2.value;
              traverseFast$1(_node, enter, opts);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        } else {
          traverseFast$1(subNode, enter, opts);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  return traverseFast;
}

var removeProperties = {};

var hasRequiredRemoveProperties;
function requireRemoveProperties() {
  if (hasRequiredRemoveProperties) return removeProperties;
  hasRequiredRemoveProperties = 1;
  Object.defineProperty(removeProperties, "__esModule", {
    value: true
  });
  removeProperties["default"] = removeProperties$1;
  var _index = requireConstants();
  var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
  var CLEAR_KEYS_PLUS_COMMENTS = [].concat(_toConsumableArray(_index.COMMENT_KEYS), ["comments"], CLEAR_KEYS);
  function removeProperties$1(node) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
    var _iterator = _createForOfIteratorHelper(map),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _key = _step.value;
        if (node[_key] != null) node[_key] = undefined;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    for (var _i = 0, _Object$keys = Object.keys(node); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      if (key[0] === "_" && node[key] != null) node[key] = undefined;
    }
    var symbols = Object.getOwnPropertySymbols(node);
    var _iterator2 = _createForOfIteratorHelper(symbols),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var sym = _step2.value;
        node[sym] = null;
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  return removeProperties;
}

var hasRequiredRemovePropertiesDeep;
function requireRemovePropertiesDeep() {
  if (hasRequiredRemovePropertiesDeep) return removePropertiesDeep;
  hasRequiredRemovePropertiesDeep = 1;
  Object.defineProperty(removePropertiesDeep, "__esModule", {
    value: true
  });
  removePropertiesDeep["default"] = removePropertiesDeep$1;
  var _traverseFast = requireTraverseFast();
  var _removeProperties = requireRemoveProperties();
  function removePropertiesDeep$1(tree, opts) {
    (0, _traverseFast["default"])(tree, _removeProperties["default"], opts);
    return tree;
  }
  return removePropertiesDeep;
}

var hasRequiredToKeyAlias;
function requireToKeyAlias() {
  if (hasRequiredToKeyAlias) return toKeyAlias;
  hasRequiredToKeyAlias = 1;
  Object.defineProperty(toKeyAlias, "__esModule", {
    value: true
  });
  toKeyAlias["default"] = toKeyAlias$1;
  var _index = requireGenerated$3();
  var _cloneNode = requireCloneNode();
  var _removePropertiesDeep = requireRemovePropertiesDeep();
  function toKeyAlias$1(node) {
    var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node.key;
    var alias;
    if (node.kind === "method") {
      return toKeyAlias$1.increment() + "";
    } else if ((0, _index.isIdentifier)(key)) {
      alias = key.name;
    } else if ((0, _index.isStringLiteral)(key)) {
      alias = JSON.stringify(key.value);
    } else {
      alias = JSON.stringify((0, _removePropertiesDeep["default"])((0, _cloneNode["default"])(key)));
    }
    if (node.computed) {
      alias = "[".concat(alias, "]");
    }
    if (node["static"]) {
      alias = "static:".concat(alias);
    }
    return alias;
  }
  toKeyAlias$1.uid = 0;
  toKeyAlias$1.increment = function () {
    if (toKeyAlias$1.uid >= Number.MAX_SAFE_INTEGER) {
      return toKeyAlias$1.uid = 0;
    } else {
      return toKeyAlias$1.uid++;
    }
  };
  return toKeyAlias;
}

var toStatement = {};

var hasRequiredToStatement;
function requireToStatement() {
  if (hasRequiredToStatement) return toStatement;
  hasRequiredToStatement = 1;
  Object.defineProperty(toStatement, "__esModule", {
    value: true
  });
  toStatement["default"] = void 0;
  var _index = requireGenerated$3();
  var _index2 = requireGenerated$2();
  toStatement["default"] = toStatement$1;
  function toStatement$1(node, ignore) {
    if ((0, _index.isStatement)(node)) {
      return node;
    }
    var mustHaveId = false;
    var newType;
    if ((0, _index.isClass)(node)) {
      mustHaveId = true;
      newType = "ClassDeclaration";
    } else if ((0, _index.isFunction)(node)) {
      mustHaveId = true;
      newType = "FunctionDeclaration";
    } else if ((0, _index.isAssignmentExpression)(node)) {
      return (0, _index2.expressionStatement)(node);
    }
    if (mustHaveId && !node.id) {
      newType = false;
    }
    if (!newType) {
      if (ignore) {
        return false;
      } else {
        throw new Error("cannot turn ".concat(node.type, " to a statement"));
      }
    }
    node.type = newType;
    return node;
  }
  return toStatement;
}

var valueToNode = {};

var hasRequiredValueToNode;
function requireValueToNode() {
  if (hasRequiredValueToNode) return valueToNode;
  hasRequiredValueToNode = 1;
  Object.defineProperty(valueToNode, "__esModule", {
    value: true
  });
  valueToNode["default"] = void 0;
  var _isValidIdentifier = requireIsValidIdentifier();
  var _index = requireGenerated$2();
  valueToNode["default"] = valueToNode$1;
  var objectToString = Function.call.bind(Object.prototype.toString);
  function isRegExp(value) {
    return objectToString(value) === "[object RegExp]";
  }
  function isPlainObject(value) {
    if (_typeof(value) !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]") {
      return false;
    }
    var proto = Object.getPrototypeOf(value);
    return proto === null || Object.getPrototypeOf(proto) === null;
  }
  function valueToNode$1(value) {
    if (value === undefined) {
      return (0, _index.identifier)("undefined");
    }
    if (value === true || value === false) {
      return (0, _index.booleanLiteral)(value);
    }
    if (value === null) {
      return (0, _index.nullLiteral)();
    }
    if (typeof value === "string") {
      return (0, _index.stringLiteral)(value);
    }
    if (typeof value === "number") {
      var result;
      if (Number.isFinite(value)) {
        result = (0, _index.numericLiteral)(Math.abs(value));
      } else {
        var numerator;
        if (Number.isNaN(value)) {
          numerator = (0, _index.numericLiteral)(0);
        } else {
          numerator = (0, _index.numericLiteral)(1);
        }
        result = (0, _index.binaryExpression)("/", numerator, (0, _index.numericLiteral)(0));
      }
      if (value < 0 || Object.is(value, -0)) {
        result = (0, _index.unaryExpression)("-", result);
      }
      return result;
    }
    if (isRegExp(value)) {
      var pattern = value.source;
      var flags = /\/([a-z]*)$/.exec(value.toString())[1];
      return (0, _index.regExpLiteral)(pattern, flags);
    }
    if (Array.isArray(value)) {
      return (0, _index.arrayExpression)(value.map(valueToNode$1));
    }
    if (isPlainObject(value)) {
      var props = [];
      for (var _i = 0, _Object$keys = Object.keys(value); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        var nodeKey = void 0;
        if ((0, _isValidIdentifier["default"])(key)) {
          nodeKey = (0, _index.identifier)(key);
        } else {
          nodeKey = (0, _index.stringLiteral)(key);
        }
        props.push((0, _index.objectProperty)(nodeKey, valueToNode$1(value[key])));
      }
      return (0, _index.objectExpression)(props);
    }
    throw new Error("don't know how to turn this value into a node");
  }
  return valueToNode;
}

var appendToMemberExpression = {};

var hasRequiredAppendToMemberExpression;
function requireAppendToMemberExpression() {
  if (hasRequiredAppendToMemberExpression) return appendToMemberExpression;
  hasRequiredAppendToMemberExpression = 1;
  Object.defineProperty(appendToMemberExpression, "__esModule", {
    value: true
  });
  appendToMemberExpression["default"] = appendToMemberExpression$1;
  var _index = requireGenerated$2();
  function appendToMemberExpression$1(member, append) {
    var computed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    member.object = (0, _index.memberExpression)(member.object, member.property, member.computed);
    member.property = append;
    member.computed = !!computed;
    return member;
  }
  return appendToMemberExpression;
}

var inherits = {};

var hasRequiredInherits;
function requireInherits() {
  if (hasRequiredInherits) return inherits;
  hasRequiredInherits = 1;
  Object.defineProperty(inherits, "__esModule", {
    value: true
  });
  inherits["default"] = inherits$1;
  var _index = requireConstants();
  var _inheritsComments = requireInheritsComments();
  function inherits$1(child, parent) {
    if (!child || !parent) return child;
    var _iterator = _createForOfIteratorHelper(_index.INHERIT_KEYS.optional),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _key = _step.value;
        if (child[_key] == null) {
          child[_key] = parent[_key];
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    for (var _i = 0, _Object$keys = Object.keys(parent); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      if (key[0] === "_" && key !== "__clone") {
        child[key] = parent[key];
      }
    }
    var _iterator2 = _createForOfIteratorHelper(_index.INHERIT_KEYS.force),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _key2 = _step2.value;
        child[_key2] = parent[_key2];
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    (0, _inheritsComments["default"])(child, parent);
    return child;
  }
  return inherits;
}

var prependToMemberExpression = {};

var hasRequiredPrependToMemberExpression;
function requirePrependToMemberExpression() {
  if (hasRequiredPrependToMemberExpression) return prependToMemberExpression;
  hasRequiredPrependToMemberExpression = 1;
  Object.defineProperty(prependToMemberExpression, "__esModule", {
    value: true
  });
  prependToMemberExpression["default"] = prependToMemberExpression$1;
  var _index = requireGenerated$2();
  var _index2 = requireLib$4();
  function prependToMemberExpression$1(member, prepend) {
    if ((0, _index2.isSuper)(member.object)) {
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    }
    member.object = (0, _index.memberExpression)(prepend, member.object);
    return member;
  }
  return prependToMemberExpression;
}

var getAssignmentIdentifiers = {};

var hasRequiredGetAssignmentIdentifiers;
function requireGetAssignmentIdentifiers() {
  if (hasRequiredGetAssignmentIdentifiers) return getAssignmentIdentifiers;
  hasRequiredGetAssignmentIdentifiers = 1;
  Object.defineProperty(getAssignmentIdentifiers, "__esModule", {
    value: true
  });
  getAssignmentIdentifiers["default"] = getAssignmentIdentifiers$1;
  function getAssignmentIdentifiers$1(node) {
    var search = [].concat(node);
    var ids = Object.create(null);
    while (search.length) {
      var id = search.pop();
      if (!id) continue;
      switch (id.type) {
        case "ArrayPattern":
          search.push.apply(search, _toConsumableArray(id.elements));
          break;
        case "AssignmentExpression":
        case "AssignmentPattern":
        case "ForInStatement":
        case "ForOfStatement":
          search.push(id.left);
          break;
        case "ObjectPattern":
          search.push.apply(search, _toConsumableArray(id.properties));
          break;
        case "ObjectProperty":
          search.push(id.value);
          break;
        case "RestElement":
        case "UpdateExpression":
          search.push(id.argument);
          break;
        case "UnaryExpression":
          if (id.operator === "delete") {
            search.push(id.argument);
          }
          break;
        case "Identifier":
          ids[id.name] = id;
          break;
      }
    }
    return ids;
  }
  return getAssignmentIdentifiers;
}

var getBindingIdentifiers = {};

var hasRequiredGetBindingIdentifiers;
function requireGetBindingIdentifiers() {
  if (hasRequiredGetBindingIdentifiers) return getBindingIdentifiers;
  hasRequiredGetBindingIdentifiers = 1;
  Object.defineProperty(getBindingIdentifiers, "__esModule", {
    value: true
  });
  getBindingIdentifiers["default"] = getBindingIdentifiers$1;
  var _index = requireGenerated$3();
  function getBindingIdentifiers$1(node, duplicates, outerOnly, newBindingsOnly) {
    var search = [].concat(node);
    var ids = Object.create(null);
    while (search.length) {
      var id = search.shift();
      if (!id) continue;
      if (newBindingsOnly && ((0, _index.isAssignmentExpression)(id) || (0, _index.isUnaryExpression)(id) || (0, _index.isUpdateExpression)(id))) {
        continue;
      }
      if ((0, _index.isIdentifier)(id)) {
        if (duplicates) {
          var _ids = ids[id.name] = ids[id.name] || [];
          _ids.push(id);
        } else {
          ids[id.name] = id;
        }
        continue;
      }
      if ((0, _index.isExportDeclaration)(id) && !(0, _index.isExportAllDeclaration)(id)) {
        if ((0, _index.isDeclaration)(id.declaration)) {
          search.push(id.declaration);
        }
        continue;
      }
      if (outerOnly) {
        if ((0, _index.isFunctionDeclaration)(id)) {
          search.push(id.id);
          continue;
        }
        if ((0, _index.isFunctionExpression)(id)) {
          continue;
        }
      }
      var _keys = getBindingIdentifiers$1.keys[id.type];
      if (_keys) {
        for (var i = 0; i < _keys.length; i++) {
          var key = _keys[i];
          var nodes = id[key];
          if (nodes) {
            if (Array.isArray(nodes)) {
              search.push.apply(search, _toConsumableArray(nodes));
            } else {
              search.push(nodes);
            }
          }
        }
      }
    }
    return ids;
  }
  var keys = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    TSImportEqualsDeclaration: ["id"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ClassPrivateMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };
  getBindingIdentifiers$1.keys = keys;
  return getBindingIdentifiers;
}

var getOuterBindingIdentifiers = {};

var hasRequiredGetOuterBindingIdentifiers;
function requireGetOuterBindingIdentifiers() {
  if (hasRequiredGetOuterBindingIdentifiers) return getOuterBindingIdentifiers;
  hasRequiredGetOuterBindingIdentifiers = 1;
  Object.defineProperty(getOuterBindingIdentifiers, "__esModule", {
    value: true
  });
  getOuterBindingIdentifiers["default"] = void 0;
  var _getBindingIdentifiers = requireGetBindingIdentifiers();
  getOuterBindingIdentifiers["default"] = getOuterBindingIdentifiers$1;
  function getOuterBindingIdentifiers$1(node, duplicates) {
    return (0, _getBindingIdentifiers["default"])(node, duplicates, true);
  }
  return getOuterBindingIdentifiers;
}

var getFunctionName = {};

var hasRequiredGetFunctionName;
function requireGetFunctionName() {
  if (hasRequiredGetFunctionName) return getFunctionName;
  hasRequiredGetFunctionName = 1;
  Object.defineProperty(getFunctionName, "__esModule", {
    value: true
  });
  getFunctionName["default"] = getFunctionName$1;
  var _index = requireGenerated$3();
  function getNameFromLiteralId(id) {
    if ((0, _index.isNullLiteral)(id)) {
      return "null";
    }
    if ((0, _index.isRegExpLiteral)(id)) {
      return "/".concat(id.pattern, "/").concat(id.flags);
    }
    if ((0, _index.isTemplateLiteral)(id)) {
      return id.quasis.map(function (quasi) {
        return quasi.value.raw;
      }).join("");
    }
    if (id.value !== undefined) {
      return String(id.value);
    }
    return null;
  }
  function getObjectMemberKey(node) {
    if (!node.computed || (0, _index.isLiteral)(node.key)) {
      return node.key;
    }
  }
  function getFunctionName$1(node, parent) {
    if ("id" in node && node.id) {
      return {
        name: node.id.name,
        originalNode: node.id
      };
    }
    var prefix = "";
    var id;
    if ((0, _index.isObjectProperty)(parent, {
      value: node
    })) {
      id = getObjectMemberKey(parent);
    } else if ((0, _index.isObjectMethod)(node) || (0, _index.isClassMethod)(node)) {
      id = getObjectMemberKey(node);
      if (node.kind === "get") prefix = "get ";else if (node.kind === "set") prefix = "set ";
    } else if ((0, _index.isVariableDeclarator)(parent, {
      init: node
    })) {
      id = parent.id;
    } else if ((0, _index.isAssignmentExpression)(parent, {
      operator: "=",
      right: node
    })) {
      id = parent.left;
    }
    if (!id) return null;
    var name = (0, _index.isLiteral)(id) ? getNameFromLiteralId(id) : (0, _index.isIdentifier)(id) ? id.name : (0, _index.isPrivateName)(id) ? id.id.name : null;
    if (name == null) return null;
    return {
      name: prefix + name,
      originalNode: id
    };
  }
  return getFunctionName;
}

var traverse$1 = {};

var hasRequiredTraverse;
function requireTraverse() {
  if (hasRequiredTraverse) return traverse$1;
  hasRequiredTraverse = 1;
  Object.defineProperty(traverse$1, "__esModule", {
    value: true
  });
  traverse$1["default"] = traverse;
  var _index = requireDefinitions();
  function traverse(node, handlers, state) {
    if (typeof handlers === "function") {
      handlers = {
        enter: handlers
      };
    }
    var _handlers = handlers,
      enter = _handlers.enter,
      exit = _handlers.exit;
    traverseSimpleImpl(node, enter, exit, state, []);
  }
  function traverseSimpleImpl(node, enter, exit, state, ancestors) {
    var keys = _index.VISITOR_KEYS[node.type];
    if (!keys) return;
    if (enter) enter(node, ancestors, state);
    var _iterator = _createForOfIteratorHelper(keys),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var key = _step.value;
        var subNode = node[key];
        if (Array.isArray(subNode)) {
          for (var i = 0; i < subNode.length; i++) {
            var child = subNode[i];
            if (!child) continue;
            ancestors.push({
              node: node,
              key: key,
              index: i
            });
            traverseSimpleImpl(child, enter, exit, state, ancestors);
            ancestors.pop();
          }
        } else if (subNode) {
          ancestors.push({
            node: node,
            key: key
          });
          traverseSimpleImpl(subNode, enter, exit, state, ancestors);
          ancestors.pop();
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    if (exit) exit(node, ancestors, state);
  }
  return traverse$1;
}

var isBinding = {};

var hasRequiredIsBinding;
function requireIsBinding() {
  if (hasRequiredIsBinding) return isBinding;
  hasRequiredIsBinding = 1;
  Object.defineProperty(isBinding, "__esModule", {
    value: true
  });
  isBinding["default"] = isBinding$1;
  var _getBindingIdentifiers = requireGetBindingIdentifiers();
  function isBinding$1(node, parent, grandparent) {
    if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
      return false;
    }
    var keys = _getBindingIdentifiers["default"].keys[parent.type];
    if (keys) {
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var val = parent[key];
        if (Array.isArray(val)) {
          if (val.includes(node)) return true;
        } else {
          if (val === node) return true;
        }
      }
    }
    return false;
  }
  return isBinding;
}

var isBlockScoped = {};

var isLet = {};

var hasRequiredIsLet;
function requireIsLet() {
  if (hasRequiredIsLet) return isLet;
  hasRequiredIsLet = 1;
  Object.defineProperty(isLet, "__esModule", {
    value: true
  });
  isLet["default"] = isLet$1;
  var _index = requireGenerated$3();
  var _index2 = requireConstants();
  function isLet$1(node) {
    return (0, _index.isVariableDeclaration)(node) && (node.kind !== "var" || node[_index2.BLOCK_SCOPED_SYMBOL]);
  }
  return isLet;
}

var hasRequiredIsBlockScoped;
function requireIsBlockScoped() {
  if (hasRequiredIsBlockScoped) return isBlockScoped;
  hasRequiredIsBlockScoped = 1;
  Object.defineProperty(isBlockScoped, "__esModule", {
    value: true
  });
  isBlockScoped["default"] = isBlockScoped$1;
  var _index = requireGenerated$3();
  var _isLet = requireIsLet();
  function isBlockScoped$1(node) {
    return (0, _index.isFunctionDeclaration)(node) || (0, _index.isClassDeclaration)(node) || (0, _isLet["default"])(node);
  }
  return isBlockScoped;
}

var isImmutable = {};

var hasRequiredIsImmutable;
function requireIsImmutable() {
  if (hasRequiredIsImmutable) return isImmutable;
  hasRequiredIsImmutable = 1;
  Object.defineProperty(isImmutable, "__esModule", {
    value: true
  });
  isImmutable["default"] = isImmutable$1;
  var _isType = requireIsType();
  var _index = requireGenerated$3();
  function isImmutable$1(node) {
    if ((0, _isType["default"])(node.type, "Immutable")) return true;
    if ((0, _index.isIdentifier)(node)) {
      if (node.name === "undefined") {
        return true;
      } else {
        return false;
      }
    }
    return false;
  }
  return isImmutable;
}

var isNodesEquivalent = {};

var hasRequiredIsNodesEquivalent;
function requireIsNodesEquivalent() {
  if (hasRequiredIsNodesEquivalent) return isNodesEquivalent;
  hasRequiredIsNodesEquivalent = 1;
  Object.defineProperty(isNodesEquivalent, "__esModule", {
    value: true
  });
  isNodesEquivalent["default"] = isNodesEquivalent$1;
  var _index = requireDefinitions();
  function isNodesEquivalent$1(a, b) {
    if (_typeof(a) !== "object" || _typeof(b) !== "object" || a == null || b == null) {
      return a === b;
    }
    if (a.type !== b.type) {
      return false;
    }
    var fields = Object.keys(_index.NODE_FIELDS[a.type] || a.type);
    var visitorKeys = _index.VISITOR_KEYS[a.type];
    for (var _i = 0, _fields = fields; _i < _fields.length; _i++) {
      var field = _fields[_i];
      var val_a = a[field];
      var val_b = b[field];
      if (_typeof(val_a) !== _typeof(val_b)) {
        return false;
      }
      if (val_a == null && val_b == null) {
        continue;
      } else if (val_a == null || val_b == null) {
        return false;
      }
      if (Array.isArray(val_a)) {
        if (!Array.isArray(val_b)) {
          return false;
        }
        if (val_a.length !== val_b.length) {
          return false;
        }
        for (var i = 0; i < val_a.length; i++) {
          if (!isNodesEquivalent$1(val_a[i], val_b[i])) {
            return false;
          }
        }
        continue;
      }
      if (_typeof(val_a) === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
        for (var _i2 = 0, _Object$keys = Object.keys(val_a); _i2 < _Object$keys.length; _i2++) {
          var key = _Object$keys[_i2];
          if (val_a[key] !== val_b[key]) {
            return false;
          }
        }
        continue;
      }
      if (!isNodesEquivalent$1(val_a, val_b)) {
        return false;
      }
    }
    return true;
  }
  return isNodesEquivalent;
}

var isReferenced = {};

var hasRequiredIsReferenced;
function requireIsReferenced() {
  if (hasRequiredIsReferenced) return isReferenced;
  hasRequiredIsReferenced = 1;
  Object.defineProperty(isReferenced, "__esModule", {
    value: true
  });
  isReferenced["default"] = isReferenced$1;
  function isReferenced$1(node, parent, grandparent) {
    switch (parent.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        if (parent.property === node) {
          return !!parent.computed;
        }
        return parent.object === node;
      case "JSXMemberExpression":
        return parent.object === node;
      case "VariableDeclarator":
        return parent.init === node;
      case "ArrowFunctionExpression":
        return parent.body === node;
      case "PrivateName":
        return false;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        if (parent.key === node) {
          return !!parent.computed;
        }
        return false;
      case "ObjectProperty":
        if (parent.key === node) {
          return !!parent.computed;
        }
        return !grandparent || grandparent.type !== "ObjectPattern";
      case "ClassProperty":
      case "ClassAccessorProperty":
        if (parent.key === node) {
          return !!parent.computed;
        }
        return true;
      case "ClassPrivateProperty":
        return parent.key !== node;
      case "ClassDeclaration":
      case "ClassExpression":
        return parent.superClass === node;
      case "AssignmentExpression":
        return parent.right === node;
      case "AssignmentPattern":
        return parent.right === node;
      case "LabeledStatement":
        return false;
      case "CatchClause":
        return false;
      case "RestElement":
        return false;
      case "BreakStatement":
      case "ContinueStatement":
        return false;
      case "FunctionDeclaration":
      case "FunctionExpression":
        return false;
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return false;
      case "ExportSpecifier":
        if (grandparent != null && grandparent.source) {
          return false;
        }
        return parent.local === node;
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return false;
      case "ImportAttribute":
        return false;
      case "JSXAttribute":
        return false;
      case "ObjectPattern":
      case "ArrayPattern":
        return false;
      case "MetaProperty":
        return false;
      case "ObjectTypeProperty":
        return parent.key !== node;
      case "TSEnumMember":
        return parent.id !== node;
      case "TSPropertySignature":
        if (parent.key === node) {
          return !!parent.computed;
        }
        return true;
    }
    return true;
  }
  return isReferenced;
}

var isScope = {};

var hasRequiredIsScope;
function requireIsScope() {
  if (hasRequiredIsScope) return isScope;
  hasRequiredIsScope = 1;
  Object.defineProperty(isScope, "__esModule", {
    value: true
  });
  isScope["default"] = isScope$1;
  var _index = requireGenerated$3();
  function isScope$1(node, parent) {
    if ((0, _index.isBlockStatement)(node) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
      return false;
    }
    if ((0, _index.isPattern)(node) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
      return true;
    }
    return (0, _index.isScopable)(node);
  }
  return isScope;
}

var isSpecifierDefault = {};

var hasRequiredIsSpecifierDefault;
function requireIsSpecifierDefault() {
  if (hasRequiredIsSpecifierDefault) return isSpecifierDefault;
  hasRequiredIsSpecifierDefault = 1;
  Object.defineProperty(isSpecifierDefault, "__esModule", {
    value: true
  });
  isSpecifierDefault["default"] = isSpecifierDefault$1;
  var _index = requireGenerated$3();
  function isSpecifierDefault$1(specifier) {
    return (0, _index.isImportDefaultSpecifier)(specifier) || (0, _index.isIdentifier)(specifier.imported || specifier.exported, {
      name: "default"
    });
  }
  return isSpecifierDefault;
}

var isValidES3Identifier = {};

var hasRequiredIsValidES3Identifier;
function requireIsValidES3Identifier() {
  if (hasRequiredIsValidES3Identifier) return isValidES3Identifier;
  hasRequiredIsValidES3Identifier = 1;
  Object.defineProperty(isValidES3Identifier, "__esModule", {
    value: true
  });
  isValidES3Identifier["default"] = isValidES3Identifier$1;
  var _isValidIdentifier = requireIsValidIdentifier();
  var RESERVED_WORDS_ES3_ONLY = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
  function isValidES3Identifier$1(name) {
    return (0, _isValidIdentifier["default"])(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
  }
  return isValidES3Identifier;
}

var isVar = {};

var hasRequiredIsVar;
function requireIsVar() {
  if (hasRequiredIsVar) return isVar;
  hasRequiredIsVar = 1;
  Object.defineProperty(isVar, "__esModule", {
    value: true
  });
  isVar["default"] = isVar$1;
  var _index = requireGenerated$3();
  var _index2 = requireConstants();
  function isVar$1(node) {
    return (0, _index.isVariableDeclaration)(node, {
      kind: "var"
    }) && !node[_index2.BLOCK_SCOPED_SYMBOL];
  }
  return isVar;
}

var toSequenceExpression = {};

var gatherSequenceExpressions = {};

var hasRequiredGatherSequenceExpressions;
function requireGatherSequenceExpressions() {
  if (hasRequiredGatherSequenceExpressions) return gatherSequenceExpressions;
  hasRequiredGatherSequenceExpressions = 1;
  Object.defineProperty(gatherSequenceExpressions, "__esModule", {
    value: true
  });
  gatherSequenceExpressions["default"] = gatherSequenceExpressions$1;
  var _getBindingIdentifiers = requireGetBindingIdentifiers();
  var _index = requireGenerated$3();
  var _index2 = requireGenerated$2();
  var _productions = requireProductions();
  var _cloneNode = requireCloneNode();
  function gatherSequenceExpressions$1(nodes, declars) {
    var exprs = [];
    var ensureLastUndefined = true;
    var _iterator = _createForOfIteratorHelper(nodes),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var node = _step.value;
        if (!(0, _index.isEmptyStatement)(node)) {
          ensureLastUndefined = false;
        }
        if ((0, _index.isExpression)(node)) {
          exprs.push(node);
        } else if ((0, _index.isExpressionStatement)(node)) {
          exprs.push(node.expression);
        } else if ((0, _index.isVariableDeclaration)(node)) {
          if (node.kind !== "var") return;
          var _iterator2 = _createForOfIteratorHelper(node.declarations),
            _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var declar = _step2.value;
              var bindings = (0, _getBindingIdentifiers["default"])(declar);
              for (var _i = 0, _Object$keys = Object.keys(bindings); _i < _Object$keys.length; _i++) {
                var key = _Object$keys[_i];
                declars.push({
                  kind: node.kind,
                  id: (0, _cloneNode["default"])(bindings[key])
                });
              }
              if (declar.init) {
                exprs.push((0, _index2.assignmentExpression)("=", declar.id, declar.init));
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          ensureLastUndefined = true;
        } else if ((0, _index.isIfStatement)(node)) {
          var consequent = node.consequent ? gatherSequenceExpressions$1([node.consequent], declars) : (0, _productions.buildUndefinedNode)();
          var alternate = node.alternate ? gatherSequenceExpressions$1([node.alternate], declars) : (0, _productions.buildUndefinedNode)();
          if (!consequent || !alternate) return;
          exprs.push((0, _index2.conditionalExpression)(node.test, consequent, alternate));
        } else if ((0, _index.isBlockStatement)(node)) {
          var body = gatherSequenceExpressions$1(node.body, declars);
          if (!body) return;
          exprs.push(body);
        } else if ((0, _index.isEmptyStatement)(node)) {
          if (nodes.indexOf(node) === 0) {
            ensureLastUndefined = true;
          }
        } else {
          return;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    if (ensureLastUndefined) {
      exprs.push((0, _productions.buildUndefinedNode)());
    }
    if (exprs.length === 1) {
      return exprs[0];
    } else {
      return (0, _index2.sequenceExpression)(exprs);
    }
  }
  return gatherSequenceExpressions;
}

var hasRequiredToSequenceExpression;
function requireToSequenceExpression() {
  if (hasRequiredToSequenceExpression) return toSequenceExpression;
  hasRequiredToSequenceExpression = 1;
  Object.defineProperty(toSequenceExpression, "__esModule", {
    value: true
  });
  toSequenceExpression["default"] = toSequenceExpression$1;
  var _gatherSequenceExpressions = requireGatherSequenceExpressions();
  function toSequenceExpression$1(nodes, scope) {
    if (!(nodes != null && nodes.length)) return;
    var declars = [];
    var result = (0, _gatherSequenceExpressions["default"])(nodes, declars);
    if (!result) return;
    for (var _i = 0, _declars = declars; _i < _declars.length; _i++) {
      var declar = _declars[_i];
      scope.push(declar);
    }
    return result;
  }
  return toSequenceExpression;
}

var hasRequiredLib$4;
function requireLib$4() {
  if (hasRequiredLib$4) return lib$5;
  hasRequiredLib$4 = 1;
  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _exportNames = {
      react: true,
      assertNode: true,
      createTypeAnnotationBasedOnTypeof: true,
      createUnionTypeAnnotation: true,
      createFlowUnionType: true,
      createTSUnionType: true,
      cloneNode: true,
      clone: true,
      cloneDeep: true,
      cloneDeepWithoutLoc: true,
      cloneWithoutLoc: true,
      addComment: true,
      addComments: true,
      inheritInnerComments: true,
      inheritLeadingComments: true,
      inheritsComments: true,
      inheritTrailingComments: true,
      removeComments: true,
      ensureBlock: true,
      toBindingIdentifierName: true,
      toBlock: true,
      toComputedKey: true,
      toExpression: true,
      toIdentifier: true,
      toKeyAlias: true,
      toStatement: true,
      valueToNode: true,
      appendToMemberExpression: true,
      inherits: true,
      prependToMemberExpression: true,
      removeProperties: true,
      removePropertiesDeep: true,
      removeTypeDuplicates: true,
      getAssignmentIdentifiers: true,
      getBindingIdentifiers: true,
      getOuterBindingIdentifiers: true,
      getFunctionName: true,
      traverse: true,
      traverseFast: true,
      shallowEqual: true,
      is: true,
      isBinding: true,
      isBlockScoped: true,
      isImmutable: true,
      isLet: true,
      isNode: true,
      isNodesEquivalent: true,
      isPlaceholderType: true,
      isReferenced: true,
      isScope: true,
      isSpecifierDefault: true,
      isType: true,
      isValidES3Identifier: true,
      isValidIdentifier: true,
      isVar: true,
      matchesPattern: true,
      validate: true,
      buildMatchMemberExpression: true,
      __internal__deprecationWarning: true
    };
    Object.defineProperty(exports, "__internal__deprecationWarning", {
      enumerable: true,
      get: function get() {
        return _deprecationWarning["default"];
      }
    });
    Object.defineProperty(exports, "addComment", {
      enumerable: true,
      get: function get() {
        return _addComment["default"];
      }
    });
    Object.defineProperty(exports, "addComments", {
      enumerable: true,
      get: function get() {
        return _addComments["default"];
      }
    });
    Object.defineProperty(exports, "appendToMemberExpression", {
      enumerable: true,
      get: function get() {
        return _appendToMemberExpression["default"];
      }
    });
    Object.defineProperty(exports, "assertNode", {
      enumerable: true,
      get: function get() {
        return _assertNode["default"];
      }
    });
    Object.defineProperty(exports, "buildMatchMemberExpression", {
      enumerable: true,
      get: function get() {
        return _buildMatchMemberExpression["default"];
      }
    });
    Object.defineProperty(exports, "clone", {
      enumerable: true,
      get: function get() {
        return _clone["default"];
      }
    });
    Object.defineProperty(exports, "cloneDeep", {
      enumerable: true,
      get: function get() {
        return _cloneDeep["default"];
      }
    });
    Object.defineProperty(exports, "cloneDeepWithoutLoc", {
      enumerable: true,
      get: function get() {
        return _cloneDeepWithoutLoc["default"];
      }
    });
    Object.defineProperty(exports, "cloneNode", {
      enumerable: true,
      get: function get() {
        return _cloneNode["default"];
      }
    });
    Object.defineProperty(exports, "cloneWithoutLoc", {
      enumerable: true,
      get: function get() {
        return _cloneWithoutLoc["default"];
      }
    });
    Object.defineProperty(exports, "createFlowUnionType", {
      enumerable: true,
      get: function get() {
        return _createFlowUnionType["default"];
      }
    });
    Object.defineProperty(exports, "createTSUnionType", {
      enumerable: true,
      get: function get() {
        return _createTSUnionType["default"];
      }
    });
    Object.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", {
      enumerable: true,
      get: function get() {
        return _createTypeAnnotationBasedOnTypeof["default"];
      }
    });
    Object.defineProperty(exports, "createUnionTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _createFlowUnionType["default"];
      }
    });
    Object.defineProperty(exports, "ensureBlock", {
      enumerable: true,
      get: function get() {
        return _ensureBlock["default"];
      }
    });
    Object.defineProperty(exports, "getAssignmentIdentifiers", {
      enumerable: true,
      get: function get() {
        return _getAssignmentIdentifiers["default"];
      }
    });
    Object.defineProperty(exports, "getBindingIdentifiers", {
      enumerable: true,
      get: function get() {
        return _getBindingIdentifiers["default"];
      }
    });
    Object.defineProperty(exports, "getFunctionName", {
      enumerable: true,
      get: function get() {
        return _getFunctionName["default"];
      }
    });
    Object.defineProperty(exports, "getOuterBindingIdentifiers", {
      enumerable: true,
      get: function get() {
        return _getOuterBindingIdentifiers["default"];
      }
    });
    Object.defineProperty(exports, "inheritInnerComments", {
      enumerable: true,
      get: function get() {
        return _inheritInnerComments["default"];
      }
    });
    Object.defineProperty(exports, "inheritLeadingComments", {
      enumerable: true,
      get: function get() {
        return _inheritLeadingComments["default"];
      }
    });
    Object.defineProperty(exports, "inheritTrailingComments", {
      enumerable: true,
      get: function get() {
        return _inheritTrailingComments["default"];
      }
    });
    Object.defineProperty(exports, "inherits", {
      enumerable: true,
      get: function get() {
        return _inherits["default"];
      }
    });
    Object.defineProperty(exports, "inheritsComments", {
      enumerable: true,
      get: function get() {
        return _inheritsComments["default"];
      }
    });
    Object.defineProperty(exports, "is", {
      enumerable: true,
      get: function get() {
        return _is["default"];
      }
    });
    Object.defineProperty(exports, "isBinding", {
      enumerable: true,
      get: function get() {
        return _isBinding["default"];
      }
    });
    Object.defineProperty(exports, "isBlockScoped", {
      enumerable: true,
      get: function get() {
        return _isBlockScoped["default"];
      }
    });
    Object.defineProperty(exports, "isImmutable", {
      enumerable: true,
      get: function get() {
        return _isImmutable["default"];
      }
    });
    Object.defineProperty(exports, "isLet", {
      enumerable: true,
      get: function get() {
        return _isLet["default"];
      }
    });
    Object.defineProperty(exports, "isNode", {
      enumerable: true,
      get: function get() {
        return _isNode["default"];
      }
    });
    Object.defineProperty(exports, "isNodesEquivalent", {
      enumerable: true,
      get: function get() {
        return _isNodesEquivalent["default"];
      }
    });
    Object.defineProperty(exports, "isPlaceholderType", {
      enumerable: true,
      get: function get() {
        return _isPlaceholderType["default"];
      }
    });
    Object.defineProperty(exports, "isReferenced", {
      enumerable: true,
      get: function get() {
        return _isReferenced["default"];
      }
    });
    Object.defineProperty(exports, "isScope", {
      enumerable: true,
      get: function get() {
        return _isScope["default"];
      }
    });
    Object.defineProperty(exports, "isSpecifierDefault", {
      enumerable: true,
      get: function get() {
        return _isSpecifierDefault["default"];
      }
    });
    Object.defineProperty(exports, "isType", {
      enumerable: true,
      get: function get() {
        return _isType["default"];
      }
    });
    Object.defineProperty(exports, "isValidES3Identifier", {
      enumerable: true,
      get: function get() {
        return _isValidES3Identifier["default"];
      }
    });
    Object.defineProperty(exports, "isValidIdentifier", {
      enumerable: true,
      get: function get() {
        return _isValidIdentifier["default"];
      }
    });
    Object.defineProperty(exports, "isVar", {
      enumerable: true,
      get: function get() {
        return _isVar["default"];
      }
    });
    Object.defineProperty(exports, "matchesPattern", {
      enumerable: true,
      get: function get() {
        return _matchesPattern["default"];
      }
    });
    Object.defineProperty(exports, "prependToMemberExpression", {
      enumerable: true,
      get: function get() {
        return _prependToMemberExpression["default"];
      }
    });
    exports.react = void 0;
    Object.defineProperty(exports, "removeComments", {
      enumerable: true,
      get: function get() {
        return _removeComments["default"];
      }
    });
    Object.defineProperty(exports, "removeProperties", {
      enumerable: true,
      get: function get() {
        return _removeProperties["default"];
      }
    });
    Object.defineProperty(exports, "removePropertiesDeep", {
      enumerable: true,
      get: function get() {
        return _removePropertiesDeep["default"];
      }
    });
    Object.defineProperty(exports, "removeTypeDuplicates", {
      enumerable: true,
      get: function get() {
        return _removeTypeDuplicates["default"];
      }
    });
    Object.defineProperty(exports, "shallowEqual", {
      enumerable: true,
      get: function get() {
        return _shallowEqual["default"];
      }
    });
    Object.defineProperty(exports, "toBindingIdentifierName", {
      enumerable: true,
      get: function get() {
        return _toBindingIdentifierName["default"];
      }
    });
    Object.defineProperty(exports, "toBlock", {
      enumerable: true,
      get: function get() {
        return _toBlock["default"];
      }
    });
    Object.defineProperty(exports, "toComputedKey", {
      enumerable: true,
      get: function get() {
        return _toComputedKey["default"];
      }
    });
    Object.defineProperty(exports, "toExpression", {
      enumerable: true,
      get: function get() {
        return _toExpression["default"];
      }
    });
    Object.defineProperty(exports, "toIdentifier", {
      enumerable: true,
      get: function get() {
        return _toIdentifier["default"];
      }
    });
    Object.defineProperty(exports, "toKeyAlias", {
      enumerable: true,
      get: function get() {
        return _toKeyAlias["default"];
      }
    });
    Object.defineProperty(exports, "toStatement", {
      enumerable: true,
      get: function get() {
        return _toStatement["default"];
      }
    });
    Object.defineProperty(exports, "traverse", {
      enumerable: true,
      get: function get() {
        return _traverse["default"];
      }
    });
    Object.defineProperty(exports, "traverseFast", {
      enumerable: true,
      get: function get() {
        return _traverseFast["default"];
      }
    });
    Object.defineProperty(exports, "validate", {
      enumerable: true,
      get: function get() {
        return _validate["default"];
      }
    });
    Object.defineProperty(exports, "valueToNode", {
      enumerable: true,
      get: function get() {
        return _valueToNode["default"];
      }
    });
    var _isReactComponent = requireIsReactComponent();
    var _isCompatTag = requireIsCompatTag();
    var _buildChildren = requireBuildChildren();
    var _assertNode = requireAssertNode();
    var _index = requireGenerated$1();
    Object.keys(_index).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _index[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _index[key];
        }
      });
    });
    var _createTypeAnnotationBasedOnTypeof = requireCreateTypeAnnotationBasedOnTypeof();
    var _createFlowUnionType = requireCreateFlowUnionType();
    var _createTSUnionType = requireCreateTSUnionType();
    var _productions = requireProductions();
    Object.keys(_productions).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _productions[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _productions[key];
        }
      });
    });
    var _index2 = requireGenerated$2();
    Object.keys(_index2).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _index2[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _index2[key];
        }
      });
    });
    var _cloneNode = requireCloneNode();
    var _clone = requireClone();
    var _cloneDeep = requireCloneDeep();
    var _cloneDeepWithoutLoc = requireCloneDeepWithoutLoc();
    var _cloneWithoutLoc = requireCloneWithoutLoc();
    var _addComment = requireAddComment();
    var _addComments = requireAddComments();
    var _inheritInnerComments = requireInheritInnerComments();
    var _inheritLeadingComments = requireInheritLeadingComments();
    var _inheritsComments = requireInheritsComments();
    var _inheritTrailingComments = requireInheritTrailingComments();
    var _removeComments = requireRemoveComments();
    var _index3 = requireGenerated();
    Object.keys(_index3).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _index3[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _index3[key];
        }
      });
    });
    var _index4 = requireConstants();
    Object.keys(_index4).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _index4[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _index4[key];
        }
      });
    });
    var _ensureBlock = requireEnsureBlock();
    var _toBindingIdentifierName = requireToBindingIdentifierName();
    var _toBlock = requireToBlock();
    var _toComputedKey = requireToComputedKey();
    var _toExpression = requireToExpression();
    var _toIdentifier = requireToIdentifier();
    var _toKeyAlias = requireToKeyAlias();
    var _toStatement = requireToStatement();
    var _valueToNode = requireValueToNode();
    var _index5 = requireDefinitions();
    Object.keys(_index5).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _index5[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _index5[key];
        }
      });
    });
    var _appendToMemberExpression = requireAppendToMemberExpression();
    var _inherits = requireInherits();
    var _prependToMemberExpression = requirePrependToMemberExpression();
    var _removeProperties = requireRemoveProperties();
    var _removePropertiesDeep = requireRemovePropertiesDeep();
    var _removeTypeDuplicates = requireRemoveTypeDuplicates$1();
    var _getAssignmentIdentifiers = requireGetAssignmentIdentifiers();
    var _getBindingIdentifiers = requireGetBindingIdentifiers();
    var _getOuterBindingIdentifiers = requireGetOuterBindingIdentifiers();
    var _getFunctionName = requireGetFunctionName();
    var _traverse = requireTraverse();
    Object.keys(_traverse).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _traverse[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _traverse[key];
        }
      });
    });
    var _traverseFast = requireTraverseFast();
    var _shallowEqual = requireShallowEqual();
    var _is = requireIs();
    var _isBinding = requireIsBinding();
    var _isBlockScoped = requireIsBlockScoped();
    var _isImmutable = requireIsImmutable();
    var _isLet = requireIsLet();
    var _isNode = requireIsNode();
    var _isNodesEquivalent = requireIsNodesEquivalent();
    var _isPlaceholderType = requireIsPlaceholderType();
    var _isReferenced = requireIsReferenced();
    var _isScope = requireIsScope();
    var _isSpecifierDefault = requireIsSpecifierDefault();
    var _isType = requireIsType();
    var _isValidES3Identifier = requireIsValidES3Identifier();
    var _isValidIdentifier = requireIsValidIdentifier();
    var _isVar = requireIsVar();
    var _matchesPattern = requireMatchesPattern();
    var _validate = requireValidate();
    var _buildMatchMemberExpression = requireBuildMatchMemberExpression();
    var _index6 = requireGenerated$3();
    Object.keys(_index6).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _index6[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _index6[key];
        }
      });
    });
    var _deprecationWarning = requireDeprecationWarning();
    var _toSequenceExpression = requireToSequenceExpression();
    exports.react = {
      isReactComponent: _isReactComponent["default"],
      isCompatTag: _isCompatTag["default"],
      buildChildren: _buildChildren["default"]
    };
    {
      exports.toSequenceExpression = _toSequenceExpression["default"];
    }
    if (process.env.BABEL_TYPES_8_BREAKING) {
      console.warn("BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-release instead!");
    }
  })(lib$5);
  return lib$5;
}

var visitors = {};

var virtualTypesValidator = {};

var hasRequiredVirtualTypesValidator;
function requireVirtualTypesValidator() {
  if (hasRequiredVirtualTypesValidator) return virtualTypesValidator;
  hasRequiredVirtualTypesValidator = 1;
  Object.defineProperty(virtualTypesValidator, "__esModule", {
    value: true
  });
  virtualTypesValidator.isBindingIdentifier = isBindingIdentifier;
  virtualTypesValidator.isBlockScoped = isBlockScoped;
  virtualTypesValidator.isExpression = isExpression;
  virtualTypesValidator.isFlow = isFlow;
  virtualTypesValidator.isForAwaitStatement = isForAwaitStatement;
  virtualTypesValidator.isGenerated = isGenerated;
  virtualTypesValidator.isPure = isPure;
  virtualTypesValidator.isReferenced = isReferenced;
  virtualTypesValidator.isReferencedIdentifier = isReferencedIdentifier;
  virtualTypesValidator.isReferencedMemberExpression = isReferencedMemberExpression;
  virtualTypesValidator.isRestProperty = isRestProperty;
  virtualTypesValidator.isScope = isScope;
  virtualTypesValidator.isSpreadProperty = isSpreadProperty;
  virtualTypesValidator.isStatement = isStatement;
  virtualTypesValidator.isUser = isUser;
  virtualTypesValidator.isVar = isVar;
  var _t = requireLib$4();
  var isBinding = _t.isBinding,
    nodeIsBlockScoped = _t.isBlockScoped,
    isExportDeclaration = _t.isExportDeclaration,
    nodeIsExpression = _t.isExpression,
    nodeIsFlow = _t.isFlow,
    isForStatement = _t.isForStatement,
    isForXStatement = _t.isForXStatement,
    isIdentifier = _t.isIdentifier,
    isImportDeclaration = _t.isImportDeclaration,
    isImportSpecifier = _t.isImportSpecifier,
    isJSXIdentifier = _t.isJSXIdentifier,
    isJSXMemberExpression = _t.isJSXMemberExpression,
    isMemberExpression = _t.isMemberExpression,
    nodeIsRestElement = _t.isRestElement,
    nodeIsReferenced = _t.isReferenced,
    nodeIsScope = _t.isScope,
    nodeIsStatement = _t.isStatement,
    nodeIsVar = _t.isVar,
    isVariableDeclaration = _t.isVariableDeclaration,
    react = _t.react,
    isForOfStatement = _t.isForOfStatement;
  var isCompatTag = react.isCompatTag;
  function isReferencedIdentifier(opts) {
    var node = this.node,
      parent = this.parent;
    if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {
      if (isJSXIdentifier(node, opts)) {
        if (isCompatTag(node.name)) return false;
      } else {
        return false;
      }
    }
    return nodeIsReferenced(node, parent, this.parentPath.parent);
  }
  function isReferencedMemberExpression() {
    var node = this.node,
      parent = this.parent;
    return isMemberExpression(node) && nodeIsReferenced(node, parent);
  }
  function isBindingIdentifier() {
    var node = this.node,
      parent = this.parent;
    var grandparent = this.parentPath.parent;
    return isIdentifier(node) && isBinding(node, parent, grandparent);
  }
  function isStatement() {
    var node = this.node,
      parent = this.parent;
    if (nodeIsStatement(node)) {
      if (isVariableDeclaration(node)) {
        if (isForXStatement(parent, {
          left: node
        })) return false;
        if (isForStatement(parent, {
          init: node
        })) return false;
      }
      return true;
    } else {
      return false;
    }
  }
  function isExpression() {
    if (this.isIdentifier()) {
      return this.isReferencedIdentifier();
    } else {
      return nodeIsExpression(this.node);
    }
  }
  function isScope() {
    return nodeIsScope(this.node, this.parent);
  }
  function isReferenced() {
    return nodeIsReferenced(this.node, this.parent);
  }
  function isBlockScoped() {
    return nodeIsBlockScoped(this.node);
  }
  function isVar() {
    return nodeIsVar(this.node);
  }
  function isUser() {
    return this.node && !!this.node.loc;
  }
  function isGenerated() {
    return !this.isUser();
  }
  function isPure(constantsOnly) {
    return this.scope.isPure(this.node, constantsOnly);
  }
  function isFlow() {
    var node = this.node;
    if (nodeIsFlow(node)) {
      return true;
    } else if (isImportDeclaration(node)) {
      return node.importKind === "type" || node.importKind === "typeof";
    } else if (isExportDeclaration(node)) {
      return node.exportKind === "type";
    } else if (isImportSpecifier(node)) {
      return node.importKind === "type" || node.importKind === "typeof";
    } else {
      return false;
    }
  }
  function isRestProperty() {
    var _this$parentPath;
    return nodeIsRestElement(this.node) && ((_this$parentPath = this.parentPath) == null ? void 0 : _this$parentPath.isObjectPattern());
  }
  function isSpreadProperty() {
    var _this$parentPath2;
    return nodeIsRestElement(this.node) && ((_this$parentPath2 = this.parentPath) == null ? void 0 : _this$parentPath2.isObjectExpression());
  }
  function isForAwaitStatement() {
    return isForOfStatement(this.node, {
      "await": true
    });
  }
  {
    virtualTypesValidator.isExistentialTypeParam = function isExistentialTypeParam() {
      throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
    };
    virtualTypesValidator.isNumericLiteralTypeAnnotation = function isNumericLiteralTypeAnnotation() {
      throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
    };
  }
  return virtualTypesValidator;
}

var hasRequiredVisitors;
function requireVisitors() {
  if (hasRequiredVisitors) return visitors;
  hasRequiredVisitors = 1;
  Object.defineProperty(visitors, "__esModule", {
    value: true
  });
  visitors.environmentVisitor = environmentVisitor;
  visitors.explode = explode$1;
  visitors.isExplodedVisitor = isExplodedVisitor;
  visitors.merge = merge;
  visitors.verify = verify$1;
  var virtualTypes = requireVirtualTypes();
  var virtualTypesValidators = requireVirtualTypesValidator();
  var _t = requireLib$4();
  var _context = requireContext();
  var DEPRECATED_KEYS = _t.DEPRECATED_KEYS,
    DEPRECATED_ALIASES = _t.DEPRECATED_ALIASES,
    FLIPPED_ALIAS_KEYS = _t.FLIPPED_ALIAS_KEYS,
    TYPES = _t.TYPES,
    deprecationWarning = _t.__internal__deprecationWarning;
  function isVirtualType(type) {
    return type in virtualTypes;
  }
  function isExplodedVisitor(visitor) {
    return visitor == null ? void 0 : visitor._exploded;
  }
  function explode$1(visitor) {
    if (isExplodedVisitor(visitor)) return visitor;
    visitor._exploded = true;
    for (var _i = 0, _Object$keys = Object.keys(visitor); _i < _Object$keys.length; _i++) {
      var nodeType = _Object$keys[_i];
      if (shouldIgnoreKey(nodeType)) continue;
      var parts = nodeType.split("|");
      if (parts.length === 1) continue;
      var fns = visitor[nodeType];
      delete visitor[nodeType];
      var _iterator = _createForOfIteratorHelper(parts),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var part = _step.value;
          visitor[part] = fns;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    verify$1(visitor);
    delete visitor.__esModule;
    ensureEntranceObjects(visitor);
    ensureCallbackArrays(visitor);
    for (var _i2 = 0, _Object$keys2 = Object.keys(visitor); _i2 < _Object$keys2.length; _i2++) {
      var _nodeType = _Object$keys2[_i2];
      if (shouldIgnoreKey(_nodeType)) continue;
      if (!isVirtualType(_nodeType)) continue;
      var _fns = visitor[_nodeType];
      for (var _i3 = 0, _Object$keys3 = Object.keys(_fns); _i3 < _Object$keys3.length; _i3++) {
        var type = _Object$keys3[_i3];
        _fns[type] = wrapCheck(_nodeType, _fns[type]);
      }
      delete visitor[_nodeType];
      var types = virtualTypes[_nodeType];
      if (types !== null) {
        var _iterator2 = _createForOfIteratorHelper(types),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _type = _step2.value;
            if (visitor[_type]) {
              mergePair(visitor[_type], _fns);
            } else {
              visitor[_type] = _fns;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      } else {
        mergePair(visitor, _fns);
      }
    }
    for (var _i4 = 0, _Object$keys4 = Object.keys(visitor); _i4 < _Object$keys4.length; _i4++) {
      var _nodeType2 = _Object$keys4[_i4];
      if (shouldIgnoreKey(_nodeType2)) continue;
      var aliases = FLIPPED_ALIAS_KEYS[_nodeType2];
      if (_nodeType2 in DEPRECATED_KEYS) {
        var deprecatedKey = DEPRECATED_KEYS[_nodeType2];
        deprecationWarning(_nodeType2, deprecatedKey, "Visitor ");
        aliases = [deprecatedKey];
      } else if (_nodeType2 in DEPRECATED_ALIASES) {
        var deprecatedAlias = DEPRECATED_ALIASES[_nodeType2];
        deprecationWarning(_nodeType2, deprecatedAlias, "Visitor ");
        aliases = FLIPPED_ALIAS_KEYS[deprecatedAlias];
      }
      if (!aliases) continue;
      var _fns2 = visitor[_nodeType2];
      delete visitor[_nodeType2];
      var _iterator3 = _createForOfIteratorHelper(aliases),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var alias = _step3.value;
          var existing = visitor[alias];
          if (existing) {
            mergePair(existing, _fns2);
          } else {
            visitor[alias] = Object.assign({}, _fns2);
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
    for (var _i5 = 0, _Object$keys5 = Object.keys(visitor); _i5 < _Object$keys5.length; _i5++) {
      var _nodeType3 = _Object$keys5[_i5];
      if (shouldIgnoreKey(_nodeType3)) continue;
      ensureCallbackArrays(visitor[_nodeType3]);
    }
    return visitor;
  }
  function verify$1(visitor) {
    if (visitor._verified) return;
    if (typeof visitor === "function") {
      throw new Error("You passed `traverse()` a function when it expected a visitor object, " + "are you sure you didn't mean `{ enter: Function }`?");
    }
    for (var _i6 = 0, _Object$keys6 = Object.keys(visitor); _i6 < _Object$keys6.length; _i6++) {
      var nodeType = _Object$keys6[_i6];
      if (nodeType === "enter" || nodeType === "exit") {
        validateVisitorMethods(nodeType, visitor[nodeType]);
      }
      if (shouldIgnoreKey(nodeType)) continue;
      if (!TYPES.includes(nodeType)) {
        throw new Error("You gave us a visitor for the node type ".concat(nodeType, " but it's not a valid type in @babel/traverse ", "7.26.9"));
      }
      var _visitors = visitor[nodeType];
      if (_typeof(_visitors) === "object") {
        for (var _i7 = 0, _Object$keys7 = Object.keys(_visitors); _i7 < _Object$keys7.length; _i7++) {
          var visitorKey = _Object$keys7[_i7];
          if (visitorKey === "enter" || visitorKey === "exit") {
            validateVisitorMethods("".concat(nodeType, ".").concat(visitorKey), _visitors[visitorKey]);
          } else {
            throw new Error("You passed `traverse()` a visitor object with the property " + "".concat(nodeType, " that has the invalid property ").concat(visitorKey));
          }
        }
      }
    }
    visitor._verified = true;
  }
  function validateVisitorMethods(path, val) {
    var fns = [].concat(val);
    var _iterator4 = _createForOfIteratorHelper(fns),
      _step4;
    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var fn = _step4.value;
        if (typeof fn !== "function") {
          throw new TypeError("Non-function found defined in ".concat(path, " with type ").concat(_typeof(fn)));
        }
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
  }
  function merge(visitors) {
    var states = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var wrapper = arguments.length > 2 ? arguments[2] : undefined;
    var mergedVisitor = {
      _verified: true,
      _exploded: true
    };
    {
      Object.defineProperty(mergedVisitor, "_exploded", {
        enumerable: false
      });
      Object.defineProperty(mergedVisitor, "_verified", {
        enumerable: false
      });
    }
    for (var i = 0; i < visitors.length; i++) {
      var visitor = explode$1(visitors[i]);
      var state = states[i];
      var topVisitor = visitor;
      if (state || wrapper) {
        topVisitor = wrapWithStateOrWrapper(topVisitor, state, wrapper);
      }
      mergePair(mergedVisitor, topVisitor);
      for (var _i8 = 0, _Object$keys8 = Object.keys(visitor); _i8 < _Object$keys8.length; _i8++) {
        var key = _Object$keys8[_i8];
        if (shouldIgnoreKey(key)) continue;
        var typeVisitor = visitor[key];
        if (state || wrapper) {
          typeVisitor = wrapWithStateOrWrapper(typeVisitor, state, wrapper);
        }
        var nodeVisitor = mergedVisitor[key] || (mergedVisitor[key] = {});
        mergePair(nodeVisitor, typeVisitor);
      }
    }
    return mergedVisitor;
  }
  function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
    var newVisitor = {};
    var _loop = function _loop() {
      var phase = _arr[_i9];
      var fns = oldVisitor[phase];
      if (!Array.isArray(fns)) return 1; // continue
      fns = fns.map(function (fn) {
        var newFn = fn;
        if (state) {
          newFn = function newFn(path) {
            fn.call(state, path, state);
          };
        }
        if (wrapper) {
          newFn = wrapper(state == null ? void 0 : state.key, phase, newFn);
        }
        if (newFn !== fn) {
          newFn.toString = function () {
            return fn.toString();
          };
        }
        return newFn;
      });
      newVisitor[phase] = fns;
    };
    for (var _i9 = 0, _arr = ["enter", "exit"]; _i9 < _arr.length; _i9++) {
      if (_loop()) continue;
    }
    return newVisitor;
  }
  function ensureEntranceObjects(obj) {
    for (var _i10 = 0, _Object$keys9 = Object.keys(obj); _i10 < _Object$keys9.length; _i10++) {
      var key = _Object$keys9[_i10];
      if (shouldIgnoreKey(key)) continue;
      var fns = obj[key];
      if (typeof fns === "function") {
        obj[key] = {
          enter: fns
        };
      }
    }
  }
  function ensureCallbackArrays(obj) {
    if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];
    if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];
  }
  function wrapCheck(nodeType, fn) {
    var fnKey = "is".concat(nodeType);
    var validator = virtualTypesValidators[fnKey];
    var newFn = function newFn(path) {
      if (validator.call(path)) {
        return fn.apply(this, arguments);
      }
    };
    newFn.toString = function () {
      return fn.toString();
    };
    return newFn;
  }
  function shouldIgnoreKey(key) {
    if (key[0] === "_") return true;
    if (key === "enter" || key === "exit" || key === "shouldSkip") return true;
    if (key === "denylist" || key === "noScope" || key === "skipKeys") {
      return true;
    }
    {
      if (key === "blacklist") {
        return true;
      }
    }
    return false;
  }
  function mergePair(dest, src) {
    for (var _i11 = 0, _arr2 = ["enter", "exit"]; _i11 < _arr2.length; _i11++) {
      var phase = _arr2[_i11];
      if (!src[phase]) continue;
      dest[phase] = [].concat(dest[phase] || [], src[phase]);
    }
  }
  var _environmentVisitor = {
    FunctionParent: function FunctionParent(path) {
      if (path.isArrowFunctionExpression()) return;
      path.skip();
      if (path.isMethod()) {
        if (!path.requeueComputedKeyAndDecorators) {
          _context.requeueComputedKeyAndDecorators.call(path);
        } else {
          path.requeueComputedKeyAndDecorators();
        }
      }
    },
    Property: function Property(path) {
      if (path.isObjectProperty()) return;
      path.skip();
      if (!path.requeueComputedKeyAndDecorators) {
        _context.requeueComputedKeyAndDecorators.call(path);
      } else {
        path.requeueComputedKeyAndDecorators();
      }
    }
  };
  function environmentVisitor(visitor) {
    return merge([_environmentVisitor, visitor]);
  }
  return visitors;
}

var hasRequiredRenamer;
function requireRenamer() {
  if (hasRequiredRenamer) return renamer;
  hasRequiredRenamer = 1;
  Object.defineProperty(renamer, "__esModule", {
    value: true
  });
  renamer["default"] = void 0;
  var t = requireLib$4();
  var _t = t;
  var _traverseNode = requireTraverseNode();
  var _visitors = requireVisitors();
  var _context = requireContext();
  var getAssignmentIdentifiers = _t.getAssignmentIdentifiers;
  var renameVisitor = {
    ReferencedIdentifier: function ReferencedIdentifier(_ref, state) {
      var node = _ref.node;
      if (node.name === state.oldName) {
        node.name = state.newName;
      }
    },
    Scope: function Scope(path, state) {
      if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
        path.skip();
        if (path.isMethod()) {
          if (!path.requeueComputedKeyAndDecorators) {
            _context.requeueComputedKeyAndDecorators.call(path);
          } else {
            path.requeueComputedKeyAndDecorators();
          }
        }
      }
    },
    ObjectProperty: function ObjectProperty(_ref2, state) {
      var node = _ref2.node,
        scope = _ref2.scope;
      var name = node.key.name;
      if (node.shorthand && (name === state.oldName || name === state.newName) && scope.getBindingIdentifier(name) === state.binding.identifier) {
        node.shorthand = false;
        {
          var _node$extra;
          if ((_node$extra = node.extra) != null && _node$extra.shorthand) node.extra.shorthand = false;
        }
      }
    },
    "AssignmentExpression|Declaration|VariableDeclarator": function AssignmentExpressionDeclarationVariableDeclarator(path, state) {
      if (path.isVariableDeclaration()) return;
      var ids = path.isAssignmentExpression() ? getAssignmentIdentifiers(path.node) : path.getOuterBindingIdentifiers();
      for (var name in ids) {
        if (name === state.oldName) ids[name].name = state.newName;
      }
    }
  };
  var Renamer = /*#__PURE__*/function () {
    function Renamer(binding, oldName, newName) {
      _classCallCheck(this, Renamer);
      this.newName = newName;
      this.oldName = oldName;
      this.binding = binding;
    }
    return _createClass(Renamer, [{
      key: "maybeConvertFromExportDeclaration",
      value: function maybeConvertFromExportDeclaration(parentDeclar) {
        var maybeExportDeclar = parentDeclar.parentPath;
        if (!maybeExportDeclar.isExportDeclaration()) {
          return;
        }
        if (maybeExportDeclar.isExportDefaultDeclaration()) {
          var declaration = maybeExportDeclar.node.declaration;
          if (t.isDeclaration(declaration) && !declaration.id) {
            return;
          }
        }
        if (maybeExportDeclar.isExportAllDeclaration()) {
          return;
        }
        maybeExportDeclar.splitExportDeclaration();
      }
    }, {
      key: "maybeConvertFromClassFunctionDeclaration",
      value: function maybeConvertFromClassFunctionDeclaration(path) {
        return path;
      }
    }, {
      key: "maybeConvertFromClassFunctionExpression",
      value: function maybeConvertFromClassFunctionExpression(path) {
        return path;
      }
    }, {
      key: "rename",
      value: function rename() {
        var binding = this.binding,
          oldName = this.oldName,
          newName = this.newName;
        var scope = binding.scope,
          path = binding.path;
        var parentDeclar = path.find(function (path) {
          return path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression();
        });
        if (parentDeclar) {
          var bindingIds = parentDeclar.getOuterBindingIdentifiers();
          if (bindingIds[oldName] === binding.identifier) {
            this.maybeConvertFromExportDeclaration(parentDeclar);
          }
        }
        var blockToTraverse = arguments[0] || scope.block;
        var skipKeys = {
          discriminant: true
        };
        if (t.isMethod(blockToTraverse)) {
          if (blockToTraverse.computed) {
            skipKeys.key = true;
          }
          if (!t.isObjectMethod(blockToTraverse)) {
            skipKeys.decorators = true;
          }
        }
        (0, _traverseNode.traverseNode)(blockToTraverse, (0, _visitors.explode)(renameVisitor), scope, this, scope.path, skipKeys);
        if (!arguments[0]) {
          scope.removeOwnBinding(oldName);
          scope.bindings[newName] = binding;
          this.binding.identifier.name = newName;
        }
        if (parentDeclar) {
          this.maybeConvertFromClassFunctionDeclaration(path);
          this.maybeConvertFromClassFunctionExpression(path);
        }
      }
    }]);
  }();
  renamer["default"] = Renamer;
  return renamer;
}

var binding = {};

var hasRequiredBinding;
function requireBinding() {
  if (hasRequiredBinding) return binding;
  hasRequiredBinding = 1;
  Object.defineProperty(binding, "__esModule", {
    value: true
  });
  binding["default"] = void 0;
  var Binding = /*#__PURE__*/function () {
    function Binding(_ref) {
      var identifier = _ref.identifier,
        scope = _ref.scope,
        path = _ref.path,
        kind = _ref.kind;
      _classCallCheck(this, Binding);
      this.identifier = void 0;
      this.scope = void 0;
      this.path = void 0;
      this.kind = void 0;
      this.constantViolations = [];
      this.constant = true;
      this.referencePaths = [];
      this.referenced = false;
      this.references = 0;
      this.identifier = identifier;
      this.scope = scope;
      this.path = path;
      this.kind = kind;
      if ((kind === "var" || kind === "hoisted") && isDeclaredInLoop(path)) {
        this.reassign(path);
      }
      this.clearValue();
    }
    return _createClass(Binding, [{
      key: "deoptValue",
      value: function deoptValue() {
        this.clearValue();
        this.hasDeoptedValue = true;
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        if (this.hasDeoptedValue) return;
        this.hasValue = true;
        this.value = value;
      }
    }, {
      key: "clearValue",
      value: function clearValue() {
        this.hasDeoptedValue = false;
        this.hasValue = false;
        this.value = null;
      }
    }, {
      key: "reassign",
      value: function reassign(path) {
        this.constant = false;
        if (this.constantViolations.includes(path)) {
          return;
        }
        this.constantViolations.push(path);
      }
    }, {
      key: "reference",
      value: function reference(path) {
        if (this.referencePaths.includes(path)) {
          return;
        }
        this.referenced = true;
        this.references++;
        this.referencePaths.push(path);
      }
    }, {
      key: "dereference",
      value: function dereference() {
        this.references--;
        this.referenced = !!this.references;
      }
    }]);
  }();
  binding["default"] = Binding;
  function isDeclaredInLoop(path) {
    for (var parentPath = path.parentPath, key = path.key; parentPath; _parentPath = parentPath, parentPath = _parentPath.parentPath, key = _parentPath.key, _parentPath) {
      var _parentPath;
      if (parentPath.isFunctionParent()) return false;
      if (parentPath.isWhile() || parentPath.isForXStatement() || parentPath.isForStatement() && key === "body") {
        return true;
      }
    }
    return false;
  }
  return binding;
}

var builtin = {
	"Array": false,
	"ArrayBuffer": false,
	Atomics: false,
	BigInt: false,
	BigInt64Array: false,
	BigUint64Array: false,
	"Boolean": false,
	constructor: false,
	"DataView": false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	"Float32Array": false,
	"Float64Array": false,
	"Function": false,
	globalThis: false,
	hasOwnProperty: false,
	"Infinity": false,
	"Int16Array": false,
	"Int32Array": false,
	"Int8Array": false,
	"isFinite": false,
	"isNaN": false,
	isPrototypeOf: false,
	"JSON": false,
	"Map": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	"Promise": false,
	propertyIsEnumerable: false,
	"Proxy": false,
	"RangeError": false,
	"ReferenceError": false,
	"Reflect": false,
	"RegExp": false,
	"Set": false,
	SharedArrayBuffer: false,
	"String": false,
	"Symbol": false,
	"SyntaxError": false,
	toLocaleString: false,
	toString: false,
	"TypeError": false,
	"Uint16Array": false,
	"Uint32Array": false,
	"Uint8Array": false,
	"Uint8ClampedArray": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	valueOf: false,
	"WeakMap": false,
	"WeakSet": false
};
var es5 = {
	"Array": false,
	"Boolean": false,
	constructor: false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	"Function": false,
	hasOwnProperty: false,
	"Infinity": false,
	"isFinite": false,
	"isNaN": false,
	isPrototypeOf: false,
	"JSON": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	propertyIsEnumerable: false,
	"RangeError": false,
	"ReferenceError": false,
	"RegExp": false,
	"String": false,
	"SyntaxError": false,
	toLocaleString: false,
	toString: false,
	"TypeError": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	valueOf: false
};
var es2015 = {
	"Array": false,
	"ArrayBuffer": false,
	"Boolean": false,
	constructor: false,
	"DataView": false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	"Float32Array": false,
	"Float64Array": false,
	"Function": false,
	hasOwnProperty: false,
	"Infinity": false,
	"Int16Array": false,
	"Int32Array": false,
	"Int8Array": false,
	"isFinite": false,
	"isNaN": false,
	isPrototypeOf: false,
	"JSON": false,
	"Map": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	"Promise": false,
	propertyIsEnumerable: false,
	"Proxy": false,
	"RangeError": false,
	"ReferenceError": false,
	"Reflect": false,
	"RegExp": false,
	"Set": false,
	"String": false,
	"Symbol": false,
	"SyntaxError": false,
	toLocaleString: false,
	toString: false,
	"TypeError": false,
	"Uint16Array": false,
	"Uint32Array": false,
	"Uint8Array": false,
	"Uint8ClampedArray": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	valueOf: false,
	"WeakMap": false,
	"WeakSet": false
};
var es2017 = {
	"Array": false,
	"ArrayBuffer": false,
	Atomics: false,
	"Boolean": false,
	constructor: false,
	"DataView": false,
	"Date": false,
	"decodeURI": false,
	"decodeURIComponent": false,
	"encodeURI": false,
	"encodeURIComponent": false,
	"Error": false,
	"escape": false,
	"eval": false,
	"EvalError": false,
	"Float32Array": false,
	"Float64Array": false,
	"Function": false,
	hasOwnProperty: false,
	"Infinity": false,
	"Int16Array": false,
	"Int32Array": false,
	"Int8Array": false,
	"isFinite": false,
	"isNaN": false,
	isPrototypeOf: false,
	"JSON": false,
	"Map": false,
	"Math": false,
	"NaN": false,
	"Number": false,
	"Object": false,
	"parseFloat": false,
	"parseInt": false,
	"Promise": false,
	propertyIsEnumerable: false,
	"Proxy": false,
	"RangeError": false,
	"ReferenceError": false,
	"Reflect": false,
	"RegExp": false,
	"Set": false,
	SharedArrayBuffer: false,
	"String": false,
	"Symbol": false,
	"SyntaxError": false,
	toLocaleString: false,
	toString: false,
	"TypeError": false,
	"Uint16Array": false,
	"Uint32Array": false,
	"Uint8Array": false,
	"Uint8ClampedArray": false,
	"undefined": false,
	"unescape": false,
	"URIError": false,
	valueOf: false,
	"WeakMap": false,
	"WeakSet": false
};
var browser = {
	AbortController: false,
	AbortSignal: false,
	addEventListener: false,
	alert: false,
	AnalyserNode: false,
	Animation: false,
	AnimationEffectReadOnly: false,
	AnimationEffectTiming: false,
	AnimationEffectTimingReadOnly: false,
	AnimationEvent: false,
	AnimationPlaybackEvent: false,
	AnimationTimeline: false,
	applicationCache: false,
	ApplicationCache: false,
	ApplicationCacheErrorEvent: false,
	atob: false,
	Attr: false,
	Audio: false,
	AudioBuffer: false,
	AudioBufferSourceNode: false,
	AudioContext: false,
	AudioDestinationNode: false,
	AudioListener: false,
	AudioNode: false,
	AudioParam: false,
	AudioProcessingEvent: false,
	AudioScheduledSourceNode: false,
	"AudioWorkletGlobalScope ": false,
	AudioWorkletNode: false,
	AudioWorkletProcessor: false,
	BarProp: false,
	BaseAudioContext: false,
	BatteryManager: false,
	BeforeUnloadEvent: false,
	BiquadFilterNode: false,
	Blob: false,
	BlobEvent: false,
	blur: false,
	BroadcastChannel: false,
	btoa: false,
	BudgetService: false,
	ByteLengthQueuingStrategy: false,
	Cache: false,
	caches: false,
	CacheStorage: false,
	cancelAnimationFrame: false,
	cancelIdleCallback: false,
	CanvasCaptureMediaStreamTrack: false,
	CanvasGradient: false,
	CanvasPattern: false,
	CanvasRenderingContext2D: false,
	ChannelMergerNode: false,
	ChannelSplitterNode: false,
	CharacterData: false,
	clearInterval: false,
	clearTimeout: false,
	clientInformation: false,
	ClipboardEvent: false,
	close: false,
	closed: false,
	CloseEvent: false,
	Comment: false,
	CompositionEvent: false,
	confirm: false,
	console: false,
	ConstantSourceNode: false,
	ConvolverNode: false,
	CountQueuingStrategy: false,
	createImageBitmap: false,
	Credential: false,
	CredentialsContainer: false,
	crypto: false,
	Crypto: false,
	CryptoKey: false,
	CSS: false,
	CSSConditionRule: false,
	CSSFontFaceRule: false,
	CSSGroupingRule: false,
	CSSImportRule: false,
	CSSKeyframeRule: false,
	CSSKeyframesRule: false,
	CSSMediaRule: false,
	CSSNamespaceRule: false,
	CSSPageRule: false,
	CSSRule: false,
	CSSRuleList: false,
	CSSStyleDeclaration: false,
	CSSStyleRule: false,
	CSSStyleSheet: false,
	CSSSupportsRule: false,
	CustomElementRegistry: false,
	customElements: false,
	CustomEvent: false,
	DataTransfer: false,
	DataTransferItem: false,
	DataTransferItemList: false,
	defaultstatus: false,
	defaultStatus: false,
	DelayNode: false,
	DeviceMotionEvent: false,
	DeviceOrientationEvent: false,
	devicePixelRatio: false,
	dispatchEvent: false,
	document: false,
	Document: false,
	DocumentFragment: false,
	DocumentType: false,
	DOMError: false,
	DOMException: false,
	DOMImplementation: false,
	DOMMatrix: false,
	DOMMatrixReadOnly: false,
	DOMParser: false,
	DOMPoint: false,
	DOMPointReadOnly: false,
	DOMQuad: false,
	DOMRect: false,
	DOMRectReadOnly: false,
	DOMStringList: false,
	DOMStringMap: false,
	DOMTokenList: false,
	DragEvent: false,
	DynamicsCompressorNode: false,
	Element: false,
	ErrorEvent: false,
	event: false,
	Event: false,
	EventSource: false,
	EventTarget: false,
	external: false,
	fetch: false,
	File: false,
	FileList: false,
	FileReader: false,
	find: false,
	focus: false,
	FocusEvent: false,
	FontFace: false,
	FontFaceSetLoadEvent: false,
	FormData: false,
	frameElement: false,
	frames: false,
	GainNode: false,
	Gamepad: false,
	GamepadButton: false,
	GamepadEvent: false,
	getComputedStyle: false,
	getSelection: false,
	HashChangeEvent: false,
	Headers: false,
	history: false,
	History: false,
	HTMLAllCollection: false,
	HTMLAnchorElement: false,
	HTMLAreaElement: false,
	HTMLAudioElement: false,
	HTMLBaseElement: false,
	HTMLBodyElement: false,
	HTMLBRElement: false,
	HTMLButtonElement: false,
	HTMLCanvasElement: false,
	HTMLCollection: false,
	HTMLContentElement: false,
	HTMLDataElement: false,
	HTMLDataListElement: false,
	HTMLDetailsElement: false,
	HTMLDialogElement: false,
	HTMLDirectoryElement: false,
	HTMLDivElement: false,
	HTMLDListElement: false,
	HTMLDocument: false,
	HTMLElement: false,
	HTMLEmbedElement: false,
	HTMLFieldSetElement: false,
	HTMLFontElement: false,
	HTMLFormControlsCollection: false,
	HTMLFormElement: false,
	HTMLFrameElement: false,
	HTMLFrameSetElement: false,
	HTMLHeadElement: false,
	HTMLHeadingElement: false,
	HTMLHRElement: false,
	HTMLHtmlElement: false,
	HTMLIFrameElement: false,
	HTMLImageElement: false,
	HTMLInputElement: false,
	HTMLLabelElement: false,
	HTMLLegendElement: false,
	HTMLLIElement: false,
	HTMLLinkElement: false,
	HTMLMapElement: false,
	HTMLMarqueeElement: false,
	HTMLMediaElement: false,
	HTMLMenuElement: false,
	HTMLMetaElement: false,
	HTMLMeterElement: false,
	HTMLModElement: false,
	HTMLObjectElement: false,
	HTMLOListElement: false,
	HTMLOptGroupElement: false,
	HTMLOptionElement: false,
	HTMLOptionsCollection: false,
	HTMLOutputElement: false,
	HTMLParagraphElement: false,
	HTMLParamElement: false,
	HTMLPictureElement: false,
	HTMLPreElement: false,
	HTMLProgressElement: false,
	HTMLQuoteElement: false,
	HTMLScriptElement: false,
	HTMLSelectElement: false,
	HTMLShadowElement: false,
	HTMLSlotElement: false,
	HTMLSourceElement: false,
	HTMLSpanElement: false,
	HTMLStyleElement: false,
	HTMLTableCaptionElement: false,
	HTMLTableCellElement: false,
	HTMLTableColElement: false,
	HTMLTableElement: false,
	HTMLTableRowElement: false,
	HTMLTableSectionElement: false,
	HTMLTemplateElement: false,
	HTMLTextAreaElement: false,
	HTMLTimeElement: false,
	HTMLTitleElement: false,
	HTMLTrackElement: false,
	HTMLUListElement: false,
	HTMLUnknownElement: false,
	HTMLVideoElement: false,
	IDBCursor: false,
	IDBCursorWithValue: false,
	IDBDatabase: false,
	IDBFactory: false,
	IDBIndex: false,
	IDBKeyRange: false,
	IDBObjectStore: false,
	IDBOpenDBRequest: false,
	IDBRequest: false,
	IDBTransaction: false,
	IDBVersionChangeEvent: false,
	IdleDeadline: false,
	IIRFilterNode: false,
	Image: false,
	ImageBitmap: false,
	ImageBitmapRenderingContext: false,
	ImageCapture: false,
	ImageData: false,
	indexedDB: false,
	innerHeight: false,
	innerWidth: false,
	InputEvent: false,
	IntersectionObserver: false,
	IntersectionObserverEntry: false,
	"Intl": false,
	isSecureContext: false,
	KeyboardEvent: false,
	KeyframeEffect: false,
	KeyframeEffectReadOnly: false,
	length: false,
	localStorage: false,
	location: true,
	Location: false,
	locationbar: false,
	matchMedia: false,
	MediaDeviceInfo: false,
	MediaDevices: false,
	MediaElementAudioSourceNode: false,
	MediaEncryptedEvent: false,
	MediaError: false,
	MediaKeyMessageEvent: false,
	MediaKeySession: false,
	MediaKeyStatusMap: false,
	MediaKeySystemAccess: false,
	MediaList: false,
	MediaQueryList: false,
	MediaQueryListEvent: false,
	MediaRecorder: false,
	MediaSettingsRange: false,
	MediaSource: false,
	MediaStream: false,
	MediaStreamAudioDestinationNode: false,
	MediaStreamAudioSourceNode: false,
	MediaStreamEvent: false,
	MediaStreamTrack: false,
	MediaStreamTrackEvent: false,
	menubar: false,
	MessageChannel: false,
	MessageEvent: false,
	MessagePort: false,
	MIDIAccess: false,
	MIDIConnectionEvent: false,
	MIDIInput: false,
	MIDIInputMap: false,
	MIDIMessageEvent: false,
	MIDIOutput: false,
	MIDIOutputMap: false,
	MIDIPort: false,
	MimeType: false,
	MimeTypeArray: false,
	MouseEvent: false,
	moveBy: false,
	moveTo: false,
	MutationEvent: false,
	MutationObserver: false,
	MutationRecord: false,
	name: false,
	NamedNodeMap: false,
	NavigationPreloadManager: false,
	navigator: false,
	Navigator: false,
	NetworkInformation: false,
	Node: false,
	NodeFilter: false,
	NodeIterator: false,
	NodeList: false,
	Notification: false,
	OfflineAudioCompletionEvent: false,
	OfflineAudioContext: false,
	offscreenBuffering: false,
	OffscreenCanvas: true,
	onabort: true,
	onafterprint: true,
	onanimationend: true,
	onanimationiteration: true,
	onanimationstart: true,
	onappinstalled: true,
	onauxclick: true,
	onbeforeinstallprompt: true,
	onbeforeprint: true,
	onbeforeunload: true,
	onblur: true,
	oncancel: true,
	oncanplay: true,
	oncanplaythrough: true,
	onchange: true,
	onclick: true,
	onclose: true,
	oncontextmenu: true,
	oncuechange: true,
	ondblclick: true,
	ondevicemotion: true,
	ondeviceorientation: true,
	ondeviceorientationabsolute: true,
	ondrag: true,
	ondragend: true,
	ondragenter: true,
	ondragleave: true,
	ondragover: true,
	ondragstart: true,
	ondrop: true,
	ondurationchange: true,
	onemptied: true,
	onended: true,
	onerror: true,
	onfocus: true,
	ongotpointercapture: true,
	onhashchange: true,
	oninput: true,
	oninvalid: true,
	onkeydown: true,
	onkeypress: true,
	onkeyup: true,
	onlanguagechange: true,
	onload: true,
	onloadeddata: true,
	onloadedmetadata: true,
	onloadstart: true,
	onlostpointercapture: true,
	onmessage: true,
	onmessageerror: true,
	onmousedown: true,
	onmouseenter: true,
	onmouseleave: true,
	onmousemove: true,
	onmouseout: true,
	onmouseover: true,
	onmouseup: true,
	onmousewheel: true,
	onoffline: true,
	ononline: true,
	onpagehide: true,
	onpageshow: true,
	onpause: true,
	onplay: true,
	onplaying: true,
	onpointercancel: true,
	onpointerdown: true,
	onpointerenter: true,
	onpointerleave: true,
	onpointermove: true,
	onpointerout: true,
	onpointerover: true,
	onpointerup: true,
	onpopstate: true,
	onprogress: true,
	onratechange: true,
	onrejectionhandled: true,
	onreset: true,
	onresize: true,
	onscroll: true,
	onsearch: true,
	onseeked: true,
	onseeking: true,
	onselect: true,
	onstalled: true,
	onstorage: true,
	onsubmit: true,
	onsuspend: true,
	ontimeupdate: true,
	ontoggle: true,
	ontransitionend: true,
	onunhandledrejection: true,
	onunload: true,
	onvolumechange: true,
	onwaiting: true,
	onwheel: true,
	open: false,
	openDatabase: false,
	opener: false,
	Option: false,
	origin: false,
	OscillatorNode: false,
	outerHeight: false,
	outerWidth: false,
	PageTransitionEvent: false,
	pageXOffset: false,
	pageYOffset: false,
	PannerNode: false,
	parent: false,
	Path2D: false,
	PaymentAddress: false,
	PaymentRequest: false,
	PaymentRequestUpdateEvent: false,
	PaymentResponse: false,
	performance: false,
	Performance: false,
	PerformanceEntry: false,
	PerformanceLongTaskTiming: false,
	PerformanceMark: false,
	PerformanceMeasure: false,
	PerformanceNavigation: false,
	PerformanceNavigationTiming: false,
	PerformanceObserver: false,
	PerformanceObserverEntryList: false,
	PerformancePaintTiming: false,
	PerformanceResourceTiming: false,
	PerformanceTiming: false,
	PeriodicWave: false,
	Permissions: false,
	PermissionStatus: false,
	personalbar: false,
	PhotoCapabilities: false,
	Plugin: false,
	PluginArray: false,
	PointerEvent: false,
	PopStateEvent: false,
	postMessage: false,
	Presentation: false,
	PresentationAvailability: false,
	PresentationConnection: false,
	PresentationConnectionAvailableEvent: false,
	PresentationConnectionCloseEvent: false,
	PresentationConnectionList: false,
	PresentationReceiver: false,
	PresentationRequest: false,
	print: false,
	ProcessingInstruction: false,
	ProgressEvent: false,
	PromiseRejectionEvent: false,
	prompt: false,
	PushManager: false,
	PushSubscription: false,
	PushSubscriptionOptions: false,
	queueMicrotask: false,
	RadioNodeList: false,
	Range: false,
	ReadableStream: false,
	registerProcessor: false,
	RemotePlayback: false,
	removeEventListener: false,
	Request: false,
	requestAnimationFrame: false,
	requestIdleCallback: false,
	resizeBy: false,
	ResizeObserver: false,
	ResizeObserverEntry: false,
	resizeTo: false,
	Response: false,
	RTCCertificate: false,
	RTCDataChannel: false,
	RTCDataChannelEvent: false,
	RTCDtlsTransport: false,
	RTCIceCandidate: false,
	RTCIceGatherer: false,
	RTCIceTransport: false,
	RTCPeerConnection: false,
	RTCPeerConnectionIceEvent: false,
	RTCRtpContributingSource: false,
	RTCRtpReceiver: false,
	RTCRtpSender: false,
	RTCSctpTransport: false,
	RTCSessionDescription: false,
	RTCStatsReport: false,
	RTCTrackEvent: false,
	screen: false,
	Screen: false,
	screenLeft: false,
	ScreenOrientation: false,
	screenTop: false,
	screenX: false,
	screenY: false,
	ScriptProcessorNode: false,
	scroll: false,
	scrollbars: false,
	scrollBy: false,
	scrollTo: false,
	scrollX: false,
	scrollY: false,
	SecurityPolicyViolationEvent: false,
	Selection: false,
	self: false,
	ServiceWorker: false,
	ServiceWorkerContainer: false,
	ServiceWorkerRegistration: false,
	sessionStorage: false,
	setInterval: false,
	setTimeout: false,
	ShadowRoot: false,
	SharedWorker: false,
	SourceBuffer: false,
	SourceBufferList: false,
	speechSynthesis: false,
	SpeechSynthesisEvent: false,
	SpeechSynthesisUtterance: false,
	StaticRange: false,
	status: false,
	statusbar: false,
	StereoPannerNode: false,
	stop: false,
	Storage: false,
	StorageEvent: false,
	StorageManager: false,
	styleMedia: false,
	StyleSheet: false,
	StyleSheetList: false,
	SubtleCrypto: false,
	SVGAElement: false,
	SVGAngle: false,
	SVGAnimatedAngle: false,
	SVGAnimatedBoolean: false,
	SVGAnimatedEnumeration: false,
	SVGAnimatedInteger: false,
	SVGAnimatedLength: false,
	SVGAnimatedLengthList: false,
	SVGAnimatedNumber: false,
	SVGAnimatedNumberList: false,
	SVGAnimatedPreserveAspectRatio: false,
	SVGAnimatedRect: false,
	SVGAnimatedString: false,
	SVGAnimatedTransformList: false,
	SVGAnimateElement: false,
	SVGAnimateMotionElement: false,
	SVGAnimateTransformElement: false,
	SVGAnimationElement: false,
	SVGCircleElement: false,
	SVGClipPathElement: false,
	SVGComponentTransferFunctionElement: false,
	SVGDefsElement: false,
	SVGDescElement: false,
	SVGDiscardElement: false,
	SVGElement: false,
	SVGEllipseElement: false,
	SVGFEBlendElement: false,
	SVGFEColorMatrixElement: false,
	SVGFEComponentTransferElement: false,
	SVGFECompositeElement: false,
	SVGFEConvolveMatrixElement: false,
	SVGFEDiffuseLightingElement: false,
	SVGFEDisplacementMapElement: false,
	SVGFEDistantLightElement: false,
	SVGFEDropShadowElement: false,
	SVGFEFloodElement: false,
	SVGFEFuncAElement: false,
	SVGFEFuncBElement: false,
	SVGFEFuncGElement: false,
	SVGFEFuncRElement: false,
	SVGFEGaussianBlurElement: false,
	SVGFEImageElement: false,
	SVGFEMergeElement: false,
	SVGFEMergeNodeElement: false,
	SVGFEMorphologyElement: false,
	SVGFEOffsetElement: false,
	SVGFEPointLightElement: false,
	SVGFESpecularLightingElement: false,
	SVGFESpotLightElement: false,
	SVGFETileElement: false,
	SVGFETurbulenceElement: false,
	SVGFilterElement: false,
	SVGForeignObjectElement: false,
	SVGGElement: false,
	SVGGeometryElement: false,
	SVGGradientElement: false,
	SVGGraphicsElement: false,
	SVGImageElement: false,
	SVGLength: false,
	SVGLengthList: false,
	SVGLinearGradientElement: false,
	SVGLineElement: false,
	SVGMarkerElement: false,
	SVGMaskElement: false,
	SVGMatrix: false,
	SVGMetadataElement: false,
	SVGMPathElement: false,
	SVGNumber: false,
	SVGNumberList: false,
	SVGPathElement: false,
	SVGPatternElement: false,
	SVGPoint: false,
	SVGPointList: false,
	SVGPolygonElement: false,
	SVGPolylineElement: false,
	SVGPreserveAspectRatio: false,
	SVGRadialGradientElement: false,
	SVGRect: false,
	SVGRectElement: false,
	SVGScriptElement: false,
	SVGSetElement: false,
	SVGStopElement: false,
	SVGStringList: false,
	SVGStyleElement: false,
	SVGSVGElement: false,
	SVGSwitchElement: false,
	SVGSymbolElement: false,
	SVGTextContentElement: false,
	SVGTextElement: false,
	SVGTextPathElement: false,
	SVGTextPositioningElement: false,
	SVGTitleElement: false,
	SVGTransform: false,
	SVGTransformList: false,
	SVGTSpanElement: false,
	SVGUnitTypes: false,
	SVGUseElement: false,
	SVGViewElement: false,
	TaskAttributionTiming: false,
	Text: false,
	TextDecoder: false,
	TextEncoder: false,
	TextEvent: false,
	TextMetrics: false,
	TextTrack: false,
	TextTrackCue: false,
	TextTrackCueList: false,
	TextTrackList: false,
	TimeRanges: false,
	toolbar: false,
	top: false,
	Touch: false,
	TouchEvent: false,
	TouchList: false,
	TrackEvent: false,
	TransitionEvent: false,
	TreeWalker: false,
	UIEvent: false,
	URL: false,
	URLSearchParams: false,
	ValidityState: false,
	visualViewport: false,
	VisualViewport: false,
	VTTCue: false,
	WaveShaperNode: false,
	WebAssembly: false,
	WebGL2RenderingContext: false,
	WebGLActiveInfo: false,
	WebGLBuffer: false,
	WebGLContextEvent: false,
	WebGLFramebuffer: false,
	WebGLProgram: false,
	WebGLQuery: false,
	WebGLRenderbuffer: false,
	WebGLRenderingContext: false,
	WebGLSampler: false,
	WebGLShader: false,
	WebGLShaderPrecisionFormat: false,
	WebGLSync: false,
	WebGLTexture: false,
	WebGLTransformFeedback: false,
	WebGLUniformLocation: false,
	WebGLVertexArrayObject: false,
	WebSocket: false,
	WheelEvent: false,
	window: false,
	Window: false,
	Worker: false,
	WritableStream: false,
	XMLDocument: false,
	XMLHttpRequest: false,
	XMLHttpRequestEventTarget: false,
	XMLHttpRequestUpload: false,
	XMLSerializer: false,
	XPathEvaluator: false,
	XPathExpression: false,
	XPathResult: false,
	XSLTProcessor: false
};
var worker = {
	addEventListener: false,
	applicationCache: false,
	atob: false,
	Blob: false,
	BroadcastChannel: false,
	btoa: false,
	Cache: false,
	caches: false,
	clearInterval: false,
	clearTimeout: false,
	close: true,
	console: false,
	fetch: false,
	FileReaderSync: false,
	FormData: false,
	Headers: false,
	IDBCursor: false,
	IDBCursorWithValue: false,
	IDBDatabase: false,
	IDBFactory: false,
	IDBIndex: false,
	IDBKeyRange: false,
	IDBObjectStore: false,
	IDBOpenDBRequest: false,
	IDBRequest: false,
	IDBTransaction: false,
	IDBVersionChangeEvent: false,
	ImageData: false,
	importScripts: true,
	indexedDB: false,
	location: false,
	MessageChannel: false,
	MessagePort: false,
	name: false,
	navigator: false,
	Notification: false,
	onclose: true,
	onconnect: true,
	onerror: true,
	onlanguagechange: true,
	onmessage: true,
	onoffline: true,
	ononline: true,
	onrejectionhandled: true,
	onunhandledrejection: true,
	performance: false,
	Performance: false,
	PerformanceEntry: false,
	PerformanceMark: false,
	PerformanceMeasure: false,
	PerformanceNavigation: false,
	PerformanceResourceTiming: false,
	PerformanceTiming: false,
	postMessage: true,
	"Promise": false,
	queueMicrotask: false,
	removeEventListener: false,
	Request: false,
	Response: false,
	self: true,
	ServiceWorkerRegistration: false,
	setInterval: false,
	setTimeout: false,
	TextDecoder: false,
	TextEncoder: false,
	URL: false,
	URLSearchParams: false,
	WebSocket: false,
	Worker: false,
	WorkerGlobalScope: false,
	XMLHttpRequest: false
};
var node$1 = {
	__dirname: false,
	__filename: false,
	Buffer: false,
	clearImmediate: false,
	clearInterval: false,
	clearTimeout: false,
	console: false,
	exports: true,
	global: false,
	"Intl": false,
	module: false,
	process: false,
	queueMicrotask: false,
	require: false,
	setImmediate: false,
	setInterval: false,
	setTimeout: false,
	TextDecoder: false,
	TextEncoder: false,
	URL: false,
	URLSearchParams: false
};
var commonjs = {
	exports: true,
	global: false,
	module: false,
	require: false
};
var amd = {
	define: false,
	require: false
};
var mocha = {
	after: false,
	afterEach: false,
	before: false,
	beforeEach: false,
	context: false,
	describe: false,
	it: false,
	mocha: false,
	run: false,
	setup: false,
	specify: false,
	suite: false,
	suiteSetup: false,
	suiteTeardown: false,
	teardown: false,
	test: false,
	xcontext: false,
	xdescribe: false,
	xit: false,
	xspecify: false
};
var jasmine = {
	afterAll: false,
	afterEach: false,
	beforeAll: false,
	beforeEach: false,
	describe: false,
	expect: false,
	fail: false,
	fdescribe: false,
	fit: false,
	it: false,
	jasmine: false,
	pending: false,
	runs: false,
	spyOn: false,
	spyOnProperty: false,
	waits: false,
	waitsFor: false,
	xdescribe: false,
	xit: false
};
var jest = {
	afterAll: false,
	afterEach: false,
	beforeAll: false,
	beforeEach: false,
	describe: false,
	expect: false,
	fdescribe: false,
	fit: false,
	it: false,
	jest: false,
	pit: false,
	require: false,
	test: false,
	xdescribe: false,
	xit: false,
	xtest: false
};
var qunit = {
	asyncTest: false,
	deepEqual: false,
	equal: false,
	expect: false,
	module: false,
	notDeepEqual: false,
	notEqual: false,
	notOk: false,
	notPropEqual: false,
	notStrictEqual: false,
	ok: false,
	propEqual: false,
	QUnit: false,
	raises: false,
	start: false,
	stop: false,
	strictEqual: false,
	test: false,
	throws: false
};
var phantomjs = {
	console: true,
	exports: true,
	phantom: true,
	require: true,
	WebPage: true
};
var couch = {
	emit: false,
	exports: false,
	getRow: false,
	log: false,
	module: false,
	provides: false,
	require: false,
	respond: false,
	send: false,
	start: false,
	sum: false
};
var rhino = {
	defineClass: false,
	deserialize: false,
	gc: false,
	help: false,
	importClass: false,
	importPackage: false,
	java: false,
	load: false,
	loadClass: false,
	Packages: false,
	print: false,
	quit: false,
	readFile: false,
	readUrl: false,
	runCommand: false,
	seal: false,
	serialize: false,
	spawn: false,
	sync: false,
	toint32: false,
	version: false
};
var nashorn = {
	__DIR__: false,
	__FILE__: false,
	__LINE__: false,
	com: false,
	edu: false,
	exit: false,
	java: false,
	Java: false,
	javafx: false,
	JavaImporter: false,
	javax: false,
	JSAdapter: false,
	load: false,
	loadWithNewGlobal: false,
	org: false,
	Packages: false,
	print: false,
	quit: false
};
var wsh = {
	ActiveXObject: true,
	Enumerator: true,
	GetObject: true,
	ScriptEngine: true,
	ScriptEngineBuildVersion: true,
	ScriptEngineMajorVersion: true,
	ScriptEngineMinorVersion: true,
	VBArray: true,
	WScript: true,
	WSH: true,
	XDomainRequest: true
};
var jquery = {
	$: false,
	jQuery: false
};
var yui = {
	YAHOO: false,
	YAHOO_config: false,
	YUI: false,
	YUI_config: false
};
var shelljs = {
	cat: false,
	cd: false,
	chmod: false,
	config: false,
	cp: false,
	dirs: false,
	echo: false,
	env: false,
	error: false,
	exec: false,
	exit: false,
	find: false,
	grep: false,
	ln: false,
	ls: false,
	mkdir: false,
	mv: false,
	popd: false,
	pushd: false,
	pwd: false,
	rm: false,
	sed: false,
	set: false,
	target: false,
	tempdir: false,
	test: false,
	touch: false,
	which: false
};
var prototypejs = {
	$: false,
	$$: false,
	$A: false,
	$break: false,
	$continue: false,
	$F: false,
	$H: false,
	$R: false,
	$w: false,
	Abstract: false,
	Ajax: false,
	Autocompleter: false,
	Builder: false,
	Class: false,
	Control: false,
	Draggable: false,
	Draggables: false,
	Droppables: false,
	Effect: false,
	Element: false,
	Enumerable: false,
	Event: false,
	Field: false,
	Form: false,
	Hash: false,
	Insertion: false,
	ObjectRange: false,
	PeriodicalExecuter: false,
	Position: false,
	Prototype: false,
	Scriptaculous: false,
	Selector: false,
	Sortable: false,
	SortableObserver: false,
	Sound: false,
	Template: false,
	Toggle: false,
	Try: false
};
var meteor = {
	_: false,
	$: false,
	Accounts: false,
	AccountsClient: false,
	AccountsCommon: false,
	AccountsServer: false,
	App: false,
	Assets: false,
	Blaze: false,
	check: false,
	Cordova: false,
	DDP: false,
	DDPRateLimiter: false,
	DDPServer: false,
	Deps: false,
	EJSON: false,
	Email: false,
	HTTP: false,
	Log: false,
	Match: false,
	Meteor: false,
	Mongo: false,
	MongoInternals: false,
	Npm: false,
	Package: false,
	Plugin: false,
	process: false,
	Random: false,
	ReactiveDict: false,
	ReactiveVar: false,
	Router: false,
	ServiceConfiguration: false,
	Session: false,
	share: false,
	Spacebars: false,
	Template: false,
	Tinytest: false,
	Tracker: false,
	UI: false,
	Utils: false,
	WebApp: false,
	WebAppInternals: false
};
var mongo = {
	_isWindows: false,
	_rand: false,
	BulkWriteResult: false,
	cat: false,
	cd: false,
	connect: false,
	db: false,
	getHostName: false,
	getMemInfo: false,
	hostname: false,
	ISODate: false,
	listFiles: false,
	load: false,
	ls: false,
	md5sumFile: false,
	mkdir: false,
	Mongo: false,
	NumberInt: false,
	NumberLong: false,
	ObjectId: false,
	PlanCache: false,
	print: false,
	printjson: false,
	pwd: false,
	quit: false,
	removeFile: false,
	rs: false,
	sh: false,
	UUID: false,
	version: false,
	WriteResult: false
};
var applescript = {
	$: false,
	Application: false,
	Automation: false,
	console: false,
	delay: false,
	Library: false,
	ObjC: false,
	ObjectSpecifier: false,
	Path: false,
	Progress: false,
	Ref: false
};
var serviceworker = {
	addEventListener: false,
	applicationCache: false,
	atob: false,
	Blob: false,
	BroadcastChannel: false,
	btoa: false,
	Cache: false,
	caches: false,
	CacheStorage: false,
	clearInterval: false,
	clearTimeout: false,
	Client: false,
	clients: false,
	Clients: false,
	close: true,
	console: false,
	ExtendableEvent: false,
	ExtendableMessageEvent: false,
	fetch: false,
	FetchEvent: false,
	FileReaderSync: false,
	FormData: false,
	Headers: false,
	IDBCursor: false,
	IDBCursorWithValue: false,
	IDBDatabase: false,
	IDBFactory: false,
	IDBIndex: false,
	IDBKeyRange: false,
	IDBObjectStore: false,
	IDBOpenDBRequest: false,
	IDBRequest: false,
	IDBTransaction: false,
	IDBVersionChangeEvent: false,
	ImageData: false,
	importScripts: false,
	indexedDB: false,
	location: false,
	MessageChannel: false,
	MessagePort: false,
	name: false,
	navigator: false,
	Notification: false,
	onclose: true,
	onconnect: true,
	onerror: true,
	onfetch: true,
	oninstall: true,
	onlanguagechange: true,
	onmessage: true,
	onmessageerror: true,
	onnotificationclick: true,
	onnotificationclose: true,
	onoffline: true,
	ononline: true,
	onpush: true,
	onpushsubscriptionchange: true,
	onrejectionhandled: true,
	onsync: true,
	onunhandledrejection: true,
	performance: false,
	Performance: false,
	PerformanceEntry: false,
	PerformanceMark: false,
	PerformanceMeasure: false,
	PerformanceNavigation: false,
	PerformanceResourceTiming: false,
	PerformanceTiming: false,
	postMessage: true,
	"Promise": false,
	queueMicrotask: false,
	registration: false,
	removeEventListener: false,
	Request: false,
	Response: false,
	self: false,
	ServiceWorker: false,
	ServiceWorkerContainer: false,
	ServiceWorkerGlobalScope: false,
	ServiceWorkerMessageEvent: false,
	ServiceWorkerRegistration: false,
	setInterval: false,
	setTimeout: false,
	skipWaiting: false,
	TextDecoder: false,
	TextEncoder: false,
	URL: false,
	URLSearchParams: false,
	WebSocket: false,
	WindowClient: false,
	Worker: false,
	WorkerGlobalScope: false,
	XMLHttpRequest: false
};
var atomtest = {
	advanceClock: false,
	fakeClearInterval: false,
	fakeClearTimeout: false,
	fakeSetInterval: false,
	fakeSetTimeout: false,
	resetTimeouts: false,
	waitsForPromise: false
};
var embertest = {
	andThen: false,
	click: false,
	currentPath: false,
	currentRouteName: false,
	currentURL: false,
	fillIn: false,
	find: false,
	findAll: false,
	findWithAssert: false,
	keyEvent: false,
	pauseTest: false,
	resumeTest: false,
	triggerEvent: false,
	visit: false,
	wait: false
};
var protractor = {
	$: false,
	$$: false,
	browser: false,
	by: false,
	By: false,
	DartObject: false,
	element: false,
	protractor: false
};
var webextensions = {
	browser: false,
	chrome: false,
	opr: false
};
var greasemonkey = {
	cloneInto: false,
	createObjectIn: false,
	exportFunction: false,
	GM: false,
	GM_addStyle: false,
	GM_deleteValue: false,
	GM_getResourceText: false,
	GM_getResourceURL: false,
	GM_getValue: false,
	GM_info: false,
	GM_listValues: false,
	GM_log: false,
	GM_openInTab: false,
	GM_registerMenuCommand: false,
	GM_setClipboard: false,
	GM_setValue: false,
	GM_xmlhttpRequest: false,
	unsafeWindow: false
};
var devtools = {
	$: false,
	$_: false,
	$$: false,
	$0: false,
	$1: false,
	$2: false,
	$3: false,
	$4: false,
	$x: false,
	chrome: false,
	clear: false,
	copy: false,
	debug: false,
	dir: false,
	dirxml: false,
	getEventListeners: false,
	inspect: false,
	keys: false,
	monitor: false,
	monitorEvents: false,
	profile: false,
	profileEnd: false,
	queryObjects: false,
	table: false,
	undebug: false,
	unmonitor: false,
	unmonitorEvents: false,
	values: false
};
var require$$0 = {
	builtin: builtin,
	es5: es5,
	es2015: es2015,
	es2017: es2017,
	browser: browser,
	worker: worker,
	node: node$1,
	commonjs: commonjs,
	amd: amd,
	mocha: mocha,
	jasmine: jasmine,
	jest: jest,
	qunit: qunit,
	phantomjs: phantomjs,
	couch: couch,
	rhino: rhino,
	nashorn: nashorn,
	wsh: wsh,
	jquery: jquery,
	yui: yui,
	shelljs: shelljs,
	prototypejs: prototypejs,
	meteor: meteor,
	mongo: mongo,
	applescript: applescript,
	serviceworker: serviceworker,
	atomtest: atomtest,
	embertest: embertest,
	protractor: protractor,
	"shared-node-browser": {
	clearInterval: false,
	clearTimeout: false,
	console: false,
	setInterval: false,
	setTimeout: false,
	URL: false,
	URLSearchParams: false
},
	webextensions: webextensions,
	greasemonkey: greasemonkey,
	devtools: devtools
};

var globals;
var hasRequiredGlobals;
function requireGlobals() {
  if (hasRequiredGlobals) return globals;
  hasRequiredGlobals = 1;
  globals = require$$0;
  return globals;
}

var cache = {};

var hasRequiredCache;
function requireCache() {
  if (hasRequiredCache) return cache;
  hasRequiredCache = 1;
  Object.defineProperty(cache, "__esModule", {
    value: true
  });
  cache.clear = clear;
  cache.clearPath = clearPath;
  cache.clearScope = clearScope;
  cache.getCachedPaths = getCachedPaths;
  cache.getOrCreateCachedPaths = getOrCreateCachedPaths;
  cache.scope = cache.path = void 0;
  var pathsCache = cache.path = new WeakMap();
  cache.scope = new WeakMap();
  function clear() {
    clearPath();
    clearScope();
  }
  function clearPath() {
    cache.path = pathsCache = new WeakMap();
  }
  function clearScope() {
    cache.scope = new WeakMap();
  }
  var nullHub = Object.freeze({});
  function getCachedPaths(hub, parent) {
    var _pathsCache$get, _hub;
    {
      hub = null;
    }
    return (_pathsCache$get = pathsCache.get((_hub = hub) != null ? _hub : nullHub)) == null ? void 0 : _pathsCache$get.get(parent);
  }
  function getOrCreateCachedPaths(hub, parent) {
    var _hub2, _hub3;
    {
      hub = null;
    }
    var parents = pathsCache.get((_hub2 = hub) != null ? _hub2 : nullHub);
    if (!parents) pathsCache.set((_hub3 = hub) != null ? _hub3 : nullHub, parents = new WeakMap());
    var paths = parents.get(parent);
    if (!paths) parents.set(parent, paths = new Map());
    return paths;
  }
  return cache;
}

var hasRequiredScope;
function requireScope() {
  if (hasRequiredScope) return scope;
  hasRequiredScope = 1;
  Object.defineProperty(scope, "__esModule", {
    value: true
  });
  scope["default"] = void 0;
  var _renamer = requireRenamer();
  var _index = requireLib();
  var _binding = requireBinding();
  var _globals = requireGlobals();
  var _t = requireLib$4();
  var t = _t;
  var _cache = requireCache();
  var _visitors = requireVisitors();
  var NOT_LOCAL_BINDING = _t.NOT_LOCAL_BINDING,
    assignmentExpression = _t.assignmentExpression,
    callExpression = _t.callExpression,
    cloneNode = _t.cloneNode,
    getBindingIdentifiers = _t.getBindingIdentifiers,
    identifier = _t.identifier,
    isArrayExpression = _t.isArrayExpression,
    isBinary = _t.isBinary,
    isCallExpression = _t.isCallExpression,
    isClass = _t.isClass,
    isClassBody = _t.isClassBody,
    isClassDeclaration = _t.isClassDeclaration,
    isExportAllDeclaration = _t.isExportAllDeclaration,
    isExportDefaultDeclaration = _t.isExportDefaultDeclaration,
    isExportNamedDeclaration = _t.isExportNamedDeclaration,
    isFunctionDeclaration = _t.isFunctionDeclaration,
    isIdentifier = _t.isIdentifier,
    isImportDeclaration = _t.isImportDeclaration,
    isLiteral = _t.isLiteral,
    isMemberExpression = _t.isMemberExpression,
    isMethod = _t.isMethod,
    isModuleSpecifier = _t.isModuleSpecifier,
    isNullLiteral = _t.isNullLiteral,
    isObjectExpression = _t.isObjectExpression,
    isProperty = _t.isProperty,
    isPureish = _t.isPureish,
    isRegExpLiteral = _t.isRegExpLiteral,
    isSuper = _t.isSuper,
    isTaggedTemplateExpression = _t.isTaggedTemplateExpression,
    isTemplateLiteral = _t.isTemplateLiteral,
    isThisExpression = _t.isThisExpression,
    isUnaryExpression = _t.isUnaryExpression,
    isVariableDeclaration = _t.isVariableDeclaration,
    expressionStatement = _t.expressionStatement,
    matchesPattern = _t.matchesPattern,
    memberExpression = _t.memberExpression,
    numericLiteral = _t.numericLiteral,
    toIdentifier = _t.toIdentifier,
    variableDeclaration = _t.variableDeclaration,
    variableDeclarator = _t.variableDeclarator,
    isRecordExpression = _t.isRecordExpression,
    isTupleExpression = _t.isTupleExpression,
    isObjectProperty = _t.isObjectProperty,
    isTopicReference = _t.isTopicReference,
    isMetaProperty = _t.isMetaProperty,
    isPrivateName = _t.isPrivateName,
    isExportDeclaration = _t.isExportDeclaration,
    _buildUndefinedNode = _t.buildUndefinedNode,
    sequenceExpression = _t.sequenceExpression;
  function gatherNodeParts(node, parts) {
    switch (node == null ? void 0 : node.type) {
      default:
        if (isImportDeclaration(node) || isExportDeclaration(node)) {
          var _node$specifiers;
          if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {
            gatherNodeParts(node.source, parts);
          } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && (_node$specifiers = node.specifiers) != null && _node$specifiers.length) {
            var _iterator = _createForOfIteratorHelper(node.specifiers),
              _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var e = _step.value;
                gatherNodeParts(e, parts);
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {
            gatherNodeParts(node.declaration, parts);
          }
        } else if (isModuleSpecifier(node)) {
          gatherNodeParts(node.local, parts);
        } else if (isLiteral(node) && !isNullLiteral(node) && !isRegExpLiteral(node) && !isTemplateLiteral(node)) {
          parts.push(node.value);
        }
        break;
      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        gatherNodeParts(node.object, parts);
        gatherNodeParts(node.property, parts);
        break;
      case "Identifier":
      case "JSXIdentifier":
        parts.push(node.name);
        break;
      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        gatherNodeParts(node.callee, parts);
        break;
      case "ObjectExpression":
      case "ObjectPattern":
        var _iterator2 = _createForOfIteratorHelper(node.properties),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _e = _step2.value;
            gatherNodeParts(_e, parts);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        break;
      case "SpreadElement":
      case "RestElement":
        gatherNodeParts(node.argument, parts);
        break;
      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        gatherNodeParts(node.key, parts);
        break;
      case "ThisExpression":
        parts.push("this");
        break;
      case "Super":
        parts.push("super");
        break;
      case "Import":
        parts.push("import");
        break;
      case "DoExpression":
        parts.push("do");
        break;
      case "YieldExpression":
        parts.push("yield");
        gatherNodeParts(node.argument, parts);
        break;
      case "AwaitExpression":
        parts.push("await");
        gatherNodeParts(node.argument, parts);
        break;
      case "AssignmentExpression":
        gatherNodeParts(node.left, parts);
        break;
      case "VariableDeclarator":
        gatherNodeParts(node.id, parts);
        break;
      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
        gatherNodeParts(node.id, parts);
        break;
      case "PrivateName":
        gatherNodeParts(node.id, parts);
        break;
      case "ParenthesizedExpression":
        gatherNodeParts(node.expression, parts);
        break;
      case "UnaryExpression":
      case "UpdateExpression":
        gatherNodeParts(node.argument, parts);
        break;
      case "MetaProperty":
        gatherNodeParts(node.meta, parts);
        gatherNodeParts(node.property, parts);
        break;
      case "JSXElement":
        gatherNodeParts(node.openingElement, parts);
        break;
      case "JSXOpeningElement":
        gatherNodeParts(node.name, parts);
        break;
      case "JSXFragment":
        gatherNodeParts(node.openingFragment, parts);
        break;
      case "JSXOpeningFragment":
        parts.push("Fragment");
        break;
      case "JSXNamespacedName":
        gatherNodeParts(node.namespace, parts);
        gatherNodeParts(node.name, parts);
        break;
    }
  }
  var collectorVisitor = {
    ForStatement: function ForStatement(path) {
      var declar = path.get("init");
      if (declar.isVar()) {
        var _scope = path.scope;
        var parentScope = _scope.getFunctionParent() || _scope.getProgramParent();
        parentScope.registerBinding("var", declar);
      }
    },
    Declaration: function Declaration(path) {
      if (path.isBlockScoped()) return;
      if (path.isImportDeclaration()) return;
      if (path.isExportDeclaration()) return;
      var parent = path.scope.getFunctionParent() || path.scope.getProgramParent();
      parent.registerDeclaration(path);
    },
    ImportDeclaration: function ImportDeclaration(path) {
      var parent = path.scope.getBlockParent();
      parent.registerDeclaration(path);
    },
    TSImportEqualsDeclaration: function TSImportEqualsDeclaration(path) {
      var parent = path.scope.getBlockParent();
      parent.registerDeclaration(path);
    },
    ReferencedIdentifier: function ReferencedIdentifier(path, state) {
      if (t.isTSQualifiedName(path.parent) && path.parent.right === path.node) {
        return;
      }
      if (path.parentPath.isTSImportEqualsDeclaration()) return;
      state.references.push(path);
    },
    ForXStatement: function ForXStatement(path, state) {
      var left = path.get("left");
      if (left.isPattern() || left.isIdentifier()) {
        state.constantViolations.push(path);
      } else if (left.isVar()) {
        var _scope2 = path.scope;
        var parentScope = _scope2.getFunctionParent() || _scope2.getProgramParent();
        parentScope.registerBinding("var", left);
      }
    },
    ExportDeclaration: {
      exit: function exit(path) {
        var node = path.node,
          scope = path.scope;
        if (isExportAllDeclaration(node)) return;
        var declar = node.declaration;
        if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {
          var id = declar.id;
          if (!id) return;
          var binding = scope.getBinding(id.name);
          binding == null || binding.reference(path);
        } else if (isVariableDeclaration(declar)) {
          var _iterator3 = _createForOfIteratorHelper(declar.declarations),
            _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var decl = _step3.value;
              for (var _i = 0, _Object$keys = Object.keys(getBindingIdentifiers(decl)); _i < _Object$keys.length; _i++) {
                var name = _Object$keys[_i];
                var _binding2 = scope.getBinding(name);
                _binding2 == null || _binding2.reference(path);
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
      }
    },
    LabeledStatement: function LabeledStatement(path) {
      path.scope.getBlockParent().registerDeclaration(path);
    },
    AssignmentExpression: function AssignmentExpression(path, state) {
      state.assignments.push(path);
    },
    UpdateExpression: function UpdateExpression(path, state) {
      state.constantViolations.push(path);
    },
    UnaryExpression: function UnaryExpression(path, state) {
      if (path.node.operator === "delete") {
        state.constantViolations.push(path);
      }
    },
    BlockScoped: function BlockScoped(path) {
      var scope = path.scope;
      if (scope.path === path) scope = scope.parent;
      var parent = scope.getBlockParent();
      parent.registerDeclaration(path);
      if (path.isClassDeclaration() && path.node.id) {
        var id = path.node.id;
        var name = id.name;
        path.scope.bindings[name] = path.scope.parent.getBinding(name);
      }
    },
    CatchClause: function CatchClause(path) {
      path.scope.registerBinding("let", path);
    },
    Function: function Function(path) {
      var params = path.get("params");
      var _iterator4 = _createForOfIteratorHelper(params),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var param = _step4.value;
          path.scope.registerBinding("param", param);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      if (path.isFunctionExpression() && path.node.id && !path.node.id[NOT_LOCAL_BINDING]) {
        path.scope.registerBinding("local", path.get("id"), path);
      }
    },
    ClassExpression: function ClassExpression(path) {
      if (path.node.id && !path.node.id[NOT_LOCAL_BINDING]) {
        path.scope.registerBinding("local", path.get("id"), path);
      }
    },
    TSTypeAnnotation: function TSTypeAnnotation(path) {
      path.skip();
    }
  };
  var uid = 0;
  var Scope = /*#__PURE__*/function () {
    function Scope(path) {
      _classCallCheck(this, Scope);
      this.uid = void 0;
      this.path = void 0;
      this.block = void 0;
      this.inited = void 0;
      this.labels = void 0;
      this.bindings = void 0;
      this.references = void 0;
      this.globals = void 0;
      this.uids = void 0;
      this.data = void 0;
      this.crawling = void 0;
      var node = path.node;
      var cached = _cache.scope.get(node);
      if ((cached == null ? void 0 : cached.path) === path) {
        return cached;
      }
      _cache.scope.set(node, this);
      this.uid = uid++;
      this.block = node;
      this.path = path;
      this.labels = new Map();
      this.inited = false;
    }
    return _createClass(Scope, [{
      key: "parent",
      get: function get() {
        var _parent;
        var parent,
          path = this.path;
        do {
          var _path;
          var shouldSkip = path.key === "key" || path.listKey === "decorators";
          path = path.parentPath;
          if (shouldSkip && path.isMethod()) path = path.parentPath;
          if ((_path = path) != null && _path.isScope()) parent = path;
        } while (path && !parent);
        return (_parent = parent) == null ? void 0 : _parent.scope;
      }
    }, {
      key: "generateDeclaredUidIdentifier",
      value: function generateDeclaredUidIdentifier(name) {
        var id = this.generateUidIdentifier(name);
        this.push({
          id: id
        });
        return cloneNode(id);
      }
    }, {
      key: "generateUidIdentifier",
      value: function generateUidIdentifier(name) {
        return identifier(this.generateUid(name));
      }
    }, {
      key: "generateUid",
      value: function generateUid() {
        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "temp";
        name = toIdentifier(name).replace(/^_+/, "").replace(/\d+$/g, "");
        var uid;
        var i = 1;
        do {
          uid = "_".concat(name);
          if (i > 1) uid += i;
          i++;
        } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));
        var program = this.getProgramParent();
        program.references[uid] = true;
        program.uids[uid] = true;
        return uid;
      }
    }, {
      key: "generateUidBasedOnNode",
      value: function generateUidBasedOnNode(node, defaultName) {
        var parts = [];
        gatherNodeParts(node, parts);
        var id = parts.join("$");
        id = id.replace(/^_/, "") || defaultName || "ref";
        return this.generateUid(id.slice(0, 20));
      }
    }, {
      key: "generateUidIdentifierBasedOnNode",
      value: function generateUidIdentifierBasedOnNode(node, defaultName) {
        return identifier(this.generateUidBasedOnNode(node, defaultName));
      }
    }, {
      key: "isStatic",
      value: function isStatic(node) {
        if (isThisExpression(node) || isSuper(node) || isTopicReference(node)) {
          return true;
        }
        if (isIdentifier(node)) {
          var binding = this.getBinding(node.name);
          if (binding) {
            return binding.constant;
          } else {
            return this.hasBinding(node.name);
          }
        }
        return false;
      }
    }, {
      key: "maybeGenerateMemoised",
      value: function maybeGenerateMemoised(node, dontPush) {
        if (this.isStatic(node)) {
          return null;
        } else {
          var id = this.generateUidIdentifierBasedOnNode(node);
          if (!dontPush) {
            this.push({
              id: id
            });
            return cloneNode(id);
          }
          return id;
        }
      }
    }, {
      key: "checkBlockScopedCollisions",
      value: function checkBlockScopedCollisions(local, kind, name, id) {
        if (kind === "param") return;
        if (local.kind === "local") return;
        var duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && kind === "const";
        if (duplicate) {
          throw this.path.hub.buildError(id, "Duplicate declaration \"".concat(name, "\""), TypeError);
        }
      }
    }, {
      key: "rename",
      value: function rename(oldName, newName) {
        var binding = this.getBinding(oldName);
        if (binding) {
          newName || (newName = this.generateUidIdentifier(oldName).name);
          var renamer = new _renamer["default"](binding, oldName, newName);
          {
            renamer.rename(arguments[2]);
          }
        }
      }
    }, {
      key: "dump",
      value: function dump() {
        var sep = "-".repeat(60);
        console.log(sep);
        var scope = this;
        do {
          console.log("#", scope.block.type);
          for (var _i2 = 0, _Object$keys2 = Object.keys(scope.bindings); _i2 < _Object$keys2.length; _i2++) {
            var name = _Object$keys2[_i2];
            var binding = scope.bindings[name];
            console.log(" -", name, {
              constant: binding.constant,
              references: binding.references,
              violations: binding.constantViolations.length,
              kind: binding.kind
            });
          }
        } while (scope = scope.parent);
        console.log(sep);
      }
    }, {
      key: "hasLabel",
      value: function hasLabel(name) {
        return !!this.getLabel(name);
      }
    }, {
      key: "getLabel",
      value: function getLabel(name) {
        return this.labels.get(name);
      }
    }, {
      key: "registerLabel",
      value: function registerLabel(path) {
        this.labels.set(path.node.label.name, path);
      }
    }, {
      key: "registerDeclaration",
      value: function registerDeclaration(path) {
        if (path.isLabeledStatement()) {
          this.registerLabel(path);
        } else if (path.isFunctionDeclaration()) {
          this.registerBinding("hoisted", path.get("id"), path);
        } else if (path.isVariableDeclaration()) {
          var declarations = path.get("declarations");
          var kind = path.node.kind;
          var _iterator5 = _createForOfIteratorHelper(declarations),
            _step5;
          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var declar = _step5.value;
              this.registerBinding(kind === "using" || kind === "await using" ? "const" : kind, declar);
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        } else if (path.isClassDeclaration()) {
          if (path.node.declare) return;
          this.registerBinding("let", path);
        } else if (path.isImportDeclaration()) {
          var isTypeDeclaration = path.node.importKind === "type" || path.node.importKind === "typeof";
          var specifiers = path.get("specifiers");
          var _iterator6 = _createForOfIteratorHelper(specifiers),
            _step6;
          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var specifier = _step6.value;
              var isTypeSpecifier = isTypeDeclaration || specifier.isImportSpecifier() && (specifier.node.importKind === "type" || specifier.node.importKind === "typeof");
              this.registerBinding(isTypeSpecifier ? "unknown" : "module", specifier);
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }
        } else if (path.isExportDeclaration()) {
          var _declar = path.get("declaration");
          if (_declar.isClassDeclaration() || _declar.isFunctionDeclaration() || _declar.isVariableDeclaration()) {
            this.registerDeclaration(_declar);
          }
        } else {
          this.registerBinding("unknown", path);
        }
      }
    }, {
      key: "buildUndefinedNode",
      value: function buildUndefinedNode() {
        return _buildUndefinedNode();
      }
    }, {
      key: "registerConstantViolation",
      value: function registerConstantViolation(path) {
        var ids = path.getAssignmentIdentifiers();
        for (var _i3 = 0, _Object$keys3 = Object.keys(ids); _i3 < _Object$keys3.length; _i3++) {
          var name = _Object$keys3[_i3];
          var _this$getBinding;
          (_this$getBinding = this.getBinding(name)) == null || _this$getBinding.reassign(path);
        }
      }
    }, {
      key: "registerBinding",
      value: function registerBinding(kind, path) {
        var bindingPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path;
        if (!kind) throw new ReferenceError("no `kind`");
        if (path.isVariableDeclaration()) {
          var declarators = path.get("declarations");
          var _iterator7 = _createForOfIteratorHelper(declarators),
            _step7;
          try {
            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
              var declar = _step7.value;
              this.registerBinding(kind, declar);
            }
          } catch (err) {
            _iterator7.e(err);
          } finally {
            _iterator7.f();
          }
          return;
        }
        var parent = this.getProgramParent();
        var ids = path.getOuterBindingIdentifiers(true);
        for (var _i4 = 0, _Object$keys4 = Object.keys(ids); _i4 < _Object$keys4.length; _i4++) {
          var name = _Object$keys4[_i4];
          parent.references[name] = true;
          var _iterator8 = _createForOfIteratorHelper(ids[name]),
            _step8;
          try {
            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
              var id = _step8.value;
              var local = this.getOwnBinding(name);
              if (local) {
                if (local.identifier === id) continue;
                this.checkBlockScopedCollisions(local, kind, name, id);
              }
              if (local) {
                local.reassign(bindingPath);
              } else {
                this.bindings[name] = new _binding["default"]({
                  identifier: id,
                  scope: this,
                  path: bindingPath,
                  kind: kind
                });
              }
            }
          } catch (err) {
            _iterator8.e(err);
          } finally {
            _iterator8.f();
          }
        }
      }
    }, {
      key: "addGlobal",
      value: function addGlobal(node) {
        this.globals[node.name] = node;
      }
    }, {
      key: "hasUid",
      value: function hasUid(name) {
        var scope = this;
        do {
          if (scope.uids[name]) return true;
        } while (scope = scope.parent);
        return false;
      }
    }, {
      key: "hasGlobal",
      value: function hasGlobal(name) {
        var scope = this;
        do {
          if (scope.globals[name]) return true;
        } while (scope = scope.parent);
        return false;
      }
    }, {
      key: "hasReference",
      value: function hasReference(name) {
        return !!this.getProgramParent().references[name];
      }
    }, {
      key: "isPure",
      value: function isPure(node, constantsOnly) {
        if (isIdentifier(node)) {
          var binding = this.getBinding(node.name);
          if (!binding) return false;
          if (constantsOnly) return binding.constant;
          return true;
        } else if (isThisExpression(node) || isMetaProperty(node) || isTopicReference(node) || isPrivateName(node)) {
          return true;
        } else if (isClass(node)) {
          var _node$decorators;
          if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {
            return false;
          }
          if (((_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length) > 0) {
            return false;
          }
          return this.isPure(node.body, constantsOnly);
        } else if (isClassBody(node)) {
          var _iterator9 = _createForOfIteratorHelper(node.body),
            _step9;
          try {
            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
              var method = _step9.value;
              if (!this.isPure(method, constantsOnly)) return false;
            }
          } catch (err) {
            _iterator9.e(err);
          } finally {
            _iterator9.f();
          }
          return true;
        } else if (isBinary(node)) {
          return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
        } else if (isArrayExpression(node) || isTupleExpression(node)) {
          var _iterator10 = _createForOfIteratorHelper(node.elements),
            _step10;
          try {
            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
              var elem = _step10.value;
              if (elem !== null && !this.isPure(elem, constantsOnly)) return false;
            }
          } catch (err) {
            _iterator10.e(err);
          } finally {
            _iterator10.f();
          }
          return true;
        } else if (isObjectExpression(node) || isRecordExpression(node)) {
          var _iterator11 = _createForOfIteratorHelper(node.properties),
            _step11;
          try {
            for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
              var prop = _step11.value;
              if (!this.isPure(prop, constantsOnly)) return false;
            }
          } catch (err) {
            _iterator11.e(err);
          } finally {
            _iterator11.f();
          }
          return true;
        } else if (isMethod(node)) {
          var _node$decorators2;
          if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
          if (((_node$decorators2 = node.decorators) == null ? void 0 : _node$decorators2.length) > 0) {
            return false;
          }
          return true;
        } else if (isProperty(node)) {
          var _node$decorators3;
          if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
          if (((_node$decorators3 = node.decorators) == null ? void 0 : _node$decorators3.length) > 0) {
            return false;
          }
          if (isObjectProperty(node) || node["static"]) {
            if (node.value !== null && !this.isPure(node.value, constantsOnly)) {
              return false;
            }
          }
          return true;
        } else if (isUnaryExpression(node)) {
          return this.isPure(node.argument, constantsOnly);
        } else if (isTemplateLiteral(node)) {
          var _iterator12 = _createForOfIteratorHelper(node.expressions),
            _step12;
          try {
            for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
              var expression = _step12.value;
              if (!this.isPure(expression, constantsOnly)) return false;
            }
          } catch (err) {
            _iterator12.e(err);
          } finally {
            _iterator12.f();
          }
          return true;
        } else if (isTaggedTemplateExpression(node)) {
          return matchesPattern(node.tag, "String.raw") && !this.hasBinding("String", {
            noGlobals: true
          }) && this.isPure(node.quasi, constantsOnly);
        } else if (isMemberExpression(node)) {
          return !node.computed && isIdentifier(node.object) && node.object.name === "Symbol" && isIdentifier(node.property) && node.property.name !== "for" && !this.hasBinding("Symbol", {
            noGlobals: true
          });
        } else if (isCallExpression(node)) {
          return matchesPattern(node.callee, "Symbol.for") && !this.hasBinding("Symbol", {
            noGlobals: true
          }) && node.arguments.length === 1 && t.isStringLiteral(node.arguments[0]);
        } else {
          return isPureish(node);
        }
      }
    }, {
      key: "setData",
      value: function setData(key, val) {
        return this.data[key] = val;
      }
    }, {
      key: "getData",
      value: function getData(key) {
        var scope = this;
        do {
          var data = scope.data[key];
          if (data != null) return data;
        } while (scope = scope.parent);
      }
    }, {
      key: "removeData",
      value: function removeData(key) {
        var scope = this;
        do {
          var data = scope.data[key];
          if (data != null) scope.data[key] = null;
        } while (scope = scope.parent);
      }
    }, {
      key: "init",
      value: function init() {
        if (!this.inited) {
          this.inited = true;
          this.crawl();
        }
      }
    }, {
      key: "crawl",
      value: function crawl() {
        var path = this.path;
        this.references = Object.create(null);
        this.bindings = Object.create(null);
        this.globals = Object.create(null);
        this.uids = Object.create(null);
        this.data = Object.create(null);
        var scope = this;
        do {
          if (scope.crawling) return;
          if (scope.path.isProgram()) {
            break;
          }
        } while (scope = scope.parent);
        var programParent = scope;
        var state = {
          references: [],
          constantViolations: [],
          assignments: []
        };
        this.crawling = true;
        if (path.type !== "Program" && (0, _visitors.isExplodedVisitor)(collectorVisitor)) {
          var _iterator13 = _createForOfIteratorHelper(collectorVisitor.enter),
            _step13;
          try {
            for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
              var _visit = _step13.value;
              _visit.call(state, path, state);
            }
          } catch (err) {
            _iterator13.e(err);
          } finally {
            _iterator13.f();
          }
          var typeVisitors = collectorVisitor[path.type];
          if (typeVisitors) {
            var _iterator14 = _createForOfIteratorHelper(typeVisitors.enter),
              _step14;
            try {
              for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
                var visit = _step14.value;
                visit.call(state, path, state);
              }
            } catch (err) {
              _iterator14.e(err);
            } finally {
              _iterator14.f();
            }
          }
        }
        path.traverse(collectorVisitor, state);
        this.crawling = false;
        var _iterator15 = _createForOfIteratorHelper(state.assignments),
          _step15;
        try {
          for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
            var _path2 = _step15.value;
            var ids = _path2.getAssignmentIdentifiers();
            for (var _i5 = 0, _Object$keys5 = Object.keys(ids); _i5 < _Object$keys5.length; _i5++) {
              var name = _Object$keys5[_i5];
              if (_path2.scope.getBinding(name)) continue;
              programParent.addGlobal(ids[name]);
            }
            _path2.scope.registerConstantViolation(_path2);
          }
        } catch (err) {
          _iterator15.e(err);
        } finally {
          _iterator15.f();
        }
        var _iterator16 = _createForOfIteratorHelper(state.references),
          _step16;
        try {
          for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
            var ref = _step16.value;
            var binding = ref.scope.getBinding(ref.node.name);
            if (binding) {
              binding.reference(ref);
            } else {
              programParent.addGlobal(ref.node);
            }
          }
        } catch (err) {
          _iterator16.e(err);
        } finally {
          _iterator16.f();
        }
        var _iterator17 = _createForOfIteratorHelper(state.constantViolations),
          _step17;
        try {
          for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
            var _path3 = _step17.value;
            _path3.scope.registerConstantViolation(_path3);
          }
        } catch (err) {
          _iterator17.e(err);
        } finally {
          _iterator17.f();
        }
      }
    }, {
      key: "push",
      value: function push(opts) {
        var path = this.path;
        if (path.isPattern()) {
          path = this.getPatternParent().path;
        } else if (!path.isBlockStatement() && !path.isProgram()) {
          path = this.getBlockParent().path;
        }
        if (path.isSwitchStatement()) {
          path = (this.getFunctionParent() || this.getProgramParent()).path;
        }
        var init = opts.init,
          unique = opts.unique,
          _opts$kind = opts.kind,
          kind = _opts$kind === void 0 ? "var" : _opts$kind,
          id = opts.id;
        if (!init && !unique && (kind === "var" || kind === "let") && path.isFunction() && !path.node.name && isCallExpression(path.parent, {
          callee: path.node
        }) && path.parent.arguments.length <= path.node.params.length && isIdentifier(id)) {
          path.pushContainer("params", id);
          path.scope.registerBinding("param", path.get("params")[path.node.params.length - 1]);
          return;
        }
        if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
          path.ensureBlock();
          path = path.get("body");
        }
        var blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
        var dataKey = "declaration:".concat(kind, ":").concat(blockHoist);
        var declarPath = !unique && path.getData(dataKey);
        if (!declarPath) {
          var declar = variableDeclaration(kind, []);
          declar._blockHoist = blockHoist;
          var _path$unshiftContaine = path.unshiftContainer("body", [declar]);
          var _path$unshiftContaine2 = _slicedToArray(_path$unshiftContaine, 1);
          declarPath = _path$unshiftContaine2[0];
          if (!unique) path.setData(dataKey, declarPath);
        }
        var declarator = variableDeclarator(id, init);
        var len = declarPath.node.declarations.push(declarator);
        path.scope.registerBinding(kind, declarPath.get("declarations")[len - 1]);
      }
    }, {
      key: "getProgramParent",
      value: function getProgramParent() {
        var scope = this;
        do {
          if (scope.path.isProgram()) {
            return scope;
          }
        } while (scope = scope.parent);
        throw new Error("Couldn't find a Program");
      }
    }, {
      key: "getFunctionParent",
      value: function getFunctionParent() {
        var scope = this;
        do {
          if (scope.path.isFunctionParent()) {
            return scope;
          }
        } while (scope = scope.parent);
        return null;
      }
    }, {
      key: "getBlockParent",
      value: function getBlockParent() {
        var scope = this;
        do {
          if (scope.path.isBlockParent()) {
            return scope;
          }
        } while (scope = scope.parent);
        throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
      }
    }, {
      key: "getPatternParent",
      value: function getPatternParent() {
        var scope = this;
        do {
          if (!scope.path.isPattern()) {
            return scope.getBlockParent();
          }
        } while (scope = scope.parent.parent);
        throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
      }
    }, {
      key: "getAllBindings",
      value: function getAllBindings() {
        var ids = Object.create(null);
        var scope = this;
        do {
          for (var _i6 = 0, _Object$keys6 = Object.keys(scope.bindings); _i6 < _Object$keys6.length; _i6++) {
            var key = _Object$keys6[_i6];
            if (key in ids === false) {
              ids[key] = scope.bindings[key];
            }
          }
          scope = scope.parent;
        } while (scope);
        return ids;
      }
    }, {
      key: "bindingIdentifierEquals",
      value: function bindingIdentifierEquals(name, node) {
        return this.getBindingIdentifier(name) === node;
      }
    }, {
      key: "getBinding",
      value: function getBinding(name) {
        var scope = this;
        var previousPath;
        do {
          var binding = scope.getOwnBinding(name);
          if (binding) {
            var _previousPath;
            if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== "param" && binding.kind !== "local") ; else {
              return binding;
            }
          } else if (!binding && name === "arguments" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
            break;
          }
          previousPath = scope.path;
        } while (scope = scope.parent);
      }
    }, {
      key: "getOwnBinding",
      value: function getOwnBinding(name) {
        return this.bindings[name];
      }
    }, {
      key: "getBindingIdentifier",
      value: function getBindingIdentifier(name) {
        var _this$getBinding2;
        return (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.identifier;
      }
    }, {
      key: "getOwnBindingIdentifier",
      value: function getOwnBindingIdentifier(name) {
        var binding = this.bindings[name];
        return binding == null ? void 0 : binding.identifier;
      }
    }, {
      key: "hasOwnBinding",
      value: function hasOwnBinding(name) {
        return !!this.getOwnBinding(name);
      }
    }, {
      key: "hasBinding",
      value: function hasBinding(name, opts) {
        if (!name) return false;
        var scope = this;
        do {
          if (scope.hasOwnBinding(name)) {
            return true;
          }
        } while (scope = scope.parent);
        var noGlobals;
        var noUids;
        if (_typeof(opts) === "object") {
          noGlobals = opts.noGlobals;
          noUids = opts.noUids;
        } else if (typeof opts === "boolean") {
          noGlobals = opts;
        }
        if (!noUids && this.hasUid(name)) return true;
        if (!noGlobals && Scope.globals.includes(name)) return true;
        if (!noGlobals && Scope.contextVariables.includes(name)) return true;
        return false;
      }
    }, {
      key: "parentHasBinding",
      value: function parentHasBinding(name, opts) {
        var _this$parent;
        return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, opts);
      }
    }, {
      key: "moveBindingTo",
      value: function moveBindingTo(name, scope) {
        var info = this.getBinding(name);
        if (info) {
          info.scope.removeOwnBinding(name);
          info.scope = scope;
          scope.bindings[name] = info;
        }
      }
    }, {
      key: "removeOwnBinding",
      value: function removeOwnBinding(name) {
        delete this.bindings[name];
      }
    }, {
      key: "removeBinding",
      value: function removeBinding(name) {
        var _this$getBinding3;
        (_this$getBinding3 = this.getBinding(name)) == null || _this$getBinding3.scope.removeOwnBinding(name);
        var scope = this;
        do {
          if (scope.uids[name]) {
            scope.uids[name] = false;
          }
        } while (scope = scope.parent);
      }
    }, {
      key: "hoistVariables",
      value: function hoistVariables() {
        var _this = this;
        var emit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (id) {
          return _this.push({
            id: id
          });
        };
        this.crawl();
        var seen = new Set();
        for (var _i7 = 0, _Object$keys7 = Object.keys(this.bindings); _i7 < _Object$keys7.length; _i7++) {
          var name = _Object$keys7[_i7];
          var binding = this.bindings[name];
          if (!binding) continue;
          var path = binding.path;
          if (!path.isVariableDeclarator()) continue;
          var parent = path.parent,
            parentPath = path.parentPath;
          if (parent.kind !== "var" || seen.has(parent)) continue;
          seen.add(path.parent);
          var firstId = void 0;
          var init = [];
          var _iterator18 = _createForOfIteratorHelper(parent.declarations),
            _step18;
          try {
            for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
              var decl = _step18.value;
              var _firstId;
              (_firstId = firstId) != null ? _firstId : firstId = decl.id;
              if (decl.init) {
                init.push(assignmentExpression("=", decl.id, decl.init));
              }
              var ids = Object.keys(getBindingIdentifiers(decl, false, true, true));
              for (var _i8 = 0, _ids = ids; _i8 < _ids.length; _i8++) {
                var _name = _ids[_i8];
                emit(identifier(_name), decl.init != null);
              }
            }
          } catch (err) {
            _iterator18.e(err);
          } finally {
            _iterator18.f();
          }
          if (parentPath.parentPath.isFor({
            left: parent
          })) {
            parentPath.replaceWith(firstId);
          } else if (init.length === 0) {
            parentPath.remove();
          } else {
            var expr = init.length === 1 ? init[0] : sequenceExpression(init);
            if (parentPath.parentPath.isForStatement({
              init: parent
            })) {
              parentPath.replaceWith(expr);
            } else {
              parentPath.replaceWith(expressionStatement(expr));
            }
          }
        }
      }
    }]);
  }();
  scope["default"] = Scope;
  Scope.globals = Object.keys(_globals.builtin);
  Scope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
  {
    Scope.prototype._renameFromMap = function _renameFromMap(map, oldName, newName, value) {
      if (map[oldName]) {
        map[newName] = value;
        map[oldName] = null;
      }
    };
    Scope.prototype.traverse = function (node, opts, state) {
      (0, _index["default"])(node, opts, this, state, this.path);
    };
    Scope.prototype._generateUid = function _generateUid(name, i) {
      var id = name;
      if (i > 1) id += i;
      return "_".concat(id);
    };
    Scope.prototype.toArray = function toArray(node, i, arrayLikeIsIterable) {
      if (isIdentifier(node)) {
        var binding = this.getBinding(node.name);
        if (binding != null && binding.constant && binding.path.isGenericType("Array")) {
          return node;
        }
      }
      if (isArrayExpression(node)) {
        return node;
      }
      if (isIdentifier(node, {
        name: "arguments"
      })) {
        return callExpression(memberExpression(memberExpression(memberExpression(identifier("Array"), identifier("prototype")), identifier("slice")), identifier("call")), [node]);
      }
      var helperName;
      var args = [node];
      if (i === true) {
        helperName = "toConsumableArray";
      } else if (typeof i === "number") {
        args.push(numericLiteral(i));
        helperName = "slicedToArray";
      } else {
        helperName = "toArray";
      }
      if (arrayLikeIsIterable) {
        args.unshift(this.path.hub.addHelper(helperName));
        helperName = "maybeArrayLike";
      }
      return callExpression(this.path.hub.addHelper(helperName), args);
    };
    Scope.prototype.getAllBindingsOfKind = function getAllBindingsOfKind() {
      var ids = Object.create(null);
      for (var _len = arguments.length, kinds = new Array(_len), _key = 0; _key < _len; _key++) {
        kinds[_key] = arguments[_key];
      }
      for (var _i9 = 0, _kinds = kinds; _i9 < _kinds.length; _i9++) {
        var kind = _kinds[_i9];
        var _scope3 = this;
        do {
          for (var _i10 = 0, _Object$keys8 = Object.keys(_scope3.bindings); _i10 < _Object$keys8.length; _i10++) {
            var name = _Object$keys8[_i10];
            var binding = _scope3.bindings[name];
            if (binding.kind === kind) ids[name] = binding;
          }
          _scope3 = _scope3.parent;
        } while (_scope3);
      }
      return ids;
    };
    Object.defineProperties(Scope.prototype, {
      parentBlock: {
        configurable: true,
        enumerable: true,
        get: function get() {
          return this.path.parent;
        }
      },
      hub: {
        configurable: true,
        enumerable: true,
        get: function get() {
          return this.path.hub;
        }
      }
    });
  }
  return scope;
}

var lib$2 = {};

var sourceMap = {};

var genMapping_umd$1 = {exports: {}};

var setArray_umd$1 = {exports: {}};

var setArray_umd = setArray_umd$1.exports;
var hasRequiredSetArray_umd;
function requireSetArray_umd() {
  if (hasRequiredSetArray_umd) return setArray_umd$1.exports;
  hasRequiredSetArray_umd = 1;
  (function (module, exports) {
    (function (global, factory) {
      factory(exports) ;
    })(setArray_umd, function (exports) {

      /**
       * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the
       * index of the `key` in the backing array.
       *
       * This is designed to allow synchronizing a second array with the contents of the backing array,
       * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,
       * and there are never duplicates.
       */
      var SetArray = /*#__PURE__*/_createClass(function SetArray() {
        _classCallCheck(this, SetArray);
        this._indexes = {
          __proto__: null
        };
        this.array = [];
      });
      /**
       * Typescript doesn't allow friend access to private fields, so this just casts the set into a type
       * with public access modifiers.
       */
      function cast(set) {
        return set;
      }
      /**
       * Gets the index associated with `key` in the backing array, if it is already present.
       */
      function get(setarr, key) {
        return cast(setarr)._indexes[key];
      }
      /**
       * Puts `key` into the backing array, if it is not already present. Returns
       * the index of the `key` in the backing array.
       */
      function put(setarr, key) {
        // The key may or may not be present. If it is present, it's a number.
        var index = get(setarr, key);
        if (index !== undefined) return index;
        var _cast = cast(setarr),
          array = _cast.array,
          indexes = _cast._indexes;
        var length = array.push(key);
        return indexes[key] = length - 1;
      }
      /**
       * Pops the last added item out of the SetArray.
       */
      function pop(setarr) {
        var _cast2 = cast(setarr),
          array = _cast2.array,
          indexes = _cast2._indexes;
        if (array.length === 0) return;
        var last = array.pop();
        indexes[last] = undefined;
      }
      /**
       * Removes the key, if it exists in the set.
       */
      function remove(setarr, key) {
        var index = get(setarr, key);
        if (index === undefined) return;
        var _cast3 = cast(setarr),
          array = _cast3.array,
          indexes = _cast3._indexes;
        for (var i = index + 1; i < array.length; i++) {
          var k = array[i];
          array[i - 1] = k;
          indexes[k]--;
        }
        indexes[key] = undefined;
        array.pop();
      }
      exports.SetArray = SetArray;
      exports.get = get;
      exports.pop = pop;
      exports.put = put;
      exports.remove = remove;
      Object.defineProperty(exports, '__esModule', {
        value: true
      });
    });
  })(setArray_umd$1, setArray_umd$1.exports);
  return setArray_umd$1.exports;
}

var sourcemapCodec_umd$1 = {exports: {}};

var sourcemapCodec_umd = sourcemapCodec_umd$1.exports;
var hasRequiredSourcemapCodec_umd;
function requireSourcemapCodec_umd() {
  if (hasRequiredSourcemapCodec_umd) return sourcemapCodec_umd$1.exports;
  hasRequiredSourcemapCodec_umd = 1;
  (function (module, exports) {
    (function (global, factory) {
      factory(exports) ;
    })(sourcemapCodec_umd, function (exports) {

      var comma = ','.charCodeAt(0);
      var semicolon = ';'.charCodeAt(0);
      var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      var intToChar = new Uint8Array(64); // 64 possible chars.
      var charToInt = new Uint8Array(128); // z is 122 in ASCII
      for (var i = 0; i < chars.length; i++) {
        var c = chars.charCodeAt(i);
        intToChar[i] = c;
        charToInt[c] = i;
      }
      function decodeInteger(reader, relative) {
        var value = 0;
        var shift = 0;
        var integer = 0;
        do {
          var _c = reader.next();
          integer = charToInt[_c];
          value |= (integer & 31) << shift;
          shift += 5;
        } while (integer & 32);
        var shouldNegate = value & 1;
        value >>>= 1;
        if (shouldNegate) {
          value = -2147483648 | -value;
        }
        return relative + value;
      }
      function encodeInteger(builder, num, relative) {
        var delta = num - relative;
        delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
        do {
          var clamped = delta & 31;
          delta >>>= 5;
          if (delta > 0) clamped |= 32;
          builder.write(intToChar[clamped]);
        } while (delta > 0);
        return num;
      }
      function hasMoreVlq(reader, max) {
        if (reader.pos >= max) return false;
        return reader.peek() !== comma;
      }
      var bufLength = 1024 * 16;
      // Provide a fallback for older environments.
      var td = typeof TextDecoder !== 'undefined' ? /* #__PURE__ */new TextDecoder() : typeof Buffer !== 'undefined' ? {
        decode: function decode(buf) {
          var out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
          return out.toString();
        }
      } : {
        decode: function decode(buf) {
          var out = '';
          for (var _i = 0; _i < buf.length; _i++) {
            out += String.fromCharCode(buf[_i]);
          }
          return out;
        }
      };
      var StringWriter = /*#__PURE__*/function () {
        function StringWriter() {
          _classCallCheck(this, StringWriter);
          this.pos = 0;
          this.out = '';
          this.buffer = new Uint8Array(bufLength);
        }
        return _createClass(StringWriter, [{
          key: "write",
          value: function write(v) {
            var buffer = this.buffer;
            buffer[this.pos++] = v;
            if (this.pos === bufLength) {
              this.out += td.decode(buffer);
              this.pos = 0;
            }
          }
        }, {
          key: "flush",
          value: function flush() {
            var buffer = this.buffer,
              out = this.out,
              pos = this.pos;
            return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
          }
        }]);
      }();
      var StringReader = /*#__PURE__*/function () {
        function StringReader(buffer) {
          _classCallCheck(this, StringReader);
          this.pos = 0;
          this.buffer = buffer;
        }
        return _createClass(StringReader, [{
          key: "next",
          value: function next() {
            return this.buffer.charCodeAt(this.pos++);
          }
        }, {
          key: "peek",
          value: function peek() {
            return this.buffer.charCodeAt(this.pos);
          }
        }, {
          key: "indexOf",
          value: function indexOf(_char) {
            var buffer = this.buffer,
              pos = this.pos;
            var idx = buffer.indexOf(_char, pos);
            return idx === -1 ? buffer.length : idx;
          }
        }]);
      }();
      var EMPTY = [];
      function decodeOriginalScopes(input) {
        var length = input.length;
        var reader = new StringReader(input);
        var scopes = [];
        var stack = [];
        var line = 0;
        for (; reader.pos < length; reader.pos++) {
          line = decodeInteger(reader, line);
          var column = decodeInteger(reader, 0);
          if (!hasMoreVlq(reader, length)) {
            var last = stack.pop();
            last[2] = line;
            last[3] = column;
            continue;
          }
          var kind = decodeInteger(reader, 0);
          var fields = decodeInteger(reader, 0);
          var hasName = fields & 1;
          var scope = hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind];
          var vars = EMPTY;
          if (hasMoreVlq(reader, length)) {
            vars = [];
            do {
              var varsIndex = decodeInteger(reader, 0);
              vars.push(varsIndex);
            } while (hasMoreVlq(reader, length));
          }
          scope.vars = vars;
          scopes.push(scope);
          stack.push(scope);
        }
        return scopes;
      }
      function encodeOriginalScopes(scopes) {
        var writer = new StringWriter();
        for (var _i2 = 0; _i2 < scopes.length;) {
          _i2 = _encodeOriginalScopes(scopes, _i2, writer, [0]);
        }
        return writer.flush();
      }
      function _encodeOriginalScopes(scopes, index, writer, state) {
        var scope = scopes[index];
        var startLine = scope[0],
          startColumn = scope[1],
          endLine = scope[2],
          endColumn = scope[3],
          kind = scope[4],
          vars = scope.vars;
        if (index > 0) writer.write(comma);
        state[0] = encodeInteger(writer, startLine, state[0]);
        encodeInteger(writer, startColumn, 0);
        encodeInteger(writer, kind, 0);
        var fields = scope.length === 6 ? 1 : 0;
        encodeInteger(writer, fields, 0);
        if (scope.length === 6) encodeInteger(writer, scope[5], 0);
        var _iterator = _createForOfIteratorHelper(vars),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var v = _step.value;
            encodeInteger(writer, v, 0);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        for (index++; index < scopes.length;) {
          var next = scopes[index];
          var l = next[0],
            _c2 = next[1];
          if (l > endLine || l === endLine && _c2 >= endColumn) {
            break;
          }
          index = _encodeOriginalScopes(scopes, index, writer, state);
        }
        writer.write(comma);
        state[0] = encodeInteger(writer, endLine, state[0]);
        encodeInteger(writer, endColumn, 0);
        return index;
      }
      function decodeGeneratedRanges(input) {
        var length = input.length;
        var reader = new StringReader(input);
        var ranges = [];
        var stack = [];
        var genLine = 0;
        var definitionSourcesIndex = 0;
        var definitionScopeIndex = 0;
        var callsiteSourcesIndex = 0;
        var callsiteLine = 0;
        var callsiteColumn = 0;
        var bindingLine = 0;
        var bindingColumn = 0;
        do {
          var semi = reader.indexOf(';');
          var genColumn = 0;
          for (; reader.pos < semi; reader.pos++) {
            genColumn = decodeInteger(reader, genColumn);
            if (!hasMoreVlq(reader, semi)) {
              var last = stack.pop();
              last[2] = genLine;
              last[3] = genColumn;
              continue;
            }
            var fields = decodeInteger(reader, 0);
            var hasDefinition = fields & 1;
            var hasCallsite = fields & 2;
            var hasScope = fields & 4;
            var callsite = null;
            var bindings = EMPTY;
            var range = void 0;
            if (hasDefinition) {
              var defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);
              definitionScopeIndex = decodeInteger(reader, definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0);
              definitionSourcesIndex = defSourcesIndex;
              range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex];
            } else {
              range = [genLine, genColumn, 0, 0];
            }
            range.isScope = !!hasScope;
            if (hasCallsite) {
              var prevCsi = callsiteSourcesIndex;
              var prevLine = callsiteLine;
              callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);
              var sameSource = prevCsi === callsiteSourcesIndex;
              callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);
              callsiteColumn = decodeInteger(reader, sameSource && prevLine === callsiteLine ? callsiteColumn : 0);
              callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];
            }
            range.callsite = callsite;
            if (hasMoreVlq(reader, semi)) {
              bindings = [];
              do {
                bindingLine = genLine;
                bindingColumn = genColumn;
                var expressionsCount = decodeInteger(reader, 0);
                var expressionRanges = void 0;
                if (expressionsCount < -1) {
                  expressionRanges = [[decodeInteger(reader, 0)]];
                  for (var _i3 = -1; _i3 > expressionsCount; _i3--) {
                    var prevBl = bindingLine;
                    bindingLine = decodeInteger(reader, bindingLine);
                    bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);
                    var expression = decodeInteger(reader, 0);
                    expressionRanges.push([expression, bindingLine, bindingColumn]);
                  }
                } else {
                  expressionRanges = [[expressionsCount]];
                }
                bindings.push(expressionRanges);
              } while (hasMoreVlq(reader, semi));
            }
            range.bindings = bindings;
            ranges.push(range);
            stack.push(range);
          }
          genLine++;
          reader.pos = semi + 1;
        } while (reader.pos < length);
        return ranges;
      }
      function encodeGeneratedRanges(ranges) {
        if (ranges.length === 0) return '';
        var writer = new StringWriter();
        for (var _i4 = 0; _i4 < ranges.length;) {
          _i4 = _encodeGeneratedRanges(ranges, _i4, writer, [0, 0, 0, 0, 0, 0, 0]);
        }
        return writer.flush();
      }
      function _encodeGeneratedRanges(ranges, index, writer, state) {
        var range = ranges[index];
        var startLine = range[0],
          startColumn = range[1],
          endLine = range[2],
          endColumn = range[3],
          isScope = range.isScope,
          callsite = range.callsite,
          bindings = range.bindings;
        if (state[0] < startLine) {
          catchupLine(writer, state[0], startLine);
          state[0] = startLine;
          state[1] = 0;
        } else if (index > 0) {
          writer.write(comma);
        }
        state[1] = encodeInteger(writer, range[1], state[1]);
        var fields = (range.length === 6 ? 1 : 0) | (callsite ? 2 : 0) | (isScope ? 4 : 0);
        encodeInteger(writer, fields, 0);
        if (range.length === 6) {
          var sourcesIndex = range[4],
            scopesIndex = range[5];
          if (sourcesIndex !== state[2]) {
            state[3] = 0;
          }
          state[2] = encodeInteger(writer, sourcesIndex, state[2]);
          state[3] = encodeInteger(writer, scopesIndex, state[3]);
        }
        if (callsite) {
          var _range$callsite = range.callsite,
            _sourcesIndex = _range$callsite[0],
            callLine = _range$callsite[1],
            callColumn = _range$callsite[2];
          if (_sourcesIndex !== state[4]) {
            state[5] = 0;
            state[6] = 0;
          } else if (callLine !== state[5]) {
            state[6] = 0;
          }
          state[4] = encodeInteger(writer, _sourcesIndex, state[4]);
          state[5] = encodeInteger(writer, callLine, state[5]);
          state[6] = encodeInteger(writer, callColumn, state[6]);
        }
        if (bindings) {
          var _iterator2 = _createForOfIteratorHelper(bindings),
            _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var binding = _step2.value;
              if (binding.length > 1) encodeInteger(writer, -binding.length, 0);
              var expression = binding[0][0];
              encodeInteger(writer, expression, 0);
              var bindingStartLine = startLine;
              var bindingStartColumn = startColumn;
              for (var _i5 = 1; _i5 < binding.length; _i5++) {
                var expRange = binding[_i5];
                bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);
                bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);
                encodeInteger(writer, expRange[0], 0);
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
        for (index++; index < ranges.length;) {
          var next = ranges[index];
          var l = next[0],
            _c3 = next[1];
          if (l > endLine || l === endLine && _c3 >= endColumn) {
            break;
          }
          index = _encodeGeneratedRanges(ranges, index, writer, state);
        }
        if (state[0] < endLine) {
          catchupLine(writer, state[0], endLine);
          state[0] = endLine;
          state[1] = 0;
        } else {
          writer.write(comma);
        }
        state[1] = encodeInteger(writer, endColumn, state[1]);
        return index;
      }
      function catchupLine(writer, lastLine, line) {
        do {
          writer.write(semicolon);
        } while (++lastLine < line);
      }
      function decode(mappings) {
        var length = mappings.length;
        var reader = new StringReader(mappings);
        var decoded = [];
        var genColumn = 0;
        var sourcesIndex = 0;
        var sourceLine = 0;
        var sourceColumn = 0;
        var namesIndex = 0;
        do {
          var semi = reader.indexOf(';');
          var line = [];
          var sorted = true;
          var lastCol = 0;
          genColumn = 0;
          while (reader.pos < semi) {
            var seg = void 0;
            genColumn = decodeInteger(reader, genColumn);
            if (genColumn < lastCol) sorted = false;
            lastCol = genColumn;
            if (hasMoreVlq(reader, semi)) {
              sourcesIndex = decodeInteger(reader, sourcesIndex);
              sourceLine = decodeInteger(reader, sourceLine);
              sourceColumn = decodeInteger(reader, sourceColumn);
              if (hasMoreVlq(reader, semi)) {
                namesIndex = decodeInteger(reader, namesIndex);
                seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];
              } else {
                seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];
              }
            } else {
              seg = [genColumn];
            }
            line.push(seg);
            reader.pos++;
          }
          if (!sorted) sort(line);
          decoded.push(line);
          reader.pos = semi + 1;
        } while (reader.pos <= length);
        return decoded;
      }
      function sort(line) {
        line.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[0] - b[0];
      }
      function encode(decoded) {
        var writer = new StringWriter();
        var sourcesIndex = 0;
        var sourceLine = 0;
        var sourceColumn = 0;
        var namesIndex = 0;
        for (var _i6 = 0; _i6 < decoded.length; _i6++) {
          var line = decoded[_i6];
          if (_i6 > 0) writer.write(semicolon);
          if (line.length === 0) continue;
          var genColumn = 0;
          for (var j = 0; j < line.length; j++) {
            var segment = line[j];
            if (j > 0) writer.write(comma);
            genColumn = encodeInteger(writer, segment[0], genColumn);
            if (segment.length === 1) continue;
            sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
            sourceLine = encodeInteger(writer, segment[2], sourceLine);
            sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
            if (segment.length === 4) continue;
            namesIndex = encodeInteger(writer, segment[4], namesIndex);
          }
        }
        return writer.flush();
      }
      exports.decode = decode;
      exports.decodeGeneratedRanges = decodeGeneratedRanges;
      exports.decodeOriginalScopes = decodeOriginalScopes;
      exports.encode = encode;
      exports.encodeGeneratedRanges = encodeGeneratedRanges;
      exports.encodeOriginalScopes = encodeOriginalScopes;
      Object.defineProperty(exports, '__esModule', {
        value: true
      });
    });
  })(sourcemapCodec_umd$1, sourcemapCodec_umd$1.exports);
  return sourcemapCodec_umd$1.exports;
}

var traceMapping_umd$1 = {exports: {}};

var resolveUri_umd$1 = {exports: {}};

var resolveUri_umd = resolveUri_umd$1.exports;
var hasRequiredResolveUri_umd;
function requireResolveUri_umd() {
  if (hasRequiredResolveUri_umd) return resolveUri_umd$1.exports;
  hasRequiredResolveUri_umd = 1;
  (function (module, exports) {
    (function (global, factory) {
      module.exports = factory() ;
    })(resolveUri_umd, function () {

      // Matches the scheme of a URL, eg "http://"
      var schemeRegex = /^[\w+.-]+:\/\//;
      /**
       * Matches the parts of a URL:
       * 1. Scheme, including ":", guaranteed.
       * 2. User/password, including "@", optional.
       * 3. Host, guaranteed.
       * 4. Port, including ":", optional.
       * 5. Path, including "/", optional.
       * 6. Query, including "?", optional.
       * 7. Hash, including "#", optional.
       */
      var urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
      /**
       * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start
       * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).
       *
       * 1. Host, optional.
       * 2. Path, which may include "/", guaranteed.
       * 3. Query, including "?", optional.
       * 4. Hash, including "#", optional.
       */
      var fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      function isAbsoluteUrl(input) {
        return schemeRegex.test(input);
      }
      function isSchemeRelativeUrl(input) {
        return input.startsWith('//');
      }
      function isAbsolutePath(input) {
        return input.startsWith('/');
      }
      function isFileUrl(input) {
        return input.startsWith('file:');
      }
      function isRelative(input) {
        return /^[.?#]/.test(input);
      }
      function parseAbsoluteUrl(input) {
        var match = urlRegex.exec(input);
        return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');
      }
      function parseFileUrl(input) {
        var match = fileRegex.exec(input);
        var path = match[2];
        return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');
      }
      function makeUrl(scheme, user, host, port, path, query, hash) {
        return {
          scheme: scheme,
          user: user,
          host: host,
          port: port,
          path: path,
          query: query,
          hash: hash,
          type: 7 /* Absolute */
        };
      }
      function parseUrl(input) {
        if (isSchemeRelativeUrl(input)) {
          var _url = parseAbsoluteUrl('http:' + input);
          _url.scheme = '';
          _url.type = 6 /* SchemeRelative */;
          return _url;
        }
        if (isAbsolutePath(input)) {
          var _url2 = parseAbsoluteUrl('http://foo.com' + input);
          _url2.scheme = '';
          _url2.host = '';
          _url2.type = 5 /* AbsolutePath */;
          return _url2;
        }
        if (isFileUrl(input)) return parseFileUrl(input);
        if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);
        var url = parseAbsoluteUrl('http://foo.com/' + input);
        url.scheme = '';
        url.host = '';
        url.type = input ? input.startsWith('?') ? 3 /* Query */ : input.startsWith('#') ? 2 /* Hash */ : 4 /* RelativePath */ : 1 /* Empty */;
        return url;
      }
      function stripPathFilename(path) {
        // If a path ends with a parent directory "..", then it's a relative path with excess parent
        // paths. It's not a file, so we can't strip it.
        if (path.endsWith('/..')) return path;
        var index = path.lastIndexOf('/');
        return path.slice(0, index + 1);
      }
      function mergePaths(url, base) {
        normalizePath(base, base.type);
        // If the path is just a "/", then it was an empty path to begin with (remember, we're a relative
        // path).
        if (url.path === '/') {
          url.path = base.path;
        } else {
          // Resolution happens relative to the base path's directory, not the file.
          url.path = stripPathFilename(base.path) + url.path;
        }
      }
      /**
       * The path can have empty directories "//", unneeded parents "foo/..", or current directory
       * "foo/.". We need to normalize to a standard representation.
       */
      function normalizePath(url, type) {
        var rel = type <= 4 /* RelativePath */;
        var pieces = url.path.split('/');
        // We need to preserve the first piece always, so that we output a leading slash. The item at
        // pieces[0] is an empty string.
        var pointer = 1;
        // Positive is the number of real directories we've output, used for popping a parent directory.
        // Eg, "foo/bar/.." will have a positive 2, and we can decrement to be left with just "foo".
        var positive = 0;
        // We need to keep a trailing slash if we encounter an empty directory (eg, splitting "foo/" will
        // generate `["foo", ""]` pieces). And, if we pop a parent directory. But once we encounter a
        // real directory, we won't need to append, unless the other conditions happen again.
        var addTrailingSlash = false;
        for (var i = 1; i < pieces.length; i++) {
          var piece = pieces[i];
          // An empty directory, could be a trailing slash, or just a double "//" in the path.
          if (!piece) {
            addTrailingSlash = true;
            continue;
          }
          // If we encounter a real directory, then we don't need to append anymore.
          addTrailingSlash = false;
          // A current directory, which we can always drop.
          if (piece === '.') continue;
          // A parent directory, we need to see if there are any real directories we can pop. Else, we
          // have an excess of parents, and we'll need to keep the "..".
          if (piece === '..') {
            if (positive) {
              addTrailingSlash = true;
              positive--;
              pointer--;
            } else if (rel) {
              // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute
              // URL, protocol relative URL, or an absolute path, we don't need to keep excess.
              pieces[pointer++] = piece;
            }
            continue;
          }
          // We've encountered a real directory. Move it to the next insertion pointer, which accounts for
          // any popped or dropped directories.
          pieces[pointer++] = piece;
          positive++;
        }
        var path = '';
        for (var _i = 1; _i < pointer; _i++) {
          path += '/' + pieces[_i];
        }
        if (!path || addTrailingSlash && !path.endsWith('/..')) {
          path += '/';
        }
        url.path = path;
      }
      /**
       * Attempts to resolve `input` URL/path relative to `base`.
       */
      function resolve(input, base) {
        if (!input && !base) return '';
        var url = parseUrl(input);
        var inputType = url.type;
        if (base && inputType !== 7 /* Absolute */) {
          var baseUrl = parseUrl(base);
          var baseType = baseUrl.type;
          switch (inputType) {
            case 1 /* Empty */:
              url.hash = baseUrl.hash;
            // fall through
            case 2 /* Hash */:
              url.query = baseUrl.query;
            // fall through
            case 3 /* Query */:
            case 4 /* RelativePath */:
              mergePaths(url, baseUrl);
            // fall through
            case 5 /* AbsolutePath */:
              // The host, user, and port are joined, you can't copy one without the others.
              url.user = baseUrl.user;
              url.host = baseUrl.host;
              url.port = baseUrl.port;
            // fall through
            case 6 /* SchemeRelative */:
              // The input doesn't have a schema at least, so we need to copy at least that over.
              url.scheme = baseUrl.scheme;
          }
          if (baseType > inputType) inputType = baseType;
        }
        normalizePath(url, inputType);
        var queryHash = url.query + url.hash;
        switch (inputType) {
          // This is impossible, because of the empty checks at the start of the function.
          // case UrlType.Empty:
          case 2 /* Hash */:
          case 3 /* Query */:
            return queryHash;
          case 4 /* RelativePath */:
            {
              // The first char is always a "/", and we need it to be relative.
              var path = url.path.slice(1);
              if (!path) return queryHash || '.';
              if (isRelative(base || input) && !isRelative(path)) {
                // If base started with a leading ".", or there is no base and input started with a ".",
                // then we need to ensure that the relative path starts with a ".". We don't know if
                // relative starts with a "..", though, so check before prepending.
                return './' + path + queryHash;
              }
              return path + queryHash;
            }
          case 5 /* AbsolutePath */:
            return url.path + queryHash;
          default:
            return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;
        }
      }
      return resolve;
    });
  })(resolveUri_umd$1);
  return resolveUri_umd$1.exports;
}

var traceMapping_umd = traceMapping_umd$1.exports;
var hasRequiredTraceMapping_umd;
function requireTraceMapping_umd() {
  if (hasRequiredTraceMapping_umd) return traceMapping_umd$1.exports;
  hasRequiredTraceMapping_umd = 1;
  (function (module, exports) {
    (function (global, factory) {
      factory(exports, requireSourcemapCodec_umd(), requireResolveUri_umd()) ;
    })(traceMapping_umd, function (exports, sourcemapCodec, resolveUri) {

      function resolve(input, base) {
        // The base is always treated as a directory, if it's not empty.
        // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327
        // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401
        if (base && !base.endsWith('/')) base += '/';
        return resolveUri(input, base);
      }

      /**
       * Removes everything after the last "/", but leaves the slash.
       */
      function stripFilename(path) {
        if (!path) return '';
        var index = path.lastIndexOf('/');
        return path.slice(0, index + 1);
      }
      var COLUMN = 0;
      var SOURCES_INDEX = 1;
      var SOURCE_LINE = 2;
      var SOURCE_COLUMN = 3;
      var NAMES_INDEX = 4;
      var REV_GENERATED_LINE = 1;
      var REV_GENERATED_COLUMN = 2;
      function maybeSort(mappings, owned) {
        var unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
        if (unsortedIndex === mappings.length) return mappings;
        // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If
        // not, we do not want to modify the consumer's input array.
        if (!owned) mappings = mappings.slice();
        for (var i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
          mappings[i] = sortSegments(mappings[i], owned);
        }
        return mappings;
      }
      function nextUnsortedSegmentLine(mappings, start) {
        for (var i = start; i < mappings.length; i++) {
          if (!isSorted(mappings[i])) return i;
        }
        return mappings.length;
      }
      function isSorted(line) {
        for (var j = 1; j < line.length; j++) {
          if (line[j][COLUMN] < line[j - 1][COLUMN]) {
            return false;
          }
        }
        return true;
      }
      function sortSegments(line, owned) {
        if (!owned) line = line.slice();
        return line.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[COLUMN] - b[COLUMN];
      }
      var found = false;
      /**
       * A binary search implementation that returns the index if a match is found.
       * If no match is found, then the left-index (the index associated with the item that comes just
       * before the desired index) is returned. To maintain proper sort order, a splice would happen at
       * the next index:
       *
       * ```js
       * const array = [1, 3];
       * const needle = 2;
       * const index = binarySearch(array, needle, (item, needle) => item - needle);
       *
       * assert.equal(index, 0);
       * array.splice(index + 1, 0, needle);
       * assert.deepEqual(array, [1, 2, 3]);
       * ```
       */
      function binarySearch(haystack, needle, low, high) {
        while (low <= high) {
          var mid = low + (high - low >> 1);
          var cmp = haystack[mid][COLUMN] - needle;
          if (cmp === 0) {
            found = true;
            return mid;
          }
          if (cmp < 0) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
        found = false;
        return low - 1;
      }
      function upperBound(haystack, needle, index) {
        for (var i = index + 1; i < haystack.length; index = i++) {
          if (haystack[i][COLUMN] !== needle) break;
        }
        return index;
      }
      function lowerBound(haystack, needle, index) {
        for (var i = index - 1; i >= 0; index = i--) {
          if (haystack[i][COLUMN] !== needle) break;
        }
        return index;
      }
      function memoizedState() {
        return {
          lastKey: -1,
          lastNeedle: -1,
          lastIndex: -1
        };
      }
      /**
       * This overly complicated beast is just to record the last tested line/column and the resulting
       * index, allowing us to skip a few tests if mappings are monotonically increasing.
       */
      function memoizedBinarySearch(haystack, needle, state, key) {
        var lastKey = state.lastKey,
          lastNeedle = state.lastNeedle,
          lastIndex = state.lastIndex;
        var low = 0;
        var high = haystack.length - 1;
        if (key === lastKey) {
          if (needle === lastNeedle) {
            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
            return lastIndex;
          }
          if (needle >= lastNeedle) {
            // lastIndex may be -1 if the previous needle was not found.
            low = lastIndex === -1 ? 0 : lastIndex;
          } else {
            high = lastIndex;
          }
        }
        state.lastKey = key;
        state.lastNeedle = needle;
        return state.lastIndex = binarySearch(haystack, needle, low, high);
      }

      // Rebuilds the original source files, with mappings that are ordered by source line/column instead
      // of generated line/column.
      function buildBySources(decoded, memos) {
        var sources = memos.map(buildNullArray);
        for (var i = 0; i < decoded.length; i++) {
          var line = decoded[i];
          for (var j = 0; j < line.length; j++) {
            var seg = line[j];
            if (seg.length === 1) continue;
            var _sourceIndex = seg[SOURCES_INDEX];
            var sourceLine = seg[SOURCE_LINE];
            var sourceColumn = seg[SOURCE_COLUMN];
            var originalSource = sources[_sourceIndex];
            var originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);
            var memo = memos[_sourceIndex];
            // The binary search either found a match, or it found the left-index just before where the
            // segment should go. Either way, we want to insert after that. And there may be multiple
            // generated segments associated with an original location, so there may need to move several
            // indexes before we find where we need to insert.
            var index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));
            memo.lastIndex = ++index;
            insert(originalLine, index, [sourceColumn, i, seg[COLUMN]]);
          }
        }
        return sources;
      }
      function insert(array, index, value) {
        for (var i = array.length; i > index; i--) {
          array[i] = array[i - 1];
        }
        array[index] = value;
      }
      // Null arrays allow us to use ordered index keys without actually allocating contiguous memory like
      // a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.
      // Numeric properties on objects are magically sorted in ascending order by the engine regardless of
      // the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending
      // order when iterating with for-in.
      function buildNullArray() {
        return {
          __proto__: null
        };
      }
      var AnyMap = function AnyMap(map, mapUrl) {
        var parsed = parse(map);
        if (!('sections' in parsed)) {
          return new TraceMap(parsed, mapUrl);
        }
        var mappings = [];
        var sources = [];
        var sourcesContent = [];
        var names = [];
        var ignoreList = [];
        recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, ignoreList, 0, 0, Infinity, Infinity);
        var joined = {
          version: 3,
          file: parsed.file,
          names: names,
          sources: sources,
          sourcesContent: sourcesContent,
          mappings: mappings,
          ignoreList: ignoreList
        };
        return presortedDecodedMap(joined);
      };
      function parse(map) {
        return typeof map === 'string' ? JSON.parse(map) : map;
      }
      function recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        var sections = input.sections;
        for (var i = 0; i < sections.length; i++) {
          var _sections$i = sections[i],
            map = _sections$i.map,
            offset = _sections$i.offset;
          var sl = stopLine;
          var sc = stopColumn;
          if (i + 1 < sections.length) {
            var nextOffset = sections[i + 1].offset;
            sl = Math.min(stopLine, lineOffset + nextOffset.line);
            if (sl === stopLine) {
              sc = Math.min(stopColumn, columnOffset + nextOffset.column);
            } else if (sl < stopLine) {
              sc = columnOffset + nextOffset.column;
            }
          }
          addSection(map, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset + offset.line, columnOffset + offset.column, sl, sc);
        }
      }
      function addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        var parsed = parse(input);
        if ('sections' in parsed) return recurse.apply(void 0, arguments);
        var map = new TraceMap(parsed, mapUrl);
        var sourcesOffset = sources.length;
        var namesOffset = names.length;
        var decoded = decodedMappings(map);
        var resolvedSources = map.resolvedSources,
          contents = map.sourcesContent,
          ignores = map.ignoreList;
        append(sources, resolvedSources);
        append(names, map.names);
        if (contents) append(sourcesContent, contents);else for (var i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);
        if (ignores) for (var _i = 0; _i < ignores.length; _i++) ignoreList.push(ignores[_i] + sourcesOffset);
        for (var _i2 = 0; _i2 < decoded.length; _i2++) {
          var lineI = lineOffset + _i2;
          // We can only add so many lines before we step into the range that the next section's map
          // controls. When we get to the last line, then we'll start checking the segments to see if
          // they've crossed into the column range. But it may not have any columns that overstep, so we
          // still need to check that we don't overstep lines, too.
          if (lineI > stopLine) return;
          // The out line may already exist in mappings (if we're continuing the line started by a
          // previous section). Or, we may have jumped ahead several lines to start this section.
          var out = getLine(mappings, lineI);
          // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the
          // map can be multiple lines), it doesn't.
          var cOffset = _i2 === 0 ? columnOffset : 0;
          var line = decoded[_i2];
          for (var j = 0; j < line.length; j++) {
            var seg = line[j];
            var column = cOffset + seg[COLUMN];
            // If this segment steps into the column range that the next section's map controls, we need
            // to stop early.
            if (lineI === stopLine && column >= stopColumn) return;
            if (seg.length === 1) {
              out.push([column]);
              continue;
            }
            var sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
            var sourceLine = seg[SOURCE_LINE];
            var sourceColumn = seg[SOURCE_COLUMN];
            out.push(seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);
          }
        }
      }
      function append(arr, other) {
        for (var i = 0; i < other.length; i++) arr.push(other[i]);
      }
      function getLine(arr, index) {
        for (var i = arr.length; i <= index; i++) arr[i] = [];
        return arr[index];
      }
      var LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';
      var COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';
      var LEAST_UPPER_BOUND = -1;
      var GREATEST_LOWER_BOUND = 1;
      var TraceMap = /*#__PURE__*/_createClass(function TraceMap(map, mapUrl) {
        _classCallCheck(this, TraceMap);
        var isString = typeof map === 'string';
        if (!isString && map._decodedMemo) return map;
        var parsed = isString ? JSON.parse(map) : map;
        var version = parsed.version,
          file = parsed.file,
          names = parsed.names,
          sourceRoot = parsed.sourceRoot,
          sources = parsed.sources,
          sourcesContent = parsed.sourcesContent;
        this.version = version;
        this.file = file;
        this.names = names || [];
        this.sourceRoot = sourceRoot;
        this.sources = sources;
        this.sourcesContent = sourcesContent;
        this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || undefined;
        var from = resolve(sourceRoot || '', stripFilename(mapUrl));
        this.resolvedSources = sources.map(function (s) {
          return resolve(s || '', from);
        });
        var mappings = parsed.mappings;
        if (typeof mappings === 'string') {
          this._encoded = mappings;
          this._decoded = undefined;
        } else {
          this._encoded = undefined;
          this._decoded = maybeSort(mappings, isString);
        }
        this._decodedMemo = memoizedState();
        this._bySources = undefined;
        this._bySourceMemos = undefined;
      });
      /**
       * Typescript doesn't allow friend access to private fields, so this just casts the map into a type
       * with public access modifiers.
       */
      function cast(map) {
        return map;
      }
      /**
       * Returns the encoded (VLQ string) form of the SourceMap's mappings field.
       */
      function encodedMappings(map) {
        var _a;
        var _b;
        return (_a = (_b = cast(map))._encoded) !== null && _a !== void 0 ? _a : _b._encoded = sourcemapCodec.encode(cast(map)._decoded);
      }
      /**
       * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.
       */
      function decodedMappings(map) {
        var _a;
        return (_a = cast(map))._decoded || (_a._decoded = sourcemapCodec.decode(cast(map)._encoded));
      }
      /**
       * A low-level API to find the segment associated with a generated line/column (think, from a
       * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.
       */
      function traceSegment(map, line, column) {
        var decoded = decodedMappings(map);
        // It's common for parent source maps to have pointers to lines that have no
        // mapping (like a "//# sourceMappingURL=") at the end of the child file.
        if (line >= decoded.length) return null;
        var segments = decoded[line];
        var index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, GREATEST_LOWER_BOUND);
        return index === -1 ? null : segments[index];
      }
      /**
       * A higher-level API to find the source/line/column associated with a generated line/column
       * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in
       * `source-map` library.
       */
      function originalPositionFor(map, needle) {
        var line = needle.line,
          column = needle.column,
          bias = needle.bias;
        line--;
        if (line < 0) throw new Error(LINE_GTR_ZERO);
        if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
        var decoded = decodedMappings(map);
        // It's common for parent source maps to have pointers to lines that have no
        // mapping (like a "//# sourceMappingURL=") at the end of the child file.
        if (line >= decoded.length) return OMapping(null, null, null, null);
        var segments = decoded[line];
        var index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
        if (index === -1) return OMapping(null, null, null, null);
        var segment = segments[index];
        if (segment.length === 1) return OMapping(null, null, null, null);
        var names = map.names,
          resolvedSources = map.resolvedSources;
        return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
      }
      /**
       * Finds the generated line/column position of the provided source/line/column source position.
       */
      function generatedPositionFor(map, needle) {
        var source = needle.source,
          line = needle.line,
          column = needle.column,
          bias = needle.bias;
        return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);
      }
      /**
       * Finds all generated line/column positions of the provided source/line/column source position.
       */
      function allGeneratedPositionsFor(map, needle) {
        var source = needle.source,
          line = needle.line,
          column = needle.column,
          bias = needle.bias;
        // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.
        return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);
      }
      /**
       * Iterates each mapping in generated position order.
       */
      function eachMapping(map, cb) {
        var decoded = decodedMappings(map);
        var names = map.names,
          resolvedSources = map.resolvedSources;
        for (var i = 0; i < decoded.length; i++) {
          var line = decoded[i];
          for (var j = 0; j < line.length; j++) {
            var seg = line[j];
            var generatedLine = i + 1;
            var generatedColumn = seg[0];
            var source = null;
            var originalLine = null;
            var originalColumn = null;
            var name = null;
            if (seg.length !== 1) {
              source = resolvedSources[seg[1]];
              originalLine = seg[2] + 1;
              originalColumn = seg[3];
            }
            if (seg.length === 5) name = names[seg[4]];
            cb({
              generatedLine: generatedLine,
              generatedColumn: generatedColumn,
              source: source,
              originalLine: originalLine,
              originalColumn: originalColumn,
              name: name
            });
          }
        }
      }
      function sourceIndex(map, source) {
        var sources = map.sources,
          resolvedSources = map.resolvedSources;
        var index = sources.indexOf(source);
        if (index === -1) index = resolvedSources.indexOf(source);
        return index;
      }
      /**
       * Retrieves the source content for a particular source, if its found. Returns null if not.
       */
      function sourceContentFor(map, source) {
        var sourcesContent = map.sourcesContent;
        if (sourcesContent == null) return null;
        var index = sourceIndex(map, source);
        return index === -1 ? null : sourcesContent[index];
      }
      /**
       * Determines if the source is marked to ignore by the source map.
       */
      function isIgnored(map, source) {
        var ignoreList = map.ignoreList;
        if (ignoreList == null) return false;
        var index = sourceIndex(map, source);
        return index === -1 ? false : ignoreList.includes(index);
      }
      /**
       * A helper that skips sorting of the input map's mappings array, which can be expensive for larger
       * maps.
       */
      function presortedDecodedMap(map, mapUrl) {
        var tracer = new TraceMap(clone(map, []), mapUrl);
        cast(tracer)._decoded = map.mappings;
        return tracer;
      }
      /**
       * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects
       * a sourcemap, or to JSON.stringify.
       */
      function decodedMap(map) {
        return clone(map, decodedMappings(map));
      }
      /**
       * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects
       * a sourcemap, or to JSON.stringify.
       */
      function encodedMap(map) {
        return clone(map, encodedMappings(map));
      }
      function clone(map, mappings) {
        return {
          version: map.version,
          file: map.file,
          names: map.names,
          sourceRoot: map.sourceRoot,
          sources: map.sources,
          sourcesContent: map.sourcesContent,
          mappings: mappings,
          ignoreList: map.ignoreList || map.x_google_ignoreList
        };
      }
      function OMapping(source, line, column, name) {
        return {
          source: source,
          line: line,
          column: column,
          name: name
        };
      }
      function GMapping(line, column) {
        return {
          line: line,
          column: column
        };
      }
      function traceSegmentInternal(segments, memo, line, column, bias) {
        var index = memoizedBinarySearch(segments, column, memo, line);
        if (found) {
          index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
        } else if (bias === LEAST_UPPER_BOUND) index++;
        if (index === -1 || index === segments.length) return -1;
        return index;
      }
      function sliceGeneratedPositions(segments, memo, line, column, bias) {
        var min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);
        // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in
        // insertion order) segment that matched. Even if we did respect the bias when tracing, we would
        // still need to call `lowerBound()` to find the first segment, which is slower than just looking
        // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the
        // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to
        // match LEAST_UPPER_BOUND.
        if (!found && bias === LEAST_UPPER_BOUND) min++;
        if (min === -1 || min === segments.length) return [];
        // We may have found the segment that started at an earlier column. If this is the case, then we
        // need to slice all generated segments that match _that_ column, because all such segments span
        // to our desired column.
        var matchedColumn = found ? column : segments[min][COLUMN];
        // The binary search is not guaranteed to find the lower bound when a match wasn't found.
        if (!found) min = lowerBound(segments, matchedColumn, min);
        var max = upperBound(segments, matchedColumn, min);
        var result = [];
        for (; min <= max; min++) {
          var segment = segments[min];
          result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
        }
        return result;
      }
      function generatedPosition(map, source, line, column, bias, all) {
        var _a;
        line--;
        if (line < 0) throw new Error(LINE_GTR_ZERO);
        if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
        var sources = map.sources,
          resolvedSources = map.resolvedSources;
        var sourceIndex = sources.indexOf(source);
        if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source);
        if (sourceIndex === -1) return all ? [] : GMapping(null, null);
        var generated = (_a = cast(map))._bySources || (_a._bySources = buildBySources(decodedMappings(map), cast(map)._bySourceMemos = sources.map(memoizedState)));
        var segments = generated[sourceIndex][line];
        if (segments == null) return all ? [] : GMapping(null, null);
        var memo = cast(map)._bySourceMemos[sourceIndex];
        if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);
        var index = traceSegmentInternal(segments, memo, line, column, bias);
        if (index === -1) return GMapping(null, null);
        var segment = segments[index];
        return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
      }
      exports.AnyMap = AnyMap;
      exports.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND;
      exports.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND;
      exports.TraceMap = TraceMap;
      exports.allGeneratedPositionsFor = allGeneratedPositionsFor;
      exports.decodedMap = decodedMap;
      exports.decodedMappings = decodedMappings;
      exports.eachMapping = eachMapping;
      exports.encodedMap = encodedMap;
      exports.encodedMappings = encodedMappings;
      exports.generatedPositionFor = generatedPositionFor;
      exports.isIgnored = isIgnored;
      exports.originalPositionFor = originalPositionFor;
      exports.presortedDecodedMap = presortedDecodedMap;
      exports.sourceContentFor = sourceContentFor;
      exports.traceSegment = traceSegment;
    });
  })(traceMapping_umd$1, traceMapping_umd$1.exports);
  return traceMapping_umd$1.exports;
}

var genMapping_umd = genMapping_umd$1.exports;
var hasRequiredGenMapping_umd;
function requireGenMapping_umd() {
  if (hasRequiredGenMapping_umd) return genMapping_umd$1.exports;
  hasRequiredGenMapping_umd = 1;
  (function (module, exports) {
    (function (global, factory) {
      factory(exports, requireSetArray_umd(), requireSourcemapCodec_umd(), requireTraceMapping_umd()) ;
    })(genMapping_umd, function (exports, setArray, sourcemapCodec, traceMapping) {

      var COLUMN = 0;
      var SOURCES_INDEX = 1;
      var SOURCE_LINE = 2;
      var SOURCE_COLUMN = 3;
      var NAMES_INDEX = 4;
      var NO_NAME = -1;
      /**
       * Provides the state to generate a sourcemap.
       */
      var GenMapping = /*#__PURE__*/_createClass(function GenMapping() {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          file = _ref.file,
          sourceRoot = _ref.sourceRoot;
        _classCallCheck(this, GenMapping);
        this._names = new setArray.SetArray();
        this._sources = new setArray.SetArray();
        this._sourcesContent = [];
        this._mappings = [];
        this.file = file;
        this.sourceRoot = sourceRoot;
        this._ignoreList = new setArray.SetArray();
      });
      /**
       * Typescript doesn't allow friend access to private fields, so this just casts the map into a type
       * with public access modifiers.
       */
      function cast(map) {
        return map;
      }
      function addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
        return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
      }
      function addMapping(map, mapping) {
        return addMappingInternal(false, map, mapping);
      }
      /**
       * Same as `addSegment`, but will only add the segment if it generates useful information in the
       * resulting map. This only works correctly if segments are added **in order**, meaning you should
       * not add a segment with a lower generated line/column than one that came before.
       */
      var maybeAddSegment = function maybeAddSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
        return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);
      };
      /**
       * Same as `addMapping`, but will only add the mapping if it generates useful information in the
       * resulting map. This only works correctly if mappings are added **in order**, meaning you should
       * not add a mapping with a lower generated line/column than one that came before.
       */
      var maybeAddMapping = function maybeAddMapping(map, mapping) {
        return addMappingInternal(true, map, mapping);
      };
      /**
       * Adds/removes the content of the source file to the source map.
       */
      function setSourceContent(map, source, content) {
        var _cast = cast(map),
          sources = _cast._sources,
          sourcesContent = _cast._sourcesContent;
        var index = setArray.put(sources, source);
        sourcesContent[index] = content;
      }
      function setIgnore(map, source) {
        var ignore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        var _cast2 = cast(map),
          sources = _cast2._sources,
          sourcesContent = _cast2._sourcesContent,
          ignoreList = _cast2._ignoreList;
        var index = setArray.put(sources, source);
        if (index === sourcesContent.length) sourcesContent[index] = null;
        if (ignore) setArray.put(ignoreList, index);else setArray.remove(ignoreList, index);
      }
      /**
       * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects
       * a sourcemap, or to JSON.stringify.
       */
      function toDecodedMap(map) {
        var _cast3 = cast(map),
          mappings = _cast3._mappings,
          sources = _cast3._sources,
          sourcesContent = _cast3._sourcesContent,
          names = _cast3._names,
          ignoreList = _cast3._ignoreList;
        removeEmptyFinalLines(mappings);
        return {
          version: 3,
          file: map.file || undefined,
          names: names.array,
          sourceRoot: map.sourceRoot || undefined,
          sources: sources.array,
          sourcesContent: sourcesContent,
          mappings: mappings,
          ignoreList: ignoreList.array
        };
      }
      /**
       * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects
       * a sourcemap, or to JSON.stringify.
       */
      function toEncodedMap(map) {
        var decoded = toDecodedMap(map);
        return Object.assign(Object.assign({}, decoded), {
          mappings: sourcemapCodec.encode(decoded.mappings)
        });
      }
      /**
       * Constructs a new GenMapping, using the already present mappings of the input.
       */
      function fromMap(input) {
        var map = new traceMapping.TraceMap(input);
        var gen = new GenMapping({
          file: map.file,
          sourceRoot: map.sourceRoot
        });
        putAll(cast(gen)._names, map.names);
        putAll(cast(gen)._sources, map.sources);
        cast(gen)._sourcesContent = map.sourcesContent || map.sources.map(function () {
          return null;
        });
        cast(gen)._mappings = traceMapping.decodedMappings(map);
        if (map.ignoreList) putAll(cast(gen)._ignoreList, map.ignoreList);
        return gen;
      }
      /**
       * Returns an array of high-level mapping objects for every recorded segment, which could then be
       * passed to the `source-map` library.
       */
      function allMappings(map) {
        var out = [];
        var _cast4 = cast(map),
          mappings = _cast4._mappings,
          sources = _cast4._sources,
          names = _cast4._names;
        for (var i = 0; i < mappings.length; i++) {
          var line = mappings[i];
          for (var j = 0; j < line.length; j++) {
            var seg = line[j];
            var generated = {
              line: i + 1,
              column: seg[COLUMN]
            };
            var source = undefined;
            var original = undefined;
            var name = undefined;
            if (seg.length !== 1) {
              source = sources.array[seg[SOURCES_INDEX]];
              original = {
                line: seg[SOURCE_LINE] + 1,
                column: seg[SOURCE_COLUMN]
              };
              if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];
            }
            out.push({
              generated: generated,
              source: source,
              original: original,
              name: name
            });
          }
        }
        return out;
      }
      // This split declaration is only so that terser can elminiate the static initialization block.
      function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {
        var _cast5 = cast(map),
          mappings = _cast5._mappings,
          sources = _cast5._sources,
          sourcesContent = _cast5._sourcesContent,
          names = _cast5._names;
        var line = getLine(mappings, genLine);
        var index = getColumnIndex(line, genColumn);
        if (!source) {
          if (skipable && skipSourceless(line, index)) return;
          return insert(line, index, [genColumn]);
        }
        var sourcesIndex = setArray.put(sources, source);
        var namesIndex = name ? setArray.put(names, name) : NO_NAME;
        if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;
        if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
          return;
        }
        return insert(line, index, name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
      }
      function getLine(mappings, index) {
        for (var i = mappings.length; i <= index; i++) {
          mappings[i] = [];
        }
        return mappings[index];
      }
      function getColumnIndex(line, genColumn) {
        var index = line.length;
        for (var i = index - 1; i >= 0; index = i--) {
          var current = line[i];
          if (genColumn >= current[COLUMN]) break;
        }
        return index;
      }
      function insert(array, index, value) {
        for (var i = array.length; i > index; i--) {
          array[i] = array[i - 1];
        }
        array[index] = value;
      }
      function removeEmptyFinalLines(mappings) {
        var length = mappings.length;
        var len = length;
        for (var i = len - 1; i >= 0; len = i, i--) {
          if (mappings[i].length > 0) break;
        }
        if (len < length) mappings.length = len;
      }
      function putAll(setarr, array) {
        for (var i = 0; i < array.length; i++) setArray.put(setarr, array[i]);
      }
      function skipSourceless(line, index) {
        // The start of a line is already sourceless, so adding a sourceless segment to the beginning
        // doesn't generate any useful information.
        if (index === 0) return true;
        var prev = line[index - 1];
        // If the previous segment is also sourceless, then adding another sourceless segment doesn't
        // genrate any new information. Else, this segment will end the source/named segment and point to
        // a sourceless position, which is useful.
        return prev.length === 1;
      }
      function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
        // A source/named segment at the start of a line gives position at that genColumn
        if (index === 0) return false;
        var prev = line[index - 1];
        // If the previous segment is sourceless, then we're transitioning to a source.
        if (prev.length === 1) return false;
        // If the previous segment maps to the exact same source position, then this segment doesn't
        // provide any new position information.
        return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);
      }
      function addMappingInternal(skipable, map, mapping) {
        var generated = mapping.generated,
          source = mapping.source,
          original = mapping.original,
          name = mapping.name,
          content = mapping.content;
        if (!source) {
          return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
        }
        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, source, original.line - 1, original.column, name, content);
      }
      exports.GenMapping = GenMapping;
      exports.addMapping = addMapping;
      exports.addSegment = addSegment;
      exports.allMappings = allMappings;
      exports.fromMap = fromMap;
      exports.maybeAddMapping = maybeAddMapping;
      exports.maybeAddSegment = maybeAddSegment;
      exports.setIgnore = setIgnore;
      exports.setSourceContent = setSourceContent;
      exports.toDecodedMap = toDecodedMap;
      exports.toEncodedMap = toEncodedMap;
      Object.defineProperty(exports, '__esModule', {
        value: true
      });
    });
  })(genMapping_umd$1, genMapping_umd$1.exports);
  return genMapping_umd$1.exports;
}

var hasRequiredSourceMap;
function requireSourceMap() {
  if (hasRequiredSourceMap) return sourceMap;
  hasRequiredSourceMap = 1;
  Object.defineProperty(sourceMap, "__esModule", {
    value: true
  });
  sourceMap["default"] = void 0;
  var _genMapping = requireGenMapping_umd();
  var _traceMapping = requireTraceMapping_umd();
  var SourceMap = /*#__PURE__*/function () {
    function SourceMap(opts, code) {
      _classCallCheck(this, SourceMap);
      var _opts$sourceFileName;
      this._map = void 0;
      this._rawMappings = void 0;
      this._sourceFileName = void 0;
      this._lastGenLine = 0;
      this._lastSourceLine = 0;
      this._lastSourceColumn = 0;
      this._inputMap = void 0;
      var map = this._map = new _genMapping.GenMapping({
        sourceRoot: opts.sourceRoot
      });
      this._sourceFileName = (_opts$sourceFileName = opts.sourceFileName) == null ? void 0 : _opts$sourceFileName.replace(/\\/g, "/");
      this._rawMappings = undefined;
      if (opts.inputSourceMap) {
        this._inputMap = new _traceMapping.TraceMap(opts.inputSourceMap);
        var resolvedSources = this._inputMap.resolvedSources;
        if (resolvedSources.length) {
          for (var i = 0; i < resolvedSources.length; i++) {
            var _this$_inputMap$sourc;
            (0, _genMapping.setSourceContent)(map, resolvedSources[i], (_this$_inputMap$sourc = this._inputMap.sourcesContent) == null ? void 0 : _this$_inputMap$sourc[i]);
          }
        }
      }
      if (typeof code === "string" && !opts.inputSourceMap) {
        (0, _genMapping.setSourceContent)(map, this._sourceFileName, code);
      } else if (_typeof(code) === "object") {
        for (var _i = 0, _Object$keys = Object.keys(code); _i < _Object$keys.length; _i++) {
          var sourceFileName = _Object$keys[_i];
          (0, _genMapping.setSourceContent)(map, sourceFileName.replace(/\\/g, "/"), code[sourceFileName]);
        }
      }
    }
    return _createClass(SourceMap, [{
      key: "get",
      value: function get() {
        return (0, _genMapping.toEncodedMap)(this._map);
      }
    }, {
      key: "getDecoded",
      value: function getDecoded() {
        return (0, _genMapping.toDecodedMap)(this._map);
      }
    }, {
      key: "getRawMappings",
      value: function getRawMappings() {
        return this._rawMappings || (this._rawMappings = (0, _genMapping.allMappings)(this._map));
      }
    }, {
      key: "mark",
      value: function mark(generated, line, column, identifierName, identifierNamePos, filename) {
        var _originalMapping;
        this._rawMappings = undefined;
        var originalMapping;
        if (line != null) {
          if (this._inputMap) {
            originalMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, {
              line: line,
              column: column
            });
            if (!originalMapping.name && identifierNamePos) {
              var originalIdentifierMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, identifierNamePos);
              if (originalIdentifierMapping.name) {
                identifierName = originalIdentifierMapping.name;
              }
            }
          } else {
            originalMapping = {
              source: (filename == null ? void 0 : filename.replace(/\\/g, "/")) || this._sourceFileName,
              line: line,
              column: column
            };
          }
        }
        (0, _genMapping.maybeAddMapping)(this._map, {
          name: identifierName,
          generated: generated,
          source: (_originalMapping = originalMapping) == null ? void 0 : _originalMapping.source,
          original: originalMapping
        });
      }
    }]);
  }();
  sourceMap["default"] = SourceMap;
  return sourceMap;
}

var printer = {};

var buffer = {};

var hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  Object.defineProperty(buffer, "__esModule", {
    value: true
  });
  buffer["default"] = void 0;
  var Buffer = /*#__PURE__*/function () {
    function Buffer(map, indentChar) {
      _classCallCheck(this, Buffer);
      this._map = null;
      this._buf = "";
      this._str = "";
      this._appendCount = 0;
      this._last = 0;
      this._queue = [];
      this._queueCursor = 0;
      this._canMarkIdName = true;
      this._indentChar = "";
      this._fastIndentations = [];
      this._position = {
        line: 1,
        column: 0
      };
      this._sourcePosition = {
        identifierName: undefined,
        identifierNamePos: undefined,
        line: undefined,
        column: undefined,
        filename: undefined
      };
      this._map = map;
      this._indentChar = indentChar;
      for (var i = 0; i < 64; i++) {
        this._fastIndentations.push(indentChar.repeat(i));
      }
      this._allocQueue();
    }
    return _createClass(Buffer, [{
      key: "_allocQueue",
      value: function _allocQueue() {
        var queue = this._queue;
        for (var i = 0; i < 16; i++) {
          queue.push({
            "char": 0,
            repeat: 1,
            line: undefined,
            column: undefined,
            identifierName: undefined,
            identifierNamePos: undefined,
            filename: ""
          });
        }
      }
    }, {
      key: "_pushQueue",
      value: function _pushQueue(_char, repeat, line, column, filename) {
        var cursor = this._queueCursor;
        if (cursor === this._queue.length) {
          this._allocQueue();
        }
        var item = this._queue[cursor];
        item["char"] = _char;
        item.repeat = repeat;
        item.line = line;
        item.column = column;
        item.filename = filename;
        this._queueCursor++;
      }
    }, {
      key: "_popQueue",
      value: function _popQueue() {
        if (this._queueCursor === 0) {
          throw new Error("Cannot pop from empty queue");
        }
        return this._queue[--this._queueCursor];
      }
    }, {
      key: "get",
      value: function get() {
        this._flush();
        var map = this._map;
        var result = {
          code: (this._buf + this._str).trimRight(),
          decodedMap: map == null ? void 0 : map.getDecoded(),
          get __mergedMap() {
            return this.map;
          },
          get map() {
            var resultMap = map ? map.get() : null;
            result.map = resultMap;
            return resultMap;
          },
          set map(value) {
            Object.defineProperty(result, "map", {
              value: value,
              writable: true
            });
          },
          get rawMappings() {
            var mappings = map == null ? void 0 : map.getRawMappings();
            result.rawMappings = mappings;
            return mappings;
          },
          set rawMappings(value) {
            Object.defineProperty(result, "rawMappings", {
              value: value,
              writable: true
            });
          }
        };
        return result;
      }
    }, {
      key: "append",
      value: function append(str, maybeNewline) {
        this._flush();
        this._append(str, this._sourcePosition, maybeNewline);
      }
    }, {
      key: "appendChar",
      value: function appendChar(_char2) {
        this._flush();
        this._appendChar(_char2, 1, this._sourcePosition);
      }
    }, {
      key: "queue",
      value: function queue(_char3) {
        if (_char3 === 10) {
          while (this._queueCursor !== 0) {
            var _char4 = this._queue[this._queueCursor - 1]["char"];
            if (_char4 !== 32 && _char4 !== 9) {
              break;
            }
            this._queueCursor--;
          }
        }
        var sourcePosition = this._sourcePosition;
        this._pushQueue(_char3, 1, sourcePosition.line, sourcePosition.column, sourcePosition.filename);
      }
    }, {
      key: "queueIndentation",
      value: function queueIndentation(repeat) {
        if (repeat === 0) return;
        this._pushQueue(-1, repeat, undefined, undefined, undefined);
      }
    }, {
      key: "_flush",
      value: function _flush() {
        var queueCursor = this._queueCursor;
        var queue = this._queue;
        for (var i = 0; i < queueCursor; i++) {
          var item = queue[i];
          this._appendChar(item["char"], item.repeat, item);
        }
        this._queueCursor = 0;
      }
    }, {
      key: "_appendChar",
      value: function _appendChar(_char5, repeat, sourcePos) {
        this._last = _char5;
        if (_char5 === -1) {
          var fastIndentation = this._fastIndentations[repeat];
          if (fastIndentation !== undefined) {
            this._str += fastIndentation;
          } else {
            this._str += repeat > 1 ? this._indentChar.repeat(repeat) : this._indentChar;
          }
        } else {
          this._str += repeat > 1 ? String.fromCharCode(_char5).repeat(repeat) : String.fromCharCode(_char5);
        }
        if (_char5 !== 10) {
          this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.identifierNamePos, sourcePos.filename);
          this._position.column += repeat;
        } else {
          this._position.line++;
          this._position.column = 0;
        }
        if (this._canMarkIdName) {
          sourcePos.identifierName = undefined;
          sourcePos.identifierNamePos = undefined;
        }
      }
    }, {
      key: "_append",
      value: function _append(str, sourcePos, maybeNewline) {
        var len = str.length;
        var position = this._position;
        this._last = str.charCodeAt(len - 1);
        if (++this._appendCount > 4096) {
          +this._str;
          this._buf += this._str;
          this._str = str;
          this._appendCount = 0;
        } else {
          this._str += str;
        }
        if (!maybeNewline && !this._map) {
          position.column += len;
          return;
        }
        var column = sourcePos.column,
          identifierName = sourcePos.identifierName,
          identifierNamePos = sourcePos.identifierNamePos,
          filename = sourcePos.filename;
        var line = sourcePos.line;
        if ((identifierName != null || identifierNamePos != null) && this._canMarkIdName) {
          sourcePos.identifierName = undefined;
          sourcePos.identifierNamePos = undefined;
        }
        var i = str.indexOf("\n");
        var last = 0;
        if (i !== 0) {
          this._mark(line, column, identifierName, identifierNamePos, filename);
        }
        while (i !== -1) {
          position.line++;
          position.column = 0;
          last = i + 1;
          if (last < len && line !== undefined) {
            this._mark(++line, 0, null, null, filename);
          }
          i = str.indexOf("\n", last);
        }
        position.column += len - last;
      }
    }, {
      key: "_mark",
      value: function _mark(line, column, identifierName, identifierNamePos, filename) {
        var _this$_map;
        (_this$_map = this._map) == null || _this$_map.mark(this._position, line, column, identifierName, identifierNamePos, filename);
      }
    }, {
      key: "removeTrailingNewline",
      value: function removeTrailingNewline() {
        var queueCursor = this._queueCursor;
        if (queueCursor !== 0 && this._queue[queueCursor - 1]["char"] === 10) {
          this._queueCursor--;
        }
      }
    }, {
      key: "removeLastSemicolon",
      value: function removeLastSemicolon() {
        var queueCursor = this._queueCursor;
        if (queueCursor !== 0 && this._queue[queueCursor - 1]["char"] === 59) {
          this._queueCursor--;
        }
      }
    }, {
      key: "getLastChar",
      value: function getLastChar() {
        var queueCursor = this._queueCursor;
        return queueCursor !== 0 ? this._queue[queueCursor - 1]["char"] : this._last;
      }
    }, {
      key: "getNewlineCount",
      value: function getNewlineCount() {
        var queueCursor = this._queueCursor;
        var count = 0;
        if (queueCursor === 0) return this._last === 10 ? 1 : 0;
        for (var i = queueCursor - 1; i >= 0; i--) {
          if (this._queue[i]["char"] !== 10) {
            break;
          }
          count++;
        }
        return count === queueCursor && this._last === 10 ? count + 1 : count;
      }
    }, {
      key: "endsWithCharAndNewline",
      value: function endsWithCharAndNewline() {
        var queue = this._queue;
        var queueCursor = this._queueCursor;
        if (queueCursor !== 0) {
          var lastCp = queue[queueCursor - 1]["char"];
          if (lastCp !== 10) return;
          if (queueCursor > 1) {
            return queue[queueCursor - 2]["char"];
          } else {
            return this._last;
          }
        }
      }
    }, {
      key: "hasContent",
      value: function hasContent() {
        return this._queueCursor !== 0 || !!this._last;
      }
    }, {
      key: "exactSource",
      value: function exactSource(loc, cb) {
        if (!this._map) {
          cb();
          return;
        }
        this.source("start", loc);
        var identifierName = loc.identifierName;
        var sourcePos = this._sourcePosition;
        if (identifierName) {
          this._canMarkIdName = false;
          sourcePos.identifierName = identifierName;
        }
        cb();
        if (identifierName) {
          this._canMarkIdName = true;
          sourcePos.identifierName = undefined;
          sourcePos.identifierNamePos = undefined;
        }
        this.source("end", loc);
      }
    }, {
      key: "source",
      value: function source(prop, loc) {
        if (!this._map) return;
        this._normalizePosition(prop, loc, 0);
      }
    }, {
      key: "sourceWithOffset",
      value: function sourceWithOffset(prop, loc, columnOffset) {
        if (!this._map) return;
        this._normalizePosition(prop, loc, columnOffset);
      }
    }, {
      key: "_normalizePosition",
      value: function _normalizePosition(prop, loc, columnOffset) {
        var pos = loc[prop];
        var target = this._sourcePosition;
        if (pos) {
          target.line = pos.line;
          target.column = Math.max(pos.column + columnOffset, 0);
          target.filename = loc.filename;
        }
      }
    }, {
      key: "getCurrentColumn",
      value: function getCurrentColumn() {
        var queue = this._queue;
        var queueCursor = this._queueCursor;
        var lastIndex = -1;
        var len = 0;
        for (var i = 0; i < queueCursor; i++) {
          var item = queue[i];
          if (item["char"] === 10) {
            lastIndex = len;
          }
          len += item.repeat;
        }
        return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;
      }
    }, {
      key: "getCurrentLine",
      value: function getCurrentLine() {
        var count = 0;
        var queue = this._queue;
        for (var i = 0; i < this._queueCursor; i++) {
          if (queue[i]["char"] === 10) {
            count++;
          }
        }
        return this._position.line + count;
      }
    }]);
  }();
  buffer["default"] = Buffer;
  return buffer;
}

var node = {};

var whitespace = {};

var hasRequiredWhitespace;
function requireWhitespace() {
  if (hasRequiredWhitespace) return whitespace;
  hasRequiredWhitespace = 1;
  Object.defineProperty(whitespace, "__esModule", {
    value: true
  });
  whitespace.nodes = void 0;
  var _t = requireLib$4();
  var FLIPPED_ALIAS_KEYS = _t.FLIPPED_ALIAS_KEYS,
    isArrayExpression = _t.isArrayExpression,
    isAssignmentExpression = _t.isAssignmentExpression,
    isBinary = _t.isBinary,
    isBlockStatement = _t.isBlockStatement,
    isCallExpression = _t.isCallExpression,
    isFunction = _t.isFunction,
    isIdentifier = _t.isIdentifier,
    isLiteral = _t.isLiteral,
    isMemberExpression = _t.isMemberExpression,
    isObjectExpression = _t.isObjectExpression,
    isOptionalCallExpression = _t.isOptionalCallExpression,
    isOptionalMemberExpression = _t.isOptionalMemberExpression,
    isStringLiteral = _t.isStringLiteral;
  function crawlInternal(node, state) {
    if (!node) return state;
    if (isMemberExpression(node) || isOptionalMemberExpression(node)) {
      crawlInternal(node.object, state);
      if (node.computed) crawlInternal(node.property, state);
    } else if (isBinary(node) || isAssignmentExpression(node)) {
      crawlInternal(node.left, state);
      crawlInternal(node.right, state);
    } else if (isCallExpression(node) || isOptionalCallExpression(node)) {
      state.hasCall = true;
      crawlInternal(node.callee, state);
    } else if (isFunction(node)) {
      state.hasFunction = true;
    } else if (isIdentifier(node)) {
      state.hasHelper = state.hasHelper || node.callee && isHelper(node.callee);
    }
    return state;
  }
  function crawl(node) {
    return crawlInternal(node, {
      hasCall: false,
      hasFunction: false,
      hasHelper: false
    });
  }
  function isHelper(node) {
    if (!node) return false;
    if (isMemberExpression(node)) {
      return isHelper(node.object) || isHelper(node.property);
    } else if (isIdentifier(node)) {
      return node.name === "require" || node.name.charCodeAt(0) === 95;
    } else if (isCallExpression(node)) {
      return isHelper(node.callee);
    } else if (isBinary(node) || isAssignmentExpression(node)) {
      return isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);
    } else {
      return false;
    }
  }
  function isType(node) {
    return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier(node) || isMemberExpression(node);
  }
  var nodes = whitespace.nodes = {
    AssignmentExpression: function AssignmentExpression(node) {
      var state = crawl(node.right);
      if (state.hasCall && state.hasHelper || state.hasFunction) {
        return state.hasFunction ? 1 | 2 : 2;
      }
    },
    SwitchCase: function SwitchCase(node, parent) {
      return (!!node.consequent.length || parent.cases[0] === node ? 1 : 0) | (!node.consequent.length && parent.cases[parent.cases.length - 1] === node ? 2 : 0);
    },
    LogicalExpression: function LogicalExpression(node) {
      if (isFunction(node.left) || isFunction(node.right)) {
        return 2;
      }
    },
    Literal: function Literal(node) {
      if (isStringLiteral(node) && node.value === "use strict") {
        return 2;
      }
    },
    CallExpression: function CallExpression(node) {
      if (isFunction(node.callee) || isHelper(node)) {
        return 1 | 2;
      }
    },
    OptionalCallExpression: function OptionalCallExpression(node) {
      if (isFunction(node.callee)) {
        return 1 | 2;
      }
    },
    VariableDeclaration: function VariableDeclaration(node) {
      for (var i = 0; i < node.declarations.length; i++) {
        var declar = node.declarations[i];
        var enabled = isHelper(declar.id) && !isType(declar.init);
        if (!enabled && declar.init) {
          var state = crawl(declar.init);
          enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
        }
        if (enabled) {
          return 1 | 2;
        }
      }
    },
    IfStatement: function IfStatement(node) {
      if (isBlockStatement(node.consequent)) {
        return 1 | 2;
      }
    }
  };
  nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (node, parent) {
    if (parent.properties[0] === node) {
      return 1;
    }
  };
  nodes.ObjectTypeCallProperty = function (node, parent) {
    var _parent$properties;
    if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {
      return 1;
    }
  };
  nodes.ObjectTypeIndexer = function (node, parent) {
    var _parent$properties2, _parent$callPropertie;
    if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {
      return 1;
    }
  };
  nodes.ObjectTypeInternalSlot = function (node, parent) {
    var _parent$properties3, _parent$callPropertie2, _parent$indexers;
    if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {
      return 1;
    }
  };
  [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
      type = _ref2[0],
      amounts = _ref2[1];
    [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {
      var ret = amounts ? 1 | 2 : 0;
      nodes[type] = function () {
        return ret;
      };
    });
  });
  return whitespace;
}

var parentheses = {};

var hasRequiredParentheses;
function requireParentheses() {
  if (hasRequiredParentheses) return parentheses;
  hasRequiredParentheses = 1;
  Object.defineProperty(parentheses, "__esModule", {
    value: true
  });
  parentheses.AssignmentExpression = AssignmentExpression;
  parentheses.Binary = Binary;
  parentheses.BinaryExpression = BinaryExpression;
  parentheses.ClassExpression = ClassExpression;
  parentheses.ArrowFunctionExpression = parentheses.ConditionalExpression = ConditionalExpression;
  parentheses.DoExpression = DoExpression;
  parentheses.FunctionExpression = FunctionExpression;
  parentheses.FunctionTypeAnnotation = FunctionTypeAnnotation;
  parentheses.Identifier = Identifier;
  parentheses.LogicalExpression = LogicalExpression;
  parentheses.NullableTypeAnnotation = NullableTypeAnnotation;
  parentheses.ObjectExpression = ObjectExpression;
  parentheses.OptionalIndexedAccessType = OptionalIndexedAccessType;
  parentheses.OptionalCallExpression = parentheses.OptionalMemberExpression = OptionalMemberExpression;
  parentheses.SequenceExpression = SequenceExpression;
  parentheses.TSSatisfiesExpression = parentheses.TSAsExpression = TSAsExpression;
  parentheses.TSConditionalType = TSConditionalType;
  parentheses.TSConstructorType = parentheses.TSFunctionType = TSFunctionType;
  parentheses.TSInferType = TSInferType;
  parentheses.TSInstantiationExpression = TSInstantiationExpression;
  parentheses.TSIntersectionType = TSIntersectionType;
  parentheses.UnaryLike = parentheses.TSTypeAssertion = UnaryLike;
  parentheses.TSTypeOperator = TSTypeOperator;
  parentheses.TSUnionType = TSUnionType;
  parentheses.IntersectionTypeAnnotation = parentheses.UnionTypeAnnotation = UnionTypeAnnotation;
  parentheses.UpdateExpression = UpdateExpression;
  parentheses.AwaitExpression = parentheses.YieldExpression = YieldExpression;
  var _t = requireLib$4();
  var _index = requireNode();
  var isArrayTypeAnnotation = _t.isArrayTypeAnnotation,
    isBinaryExpression = _t.isBinaryExpression,
    isCallExpression = _t.isCallExpression,
    isForOfStatement = _t.isForOfStatement,
    isIndexedAccessType = _t.isIndexedAccessType,
    isMemberExpression = _t.isMemberExpression,
    isObjectPattern = _t.isObjectPattern,
    isOptionalMemberExpression = _t.isOptionalMemberExpression,
    isYieldExpression = _t.isYieldExpression,
    isStatement = _t.isStatement;
  var PRECEDENCE = new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-", 8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
  function getBinaryPrecedence(node, nodeType) {
    if (nodeType === "BinaryExpression" || nodeType === "LogicalExpression") {
      return PRECEDENCE.get(node.operator);
    }
    if (nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression") {
      return PRECEDENCE.get("in");
    }
  }
  function isTSTypeExpression(nodeType) {
    return nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression" || nodeType === "TSTypeAssertion";
  }
  var isClassExtendsClause = function isClassExtendsClause(node, parent) {
    var parentType = parent.type;
    return (parentType === "ClassDeclaration" || parentType === "ClassExpression") && parent.superClass === node;
  };
  var hasPostfixPart = function hasPostfixPart(node, parent) {
    var parentType = parent.type;
    return (parentType === "MemberExpression" || parentType === "OptionalMemberExpression") && parent.object === node || (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression") && parent.callee === node || parentType === "TaggedTemplateExpression" && parent.tag === node || parentType === "TSNonNullExpression";
  };
  function NullableTypeAnnotation(node, parent) {
    return isArrayTypeAnnotation(parent);
  }
  function FunctionTypeAnnotation(node, parent, tokenContext) {
    var parentType = parent.type;
    return parentType === "UnionTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "ArrayTypeAnnotation" || Boolean(tokenContext & _index.TokenContext.arrowFlowReturnType);
  }
  function UpdateExpression(node, parent) {
    return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);
  }
  function needsParenBeforeExpressionBrace(tokenContext) {
    return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.arrowBody));
  }
  function ObjectExpression(node, parent, tokenContext) {
    return needsParenBeforeExpressionBrace(tokenContext);
  }
  function DoExpression(node, parent, tokenContext) {
    return !node.async && Boolean(tokenContext & _index.TokenContext.expressionStatement);
  }
  function Binary(node, parent) {
    var parentType = parent.type;
    if (node.type === "BinaryExpression" && node.operator === "**" && parentType === "BinaryExpression" && parent.operator === "**") {
      return parent.left === node;
    }
    if (isClassExtendsClause(node, parent)) {
      return true;
    }
    if (hasPostfixPart(node, parent) || parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "AwaitExpression") {
      return true;
    }
    var parentPos = getBinaryPrecedence(parent, parentType);
    if (parentPos != null) {
      var nodePos = getBinaryPrecedence(node, node.type);
      if (parentPos === nodePos && parentType === "BinaryExpression" && parent.right === node || parentPos > nodePos) {
        return true;
      }
    }
    return undefined;
  }
  function UnionTypeAnnotation(node, parent) {
    var parentType = parent.type;
    return parentType === "ArrayTypeAnnotation" || parentType === "NullableTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "UnionTypeAnnotation";
  }
  function OptionalIndexedAccessType(node, parent) {
    return isIndexedAccessType(parent) && parent.objectType === node;
  }
  function TSAsExpression(node, parent) {
    if ((parent.type === "AssignmentExpression" || parent.type === "AssignmentPattern") && parent.left === node) {
      return true;
    }
    if (parent.type === "BinaryExpression" && (parent.operator === "|" || parent.operator === "&") && node === parent.left) {
      return true;
    }
    return Binary(node, parent);
  }
  function TSConditionalType(node, parent) {
    var parentType = parent.type;
    if (parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType" || parentType === "TSTypeOperator" || parentType === "TSTypeParameter") {
      return true;
    }
    if ((parentType === "TSIntersectionType" || parentType === "TSUnionType") && parent.types[0] === node) {
      return true;
    }
    if (parentType === "TSConditionalType" && (parent.checkType === node || parent.extendsType === node)) {
      return true;
    }
    return false;
  }
  function TSUnionType(node, parent) {
    var parentType = parent.type;
    return parentType === "TSIntersectionType" || parentType === "TSTypeOperator" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType";
  }
  function TSIntersectionType(node, parent) {
    var parentType = parent.type;
    return parentType === "TSTypeOperator" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType";
  }
  function TSInferType(node, parent) {
    var parentType = parent.type;
    if (parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType") {
      return true;
    }
    if (node.typeParameter.constraint) {
      if ((parentType === "TSIntersectionType" || parentType === "TSUnionType") && parent.types[0] === node) {
        return true;
      }
    }
    return false;
  }
  function TSTypeOperator(node, parent) {
    var parentType = parent.type;
    return parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSOptionalType";
  }
  function TSInstantiationExpression(node, parent) {
    var parentType = parent.type;
    return (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression" || parentType === "TSInstantiationExpression") && !!parent.typeParameters;
  }
  function TSFunctionType(node, parent) {
    var parentType = parent.type;
    return parentType === "TSIntersectionType" || parentType === "TSUnionType" || parentType === "TSTypeOperator" || parentType === "TSOptionalType" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node || parentType === "TSConditionalType" && (parent.checkType === node || parent.extendsType === node);
  }
  function BinaryExpression(node, parent, tokenContext, inForStatementInit) {
    return node.operator === "in" && inForStatementInit;
  }
  function SequenceExpression(node, parent) {
    var parentType = parent.type;
    if (parentType === "SequenceExpression" || parentType === "ParenthesizedExpression" || parentType === "MemberExpression" && parent.property === node || parentType === "OptionalMemberExpression" && parent.property === node || parentType === "TemplateLiteral") {
      return false;
    }
    if (parentType === "ClassDeclaration") {
      return true;
    }
    if (parentType === "ForOfStatement") {
      return parent.right === node;
    }
    if (parentType === "ExportDefaultDeclaration") {
      return true;
    }
    return !isStatement(parent);
  }
  function YieldExpression(node, parent) {
    var parentType = parent.type;
    return parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "UnaryExpression" || parentType === "SpreadElement" || hasPostfixPart(node, parent) || parentType === "AwaitExpression" && isYieldExpression(node) || parentType === "ConditionalExpression" && node === parent.test || isClassExtendsClause(node, parent) || isTSTypeExpression(parentType);
  }
  function ClassExpression(node, parent, tokenContext) {
    return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));
  }
  function UnaryLike(node, parent) {
    return hasPostfixPart(node, parent) || isBinaryExpression(parent) && parent.operator === "**" && parent.left === node || isClassExtendsClause(node, parent);
  }
  function FunctionExpression(node, parent, tokenContext) {
    return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));
  }
  function ConditionalExpression(node, parent) {
    var parentType = parent.type;
    if (parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "ConditionalExpression" && parent.test === node || parentType === "AwaitExpression" || isTSTypeExpression(parentType)) {
      return true;
    }
    return UnaryLike(node, parent);
  }
  function OptionalMemberExpression(node, parent) {
    return isCallExpression(parent) && parent.callee === node || isMemberExpression(parent) && parent.object === node;
  }
  function AssignmentExpression(node, parent, tokenContext) {
    if (needsParenBeforeExpressionBrace(tokenContext) && isObjectPattern(node.left)) {
      return true;
    } else {
      return ConditionalExpression(node, parent);
    }
  }
  function LogicalExpression(node, parent) {
    var parentType = parent.type;
    if (isTSTypeExpression(parentType)) return true;
    if (parentType !== "LogicalExpression") return false;
    switch (node.operator) {
      case "||":
        return parent.operator === "??" || parent.operator === "&&";
      case "&&":
        return parent.operator === "??";
      case "??":
        return parent.operator !== "??";
    }
  }
  function Identifier(node, parent, tokenContext, _inForInit, getRawIdentifier) {
    var _node$extra;
    var parentType = parent.type;
    if ((_node$extra = node.extra) != null && _node$extra.parenthesized && parentType === "AssignmentExpression" && parent.left === node) {
      var rightType = parent.right.type;
      if ((rightType === "FunctionExpression" || rightType === "ClassExpression") && parent.right.id == null) {
        return true;
      }
    }
    if (getRawIdentifier && getRawIdentifier(node) !== node.name) {
      return false;
    }
    if (node.name === "let") {
      var isFollowedByBracket = isMemberExpression(parent, {
        object: node,
        computed: true
      }) || isOptionalMemberExpression(parent, {
        object: node,
        computed: true,
        optional: false
      });
      if (isFollowedByBracket && tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.forHead | _index.TokenContext.forInHead)) {
        return true;
      }
      return Boolean(tokenContext & _index.TokenContext.forOfHead);
    }
    return node.name === "async" && isForOfStatement(parent, {
      left: node,
      "await": false
    });
  }
  return parentheses;
}

var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  Object.defineProperty(node, "__esModule", {
    value: true
  });
  node.TokenContext = void 0;
  node.isLastChild = isLastChild;
  node.needsParens = needsParens;
  node.needsWhitespace = needsWhitespace;
  node.needsWhitespaceAfter = needsWhitespaceAfter;
  node.needsWhitespaceBefore = needsWhitespaceBefore;
  var whitespace = requireWhitespace();
  var parens = requireParentheses();
  var _t = requireLib$4();
  var FLIPPED_ALIAS_KEYS = _t.FLIPPED_ALIAS_KEYS,
    VISITOR_KEYS = _t.VISITOR_KEYS,
    isCallExpression = _t.isCallExpression,
    isDecorator = _t.isDecorator,
    isExpressionStatement = _t.isExpressionStatement,
    isMemberExpression = _t.isMemberExpression,
    isNewExpression = _t.isNewExpression,
    isParenthesizedExpression = _t.isParenthesizedExpression;
  node.TokenContext = {
    expressionStatement: 1,
    arrowBody: 2,
    exportDefault: 4,
    forHead: 8,
    forInHead: 16,
    forOfHead: 32,
    arrowFlowReturnType: 64
  };
  function expandAliases(obj) {
    var map = new Map();
    function add(type, func) {
      var fn = map.get(type);
      map.set(type, fn ? function (node, parent, stack, inForInit, getRawIdentifier) {
        var _fn;
        return (_fn = fn(node, parent, stack, inForInit, getRawIdentifier)) != null ? _fn : func(node, parent, stack, inForInit, getRawIdentifier);
      } : func);
    }
    for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
      var type = _Object$keys[_i];
      var aliases = FLIPPED_ALIAS_KEYS[type];
      if (aliases) {
        var _iterator = _createForOfIteratorHelper(aliases),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var alias = _step.value;
            add(alias, obj[type]);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      } else {
        add(type, obj[type]);
      }
    }
    return map;
  }
  var expandedParens = expandAliases(parens);
  var expandedWhitespaceNodes = expandAliases(whitespace.nodes);
  function isOrHasCallExpression(node) {
    if (isCallExpression(node)) {
      return true;
    }
    return isMemberExpression(node) && isOrHasCallExpression(node.object);
  }
  function needsWhitespace(node, parent, type) {
    var _expandedWhitespaceNo;
    if (!node) return false;
    if (isExpressionStatement(node)) {
      node = node.expression;
    }
    var flag = (_expandedWhitespaceNo = expandedWhitespaceNodes.get(node.type)) == null ? void 0 : _expandedWhitespaceNo(node, parent);
    if (typeof flag === "number") {
      return (flag & type) !== 0;
    }
    return false;
  }
  function needsWhitespaceBefore(node, parent) {
    return needsWhitespace(node, parent, 1);
  }
  function needsWhitespaceAfter(node, parent) {
    return needsWhitespace(node, parent, 2);
  }
  function needsParens(node, parent, tokenContext, inForInit, getRawIdentifier) {
    var _expandedParens$get;
    if (!parent) return false;
    if (isNewExpression(parent) && parent.callee === node) {
      if (isOrHasCallExpression(node)) return true;
    }
    if (isDecorator(parent)) {
      return !isDecoratorMemberExpression(node) && !(isCallExpression(node) && isDecoratorMemberExpression(node.callee)) && !isParenthesizedExpression(node);
    }
    return (_expandedParens$get = expandedParens.get(node.type)) == null ? void 0 : _expandedParens$get(node, parent, tokenContext, inForInit, getRawIdentifier);
  }
  function isDecoratorMemberExpression(node) {
    switch (node.type) {
      case "Identifier":
        return true;
      case "MemberExpression":
        return !node.computed && node.property.type === "Identifier" && isDecoratorMemberExpression(node.object);
      default:
        return false;
    }
  }
  function isLastChild(parent, child) {
    var visitorKeys = VISITOR_KEYS[parent.type];
    for (var i = visitorKeys.length - 1; i >= 0; i--) {
      var val = parent[visitorKeys[i]];
      if (val === child) {
        return true;
      } else if (Array.isArray(val)) {
        var j = val.length - 1;
        while (j >= 0 && val[j] === null) j--;
        return j >= 0 && val[j] === child;
      } else if (val) {
        return false;
      }
    }
    return false;
  }
  return node;
}

var tokenMap = {};

var hasRequiredTokenMap;
function requireTokenMap() {
  var _marked = /*#__PURE__*/_regeneratorRuntime().mark(childrenIterator);
  if (hasRequiredTokenMap) return tokenMap;
  hasRequiredTokenMap = 1;
  Object.defineProperty(tokenMap, "__esModule", {
    value: true
  });
  tokenMap.TokenMap = void 0;
  var _t = requireLib$4();
  var traverseFast = _t.traverseFast,
    VISITOR_KEYS = _t.VISITOR_KEYS;
  var TokenMap = /*#__PURE__*/function () {
    function TokenMap(ast, tokens, source) {
      var _this = this;
      _classCallCheck(this, TokenMap);
      this._tokens = void 0;
      this._source = void 0;
      this._nodesToTokenIndexes = new Map();
      this._nodesOccurrencesCountCache = new Map();
      this._tokensCache = new Map();
      this._tokens = tokens;
      this._source = source;
      traverseFast(ast, function (node) {
        var indexes = _this._getTokensIndexesOfNode(node);
        if (indexes.length > 0) _this._nodesToTokenIndexes.set(node, indexes);
      });
      this._tokensCache = null;
    }
    return _createClass(TokenMap, [{
      key: "has",
      value: function has(node) {
        return this._nodesToTokenIndexes.has(node);
      }
    }, {
      key: "getIndexes",
      value: function getIndexes(node) {
        return this._nodesToTokenIndexes.get(node);
      }
    }, {
      key: "find",
      value: function find(node, condition) {
        var indexes = this._nodesToTokenIndexes.get(node);
        if (indexes) {
          for (var k = 0; k < indexes.length; k++) {
            var index = indexes[k];
            var tok = this._tokens[index];
            if (condition(tok, index)) return tok;
          }
        }
        return null;
      }
    }, {
      key: "findLastIndex",
      value: function findLastIndex(node, condition) {
        var indexes = this._nodesToTokenIndexes.get(node);
        if (indexes) {
          for (var k = indexes.length - 1; k >= 0; k--) {
            var index = indexes[k];
            var tok = this._tokens[index];
            if (condition(tok, index)) return index;
          }
        }
        return -1;
      }
    }, {
      key: "findMatching",
      value: function findMatching(node, test) {
        var occurrenceCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var indexes = this._nodesToTokenIndexes.get(node);
        if (indexes) {
          var i = 0;
          var count = occurrenceCount;
          if (count > 1) {
            var cache = this._nodesOccurrencesCountCache.get(node);
            if (cache && cache.test === test && cache.count < count) {
              i = cache.i + 1;
              occurrenceCount -= cache.count + 1;
            }
          }
          for (; i < indexes.length; i++) {
            var tok = this._tokens[indexes[i]];
            if (this.matchesOriginal(tok, test)) {
              if (occurrenceCount === 0) {
                if (count > 0) {
                  this._nodesOccurrencesCountCache.set(node, {
                    test: test,
                    count: count,
                    i: i
                  });
                }
                return tok;
              }
              occurrenceCount--;
            }
          }
        }
        return null;
      }
    }, {
      key: "matchesOriginal",
      value: function matchesOriginal(token, test) {
        if (token.end - token.start !== test.length) return false;
        if (token.value != null) return token.value === test;
        return this._source.startsWith(test, token.start);
      }
    }, {
      key: "startMatches",
      value: function startMatches(node, test) {
        var indexes = this._nodesToTokenIndexes.get(node);
        if (!indexes) return false;
        var tok = this._tokens[indexes[0]];
        if (tok.start !== node.start) return false;
        return this.matchesOriginal(tok, test);
      }
    }, {
      key: "endMatches",
      value: function endMatches(node, test) {
        var indexes = this._nodesToTokenIndexes.get(node);
        if (!indexes) return false;
        var tok = this._tokens[indexes[indexes.length - 1]];
        if (tok.end !== node.end) return false;
        return this.matchesOriginal(tok, test);
      }
    }, {
      key: "_getTokensIndexesOfNode",
      value: function _getTokensIndexesOfNode(node) {
        if (node.start == null || node.end == null) return [];
        var _this$_findTokensOfNo = this._findTokensOfNode(node, 0, this._tokens.length - 1),
          first = _this$_findTokensOfNo.first,
          last = _this$_findTokensOfNo.last;
        var low = first;
        var children = childrenIterator(node);
        if ((node.type === "ExportNamedDeclaration" || node.type === "ExportDefaultDeclaration") && node.declaration && node.declaration.type === "ClassDeclaration") {
          children.next();
        }
        var indexes = [];
        var _iterator = _createForOfIteratorHelper(children),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var child = _step.value;
            if (child == null) continue;
            if (child.start == null || child.end == null) continue;
            var childTok = this._findTokensOfNode(child, low, last);
            var high = childTok.first;
            for (var _k = low; _k < high; _k++) indexes.push(_k);
            low = childTok.last + 1;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        for (var k = low; k <= last; k++) indexes.push(k);
        return indexes;
      }
    }, {
      key: "_findTokensOfNode",
      value: function _findTokensOfNode(node, low, high) {
        var cached = this._tokensCache.get(node);
        if (cached) return cached;
        var first = this._findFirstTokenOfNode(node.start, low, high);
        var last = this._findLastTokenOfNode(node.end, first, high);
        this._tokensCache.set(node, {
          first: first,
          last: last
        });
        return {
          first: first,
          last: last
        };
      }
    }, {
      key: "_findFirstTokenOfNode",
      value: function _findFirstTokenOfNode(start, low, high) {
        while (low <= high) {
          var mid = high + low >> 1;
          if (start < this._tokens[mid].start) {
            high = mid - 1;
          } else if (start > this._tokens[mid].start) {
            low = mid + 1;
          } else {
            return mid;
          }
        }
        return low;
      }
    }, {
      key: "_findLastTokenOfNode",
      value: function _findLastTokenOfNode(end, low, high) {
        while (low <= high) {
          var mid = high + low >> 1;
          if (end < this._tokens[mid].end) {
            high = mid - 1;
          } else if (end > this._tokens[mid].end) {
            low = mid + 1;
          } else {
            return mid;
          }
        }
        return high;
      }
    }]);
  }();
  tokenMap.TokenMap = TokenMap;
  function childrenIterator(node) {
    var i, keys, _iterator2, _step2, key, child;
    return _regeneratorRuntime().wrap(function childrenIterator$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (!(node.type === "TemplateLiteral")) {
            _context.next = 13;
            break;
          }
          _context.next = 3;
          return node.quasis[0];
        case 3:
          i = 1;
        case 4:
          if (!(i < node.quasis.length)) {
            _context.next = 12;
            break;
          }
          _context.next = 7;
          return node.expressions[i - 1];
        case 7:
          _context.next = 9;
          return node.quasis[i];
        case 9:
          i++;
          _context.next = 4;
          break;
        case 12:
          return _context.abrupt("return");
        case 13:
          keys = VISITOR_KEYS[node.type];
          _iterator2 = _createForOfIteratorHelper(keys);
          _context.prev = 15;
          _iterator2.s();
        case 17:
          if ((_step2 = _iterator2.n()).done) {
            _context.next = 30;
            break;
          }
          key = _step2.value;
          child = node[key];
          if (child) {
            _context.next = 22;
            break;
          }
          return _context.abrupt("continue", 28);
        case 22:
          if (!Array.isArray(child)) {
            _context.next = 26;
            break;
          }
          return _context.delegateYield(child, "t0", 24);
        case 24:
          _context.next = 28;
          break;
        case 26:
          _context.next = 28;
          return child;
        case 28:
          _context.next = 17;
          break;
        case 30:
          _context.next = 35;
          break;
        case 32:
          _context.prev = 32;
          _context.t1 = _context["catch"](15);
          _iterator2.e(_context.t1);
        case 35:
          _context.prev = 35;
          _iterator2.f();
          return _context.finish(35);
        case 38:
        case "end":
          return _context.stop();
      }
    }, _marked, null, [[15, 32, 35, 38]]);
  }
  return tokenMap;
}

var generators = {};

var templateLiterals = {};

var hasRequiredTemplateLiterals;
function requireTemplateLiterals() {
  if (hasRequiredTemplateLiterals) return templateLiterals;
  hasRequiredTemplateLiterals = 1;
  Object.defineProperty(templateLiterals, "__esModule", {
    value: true
  });
  templateLiterals.TaggedTemplateExpression = TaggedTemplateExpression;
  templateLiterals.TemplateElement = TemplateElement;
  templateLiterals.TemplateLiteral = TemplateLiteral;
  templateLiterals._printTemplate = _printTemplate;
  function TaggedTemplateExpression(node) {
    this.print(node.tag);
    {
      this.print(node.typeParameters);
    }
    this.print(node.quasi);
  }
  function TemplateElement() {
    throw new Error("TemplateElement printing is handled in TemplateLiteral");
  }
  function _printTemplate(node, substitutions) {
    var quasis = node.quasis;
    var partRaw = "`";
    for (var i = 0; i < quasis.length - 1; i++) {
      partRaw += quasis[i].value.raw;
      this.token(partRaw + "${", true);
      this.print(substitutions[i]);
      partRaw = "}";
      if (this.tokenMap) {
        var token = this.tokenMap.findMatching(node, "}", i);
        if (token) this._catchUpTo(token.loc.start);
      }
    }
    partRaw += quasis[quasis.length - 1].value.raw;
    this.token(partRaw + "`", true);
  }
  function TemplateLiteral(node) {
    this._printTemplate(node, node.expressions);
  }
  return templateLiterals;
}

var expressions = {};

var hasRequiredExpressions;
function requireExpressions() {
  if (hasRequiredExpressions) return expressions;
  hasRequiredExpressions = 1;
  Object.defineProperty(expressions, "__esModule", {
    value: true
  });
  expressions.LogicalExpression = expressions.BinaryExpression = expressions.AssignmentExpression = AssignmentExpression;
  expressions.AssignmentPattern = AssignmentPattern;
  expressions.AwaitExpression = AwaitExpression;
  expressions.BindExpression = BindExpression;
  expressions.CallExpression = CallExpression;
  expressions.ConditionalExpression = ConditionalExpression;
  expressions.Decorator = Decorator;
  expressions.DoExpression = DoExpression;
  expressions.EmptyStatement = EmptyStatement;
  expressions.ExpressionStatement = ExpressionStatement;
  expressions.Import = Import;
  expressions.MemberExpression = MemberExpression;
  expressions.MetaProperty = MetaProperty;
  expressions.ModuleExpression = ModuleExpression;
  expressions.NewExpression = NewExpression;
  expressions.OptionalCallExpression = OptionalCallExpression;
  expressions.OptionalMemberExpression = OptionalMemberExpression;
  expressions.ParenthesizedExpression = ParenthesizedExpression;
  expressions.PrivateName = PrivateName;
  expressions.SequenceExpression = SequenceExpression;
  expressions.Super = Super;
  expressions.ThisExpression = ThisExpression;
  expressions.UnaryExpression = UnaryExpression;
  expressions.UpdateExpression = UpdateExpression;
  expressions.V8IntrinsicIdentifier = V8IntrinsicIdentifier;
  expressions.YieldExpression = YieldExpression;
  expressions._shouldPrintDecoratorsBeforeExport = _shouldPrintDecoratorsBeforeExport;
  var _t = requireLib$4();
  var _index = requireNode();
  var isCallExpression = _t.isCallExpression,
    isLiteral = _t.isLiteral,
    isMemberExpression = _t.isMemberExpression,
    isNewExpression = _t.isNewExpression,
    isPattern = _t.isPattern;
  function UnaryExpression(node) {
    var operator = node.operator;
    if (operator === "void" || operator === "delete" || operator === "typeof" || operator === "throw") {
      this.word(operator);
      this.space();
    } else {
      this.token(operator);
    }
    this.print(node.argument);
  }
  function DoExpression(node) {
    if (node.async) {
      this.word("async", true);
      this.space();
    }
    this.word("do");
    this.space();
    this.print(node.body);
  }
  function ParenthesizedExpression(node) {
    this.tokenChar(40);
    var exit = this.enterDelimited();
    this.print(node.expression);
    exit();
    this.rightParens(node);
  }
  function UpdateExpression(node) {
    if (node.prefix) {
      this.token(node.operator);
      this.print(node.argument);
    } else {
      this.print(node.argument, true);
      this.token(node.operator);
    }
  }
  function ConditionalExpression(node) {
    this.print(node.test);
    this.space();
    this.tokenChar(63);
    this.space();
    this.print(node.consequent);
    this.space();
    this.tokenChar(58);
    this.space();
    this.print(node.alternate);
  }
  function NewExpression(node, parent) {
    this.word("new");
    this.space();
    this.print(node.callee);
    if (this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression(parent, {
      callee: node
    }) && !isMemberExpression(parent) && !isNewExpression(parent)) {
      return;
    }
    this.print(node.typeArguments);
    {
      this.print(node.typeParameters);
    }
    if (node.optional) {
      this.token("?.");
    }
    if (node.arguments.length === 0 && this.tokenMap && !this.tokenMap.endMatches(node, ")")) {
      return;
    }
    this.tokenChar(40);
    var exit = this.enterDelimited();
    this.printList(node.arguments, this.shouldPrintTrailingComma(")"));
    exit();
    this.rightParens(node);
  }
  function SequenceExpression(node) {
    this.printList(node.expressions);
  }
  function ThisExpression() {
    this.word("this");
  }
  function Super() {
    this.word("super");
  }
  function _shouldPrintDecoratorsBeforeExport(node) {
    if (typeof this.format.decoratorsBeforeExport === "boolean") {
      return this.format.decoratorsBeforeExport;
    }
    return typeof node.start === "number" && node.start === node.declaration.start;
  }
  function Decorator(node) {
    this.tokenChar(64);
    this.print(node.expression);
    this.newline();
  }
  function OptionalMemberExpression(node) {
    var computed = node.computed;
    var optional = node.optional,
      property = node.property;
    this.print(node.object);
    if (!computed && isMemberExpression(property)) {
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    }
    if (isLiteral(property) && typeof property.value === "number") {
      computed = true;
    }
    if (optional) {
      this.token("?.");
    }
    if (computed) {
      this.tokenChar(91);
      this.print(property);
      this.tokenChar(93);
    } else {
      if (!optional) {
        this.tokenChar(46);
      }
      this.print(property);
    }
  }
  function OptionalCallExpression(node) {
    this.print(node.callee);
    {
      this.print(node.typeParameters);
    }
    if (node.optional) {
      this.token("?.");
    }
    this.print(node.typeArguments);
    this.tokenChar(40);
    var exit = this.enterDelimited();
    this.printList(node.arguments);
    exit();
    this.rightParens(node);
  }
  function CallExpression(node) {
    this.print(node.callee);
    this.print(node.typeArguments);
    {
      this.print(node.typeParameters);
    }
    this.tokenChar(40);
    var exit = this.enterDelimited();
    this.printList(node.arguments, this.shouldPrintTrailingComma(")"));
    exit();
    this.rightParens(node);
  }
  function Import() {
    this.word("import");
  }
  function AwaitExpression(node) {
    this.word("await");
    if (node.argument) {
      this.space();
      this.printTerminatorless(node.argument);
    }
  }
  function YieldExpression(node) {
    this.word("yield", true);
    if (node.delegate) {
      this.tokenChar(42);
      if (node.argument) {
        this.space();
        this.print(node.argument);
      }
    } else {
      if (node.argument) {
        this.space();
        this.printTerminatorless(node.argument);
      }
    }
  }
  function EmptyStatement() {
    this.semicolon(true);
  }
  function ExpressionStatement(node) {
    this.tokenContext |= _index.TokenContext.expressionStatement;
    this.print(node.expression);
    this.semicolon();
  }
  function AssignmentPattern(node) {
    this.print(node.left);
    if (node.left.type === "Identifier" || isPattern(node.left)) {
      if (node.left.optional) this.tokenChar(63);
      this.print(node.left.typeAnnotation);
    }
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node.right);
  }
  function AssignmentExpression(node) {
    this.print(node.left);
    this.space();
    if (node.operator === "in" || node.operator === "instanceof") {
      this.word(node.operator);
    } else {
      this.token(node.operator);
      this._endsWithDiv = node.operator === "/";
    }
    this.space();
    this.print(node.right);
  }
  function BindExpression(node) {
    this.print(node.object);
    this.token("::");
    this.print(node.callee);
  }
  function MemberExpression(node) {
    this.print(node.object);
    if (!node.computed && isMemberExpression(node.property)) {
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    }
    var computed = node.computed;
    if (isLiteral(node.property) && typeof node.property.value === "number") {
      computed = true;
    }
    if (computed) {
      var exit = this.enterDelimited();
      this.tokenChar(91);
      this.print(node.property);
      this.tokenChar(93);
      exit();
    } else {
      this.tokenChar(46);
      this.print(node.property);
    }
  }
  function MetaProperty(node) {
    this.print(node.meta);
    this.tokenChar(46);
    this.print(node.property);
  }
  function PrivateName(node) {
    this.tokenChar(35);
    this.print(node.id);
  }
  function V8IntrinsicIdentifier(node) {
    this.tokenChar(37);
    this.word(node.name);
  }
  function ModuleExpression(node) {
    this.word("module", true);
    this.space();
    this.tokenChar(123);
    this.indent();
    var body = node.body;
    if (body.body.length || body.directives.length) {
      this.newline();
    }
    this.print(body);
    this.dedent();
    this.rightBrace(node);
  }
  return expressions;
}

var statements = {};

var hasRequiredStatements;
function requireStatements() {
  if (hasRequiredStatements) return statements;
  hasRequiredStatements = 1;
  Object.defineProperty(statements, "__esModule", {
    value: true
  });
  statements.BreakStatement = BreakStatement;
  statements.CatchClause = CatchClause;
  statements.ContinueStatement = ContinueStatement;
  statements.DebuggerStatement = DebuggerStatement;
  statements.DoWhileStatement = DoWhileStatement;
  statements.ForOfStatement = statements.ForInStatement = void 0;
  statements.ForStatement = ForStatement;
  statements.IfStatement = IfStatement;
  statements.LabeledStatement = LabeledStatement;
  statements.ReturnStatement = ReturnStatement;
  statements.SwitchCase = SwitchCase;
  statements.SwitchStatement = SwitchStatement;
  statements.ThrowStatement = ThrowStatement;
  statements.TryStatement = TryStatement;
  statements.VariableDeclaration = VariableDeclaration;
  statements.VariableDeclarator = VariableDeclarator;
  statements.WhileStatement = WhileStatement;
  statements.WithStatement = WithStatement;
  var _t = requireLib$4();
  var _index = requireNode();
  var isFor = _t.isFor,
    isForStatement = _t.isForStatement,
    isIfStatement = _t.isIfStatement,
    isStatement = _t.isStatement;
  function WithStatement(node) {
    this.word("with");
    this.space();
    this.tokenChar(40);
    this.print(node.object);
    this.tokenChar(41);
    this.printBlock(node);
  }
  function IfStatement(node) {
    this.word("if");
    this.space();
    this.tokenChar(40);
    this.print(node.test);
    this.tokenChar(41);
    this.space();
    var needsBlock = node.alternate && isIfStatement(getLastStatement(node.consequent));
    if (needsBlock) {
      this.tokenChar(123);
      this.newline();
      this.indent();
    }
    this.printAndIndentOnComments(node.consequent);
    if (needsBlock) {
      this.dedent();
      this.newline();
      this.tokenChar(125);
    }
    if (node.alternate) {
      if (this.endsWith(125)) this.space();
      this.word("else");
      this.space();
      this.printAndIndentOnComments(node.alternate);
    }
  }
  function getLastStatement(statement) {
    var body = statement.body;
    if (isStatement(body) === false) {
      return statement;
    }
    return getLastStatement(body);
  }
  function ForStatement(node) {
    this.word("for");
    this.space();
    this.tokenChar(40);
    {
      var exit = this.enterForStatementInit();
      this.tokenContext |= _index.TokenContext.forHead;
      this.print(node.init);
      exit();
    }
    this.tokenChar(59);
    if (node.test) {
      this.space();
      this.print(node.test);
    }
    this.token(";", false, 1);
    if (node.update) {
      this.space();
      this.print(node.update);
    }
    this.tokenChar(41);
    this.printBlock(node);
  }
  function WhileStatement(node) {
    this.word("while");
    this.space();
    this.tokenChar(40);
    this.print(node.test);
    this.tokenChar(41);
    this.printBlock(node);
  }
  function ForXStatement(node) {
    this.word("for");
    this.space();
    var isForOf = node.type === "ForOfStatement";
    if (isForOf && node["await"]) {
      this.word("await");
      this.space();
    }
    this.noIndentInnerCommentsHere();
    this.tokenChar(40);
    {
      var exit = isForOf ? null : this.enterForStatementInit();
      this.tokenContext |= isForOf ? _index.TokenContext.forOfHead : _index.TokenContext.forInHead;
      this.print(node.left);
      exit == null || exit();
    }
    this.space();
    this.word(isForOf ? "of" : "in");
    this.space();
    this.print(node.right);
    this.tokenChar(41);
    this.printBlock(node);
  }
  statements.ForInStatement = ForXStatement;
  statements.ForOfStatement = ForXStatement;
  function DoWhileStatement(node) {
    this.word("do");
    this.space();
    this.print(node.body);
    this.space();
    this.word("while");
    this.space();
    this.tokenChar(40);
    this.print(node.test);
    this.tokenChar(41);
    this.semicolon();
  }
  function printStatementAfterKeyword(printer, node) {
    if (node) {
      printer.space();
      printer.printTerminatorless(node);
    }
    printer.semicolon();
  }
  function BreakStatement(node) {
    this.word("break");
    printStatementAfterKeyword(this, node.label);
  }
  function ContinueStatement(node) {
    this.word("continue");
    printStatementAfterKeyword(this, node.label);
  }
  function ReturnStatement(node) {
    this.word("return");
    printStatementAfterKeyword(this, node.argument);
  }
  function ThrowStatement(node) {
    this.word("throw");
    printStatementAfterKeyword(this, node.argument);
  }
  function LabeledStatement(node) {
    this.print(node.label);
    this.tokenChar(58);
    this.space();
    this.print(node.body);
  }
  function TryStatement(node) {
    this.word("try");
    this.space();
    this.print(node.block);
    this.space();
    if (node.handlers) {
      this.print(node.handlers[0]);
    } else {
      this.print(node.handler);
    }
    if (node.finalizer) {
      this.space();
      this.word("finally");
      this.space();
      this.print(node.finalizer);
    }
  }
  function CatchClause(node) {
    this.word("catch");
    this.space();
    if (node.param) {
      this.tokenChar(40);
      this.print(node.param);
      this.print(node.param.typeAnnotation);
      this.tokenChar(41);
      this.space();
    }
    this.print(node.body);
  }
  function SwitchStatement(node) {
    this.word("switch");
    this.space();
    this.tokenChar(40);
    this.print(node.discriminant);
    this.tokenChar(41);
    this.space();
    this.tokenChar(123);
    this.printSequence(node.cases, true, undefined, function addNewlines(leading, cas) {
      if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
    });
    this.rightBrace(node);
  }
  function SwitchCase(node) {
    if (node.test) {
      this.word("case");
      this.space();
      this.print(node.test);
      this.tokenChar(58);
    } else {
      this.word("default");
      this.tokenChar(58);
    }
    if (node.consequent.length) {
      this.newline();
      this.printSequence(node.consequent, true);
    }
  }
  function DebuggerStatement() {
    this.word("debugger");
    this.semicolon();
  }
  function VariableDeclaration(node, parent) {
    if (node.declare) {
      this.word("declare");
      this.space();
    }
    var kind = node.kind;
    if (kind === "await using") {
      this.word("await");
      this.space();
      this.word("using", true);
    } else {
      this.word(kind, kind === "using");
    }
    this.space();
    var hasInits = false;
    if (!isFor(parent)) {
      var _iterator = _createForOfIteratorHelper(node.declarations),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var declar = _step.value;
          if (declar.init) {
            hasInits = true;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    this.printList(node.declarations, undefined, undefined, node.declarations.length > 1, hasInits ? function (occurrenceCount) {
      this.token(",", false, occurrenceCount);
      this.newline();
    } : undefined);
    if (isFor(parent)) {
      if (isForStatement(parent)) {
        if (parent.init === node) return;
      } else {
        if (parent.left === node) return;
      }
    }
    this.semicolon();
  }
  function VariableDeclarator(node) {
    this.print(node.id);
    if (node.definite) this.tokenChar(33);
    this.print(node.id.typeAnnotation);
    if (node.init) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.init);
    }
  }
  return statements;
}

var classes = {};

var hasRequiredClasses;
function requireClasses() {
  if (hasRequiredClasses) return classes;
  hasRequiredClasses = 1;
  Object.defineProperty(classes, "__esModule", {
    value: true
  });
  classes.ClassAccessorProperty = ClassAccessorProperty;
  classes.ClassBody = ClassBody;
  classes.ClassExpression = classes.ClassDeclaration = ClassDeclaration;
  classes.ClassMethod = ClassMethod;
  classes.ClassPrivateMethod = ClassPrivateMethod;
  classes.ClassPrivateProperty = ClassPrivateProperty;
  classes.ClassProperty = ClassProperty;
  classes.StaticBlock = StaticBlock;
  classes._classMethodHead = _classMethodHead;
  var _t = requireLib$4();
  var isExportDefaultDeclaration = _t.isExportDefaultDeclaration,
    isExportNamedDeclaration = _t.isExportNamedDeclaration;
  function ClassDeclaration(node, parent) {
    var inExport = isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent);
    if (!inExport || !this._shouldPrintDecoratorsBeforeExport(parent)) {
      this.printJoin(node.decorators);
    }
    if (node.declare) {
      this.word("declare");
      this.space();
    }
    if (node["abstract"]) {
      this.word("abstract");
      this.space();
    }
    this.word("class");
    if (node.id) {
      this.space();
      this.print(node.id);
    }
    this.print(node.typeParameters);
    if (node.superClass) {
      this.space();
      this.word("extends");
      this.space();
      this.print(node.superClass);
      this.print(node.superTypeParameters);
    }
    if (node["implements"]) {
      this.space();
      this.word("implements");
      this.space();
      this.printList(node["implements"]);
    }
    this.space();
    this.print(node.body);
  }
  function ClassBody(node) {
    this.tokenChar(123);
    if (node.body.length === 0) {
      this.tokenChar(125);
    } else {
      this.newline();
      var separator = classBodyEmptySemicolonsPrinter(this, node);
      separator == null || separator(-1);
      var exit = this.enterDelimited();
      this.printJoin(node.body, true, true, separator, true);
      exit();
      if (!this.endsWith(10)) this.newline();
      this.rightBrace(node);
    }
  }
  function classBodyEmptySemicolonsPrinter(printer, node) {
    if (!printer.tokenMap || node.start == null || node.end == null) {
      return null;
    }
    var indexes = printer.tokenMap.getIndexes(node);
    if (!indexes) return null;
    var k = 1;
    var occurrenceCount = 0;
    var nextLocIndex = 0;
    var advanceNextLocIndex = function advanceNextLocIndex() {
      while (nextLocIndex < node.body.length && node.body[nextLocIndex].start == null) {
        nextLocIndex++;
      }
    };
    advanceNextLocIndex();
    return function (i) {
      if (nextLocIndex <= i) {
        nextLocIndex = i + 1;
        advanceNextLocIndex();
      }
      var end = nextLocIndex === node.body.length ? node.end : node.body[nextLocIndex].start;
      var tok;
      while (k < indexes.length && printer.tokenMap.matchesOriginal(tok = printer._tokens[indexes[k]], ";") && tok.start < end) {
        printer.token(";", undefined, occurrenceCount++);
        k++;
      }
    };
  }
  function ClassProperty(node) {
    this.printJoin(node.decorators);
    if (!node["static"] && !this.format.preserveFormat) {
      var _node$key$loc;
      var endLine = (_node$key$loc = node.key.loc) == null || (_node$key$loc = _node$key$loc.end) == null ? void 0 : _node$key$loc.line;
      if (endLine) this.catchUp(endLine);
    }
    this.tsPrintClassMemberModifiers(node);
    if (node.computed) {
      this.tokenChar(91);
      this.print(node.key);
      this.tokenChar(93);
    } else {
      this._variance(node);
      this.print(node.key);
    }
    if (node.optional) {
      this.tokenChar(63);
    }
    if (node.definite) {
      this.tokenChar(33);
    }
    this.print(node.typeAnnotation);
    if (node.value) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.value);
    }
    this.semicolon();
  }
  function ClassAccessorProperty(node) {
    var _node$key$loc2;
    this.printJoin(node.decorators);
    var endLine = (_node$key$loc2 = node.key.loc) == null || (_node$key$loc2 = _node$key$loc2.end) == null ? void 0 : _node$key$loc2.line;
    if (endLine) this.catchUp(endLine);
    this.tsPrintClassMemberModifiers(node);
    this.word("accessor", true);
    this.space();
    if (node.computed) {
      this.tokenChar(91);
      this.print(node.key);
      this.tokenChar(93);
    } else {
      this._variance(node);
      this.print(node.key);
    }
    if (node.optional) {
      this.tokenChar(63);
    }
    if (node.definite) {
      this.tokenChar(33);
    }
    this.print(node.typeAnnotation);
    if (node.value) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.value);
    }
    this.semicolon();
  }
  function ClassPrivateProperty(node) {
    this.printJoin(node.decorators);
    this.tsPrintClassMemberModifiers(node);
    this.print(node.key);
    if (node.optional) {
      this.tokenChar(63);
    }
    if (node.definite) {
      this.tokenChar(33);
    }
    this.print(node.typeAnnotation);
    if (node.value) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.value);
    }
    this.semicolon();
  }
  function ClassMethod(node) {
    this._classMethodHead(node);
    this.space();
    this.print(node.body);
  }
  function ClassPrivateMethod(node) {
    this._classMethodHead(node);
    this.space();
    this.print(node.body);
  }
  function _classMethodHead(node) {
    this.printJoin(node.decorators);
    if (!this.format.preserveFormat) {
      var _node$key$loc3;
      var endLine = (_node$key$loc3 = node.key.loc) == null || (_node$key$loc3 = _node$key$loc3.end) == null ? void 0 : _node$key$loc3.line;
      if (endLine) this.catchUp(endLine);
    }
    this.tsPrintClassMemberModifiers(node);
    this._methodHead(node);
  }
  function StaticBlock(node) {
    this.word("static");
    this.space();
    this.tokenChar(123);
    if (node.body.length === 0) {
      this.tokenChar(125);
    } else {
      this.newline();
      this.printSequence(node.body, true);
      this.rightBrace(node);
    }
  }
  return classes;
}

var methods = {};

var hasRequiredMethods;
function requireMethods() {
  if (hasRequiredMethods) return methods;
  hasRequiredMethods = 1;
  Object.defineProperty(methods, "__esModule", {
    value: true
  });
  methods.ArrowFunctionExpression = ArrowFunctionExpression;
  methods.FunctionDeclaration = methods.FunctionExpression = FunctionExpression;
  methods._functionHead = _functionHead;
  methods._methodHead = _methodHead;
  methods._param = _param;
  methods._parameters = _parameters;
  methods._params = _params;
  methods._predicate = _predicate;
  methods._shouldPrintArrowParamsParens = _shouldPrintArrowParamsParens;
  var _t = requireLib$4();
  var _index = requireNode();
  var isIdentifier = _t.isIdentifier;
  function _params(node, idNode, parentNode) {
    this.print(node.typeParameters);
    var nameInfo = _getFuncIdName.call(this, idNode, parentNode);
    if (nameInfo) {
      this.sourceIdentifierName(nameInfo.name, nameInfo.pos);
    }
    this.tokenChar(40);
    this._parameters(node.params, ")");
    var noLineTerminator = node.type === "ArrowFunctionExpression";
    this.print(node.returnType, noLineTerminator);
    this._noLineTerminator = noLineTerminator;
  }
  function _parameters(parameters, endToken) {
    var exit = this.enterDelimited();
    var trailingComma = this.shouldPrintTrailingComma(endToken);
    var paramLength = parameters.length;
    for (var i = 0; i < paramLength; i++) {
      this._param(parameters[i]);
      if (trailingComma || i < paramLength - 1) {
        this.token(",", null, i);
        this.space();
      }
    }
    this.token(endToken);
    exit();
  }
  function _param(parameter) {
    this.printJoin(parameter.decorators);
    this.print(parameter);
    if (parameter.optional) {
      this.tokenChar(63);
    }
    this.print(parameter.typeAnnotation);
  }
  function _methodHead(node) {
    var kind = node.kind;
    var key = node.key;
    if (kind === "get" || kind === "set") {
      this.word(kind);
      this.space();
    }
    if (node.async) {
      this.word("async", true);
      this.space();
    }
    if (kind === "method" || kind === "init") {
      if (node.generator) {
        this.tokenChar(42);
      }
    }
    if (node.computed) {
      this.tokenChar(91);
      this.print(key);
      this.tokenChar(93);
    } else {
      this.print(key);
    }
    if (node.optional) {
      this.tokenChar(63);
    }
    this._params(node, node.computed && node.key.type !== "StringLiteral" ? undefined : node.key, undefined);
  }
  function _predicate(node, noLineTerminatorAfter) {
    if (node.predicate) {
      if (!node.returnType) {
        this.tokenChar(58);
      }
      this.space();
      this.print(node.predicate, noLineTerminatorAfter);
    }
  }
  function _functionHead(node, parent) {
    if (node.async) {
      this.word("async");
      if (!this.format.preserveFormat) {
        this._endsWithInnerRaw = false;
      }
      this.space();
    }
    this.word("function");
    if (node.generator) {
      if (!this.format.preserveFormat) {
        this._endsWithInnerRaw = false;
      }
      this.tokenChar(42);
    }
    this.space();
    if (node.id) {
      this.print(node.id);
    }
    this._params(node, node.id, parent);
    if (node.type !== "TSDeclareFunction") {
      this._predicate(node);
    }
  }
  function FunctionExpression(node, parent) {
    this._functionHead(node, parent);
    this.space();
    this.print(node.body);
  }
  function ArrowFunctionExpression(node, parent) {
    if (node.async) {
      this.word("async", true);
      this.space();
    }
    if (this._shouldPrintArrowParamsParens(node)) {
      this._params(node, undefined, parent);
    } else {
      this.print(node.params[0], true);
    }
    this._predicate(node, true);
    this.space();
    this.printInnerComments();
    this.token("=>");
    this.space();
    this.tokenContext |= _index.TokenContext.arrowBody;
    this.print(node.body);
  }
  function _shouldPrintArrowParamsParens(node) {
    var _firstParam$leadingCo, _firstParam$trailingC;
    if (node.params.length !== 1) return true;
    if (node.typeParameters || node.returnType || node.predicate) {
      return true;
    }
    var firstParam = node.params[0];
    if (!isIdentifier(firstParam) || firstParam.typeAnnotation || firstParam.optional || (_firstParam$leadingCo = firstParam.leadingComments) != null && _firstParam$leadingCo.length || (_firstParam$trailingC = firstParam.trailingComments) != null && _firstParam$trailingC.length) {
      return true;
    }
    if (this.tokenMap) {
      if (node.loc == null) return true;
      if (this.tokenMap.findMatching(node, "(") !== null) return true;
      var arrowToken = this.tokenMap.findMatching(node, "=>");
      if ((arrowToken == null ? void 0 : arrowToken.loc) == null) return true;
      return arrowToken.loc.start.line !== node.loc.start.line;
    }
    if (this.format.retainLines) return true;
    return false;
  }
  function _getFuncIdName(idNode, parent) {
    var id = idNode;
    if (!id && parent) {
      var parentType = parent.type;
      if (parentType === "VariableDeclarator") {
        id = parent.id;
      } else if (parentType === "AssignmentExpression" || parentType === "AssignmentPattern") {
        id = parent.left;
      } else if (parentType === "ObjectProperty" || parentType === "ClassProperty") {
        if (!parent.computed || parent.key.type === "StringLiteral") {
          id = parent.key;
        }
      } else if (parentType === "ClassPrivateProperty" || parentType === "ClassAccessorProperty") {
        id = parent.key;
      }
    }
    if (!id) return;
    var nameInfo;
    if (id.type === "Identifier") {
      var _id$loc, _id$loc2;
      nameInfo = {
        pos: (_id$loc = id.loc) == null ? void 0 : _id$loc.start,
        name: ((_id$loc2 = id.loc) == null ? void 0 : _id$loc2.identifierName) || id.name
      };
    } else if (id.type === "PrivateName") {
      var _id$loc3;
      nameInfo = {
        pos: (_id$loc3 = id.loc) == null ? void 0 : _id$loc3.start,
        name: "#" + id.id.name
      };
    } else if (id.type === "StringLiteral") {
      var _id$loc4;
      nameInfo = {
        pos: (_id$loc4 = id.loc) == null ? void 0 : _id$loc4.start,
        name: id.value
      };
    }
    return nameInfo;
  }
  return methods;
}

var modules = {};

var hasRequiredModules;
function requireModules() {
  if (hasRequiredModules) return modules;
  hasRequiredModules = 1;
  Object.defineProperty(modules, "__esModule", {
    value: true
  });
  modules.ExportAllDeclaration = ExportAllDeclaration;
  modules.ExportDefaultDeclaration = ExportDefaultDeclaration;
  modules.ExportDefaultSpecifier = ExportDefaultSpecifier;
  modules.ExportNamedDeclaration = ExportNamedDeclaration;
  modules.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
  modules.ExportSpecifier = ExportSpecifier;
  modules.ImportAttribute = ImportAttribute;
  modules.ImportDeclaration = ImportDeclaration;
  modules.ImportDefaultSpecifier = ImportDefaultSpecifier;
  modules.ImportExpression = ImportExpression;
  modules.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
  modules.ImportSpecifier = ImportSpecifier;
  modules._printAttributes = _printAttributes;
  var _t = requireLib$4();
  var _index = requireNode();
  var isClassDeclaration = _t.isClassDeclaration,
    isExportDefaultSpecifier = _t.isExportDefaultSpecifier,
    isExportNamespaceSpecifier = _t.isExportNamespaceSpecifier,
    isImportDefaultSpecifier = _t.isImportDefaultSpecifier,
    isImportNamespaceSpecifier = _t.isImportNamespaceSpecifier,
    isStatement = _t.isStatement;
  function ImportSpecifier(node) {
    if (node.importKind === "type" || node.importKind === "typeof") {
      this.word(node.importKind);
      this.space();
    }
    this.print(node.imported);
    if (node.local && node.local.name !== node.imported.name) {
      this.space();
      this.word("as");
      this.space();
      this.print(node.local);
    }
  }
  function ImportDefaultSpecifier(node) {
    this.print(node.local);
  }
  function ExportDefaultSpecifier(node) {
    this.print(node.exported);
  }
  function ExportSpecifier(node) {
    if (node.exportKind === "type") {
      this.word("type");
      this.space();
    }
    this.print(node.local);
    if (node.exported && node.local.name !== node.exported.name) {
      this.space();
      this.word("as");
      this.space();
      this.print(node.exported);
    }
  }
  function ExportNamespaceSpecifier(node) {
    this.tokenChar(42);
    this.space();
    this.word("as");
    this.space();
    this.print(node.exported);
  }
  var warningShown = false;
  function _printAttributes(node, hasPreviousBrace) {
    var importAttributesKeyword = this.format.importAttributesKeyword;
    var attributes = node.attributes,
      assertions = node.assertions;
    if (attributes && !importAttributesKeyword && !warningShown) {
      warningShown = true;
      console.warn("You are using import attributes, without specifying the desired output syntax.\nPlease specify the \"importAttributesKeyword\" generator option, whose value can be one of:\n - \"with\"        : `import { a } from \"b\" with { type: \"json\" };`\n - \"assert\"      : `import { a } from \"b\" assert { type: \"json\" };`\n - \"with-legacy\" : `import { a } from \"b\" with type: \"json\";`\n");
    }
    var useAssertKeyword = importAttributesKeyword === "assert" || !importAttributesKeyword && assertions;
    this.word(useAssertKeyword ? "assert" : "with");
    this.space();
    if (!useAssertKeyword && importAttributesKeyword !== "with") {
      this.printList(attributes || assertions);
      return;
    }
    var occurrenceCount = hasPreviousBrace ? 1 : 0;
    this.token("{", null, occurrenceCount);
    this.space();
    this.printList(attributes || assertions, this.shouldPrintTrailingComma("}"));
    this.space();
    this.token("}", null, occurrenceCount);
  }
  function ExportAllDeclaration(node) {
    var _node$attributes, _node$assertions;
    this.word("export");
    this.space();
    if (node.exportKind === "type") {
      this.word("type");
      this.space();
    }
    this.tokenChar(42);
    this.space();
    this.word("from");
    this.space();
    if ((_node$attributes = node.attributes) != null && _node$attributes.length || (_node$assertions = node.assertions) != null && _node$assertions.length) {
      this.print(node.source, true);
      this.space();
      this._printAttributes(node, false);
    } else {
      this.print(node.source);
    }
    this.semicolon();
  }
  function maybePrintDecoratorsBeforeExport(printer, node) {
    if (isClassDeclaration(node.declaration) && printer._shouldPrintDecoratorsBeforeExport(node)) {
      printer.printJoin(node.declaration.decorators);
    }
  }
  function ExportNamedDeclaration(node) {
    maybePrintDecoratorsBeforeExport(this, node);
    this.word("export");
    this.space();
    if (node.declaration) {
      var declar = node.declaration;
      this.print(declar);
      if (!isStatement(declar)) this.semicolon();
    } else {
      if (node.exportKind === "type") {
        this.word("type");
        this.space();
      }
      var specifiers = node.specifiers.slice(0);
      var hasSpecial = false;
      for (;;) {
        var first = specifiers[0];
        if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {
          hasSpecial = true;
          this.print(specifiers.shift());
          if (specifiers.length) {
            this.tokenChar(44);
            this.space();
          }
        } else {
          break;
        }
      }
      var hasBrace = false;
      if (specifiers.length || !specifiers.length && !hasSpecial) {
        hasBrace = true;
        this.tokenChar(123);
        if (specifiers.length) {
          this.space();
          this.printList(specifiers, this.shouldPrintTrailingComma("}"));
          this.space();
        }
        this.tokenChar(125);
      }
      if (node.source) {
        var _node$attributes2, _node$assertions2;
        this.space();
        this.word("from");
        this.space();
        if ((_node$attributes2 = node.attributes) != null && _node$attributes2.length || (_node$assertions2 = node.assertions) != null && _node$assertions2.length) {
          this.print(node.source, true);
          this.space();
          this._printAttributes(node, hasBrace);
        } else {
          this.print(node.source);
        }
      }
      this.semicolon();
    }
  }
  function ExportDefaultDeclaration(node) {
    maybePrintDecoratorsBeforeExport(this, node);
    this.word("export");
    this.noIndentInnerCommentsHere();
    this.space();
    this.word("default");
    this.space();
    this.tokenContext |= _index.TokenContext.exportDefault;
    var declar = node.declaration;
    this.print(declar);
    if (!isStatement(declar)) this.semicolon();
  }
  function ImportDeclaration(node) {
    var _node$attributes3, _node$assertions3;
    this.word("import");
    this.space();
    var isTypeKind = node.importKind === "type" || node.importKind === "typeof";
    if (isTypeKind) {
      this.noIndentInnerCommentsHere();
      this.word(node.importKind);
      this.space();
    } else if (node.module) {
      this.noIndentInnerCommentsHere();
      this.word("module");
      this.space();
    } else if (node.phase) {
      this.noIndentInnerCommentsHere();
      this.word(node.phase);
      this.space();
    }
    var specifiers = node.specifiers.slice(0);
    var hasSpecifiers = !!specifiers.length;
    while (hasSpecifiers) {
      var first = specifiers[0];
      if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {
        this.print(specifiers.shift());
        if (specifiers.length) {
          this.tokenChar(44);
          this.space();
        }
      } else {
        break;
      }
    }
    var hasBrace = false;
    if (specifiers.length) {
      hasBrace = true;
      this.tokenChar(123);
      this.space();
      this.printList(specifiers, this.shouldPrintTrailingComma("}"));
      this.space();
      this.tokenChar(125);
    } else if (isTypeKind && !hasSpecifiers) {
      hasBrace = true;
      this.tokenChar(123);
      this.tokenChar(125);
    }
    if (hasSpecifiers || isTypeKind) {
      this.space();
      this.word("from");
      this.space();
    }
    if ((_node$attributes3 = node.attributes) != null && _node$attributes3.length || (_node$assertions3 = node.assertions) != null && _node$assertions3.length) {
      this.print(node.source, true);
      this.space();
      this._printAttributes(node, hasBrace);
    } else {
      this.print(node.source);
    }
    this.semicolon();
  }
  function ImportAttribute(node) {
    this.print(node.key);
    this.tokenChar(58);
    this.space();
    this.print(node.value);
  }
  function ImportNamespaceSpecifier(node) {
    this.tokenChar(42);
    this.space();
    this.word("as");
    this.space();
    this.print(node.local);
  }
  function ImportExpression(node) {
    this.word("import");
    if (node.phase) {
      this.tokenChar(46);
      this.word(node.phase);
    }
    this.tokenChar(40);
    this.print(node.source);
    if (node.options != null) {
      this.tokenChar(44);
      this.space();
      this.print(node.options);
    }
    this.tokenChar(41);
  }
  return modules;
}

var types = {};

var jsesc_1;
var hasRequiredJsesc;
function requireJsesc() {
  if (hasRequiredJsesc) return jsesc_1;
  hasRequiredJsesc = 1;
  var object = {};
  var hasOwnProperty = object.hasOwnProperty;
  var forOwn = function forOwn(object, callback) {
    for (var key in object) {
      if (hasOwnProperty.call(object, key)) {
        callback(key, object[key]);
      }
    }
  };
  var extend = function extend(destination, source) {
    if (!source) {
      return destination;
    }
    forOwn(source, function (key, value) {
      destination[key] = value;
    });
    return destination;
  };
  var forEach = function forEach(array, callback) {
    var length = array.length;
    var index = -1;
    while (++index < length) {
      callback(array[index]);
    }
  };
  var fourHexEscape = function fourHexEscape(hex) {
    return "\\u" + ('0000' + hex).slice(-4);
  };
  var hexadecimal = function hexadecimal(code, lowercase) {
    var hexadecimal = code.toString(16);
    if (lowercase) return hexadecimal;
    return hexadecimal.toUpperCase();
  };
  var toString = object.toString;
  var isArray = Array.isArray;
  var isBuffer = function isBuffer(value) {
    return typeof Buffer === 'function' && Buffer.isBuffer(value);
  };
  var isObject = function isObject(value) {
    // This is a very simple check, but it’s good enough for what we need.
    return toString.call(value) == '[object Object]';
  };
  var isString = function isString(value) {
    return typeof value == 'string' || toString.call(value) == '[object String]';
  };
  var isNumber = function isNumber(value) {
    return typeof value == 'number' || toString.call(value) == '[object Number]';
  };
  var isBigInt = function isBigInt(value) {
    return typeof value == 'bigint';
  };
  var isFunction = function isFunction(value) {
    return typeof value == 'function';
  };
  var isMap = function isMap(value) {
    return toString.call(value) == '[object Map]';
  };
  var isSet = function isSet(value) {
    return toString.call(value) == '[object Set]';
  };

  /*--------------------------------------------------------------------------*/

  // https://mathiasbynens.be/notes/javascript-escapes#single
  var singleEscapes = {
    '\\': '\\\\',
    '\b': '\\b',
    '\f': '\\f',
    '\n': '\\n',
    '\r': '\\r',
    '\t': '\\t'
    // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
    // '\v': '\\x0B'
  };
  var regexSingleEscape = /[\\\b\f\n\r\t]/;
  var regexDigit = /[0-9]/;
  var regexWhitespace = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
  var escapeEverythingRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g;
  var escapeNonAsciiRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g;
  var _jsesc = function jsesc(argument, options) {
    var increaseIndentation = function increaseIndentation() {
      oldIndent = indent;
      ++options.indentLevel;
      indent = options.indent.repeat(options.indentLevel);
    };
    // Handle options
    var defaults = {
      'escapeEverything': false,
      'minimal': false,
      'isScriptContext': false,
      'quotes': 'single',
      'wrap': false,
      'es6': false,
      'json': false,
      'compact': true,
      'lowercaseHex': false,
      'numbers': 'decimal',
      'indent': '\t',
      'indentLevel': 0,
      '__inline1__': false,
      '__inline2__': false
    };
    var json = options && options.json;
    if (json) {
      defaults.quotes = 'double';
      defaults.wrap = true;
    }
    options = extend(defaults, options);
    if (options.quotes != 'single' && options.quotes != 'double' && options.quotes != 'backtick') {
      options.quotes = 'single';
    }
    var quote = options.quotes == 'double' ? '"' : options.quotes == 'backtick' ? '`' : '\'';
    var compact = options.compact;
    var lowercaseHex = options.lowercaseHex;
    var indent = options.indent.repeat(options.indentLevel);
    var oldIndent = '';
    var inline1 = options.__inline1__;
    var inline2 = options.__inline2__;
    var newLine = compact ? '' : '\n';
    var result;
    var isEmpty = true;
    var useBinNumbers = options.numbers == 'binary';
    var useOctNumbers = options.numbers == 'octal';
    var useDecNumbers = options.numbers == 'decimal';
    var useHexNumbers = options.numbers == 'hexadecimal';
    if (json && argument && isFunction(argument.toJSON)) {
      argument = argument.toJSON();
    }
    if (!isString(argument)) {
      if (isMap(argument)) {
        if (argument.size == 0) {
          return 'new Map()';
        }
        if (!compact) {
          options.__inline1__ = true;
          options.__inline2__ = false;
        }
        return 'new Map(' + _jsesc(Array.from(argument), options) + ')';
      }
      if (isSet(argument)) {
        if (argument.size == 0) {
          return 'new Set()';
        }
        return 'new Set(' + _jsesc(Array.from(argument), options) + ')';
      }
      if (isBuffer(argument)) {
        if (argument.length == 0) {
          return 'Buffer.from([])';
        }
        return 'Buffer.from(' + _jsesc(Array.from(argument), options) + ')';
      }
      if (isArray(argument)) {
        result = [];
        options.wrap = true;
        if (inline1) {
          options.__inline1__ = false;
          options.__inline2__ = true;
        }
        if (!inline2) {
          increaseIndentation();
        }
        forEach(argument, function (value) {
          isEmpty = false;
          if (inline2) {
            options.__inline2__ = false;
          }
          result.push((compact || inline2 ? '' : indent) + _jsesc(value, options));
        });
        if (isEmpty) {
          return '[]';
        }
        if (inline2) {
          return '[' + result.join(', ') + ']';
        }
        return '[' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + ']';
      } else if (isNumber(argument) || isBigInt(argument)) {
        if (json) {
          // Some number values (e.g. `Infinity`) cannot be represented in JSON.
          // `BigInt` values less than `-Number.MAX_VALUE` or greater than
          // `Number.MAX_VALUE` cannot be represented in JSON so they will become
          // `-Infinity` or `Infinity`, respectively, and then become `null` when
          // stringified.
          return JSON.stringify(Number(argument));
        }
        var _result;
        if (useDecNumbers) {
          _result = String(argument);
        } else if (useHexNumbers) {
          var _hexadecimal = argument.toString(16);
          if (!lowercaseHex) {
            _hexadecimal = _hexadecimal.toUpperCase();
          }
          _result = '0x' + _hexadecimal;
        } else if (useBinNumbers) {
          _result = '0b' + argument.toString(2);
        } else if (useOctNumbers) {
          _result = '0o' + argument.toString(8);
        }
        if (isBigInt(argument)) {
          return _result + 'n';
        }
        return _result;
      } else if (isBigInt(argument)) {
        if (json) {
          // `BigInt` values less than `-Number.MAX_VALUE` or greater than
          // `Number.MAX_VALUE` will become `-Infinity` or `Infinity`,
          // respectively, and cannot be represented in JSON.
          return JSON.stringify(Number(argument));
        }
        return argument + 'n';
      } else if (!isObject(argument)) {
        if (json) {
          // For some values (e.g. `undefined`, `function` objects),
          // `JSON.stringify(value)` returns `undefined` (which isn’t valid
          // JSON) instead of `'null'`.
          return JSON.stringify(argument) || 'null';
        }
        return String(argument);
      } else {
        // it’s an object
        result = [];
        options.wrap = true;
        increaseIndentation();
        forOwn(argument, function (key, value) {
          isEmpty = false;
          result.push((compact ? '' : indent) + _jsesc(key, options) + ':' + (compact ? '' : ' ') + _jsesc(value, options));
        });
        if (isEmpty) {
          return '{}';
        }
        return '{' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + '}';
      }
    }
    var regex = options.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;
    result = argument.replace(regex, function (_char, pair, lone, quoteChar, index, string) {
      if (pair) {
        if (options.minimal) return pair;
        var first = pair.charCodeAt(0);
        var second = pair.charCodeAt(1);
        if (options.es6) {
          // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
          var codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
          var _hex = hexadecimal(codePoint, lowercaseHex);
          return "\\u{" + _hex + '}';
        }
        return fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));
      }
      if (lone) {
        return fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));
      }
      if (_char == '\0' && !json && !regexDigit.test(string.charAt(index + 1))) {
        return '\\0';
      }
      if (quoteChar) {
        if (quoteChar == quote || options.escapeEverything) {
          return '\\' + quoteChar;
        }
        return quoteChar;
      }
      if (regexSingleEscape.test(_char)) {
        // no need for a `hasOwnProperty` check here
        return singleEscapes[_char];
      }
      if (options.minimal && !regexWhitespace.test(_char)) {
        return _char;
      }
      var hex = hexadecimal(_char.charCodeAt(0), lowercaseHex);
      if (json || hex.length > 2) {
        return fourHexEscape(hex);
      }
      return '\\x' + ('00' + hex).slice(-2);
    });
    if (quote == '`') {
      result = result.replace(/\$\{/g, '\\${');
    }
    if (options.isScriptContext) {
      // https://mathiasbynens.be/notes/etago
      result = result.replace(/<\/(script|style)/gi, '<\\/$1').replace(/<!--/g, json ? "\\u003C!--" : '\\x3C!--');
    }
    if (options.wrap) {
      result = quote + result + quote;
    }
    return result;
  };
  _jsesc.version = '3.0.2';
  jsesc_1 = _jsesc;
  return jsesc_1;
}

var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types;
  hasRequiredTypes = 1;
  Object.defineProperty(types, "__esModule", {
    value: true
  });
  types.ArgumentPlaceholder = ArgumentPlaceholder;
  types.ArrayPattern = types.ArrayExpression = ArrayExpression;
  types.BigIntLiteral = BigIntLiteral;
  types.BooleanLiteral = BooleanLiteral;
  types.Identifier = Identifier;
  types.NullLiteral = NullLiteral;
  types.NumericLiteral = NumericLiteral;
  types.ObjectPattern = types.ObjectExpression = ObjectExpression;
  types.ObjectMethod = ObjectMethod;
  types.ObjectProperty = ObjectProperty;
  types.PipelineBareFunction = PipelineBareFunction;
  types.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;
  types.PipelineTopicExpression = PipelineTopicExpression;
  types.RecordExpression = RecordExpression;
  types.RegExpLiteral = RegExpLiteral;
  types.SpreadElement = types.RestElement = RestElement;
  types.StringLiteral = StringLiteral;
  types.TopicReference = TopicReference;
  types.TupleExpression = TupleExpression;
  types._getRawIdentifier = _getRawIdentifier;
  var _t = requireLib$4();
  var _jsesc = requireJsesc();
  var isAssignmentPattern = _t.isAssignmentPattern,
    isIdentifier = _t.isIdentifier;
  var lastRawIdentNode = null;
  var lastRawIdentResult = "";
  function _getRawIdentifier(node) {
    if (node === lastRawIdentNode) return lastRawIdentResult;
    lastRawIdentNode = node;
    var name = node.name;
    var token = this.tokenMap.find(node, function (tok) {
      return tok.value === name;
    });
    if (token) {
      lastRawIdentResult = this._originalCode.slice(token.start, token.end);
      return lastRawIdentResult;
    }
    return lastRawIdentResult = node.name;
  }
  function Identifier(node) {
    var _node$loc;
    this.sourceIdentifierName(((_node$loc = node.loc) == null ? void 0 : _node$loc.identifierName) || node.name);
    this.word(this.tokenMap ? this._getRawIdentifier(node) : node.name);
  }
  function ArgumentPlaceholder() {
    this.tokenChar(63);
  }
  function RestElement(node) {
    this.token("...");
    this.print(node.argument);
  }
  function ObjectExpression(node) {
    var props = node.properties;
    this.tokenChar(123);
    if (props.length) {
      var exit = this.enterDelimited();
      this.space();
      this.printList(props, this.shouldPrintTrailingComma("}"), true, true);
      this.space();
      exit();
    }
    this.sourceWithOffset("end", node.loc, -1);
    this.tokenChar(125);
  }
  function ObjectMethod(node) {
    this.printJoin(node.decorators);
    this._methodHead(node);
    this.space();
    this.print(node.body);
  }
  function ObjectProperty(node) {
    this.printJoin(node.decorators);
    if (node.computed) {
      this.tokenChar(91);
      this.print(node.key);
      this.tokenChar(93);
    } else {
      if (isAssignmentPattern(node.value) && isIdentifier(node.key) && node.key.name === node.value.left.name) {
        this.print(node.value);
        return;
      }
      this.print(node.key);
      if (node.shorthand && isIdentifier(node.key) && isIdentifier(node.value) && node.key.name === node.value.name) {
        return;
      }
    }
    this.tokenChar(58);
    this.space();
    this.print(node.value);
  }
  function ArrayExpression(node) {
    var elems = node.elements;
    var len = elems.length;
    this.tokenChar(91);
    var exit = this.enterDelimited();
    for (var i = 0; i < elems.length; i++) {
      var elem = elems[i];
      if (elem) {
        if (i > 0) this.space();
        this.print(elem);
        if (i < len - 1 || this.shouldPrintTrailingComma("]")) {
          this.token(",", false, i);
        }
      } else {
        this.token(",", false, i);
      }
    }
    exit();
    this.tokenChar(93);
  }
  function RecordExpression(node) {
    var props = node.properties;
    var startToken;
    var endToken;
    {
      if (this.format.recordAndTupleSyntaxType === "bar") {
        startToken = "{|";
        endToken = "|}";
      } else if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null) {
        throw new Error("The \"recordAndTupleSyntaxType\" generator option must be \"bar\" or \"hash\" (".concat(JSON.stringify(this.format.recordAndTupleSyntaxType), " received)."));
      } else {
        startToken = "#{";
        endToken = "}";
      }
    }
    this.token(startToken);
    if (props.length) {
      this.space();
      this.printList(props, this.shouldPrintTrailingComma(endToken), true, true);
      this.space();
    }
    this.token(endToken);
  }
  function TupleExpression(node) {
    var elems = node.elements;
    var len = elems.length;
    var startToken;
    var endToken;
    {
      if (this.format.recordAndTupleSyntaxType === "bar") {
        startToken = "[|";
        endToken = "|]";
      } else if (this.format.recordAndTupleSyntaxType === "hash") {
        startToken = "#[";
        endToken = "]";
      } else {
        throw new Error("".concat(this.format.recordAndTupleSyntaxType, " is not a valid recordAndTuple syntax type"));
      }
    }
    this.token(startToken);
    for (var i = 0; i < elems.length; i++) {
      var elem = elems[i];
      if (elem) {
        if (i > 0) this.space();
        this.print(elem);
        if (i < len - 1 || this.shouldPrintTrailingComma(endToken)) {
          this.token(",", false, i);
        }
      }
    }
    this.token(endToken);
  }
  function RegExpLiteral(node) {
    this.word("/".concat(node.pattern, "/").concat(node.flags));
  }
  function BooleanLiteral(node) {
    this.word(node.value ? "true" : "false");
  }
  function NullLiteral() {
    this.word("null");
  }
  function NumericLiteral(node) {
    var raw = this.getPossibleRaw(node);
    var opts = this.format.jsescOption;
    var value = node.value;
    var str = value + "";
    if (opts.numbers) {
      this.number(_jsesc(value, opts), value);
    } else if (raw == null) {
      this.number(str, value);
    } else if (this.format.minified) {
      this.number(raw.length < str.length ? raw : str, value);
    } else {
      this.number(raw, value);
    }
  }
  function StringLiteral(node) {
    var raw = this.getPossibleRaw(node);
    if (!this.format.minified && raw !== undefined) {
      this.token(raw);
      return;
    }
    var val = _jsesc(node.value, this.format.jsescOption);
    this.token(val);
  }
  function BigIntLiteral(node) {
    var raw = this.getPossibleRaw(node);
    if (!this.format.minified && raw !== undefined) {
      this.word(raw);
      return;
    }
    this.word(node.value + "n");
  }
  var validTopicTokenSet = new Set(["^^", "@@", "^", "%", "#"]);
  function TopicReference() {
    var topicToken = this.format.topicToken;
    if (validTopicTokenSet.has(topicToken)) {
      this.token(topicToken);
    } else {
      var givenTopicTokenJSON = JSON.stringify(topicToken);
      var validTopics = Array.from(validTopicTokenSet, function (v) {
        return JSON.stringify(v);
      });
      throw new Error("The \"topicToken\" generator option must be one of " + "".concat(validTopics.join(", "), " (").concat(givenTopicTokenJSON, " received instead)."));
    }
  }
  function PipelineTopicExpression(node) {
    this.print(node.expression);
  }
  function PipelineBareFunction(node) {
    this.print(node.callee);
  }
  function PipelinePrimaryTopicReference() {
    this.tokenChar(35);
  }
  return types;
}

var flow = {};

var hasRequiredFlow;
function requireFlow() {
  if (hasRequiredFlow) return flow;
  hasRequiredFlow = 1;
  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AnyTypeAnnotation = AnyTypeAnnotation;
    exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
    exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
    exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
    exports.DeclareClass = DeclareClass;
    exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
    exports.DeclareExportDeclaration = DeclareExportDeclaration;
    exports.DeclareFunction = DeclareFunction;
    exports.DeclareInterface = DeclareInterface;
    exports.DeclareModule = DeclareModule;
    exports.DeclareModuleExports = DeclareModuleExports;
    exports.DeclareOpaqueType = DeclareOpaqueType;
    exports.DeclareTypeAlias = DeclareTypeAlias;
    exports.DeclareVariable = DeclareVariable;
    exports.DeclaredPredicate = DeclaredPredicate;
    exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
    exports.EnumBooleanBody = EnumBooleanBody;
    exports.EnumBooleanMember = EnumBooleanMember;
    exports.EnumDeclaration = EnumDeclaration;
    exports.EnumDefaultedMember = EnumDefaultedMember;
    exports.EnumNumberBody = EnumNumberBody;
    exports.EnumNumberMember = EnumNumberMember;
    exports.EnumStringBody = EnumStringBody;
    exports.EnumStringMember = EnumStringMember;
    exports.EnumSymbolBody = EnumSymbolBody;
    exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
    exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
    exports.FunctionTypeParam = FunctionTypeParam;
    exports.IndexedAccessType = IndexedAccessType;
    exports.InferredPredicate = InferredPredicate;
    exports.InterfaceDeclaration = InterfaceDeclaration;
    exports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;
    exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
    exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
    exports.MixedTypeAnnotation = MixedTypeAnnotation;
    exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
    exports.NullableTypeAnnotation = NullableTypeAnnotation;
    Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _types2.NumericLiteral;
      }
    });
    exports.NumberTypeAnnotation = NumberTypeAnnotation;
    exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
    exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
    exports.ObjectTypeIndexer = ObjectTypeIndexer;
    exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
    exports.ObjectTypeProperty = ObjectTypeProperty;
    exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
    exports.OpaqueType = OpaqueType;
    exports.OptionalIndexedAccessType = OptionalIndexedAccessType;
    exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
    Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
      enumerable: true,
      get: function get() {
        return _types2.StringLiteral;
      }
    });
    exports.StringTypeAnnotation = StringTypeAnnotation;
    exports.SymbolTypeAnnotation = SymbolTypeAnnotation;
    exports.ThisTypeAnnotation = ThisTypeAnnotation;
    exports.TupleTypeAnnotation = TupleTypeAnnotation;
    exports.TypeAlias = TypeAlias;
    exports.TypeAnnotation = TypeAnnotation;
    exports.TypeCastExpression = TypeCastExpression;
    exports.TypeParameter = TypeParameter;
    exports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;
    exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
    exports.UnionTypeAnnotation = UnionTypeAnnotation;
    exports.Variance = Variance;
    exports.VoidTypeAnnotation = VoidTypeAnnotation;
    exports._interfaceish = _interfaceish;
    exports._variance = _variance;
    var _t = requireLib$4();
    var _modules = requireModules();
    var _index = requireNode();
    var _types2 = requireTypes();
    var isDeclareExportDeclaration = _t.isDeclareExportDeclaration,
      isStatement = _t.isStatement;
    function AnyTypeAnnotation() {
      this.word("any");
    }
    function ArrayTypeAnnotation(node) {
      this.print(node.elementType, true);
      this.tokenChar(91);
      this.tokenChar(93);
    }
    function BooleanTypeAnnotation() {
      this.word("boolean");
    }
    function BooleanLiteralTypeAnnotation(node) {
      this.word(node.value ? "true" : "false");
    }
    function NullLiteralTypeAnnotation() {
      this.word("null");
    }
    function DeclareClass(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("class");
      this.space();
      this._interfaceish(node);
    }
    function DeclareFunction(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("function");
      this.space();
      this.print(node.id);
      this.print(node.id.typeAnnotation.typeAnnotation);
      if (node.predicate) {
        this.space();
        this.print(node.predicate);
      }
      this.semicolon();
    }
    function InferredPredicate() {
      this.tokenChar(37);
      this.word("checks");
    }
    function DeclaredPredicate(node) {
      this.tokenChar(37);
      this.word("checks");
      this.tokenChar(40);
      this.print(node.value);
      this.tokenChar(41);
    }
    function DeclareInterface(node) {
      this.word("declare");
      this.space();
      this.InterfaceDeclaration(node);
    }
    function DeclareModule(node) {
      this.word("declare");
      this.space();
      this.word("module");
      this.space();
      this.print(node.id);
      this.space();
      this.print(node.body);
    }
    function DeclareModuleExports(node) {
      this.word("declare");
      this.space();
      this.word("module");
      this.tokenChar(46);
      this.word("exports");
      this.print(node.typeAnnotation);
    }
    function DeclareTypeAlias(node) {
      this.word("declare");
      this.space();
      this.TypeAlias(node);
    }
    function DeclareOpaqueType(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.OpaqueType(node);
    }
    function DeclareVariable(node, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("var");
      this.space();
      this.print(node.id);
      this.print(node.id.typeAnnotation);
      this.semicolon();
    }
    function DeclareExportDeclaration(node) {
      this.word("declare");
      this.space();
      this.word("export");
      this.space();
      if (node["default"]) {
        this.word("default");
        this.space();
      }
      FlowExportDeclaration.call(this, node);
    }
    function DeclareExportAllDeclaration(node) {
      this.word("declare");
      this.space();
      _modules.ExportAllDeclaration.call(this, node);
    }
    function EnumDeclaration(node) {
      var id = node.id,
        body = node.body;
      this.word("enum");
      this.space();
      this.print(id);
      this.print(body);
    }
    function enumExplicitType(context, name, hasExplicitType) {
      if (hasExplicitType) {
        context.space();
        context.word("of");
        context.space();
        context.word(name);
      }
      context.space();
    }
    function enumBody(context, node) {
      var members = node.members;
      context.token("{");
      context.indent();
      context.newline();
      var _iterator = _createForOfIteratorHelper(members),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var member = _step.value;
          context.print(member);
          context.newline();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      if (node.hasUnknownMembers) {
        context.token("...");
        context.newline();
      }
      context.dedent();
      context.token("}");
    }
    function EnumBooleanBody(node) {
      var explicitType = node.explicitType;
      enumExplicitType(this, "boolean", explicitType);
      enumBody(this, node);
    }
    function EnumNumberBody(node) {
      var explicitType = node.explicitType;
      enumExplicitType(this, "number", explicitType);
      enumBody(this, node);
    }
    function EnumStringBody(node) {
      var explicitType = node.explicitType;
      enumExplicitType(this, "string", explicitType);
      enumBody(this, node);
    }
    function EnumSymbolBody(node) {
      enumExplicitType(this, "symbol", true);
      enumBody(this, node);
    }
    function EnumDefaultedMember(node) {
      var id = node.id;
      this.print(id);
      this.tokenChar(44);
    }
    function enumInitializedMember(context, node) {
      context.print(node.id);
      context.space();
      context.token("=");
      context.space();
      context.print(node.init);
      context.token(",");
    }
    function EnumBooleanMember(node) {
      enumInitializedMember(this, node);
    }
    function EnumNumberMember(node) {
      enumInitializedMember(this, node);
    }
    function EnumStringMember(node) {
      enumInitializedMember(this, node);
    }
    function FlowExportDeclaration(node) {
      if (node.declaration) {
        var declar = node.declaration;
        this.print(declar);
        if (!isStatement(declar)) this.semicolon();
      } else {
        this.tokenChar(123);
        if (node.specifiers.length) {
          this.space();
          this.printList(node.specifiers);
          this.space();
        }
        this.tokenChar(125);
        if (node.source) {
          this.space();
          this.word("from");
          this.space();
          this.print(node.source);
        }
        this.semicolon();
      }
    }
    function ExistsTypeAnnotation() {
      this.tokenChar(42);
    }
    function FunctionTypeAnnotation(node, parent) {
      this.print(node.typeParameters);
      this.tokenChar(40);
      if (node["this"]) {
        this.word("this");
        this.tokenChar(58);
        this.space();
        this.print(node["this"].typeAnnotation);
        if (node.params.length || node.rest) {
          this.tokenChar(44);
          this.space();
        }
      }
      this.printList(node.params);
      if (node.rest) {
        if (node.params.length) {
          this.tokenChar(44);
          this.space();
        }
        this.token("...");
        this.print(node.rest);
      }
      this.tokenChar(41);
      var type = parent == null ? void 0 : parent.type;
      if (type != null && (type === "ObjectTypeCallProperty" || type === "ObjectTypeInternalSlot" || type === "DeclareFunction" || type === "ObjectTypeProperty" && parent.method)) {
        this.tokenChar(58);
      } else {
        this.space();
        this.token("=>");
      }
      this.space();
      this.print(node.returnType);
    }
    function FunctionTypeParam(node) {
      this.print(node.name);
      if (node.optional) this.tokenChar(63);
      if (node.name) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node.typeAnnotation);
    }
    function InterfaceExtends(node) {
      this.print(node.id);
      this.print(node.typeParameters, true);
    }
    function _interfaceish(node) {
      var _node$extends;
      this.print(node.id);
      this.print(node.typeParameters);
      if ((_node$extends = node["extends"]) != null && _node$extends.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(node["extends"]);
      }
      if (node.type === "DeclareClass") {
        var _node$mixins, _node$implements;
        if ((_node$mixins = node.mixins) != null && _node$mixins.length) {
          this.space();
          this.word("mixins");
          this.space();
          this.printList(node.mixins);
        }
        if ((_node$implements = node["implements"]) != null && _node$implements.length) {
          this.space();
          this.word("implements");
          this.space();
          this.printList(node["implements"]);
        }
      }
      this.space();
      this.print(node.body);
    }
    function _variance(node) {
      var _node$variance;
      var kind = (_node$variance = node.variance) == null ? void 0 : _node$variance.kind;
      if (kind != null) {
        if (kind === "plus") {
          this.tokenChar(43);
        } else if (kind === "minus") {
          this.tokenChar(45);
        }
      }
    }
    function InterfaceDeclaration(node) {
      this.word("interface");
      this.space();
      this._interfaceish(node);
    }
    function andSeparator(occurrenceCount) {
      this.space();
      this.token("&", false, occurrenceCount);
      this.space();
    }
    function InterfaceTypeAnnotation(node) {
      var _node$extends2;
      this.word("interface");
      if ((_node$extends2 = node["extends"]) != null && _node$extends2.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(node["extends"]);
      }
      this.space();
      this.print(node.body);
    }
    function IntersectionTypeAnnotation(node) {
      this.printJoin(node.types, undefined, undefined, andSeparator);
    }
    function MixedTypeAnnotation() {
      this.word("mixed");
    }
    function EmptyTypeAnnotation() {
      this.word("empty");
    }
    function NullableTypeAnnotation(node) {
      this.tokenChar(63);
      this.print(node.typeAnnotation);
    }
    function NumberTypeAnnotation() {
      this.word("number");
    }
    function StringTypeAnnotation() {
      this.word("string");
    }
    function ThisTypeAnnotation() {
      this.word("this");
    }
    function TupleTypeAnnotation(node) {
      this.tokenChar(91);
      this.printList(node.types);
      this.tokenChar(93);
    }
    function TypeofTypeAnnotation(node) {
      this.word("typeof");
      this.space();
      this.print(node.argument);
    }
    function TypeAlias(node) {
      this.word("type");
      this.space();
      this.print(node.id);
      this.print(node.typeParameters);
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node.right);
      this.semicolon();
    }
    function TypeAnnotation(node, parent) {
      this.tokenChar(58);
      this.space();
      if (parent.type === "ArrowFunctionExpression") {
        this.tokenContext |= _index.TokenContext.arrowFlowReturnType;
      } else if (node.optional) {
        this.tokenChar(63);
      }
      this.print(node.typeAnnotation);
    }
    function TypeParameterInstantiation(node) {
      this.tokenChar(60);
      this.printList(node.params);
      this.tokenChar(62);
    }
    function TypeParameter(node) {
      this._variance(node);
      this.word(node.name);
      if (node.bound) {
        this.print(node.bound);
      }
      if (node["default"]) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node["default"]);
      }
    }
    function OpaqueType(node) {
      this.word("opaque");
      this.space();
      this.word("type");
      this.space();
      this.print(node.id);
      this.print(node.typeParameters);
      if (node.supertype) {
        this.tokenChar(58);
        this.space();
        this.print(node.supertype);
      }
      if (node.impltype) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node.impltype);
      }
      this.semicolon();
    }
    function ObjectTypeAnnotation(node) {
      var _this = this;
      if (node.exact) {
        this.token("{|");
      } else {
        this.tokenChar(123);
      }
      var props = [].concat(_toConsumableArray(node.properties), _toConsumableArray(node.callProperties || []), _toConsumableArray(node.indexers || []), _toConsumableArray(node.internalSlots || []));
      if (props.length) {
        this.newline();
        this.space();
        this.printJoin(props, true, true, undefined, undefined, function addNewlines(leading) {
          if (leading && !props[0]) return 1;
        }, function () {
          if (props.length !== 1 || node.inexact) {
            _this.tokenChar(44);
            _this.space();
          }
        });
        this.space();
      }
      if (node.inexact) {
        this.indent();
        this.token("...");
        if (props.length) {
          this.newline();
        }
        this.dedent();
      }
      if (node.exact) {
        this.token("|}");
      } else {
        this.tokenChar(125);
      }
    }
    function ObjectTypeInternalSlot(node) {
      if (node["static"]) {
        this.word("static");
        this.space();
      }
      this.tokenChar(91);
      this.tokenChar(91);
      this.print(node.id);
      this.tokenChar(93);
      this.tokenChar(93);
      if (node.optional) this.tokenChar(63);
      if (!node.method) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node.value);
    }
    function ObjectTypeCallProperty(node) {
      if (node["static"]) {
        this.word("static");
        this.space();
      }
      this.print(node.value);
    }
    function ObjectTypeIndexer(node) {
      if (node["static"]) {
        this.word("static");
        this.space();
      }
      this._variance(node);
      this.tokenChar(91);
      if (node.id) {
        this.print(node.id);
        this.tokenChar(58);
        this.space();
      }
      this.print(node.key);
      this.tokenChar(93);
      this.tokenChar(58);
      this.space();
      this.print(node.value);
    }
    function ObjectTypeProperty(node) {
      if (node.proto) {
        this.word("proto");
        this.space();
      }
      if (node["static"]) {
        this.word("static");
        this.space();
      }
      if (node.kind === "get" || node.kind === "set") {
        this.word(node.kind);
        this.space();
      }
      this._variance(node);
      this.print(node.key);
      if (node.optional) this.tokenChar(63);
      if (!node.method) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node.value);
    }
    function ObjectTypeSpreadProperty(node) {
      this.token("...");
      this.print(node.argument);
    }
    function QualifiedTypeIdentifier(node) {
      this.print(node.qualification);
      this.tokenChar(46);
      this.print(node.id);
    }
    function SymbolTypeAnnotation() {
      this.word("symbol");
    }
    function orSeparator(occurrenceCount) {
      this.space();
      this.token("|", false, occurrenceCount);
      this.space();
    }
    function UnionTypeAnnotation(node) {
      this.printJoin(node.types, undefined, undefined, orSeparator);
    }
    function TypeCastExpression(node) {
      this.tokenChar(40);
      this.print(node.expression);
      this.print(node.typeAnnotation);
      this.tokenChar(41);
    }
    function Variance(node) {
      if (node.kind === "plus") {
        this.tokenChar(43);
      } else {
        this.tokenChar(45);
      }
    }
    function VoidTypeAnnotation() {
      this.word("void");
    }
    function IndexedAccessType(node) {
      this.print(node.objectType, true);
      this.tokenChar(91);
      this.print(node.indexType);
      this.tokenChar(93);
    }
    function OptionalIndexedAccessType(node) {
      this.print(node.objectType);
      if (node.optional) {
        this.token("?.");
      }
      this.tokenChar(91);
      this.print(node.indexType);
      this.tokenChar(93);
    }
  })(flow);
  return flow;
}

var base = {};

var hasRequiredBase;
function requireBase() {
  if (hasRequiredBase) return base;
  hasRequiredBase = 1;
  Object.defineProperty(base, "__esModule", {
    value: true
  });
  base.BlockStatement = BlockStatement;
  base.Directive = Directive;
  base.DirectiveLiteral = DirectiveLiteral;
  base.File = File;
  base.InterpreterDirective = InterpreterDirective;
  base.Placeholder = Placeholder;
  base.Program = Program;
  function File(node) {
    if (node.program) {
      this.print(node.program.interpreter);
    }
    this.print(node.program);
  }
  function Program(node) {
    var _node$directives;
    this.noIndentInnerCommentsHere();
    this.printInnerComments();
    var directivesLen = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;
    if (directivesLen) {
      var _node$directives$trai;
      var newline = node.body.length ? 2 : 1;
      this.printSequence(node.directives, undefined, newline);
      if (!((_node$directives$trai = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai.length)) {
        this.newline(newline);
      }
    }
    this.printSequence(node.body);
  }
  function BlockStatement(node) {
    var _node$directives2;
    this.tokenChar(123);
    var exit = this.enterDelimited();
    var directivesLen = (_node$directives2 = node.directives) == null ? void 0 : _node$directives2.length;
    if (directivesLen) {
      var _node$directives$trai2;
      var newline = node.body.length ? 2 : 1;
      this.printSequence(node.directives, true, newline);
      if (!((_node$directives$trai2 = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai2.length)) {
        this.newline(newline);
      }
    }
    this.printSequence(node.body, true);
    exit();
    this.rightBrace(node);
  }
  function Directive(node) {
    this.print(node.value);
    this.semicolon();
  }
  var unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
  var unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
  function DirectiveLiteral(node) {
    var raw = this.getPossibleRaw(node);
    if (!this.format.minified && raw !== undefined) {
      this.token(raw);
      return;
    }
    var value = node.value;
    if (!unescapedDoubleQuoteRE.test(value)) {
      this.token("\"".concat(value, "\""));
    } else if (!unescapedSingleQuoteRE.test(value)) {
      this.token("'".concat(value, "'"));
    } else {
      throw new Error("Malformed AST: it is not possible to print a directive containing" + " both unescaped single and double quotes.");
    }
  }
  function InterpreterDirective(node) {
    this.token("#!".concat(node.value));
    this.newline(1, true);
  }
  function Placeholder(node) {
    this.token("%%");
    this.print(node.name);
    this.token("%%");
    if (node.expectedNode === "Statement") {
      this.semicolon();
    }
  }
  return base;
}

var jsx = {};

var hasRequiredJsx;
function requireJsx() {
  if (hasRequiredJsx) return jsx;
  hasRequiredJsx = 1;
  Object.defineProperty(jsx, "__esModule", {
    value: true
  });
  jsx.JSXAttribute = JSXAttribute;
  jsx.JSXClosingElement = JSXClosingElement;
  jsx.JSXClosingFragment = JSXClosingFragment;
  jsx.JSXElement = JSXElement;
  jsx.JSXEmptyExpression = JSXEmptyExpression;
  jsx.JSXExpressionContainer = JSXExpressionContainer;
  jsx.JSXFragment = JSXFragment;
  jsx.JSXIdentifier = JSXIdentifier;
  jsx.JSXMemberExpression = JSXMemberExpression;
  jsx.JSXNamespacedName = JSXNamespacedName;
  jsx.JSXOpeningElement = JSXOpeningElement;
  jsx.JSXOpeningFragment = JSXOpeningFragment;
  jsx.JSXSpreadAttribute = JSXSpreadAttribute;
  jsx.JSXSpreadChild = JSXSpreadChild;
  jsx.JSXText = JSXText;
  function JSXAttribute(node) {
    this.print(node.name);
    if (node.value) {
      this.tokenChar(61);
      this.print(node.value);
    }
  }
  function JSXIdentifier(node) {
    this.word(node.name);
  }
  function JSXNamespacedName(node) {
    this.print(node.namespace);
    this.tokenChar(58);
    this.print(node.name);
  }
  function JSXMemberExpression(node) {
    this.print(node.object);
    this.tokenChar(46);
    this.print(node.property);
  }
  function JSXSpreadAttribute(node) {
    this.tokenChar(123);
    this.token("...");
    this.print(node.argument);
    this.rightBrace(node);
  }
  function JSXExpressionContainer(node) {
    this.tokenChar(123);
    this.print(node.expression);
    this.rightBrace(node);
  }
  function JSXSpreadChild(node) {
    this.tokenChar(123);
    this.token("...");
    this.print(node.expression);
    this.rightBrace(node);
  }
  function JSXText(node) {
    var raw = this.getPossibleRaw(node);
    if (raw !== undefined) {
      this.token(raw, true);
    } else {
      this.token(node.value, true);
    }
  }
  function JSXElement(node) {
    var open = node.openingElement;
    this.print(open);
    if (open.selfClosing) return;
    this.indent();
    var _iterator = _createForOfIteratorHelper(node.children),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var child = _step.value;
        this.print(child);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    this.dedent();
    this.print(node.closingElement);
  }
  function spaceSeparator() {
    this.space();
  }
  function JSXOpeningElement(node) {
    this.tokenChar(60);
    this.print(node.name);
    {
      if (node.typeArguments) {
        this.print(node.typeArguments);
      }
      this.print(node.typeParameters);
    }
    if (node.attributes.length > 0) {
      this.space();
      this.printJoin(node.attributes, undefined, undefined, spaceSeparator);
    }
    if (node.selfClosing) {
      this.space();
      this.tokenChar(47);
    }
    this.tokenChar(62);
  }
  function JSXClosingElement(node) {
    this.tokenChar(60);
    this.tokenChar(47);
    this.print(node.name);
    this.tokenChar(62);
  }
  function JSXEmptyExpression() {
    this.printInnerComments();
  }
  function JSXFragment(node) {
    this.print(node.openingFragment);
    this.indent();
    var _iterator2 = _createForOfIteratorHelper(node.children),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var child = _step2.value;
        this.print(child);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    this.dedent();
    this.print(node.closingFragment);
  }
  function JSXOpeningFragment() {
    this.tokenChar(60);
    this.tokenChar(62);
  }
  function JSXClosingFragment() {
    this.token("</");
    this.tokenChar(62);
  }
  return jsx;
}

var typescript = {};

var hasRequiredTypescript;
function requireTypescript() {
  if (hasRequiredTypescript) return typescript;
  hasRequiredTypescript = 1;
  Object.defineProperty(typescript, "__esModule", {
    value: true
  });
  typescript.TSAnyKeyword = TSAnyKeyword;
  typescript.TSArrayType = TSArrayType;
  typescript.TSSatisfiesExpression = typescript.TSAsExpression = TSTypeExpression;
  typescript.TSBigIntKeyword = TSBigIntKeyword;
  typescript.TSBooleanKeyword = TSBooleanKeyword;
  typescript.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
  typescript.TSInterfaceHeritage = typescript.TSClassImplements = TSClassImplements;
  typescript.TSConditionalType = TSConditionalType;
  typescript.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
  typescript.TSConstructorType = TSConstructorType;
  typescript.TSDeclareFunction = TSDeclareFunction;
  typescript.TSDeclareMethod = TSDeclareMethod;
  typescript.TSEnumBody = TSEnumBody;
  typescript.TSEnumDeclaration = TSEnumDeclaration;
  typescript.TSEnumMember = TSEnumMember;
  typescript.TSExportAssignment = TSExportAssignment;
  typescript.TSExternalModuleReference = TSExternalModuleReference;
  typescript.TSFunctionType = TSFunctionType;
  typescript.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
  typescript.TSImportType = TSImportType;
  typescript.TSIndexSignature = TSIndexSignature;
  typescript.TSIndexedAccessType = TSIndexedAccessType;
  typescript.TSInferType = TSInferType;
  typescript.TSInstantiationExpression = TSInstantiationExpression;
  typescript.TSInterfaceBody = TSInterfaceBody;
  typescript.TSInterfaceDeclaration = TSInterfaceDeclaration;
  typescript.TSIntersectionType = TSIntersectionType;
  typescript.TSIntrinsicKeyword = TSIntrinsicKeyword;
  typescript.TSLiteralType = TSLiteralType;
  typescript.TSMappedType = TSMappedType;
  typescript.TSMethodSignature = TSMethodSignature;
  typescript.TSModuleBlock = TSModuleBlock;
  typescript.TSModuleDeclaration = TSModuleDeclaration;
  typescript.TSNamedTupleMember = TSNamedTupleMember;
  typescript.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
  typescript.TSNeverKeyword = TSNeverKeyword;
  typescript.TSNonNullExpression = TSNonNullExpression;
  typescript.TSNullKeyword = TSNullKeyword;
  typescript.TSNumberKeyword = TSNumberKeyword;
  typescript.TSObjectKeyword = TSObjectKeyword;
  typescript.TSOptionalType = TSOptionalType;
  typescript.TSParameterProperty = TSParameterProperty;
  typescript.TSParenthesizedType = TSParenthesizedType;
  typescript.TSPropertySignature = TSPropertySignature;
  typescript.TSQualifiedName = TSQualifiedName;
  typescript.TSRestType = TSRestType;
  typescript.TSStringKeyword = TSStringKeyword;
  typescript.TSSymbolKeyword = TSSymbolKeyword;
  typescript.TSTemplateLiteralType = TSTemplateLiteralType;
  typescript.TSThisType = TSThisType;
  typescript.TSTupleType = TSTupleType;
  typescript.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
  typescript.TSTypeAnnotation = TSTypeAnnotation;
  typescript.TSTypeAssertion = TSTypeAssertion;
  typescript.TSTypeLiteral = TSTypeLiteral;
  typescript.TSTypeOperator = TSTypeOperator;
  typescript.TSTypeParameter = TSTypeParameter;
  typescript.TSTypeParameterDeclaration = typescript.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
  typescript.TSTypePredicate = TSTypePredicate;
  typescript.TSTypeQuery = TSTypeQuery;
  typescript.TSTypeReference = TSTypeReference;
  typescript.TSUndefinedKeyword = TSUndefinedKeyword;
  typescript.TSUnionType = TSUnionType;
  typescript.TSUnknownKeyword = TSUnknownKeyword;
  typescript.TSVoidKeyword = TSVoidKeyword;
  typescript.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;
  typescript.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
  typescript.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
  typescript.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;
  function TSTypeAnnotation(node, parent) {
    this.token((parent.type === "TSFunctionType" || parent.type === "TSConstructorType") && parent.typeAnnotation === node ? "=>" : ":");
    this.space();
    if (node.optional) this.tokenChar(63);
    this.print(node.typeAnnotation);
  }
  function TSTypeParameterInstantiation(node, parent) {
    var _this = this;
    this.tokenChar(60);
    var printTrailingSeparator = parent.type === "ArrowFunctionExpression" && node.params.length === 1;
    if (this.tokenMap && node.start != null && node.end != null) {
      printTrailingSeparator && (printTrailingSeparator = !!this.tokenMap.find(node, function (t) {
        return _this.tokenMap.matchesOriginal(t, ",");
      }));
      printTrailingSeparator || (printTrailingSeparator = this.shouldPrintTrailingComma(">"));
    }
    this.printList(node.params, printTrailingSeparator);
    this.tokenChar(62);
  }
  function TSTypeParameter(node) {
    if (node["in"]) {
      this.word("in");
      this.space();
    }
    if (node.out) {
      this.word("out");
      this.space();
    }
    this.word(node.name);
    if (node.constraint) {
      this.space();
      this.word("extends");
      this.space();
      this.print(node.constraint);
    }
    if (node["default"]) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node["default"]);
    }
  }
  function TSParameterProperty(node) {
    if (node.accessibility) {
      this.word(node.accessibility);
      this.space();
    }
    if (node.readonly) {
      this.word("readonly");
      this.space();
    }
    this._param(node.parameter);
  }
  function TSDeclareFunction(node, parent) {
    if (node.declare) {
      this.word("declare");
      this.space();
    }
    this._functionHead(node, parent);
    this.semicolon();
  }
  function TSDeclareMethod(node) {
    this._classMethodHead(node);
    this.semicolon();
  }
  function TSQualifiedName(node) {
    this.print(node.left);
    this.tokenChar(46);
    this.print(node.right);
  }
  function TSCallSignatureDeclaration(node) {
    this.tsPrintSignatureDeclarationBase(node);
    maybePrintTrailingCommaOrSemicolon(this, node);
  }
  function maybePrintTrailingCommaOrSemicolon(printer, node) {
    if (!printer.tokenMap || !node.start || !node.end) {
      printer.semicolon();
      return;
    }
    if (printer.tokenMap.endMatches(node, ",")) {
      printer.token(",");
    } else if (printer.tokenMap.endMatches(node, ";")) {
      printer.semicolon();
    }
  }
  function TSConstructSignatureDeclaration(node) {
    this.word("new");
    this.space();
    this.tsPrintSignatureDeclarationBase(node);
    maybePrintTrailingCommaOrSemicolon(this, node);
  }
  function TSPropertySignature(node) {
    var readonly = node.readonly;
    if (readonly) {
      this.word("readonly");
      this.space();
    }
    this.tsPrintPropertyOrMethodName(node);
    this.print(node.typeAnnotation);
    maybePrintTrailingCommaOrSemicolon(this, node);
  }
  function tsPrintPropertyOrMethodName(node) {
    if (node.computed) {
      this.tokenChar(91);
    }
    this.print(node.key);
    if (node.computed) {
      this.tokenChar(93);
    }
    if (node.optional) {
      this.tokenChar(63);
    }
  }
  function TSMethodSignature(node) {
    var kind = node.kind;
    if (kind === "set" || kind === "get") {
      this.word(kind);
      this.space();
    }
    this.tsPrintPropertyOrMethodName(node);
    this.tsPrintSignatureDeclarationBase(node);
    maybePrintTrailingCommaOrSemicolon(this, node);
  }
  function TSIndexSignature(node) {
    var readonly = node.readonly,
      isStatic = node["static"];
    if (isStatic) {
      this.word("static");
      this.space();
    }
    if (readonly) {
      this.word("readonly");
      this.space();
    }
    this.tokenChar(91);
    this._parameters(node.parameters, "]");
    this.print(node.typeAnnotation);
    maybePrintTrailingCommaOrSemicolon(this, node);
  }
  function TSAnyKeyword() {
    this.word("any");
  }
  function TSBigIntKeyword() {
    this.word("bigint");
  }
  function TSUnknownKeyword() {
    this.word("unknown");
  }
  function TSNumberKeyword() {
    this.word("number");
  }
  function TSObjectKeyword() {
    this.word("object");
  }
  function TSBooleanKeyword() {
    this.word("boolean");
  }
  function TSStringKeyword() {
    this.word("string");
  }
  function TSSymbolKeyword() {
    this.word("symbol");
  }
  function TSVoidKeyword() {
    this.word("void");
  }
  function TSUndefinedKeyword() {
    this.word("undefined");
  }
  function TSNullKeyword() {
    this.word("null");
  }
  function TSNeverKeyword() {
    this.word("never");
  }
  function TSIntrinsicKeyword() {
    this.word("intrinsic");
  }
  function TSThisType() {
    this.word("this");
  }
  function TSFunctionType(node) {
    this.tsPrintFunctionOrConstructorType(node);
  }
  function TSConstructorType(node) {
    if (node["abstract"]) {
      this.word("abstract");
      this.space();
    }
    this.word("new");
    this.space();
    this.tsPrintFunctionOrConstructorType(node);
  }
  function tsPrintFunctionOrConstructorType(node) {
    var typeParameters = node.typeParameters;
    var parameters = node.parameters;
    this.print(typeParameters);
    this.tokenChar(40);
    this._parameters(parameters, ")");
    this.space();
    var returnType = node.typeAnnotation;
    this.print(returnType);
  }
  function TSTypeReference(node) {
    var typeArguments = node.typeParameters;
    this.print(node.typeName, !!typeArguments);
    this.print(typeArguments);
  }
  function TSTypePredicate(node) {
    if (node.asserts) {
      this.word("asserts");
      this.space();
    }
    this.print(node.parameterName);
    if (node.typeAnnotation) {
      this.space();
      this.word("is");
      this.space();
      this.print(node.typeAnnotation.typeAnnotation);
    }
  }
  function TSTypeQuery(node) {
    this.word("typeof");
    this.space();
    this.print(node.exprName);
    var typeArguments = node.typeParameters;
    if (typeArguments) {
      this.print(typeArguments);
    }
  }
  function TSTypeLiteral(node) {
    var _this2 = this;
    printBraced(this, node, function () {
      return _this2.printJoin(node.members, true, true);
    });
  }
  function TSArrayType(node) {
    this.print(node.elementType, true);
    this.tokenChar(91);
    this.tokenChar(93);
  }
  function TSTupleType(node) {
    this.tokenChar(91);
    this.printList(node.elementTypes, this.shouldPrintTrailingComma("]"));
    this.tokenChar(93);
  }
  function TSOptionalType(node) {
    this.print(node.typeAnnotation);
    this.tokenChar(63);
  }
  function TSRestType(node) {
    this.token("...");
    this.print(node.typeAnnotation);
  }
  function TSNamedTupleMember(node) {
    this.print(node.label);
    if (node.optional) this.tokenChar(63);
    this.tokenChar(58);
    this.space();
    this.print(node.elementType);
  }
  function TSUnionType(node) {
    tsPrintUnionOrIntersectionType(this, node, "|");
  }
  function TSIntersectionType(node) {
    tsPrintUnionOrIntersectionType(this, node, "&");
  }
  function tsPrintUnionOrIntersectionType(printer, node, sep) {
    var _printer$tokenMap;
    var hasLeadingToken = 0;
    if ((_printer$tokenMap = printer.tokenMap) != null && _printer$tokenMap.startMatches(node, sep)) {
      hasLeadingToken = 1;
      printer.token(sep);
    }
    printer.printJoin(node.types, undefined, undefined, function (i) {
      this.space();
      this.token(sep, null, i + hasLeadingToken);
      this.space();
    });
  }
  function TSConditionalType(node) {
    this.print(node.checkType);
    this.space();
    this.word("extends");
    this.space();
    this.print(node.extendsType);
    this.space();
    this.tokenChar(63);
    this.space();
    this.print(node.trueType);
    this.space();
    this.tokenChar(58);
    this.space();
    this.print(node.falseType);
  }
  function TSInferType(node) {
    this.word("infer");
    this.print(node.typeParameter);
  }
  function TSParenthesizedType(node) {
    this.tokenChar(40);
    this.print(node.typeAnnotation);
    this.tokenChar(41);
  }
  function TSTypeOperator(node) {
    this.word(node.operator);
    this.space();
    this.print(node.typeAnnotation);
  }
  function TSIndexedAccessType(node) {
    this.print(node.objectType, true);
    this.tokenChar(91);
    this.print(node.indexType);
    this.tokenChar(93);
  }
  function TSMappedType(node) {
    var nameType = node.nameType,
      optional = node.optional,
      readonly = node.readonly,
      typeAnnotation = node.typeAnnotation;
    this.tokenChar(123);
    var exit = this.enterDelimited();
    this.space();
    if (readonly) {
      tokenIfPlusMinus(this, readonly);
      this.word("readonly");
      this.space();
    }
    this.tokenChar(91);
    {
      this.word(node.typeParameter.name);
    }
    this.space();
    this.word("in");
    this.space();
    {
      this.print(node.typeParameter.constraint);
    }
    if (nameType) {
      this.space();
      this.word("as");
      this.space();
      this.print(nameType);
    }
    this.tokenChar(93);
    if (optional) {
      tokenIfPlusMinus(this, optional);
      this.tokenChar(63);
    }
    if (typeAnnotation) {
      this.tokenChar(58);
      this.space();
      this.print(typeAnnotation);
    }
    this.space();
    exit();
    this.tokenChar(125);
  }
  function tokenIfPlusMinus(self, tok) {
    if (tok !== true) {
      self.token(tok);
    }
  }
  function TSTemplateLiteralType(node) {
    this._printTemplate(node, node.types);
  }
  function TSLiteralType(node) {
    this.print(node.literal);
  }
  function TSClassImplements(node) {
    this.print(node.expression);
    this.print(node.typeArguments);
  }
  function TSInterfaceDeclaration(node) {
    var declare = node.declare,
      id = node.id,
      typeParameters = node.typeParameters,
      extendz = node["extends"],
      body = node.body;
    if (declare) {
      this.word("declare");
      this.space();
    }
    this.word("interface");
    this.space();
    this.print(id);
    this.print(typeParameters);
    if (extendz != null && extendz.length) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(extendz);
    }
    this.space();
    this.print(body);
  }
  function TSInterfaceBody(node) {
    var _this3 = this;
    printBraced(this, node, function () {
      return _this3.printJoin(node.body, true, true);
    });
  }
  function TSTypeAliasDeclaration(node) {
    var declare = node.declare,
      id = node.id,
      typeParameters = node.typeParameters,
      typeAnnotation = node.typeAnnotation;
    if (declare) {
      this.word("declare");
      this.space();
    }
    this.word("type");
    this.space();
    this.print(id);
    this.print(typeParameters);
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(typeAnnotation);
    this.semicolon();
  }
  function TSTypeExpression(node) {
    var type = node.type,
      expression = node.expression,
      typeAnnotation = node.typeAnnotation;
    this.print(expression, true);
    this.space();
    this.word(type === "TSAsExpression" ? "as" : "satisfies");
    this.space();
    this.print(typeAnnotation);
  }
  function TSTypeAssertion(node) {
    var typeAnnotation = node.typeAnnotation,
      expression = node.expression;
    this.tokenChar(60);
    this.print(typeAnnotation);
    this.tokenChar(62);
    this.space();
    this.print(expression);
  }
  function TSInstantiationExpression(node) {
    this.print(node.expression);
    {
      this.print(node.typeParameters);
    }
  }
  function TSEnumDeclaration(node) {
    var declare = node.declare,
      isConst = node["const"],
      id = node.id;
    if (declare) {
      this.word("declare");
      this.space();
    }
    if (isConst) {
      this.word("const");
      this.space();
    }
    this.word("enum");
    this.space();
    this.print(id);
    this.space();
    {
      TSEnumBody.call(this, node);
    }
  }
  function TSEnumBody(node) {
    var _this4 = this;
    printBraced(this, node, function () {
      var _this$shouldPrintTrai;
      return _this4.printList(node.members, (_this$shouldPrintTrai = _this4.shouldPrintTrailingComma("}")) != null ? _this$shouldPrintTrai : true, true, true);
    });
  }
  function TSEnumMember(node) {
    var id = node.id,
      initializer = node.initializer;
    this.print(id);
    if (initializer) {
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(initializer);
    }
  }
  function TSModuleDeclaration(node) {
    var declare = node.declare,
      id = node.id,
      kind = node.kind;
    if (declare) {
      this.word("declare");
      this.space();
    }
    {
      if (!node.global) {
        this.word(kind != null ? kind : id.type === "Identifier" ? "namespace" : "module");
        this.space();
      }
      this.print(id);
      if (!node.body) {
        this.semicolon();
        return;
      }
      var body = node.body;
      while (body.type === "TSModuleDeclaration") {
        this.tokenChar(46);
        this.print(body.id);
        body = body.body;
      }
      this.space();
      this.print(body);
    }
  }
  function TSModuleBlock(node) {
    var _this5 = this;
    printBraced(this, node, function () {
      return _this5.printSequence(node.body, true);
    });
  }
  function TSImportType(node) {
    var argument = node.argument,
      qualifier = node.qualifier,
      options = node.options;
    this.word("import");
    this.tokenChar(40);
    this.print(argument);
    if (options) {
      this.tokenChar(44);
      this.print(options);
    }
    this.tokenChar(41);
    if (qualifier) {
      this.tokenChar(46);
      this.print(qualifier);
    }
    var typeArguments = node.typeParameters;
    if (typeArguments) {
      this.print(typeArguments);
    }
  }
  function TSImportEqualsDeclaration(node) {
    var id = node.id,
      moduleReference = node.moduleReference;
    if (node.isExport) {
      this.word("export");
      this.space();
    }
    this.word("import");
    this.space();
    this.print(id);
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(moduleReference);
    this.semicolon();
  }
  function TSExternalModuleReference(node) {
    this.token("require(");
    this.print(node.expression);
    this.tokenChar(41);
  }
  function TSNonNullExpression(node) {
    this.print(node.expression);
    this.tokenChar(33);
  }
  function TSExportAssignment(node) {
    this.word("export");
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node.expression);
    this.semicolon();
  }
  function TSNamespaceExportDeclaration(node) {
    this.word("export");
    this.space();
    this.word("as");
    this.space();
    this.word("namespace");
    this.space();
    this.print(node.id);
    this.semicolon();
  }
  function tsPrintSignatureDeclarationBase(node) {
    var typeParameters = node.typeParameters;
    var parameters = node.parameters;
    this.print(typeParameters);
    this.tokenChar(40);
    this._parameters(parameters, ")");
    var returnType = node.typeAnnotation;
    this.print(returnType);
  }
  function tsPrintClassMemberModifiers(node) {
    var isPrivateField = node.type === "ClassPrivateProperty";
    var isPublicField = node.type === "ClassAccessorProperty" || node.type === "ClassProperty";
    printModifiersList(this, node, [isPublicField && node.declare && "declare", !isPrivateField && node.accessibility]);
    if (node["static"]) {
      this.word("static");
      this.space();
    }
    printModifiersList(this, node, [!isPrivateField && node.override && "override", !isPrivateField && node["abstract"] && "abstract", (isPublicField || isPrivateField) && node.readonly && "readonly"]);
  }
  function printBraced(printer, node, cb) {
    printer.token("{");
    var exit = printer.enterDelimited();
    cb();
    exit();
    printer.rightBrace(node);
  }
  function printModifiersList(printer, node, modifiers) {
    var _printer$tokenMap2;
    var modifiersSet = new Set();
    var _iterator = _createForOfIteratorHelper(modifiers),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var modifier = _step.value;
        if (modifier) modifiersSet.add(modifier);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    (_printer$tokenMap2 = printer.tokenMap) == null || _printer$tokenMap2.find(node, function (tok) {
      if (modifiersSet.has(tok.value)) {
        printer.token(tok.value);
        printer.space();
        modifiersSet["delete"](tok.value);
        return modifiersSet.size === 0;
      }
    });
    var _iterator2 = _createForOfIteratorHelper(modifiersSet),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _modifier = _step2.value;
        printer.word(_modifier);
        printer.space();
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  return typescript;
}

var hasRequiredGenerators;
function requireGenerators() {
  if (hasRequiredGenerators) return generators;
  hasRequiredGenerators = 1;
  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _templateLiterals = requireTemplateLiterals();
    Object.keys(_templateLiterals).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _templateLiterals[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _templateLiterals[key];
        }
      });
    });
    var _expressions = requireExpressions();
    Object.keys(_expressions).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _expressions[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _expressions[key];
        }
      });
    });
    var _statements = requireStatements();
    Object.keys(_statements).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _statements[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _statements[key];
        }
      });
    });
    var _classes = requireClasses();
    Object.keys(_classes).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _classes[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _classes[key];
        }
      });
    });
    var _methods = requireMethods();
    Object.keys(_methods).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _methods[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _methods[key];
        }
      });
    });
    var _modules = requireModules();
    Object.keys(_modules).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _modules[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _modules[key];
        }
      });
    });
    var _types = requireTypes();
    Object.keys(_types).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _types[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _types[key];
        }
      });
    });
    var _flow = requireFlow();
    Object.keys(_flow).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _flow[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _flow[key];
        }
      });
    });
    var _base = requireBase();
    Object.keys(_base).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _base[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _base[key];
        }
      });
    });
    var _jsx = requireJsx();
    Object.keys(_jsx).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _jsx[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _jsx[key];
        }
      });
    });
    var _typescript = requireTypescript();
    Object.keys(_typescript).forEach(function (key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _typescript[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _typescript[key];
        }
      });
    });
  })(generators);
  return generators;
}

var deprecated = {};

var hasRequiredDeprecated;
function requireDeprecated() {
  if (hasRequiredDeprecated) return deprecated;
  hasRequiredDeprecated = 1;
  Object.defineProperty(deprecated, "__esModule", {
    value: true
  });
  deprecated.addDeprecatedGenerators = addDeprecatedGenerators;
  function addDeprecatedGenerators(PrinterClass) {
    {
      var deprecatedBabel7Generators = {
        Noop: function Noop() {},
        TSExpressionWithTypeArguments: function TSExpressionWithTypeArguments(node) {
          this.print(node.expression);
          this.print(node.typeParameters);
        },
        DecimalLiteral: function DecimalLiteral(node) {
          var raw = this.getPossibleRaw(node);
          if (!this.format.minified && raw !== undefined) {
            this.word(raw);
            return;
          }
          this.word(node.value + "m");
        }
      };
      Object.assign(PrinterClass.prototype, deprecatedBabel7Generators);
    }
  }
  return deprecated;
}

var hasRequiredPrinter;
function requirePrinter() {
  if (hasRequiredPrinter) return printer;
  hasRequiredPrinter = 1;
  Object.defineProperty(printer, "__esModule", {
    value: true
  });
  printer["default"] = void 0;
  var _buffer = requireBuffer();
  var n = requireNode();
  var _t = requireLib$4();
  var _tokenMap = requireTokenMap();
  var generatorFunctions = requireGenerators();
  var _deprecated = requireDeprecated();
  var isExpression = _t.isExpression,
    isFunction = _t.isFunction,
    isStatement = _t.isStatement,
    isClassBody = _t.isClassBody,
    isTSInterfaceBody = _t.isTSInterfaceBody,
    isTSEnumMember = _t.isTSEnumMember;
  var SCIENTIFIC_NOTATION = /e/i;
  var ZERO_DECIMAL_INTEGER = /\.0+$/;
  var HAS_NEWLINE = /[\n\r\u2028\u2029]/;
  var HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\n\r\u2028\u2029]|\*\//;
  function commentIsNewline(c) {
    return c.type === "CommentLine" || HAS_NEWLINE.test(c.value);
  }
  var needsParens = n.needsParens;
  var Printer = /*#__PURE__*/function () {
    function Printer(format, map, tokens, originalCode) {
      _classCallCheck(this, Printer);
      this.inForStatementInit = false;
      this.tokenContext = 0;
      this._tokens = null;
      this._originalCode = null;
      this._currentNode = null;
      this._indent = 0;
      this._indentRepeat = 0;
      this._insideAux = false;
      this._noLineTerminator = false;
      this._noLineTerminatorAfterNode = null;
      this._printAuxAfterOnNextUserNode = false;
      this._printedComments = new Set();
      this._endsWithInteger = false;
      this._endsWithWord = false;
      this._endsWithDiv = false;
      this._lastCommentLine = 0;
      this._endsWithInnerRaw = false;
      this._indentInnerComments = true;
      this.tokenMap = null;
      this._boundGetRawIdentifier = this._getRawIdentifier.bind(this);
      this._printSemicolonBeforeNextNode = -1;
      this._printSemicolonBeforeNextToken = -1;
      this.format = format;
      this._tokens = tokens;
      this._originalCode = originalCode;
      this._indentRepeat = format.indent.style.length;
      this._inputMap = map == null ? void 0 : map._inputMap;
      this._buf = new _buffer["default"](map, format.indent.style[0]);
    }
    return _createClass(Printer, [{
      key: "enterForStatementInit",
      value: function enterForStatementInit() {
        var _this = this;
        if (this.inForStatementInit) return function () {};
        this.inForStatementInit = true;
        return function () {
          _this.inForStatementInit = false;
        };
      }
    }, {
      key: "enterDelimited",
      value: function enterDelimited() {
        var _this2 = this;
        var oldInForStatementInit = this.inForStatementInit;
        var oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
        if (oldInForStatementInit === false && oldNoLineTerminatorAfterNode === null) {
          return function () {};
        }
        this.inForStatementInit = false;
        this._noLineTerminatorAfterNode = null;
        return function () {
          _this2.inForStatementInit = oldInForStatementInit;
          _this2._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;
        };
      }
    }, {
      key: "generate",
      value: function generate(ast) {
        if (this.format.preserveFormat) {
          this.tokenMap = new _tokenMap.TokenMap(ast, this._tokens, this._originalCode);
        }
        this.print(ast);
        this._maybeAddAuxComment();
        return this._buf.get();
      }
    }, {
      key: "indent",
      value: function indent() {
        var format = this.format;
        if (format.preserveFormat || format.compact || format.concise) {
          return;
        }
        this._indent++;
      }
    }, {
      key: "dedent",
      value: function dedent() {
        var format = this.format;
        if (format.preserveFormat || format.compact || format.concise) {
          return;
        }
        this._indent--;
      }
    }, {
      key: "semicolon",
      value: function semicolon() {
        var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        this._maybeAddAuxComment();
        if (force) {
          this._appendChar(59);
          this._noLineTerminator = false;
          return;
        }
        if (this.tokenMap) {
          var node = this._currentNode;
          if (node.start != null && node.end != null) {
            if (!this.tokenMap.endMatches(node, ";")) {
              this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();
              return;
            }
            var indexes = this.tokenMap.getIndexes(this._currentNode);
            this._catchUpTo(this._tokens[indexes[indexes.length - 1]].loc.start);
          }
        }
        this._queue(59);
        this._noLineTerminator = false;
      }
    }, {
      key: "rightBrace",
      value: function rightBrace(node) {
        if (this.format.minified) {
          this._buf.removeLastSemicolon();
        }
        this.sourceWithOffset("end", node.loc, -1);
        this.tokenChar(125);
      }
    }, {
      key: "rightParens",
      value: function rightParens(node) {
        this.sourceWithOffset("end", node.loc, -1);
        this.tokenChar(41);
      }
    }, {
      key: "space",
      value: function space() {
        var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var format = this.format;
        if (format.compact || format.preserveFormat) return;
        if (force) {
          this._space();
        } else if (this._buf.hasContent()) {
          var lastCp = this.getLastChar();
          if (lastCp !== 32 && lastCp !== 10) {
            this._space();
          }
        }
      }
    }, {
      key: "word",
      value: function word(str) {
        var noLineTerminatorAfter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        this.tokenContext = 0;
        this._maybePrintInnerComments(str);
        this._maybeAddAuxComment();
        if (this.tokenMap) this._catchUpToCurrentToken(str);
        if (this._endsWithWord || this._endsWithDiv && str.charCodeAt(0) === 47) {
          this._space();
        }
        this._append(str, false);
        this._endsWithWord = true;
        this._noLineTerminator = noLineTerminatorAfter;
      }
    }, {
      key: "number",
      value: function number(str, _number) {
        function isNonDecimalLiteral(str) {
          if (str.length > 2 && str.charCodeAt(0) === 48) {
            var secondChar = str.charCodeAt(1);
            return secondChar === 98 || secondChar === 111 || secondChar === 120;
          }
          return false;
        }
        this.word(str);
        this._endsWithInteger = Number.isInteger(_number) && !isNonDecimalLiteral(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;
      }
    }, {
      key: "token",
      value: function token(str) {
        var maybeNewline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var occurrenceCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        this.tokenContext = 0;
        this._maybePrintInnerComments(str, occurrenceCount);
        this._maybeAddAuxComment();
        if (this.tokenMap) this._catchUpToCurrentToken(str, occurrenceCount);
        var lastChar = this.getLastChar();
        var strFirst = str.charCodeAt(0);
        if (lastChar === 33 && (str === "--" || strFirst === 61) || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {
          this._space();
        }
        this._append(str, maybeNewline);
        this._noLineTerminator = false;
      }
    }, {
      key: "tokenChar",
      value: function tokenChar(_char) {
        this.tokenContext = 0;
        var str = String.fromCharCode(_char);
        this._maybePrintInnerComments(str);
        this._maybeAddAuxComment();
        if (this.tokenMap) this._catchUpToCurrentToken(str);
        var lastChar = this.getLastChar();
        if (_char === 43 && lastChar === 43 || _char === 45 && lastChar === 45 || _char === 46 && this._endsWithInteger) {
          this._space();
        }
        this._appendChar(_char);
        this._noLineTerminator = false;
      }
    }, {
      key: "newline",
      value: function newline() {
        var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        var force = arguments.length > 1 ? arguments[1] : undefined;
        if (i <= 0) return;
        if (!force) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) {
            this.space();
            return;
          }
        }
        if (i > 2) i = 2;
        i -= this._buf.getNewlineCount();
        for (var j = 0; j < i; j++) {
          this._newline();
        }
        return;
      }
    }, {
      key: "endsWith",
      value: function endsWith(_char2) {
        return this.getLastChar() === _char2;
      }
    }, {
      key: "getLastChar",
      value: function getLastChar() {
        return this._buf.getLastChar();
      }
    }, {
      key: "endsWithCharAndNewline",
      value: function endsWithCharAndNewline() {
        return this._buf.endsWithCharAndNewline();
      }
    }, {
      key: "removeTrailingNewline",
      value: function removeTrailingNewline() {
        this._buf.removeTrailingNewline();
      }
    }, {
      key: "exactSource",
      value: function exactSource(loc, cb) {
        if (!loc) {
          cb();
          return;
        }
        this._catchUp("start", loc);
        this._buf.exactSource(loc, cb);
      }
    }, {
      key: "source",
      value: function source(prop, loc) {
        if (!loc) return;
        this._catchUp(prop, loc);
        this._buf.source(prop, loc);
      }
    }, {
      key: "sourceWithOffset",
      value: function sourceWithOffset(prop, loc, columnOffset) {
        if (!loc || this.format.preserveFormat) return;
        this._catchUp(prop, loc);
        this._buf.sourceWithOffset(prop, loc, columnOffset);
      }
    }, {
      key: "sourceIdentifierName",
      value: function sourceIdentifierName(identifierName, pos) {
        if (!this._buf._canMarkIdName) return;
        var sourcePosition = this._buf._sourcePosition;
        sourcePosition.identifierNamePos = pos;
        sourcePosition.identifierName = identifierName;
      }
    }, {
      key: "_space",
      value: function _space() {
        this._queue(32);
      }
    }, {
      key: "_newline",
      value: function _newline() {
        this._queue(10);
      }
    }, {
      key: "_catchUpToCurrentToken",
      value: function _catchUpToCurrentToken(str) {
        var occurrenceCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var token = this.tokenMap.findMatching(this._currentNode, str, occurrenceCount);
        if (token) this._catchUpTo(token.loc.start);
        if (this._printSemicolonBeforeNextToken !== -1 && this._printSemicolonBeforeNextToken === this._buf.getCurrentLine()) {
          this._buf.appendChar(59);
          this._endsWithWord = false;
          this._endsWithInteger = false;
          this._endsWithDiv = false;
        }
        this._printSemicolonBeforeNextToken = -1;
        this._printSemicolonBeforeNextNode = -1;
      }
    }, {
      key: "_append",
      value: function _append(str, maybeNewline) {
        this._maybeIndent(str.charCodeAt(0));
        this._buf.append(str, maybeNewline);
        this._endsWithWord = false;
        this._endsWithInteger = false;
        this._endsWithDiv = false;
      }
    }, {
      key: "_appendChar",
      value: function _appendChar(_char3) {
        this._maybeIndent(_char3);
        this._buf.appendChar(_char3);
        this._endsWithWord = false;
        this._endsWithInteger = false;
        this._endsWithDiv = false;
      }
    }, {
      key: "_queue",
      value: function _queue(_char4) {
        this._maybeIndent(_char4);
        this._buf.queue(_char4);
        this._endsWithWord = false;
        this._endsWithInteger = false;
      }
    }, {
      key: "_maybeIndent",
      value: function _maybeIndent(firstChar) {
        if (this._indent && firstChar !== 10 && this.endsWith(10)) {
          this._buf.queueIndentation(this._getIndent());
        }
      }
    }, {
      key: "_shouldIndent",
      value: function _shouldIndent(firstChar) {
        if (this._indent && firstChar !== 10 && this.endsWith(10)) {
          return true;
        }
      }
    }, {
      key: "catchUp",
      value: function catchUp(line) {
        if (!this.format.retainLines) return;
        var count = line - this._buf.getCurrentLine();
        for (var i = 0; i < count; i++) {
          this._newline();
        }
      }
    }, {
      key: "_catchUp",
      value: function _catchUp(prop, loc) {
        var format = this.format;
        if (!format.preserveFormat) {
          if (format.retainLines && loc != null && loc[prop]) {
            this.catchUp(loc[prop].line);
          }
          return;
        }
        var pos = loc == null ? void 0 : loc[prop];
        if (pos != null) this._catchUpTo(pos);
      }
    }, {
      key: "_catchUpTo",
      value: function _catchUpTo(_ref) {
        var line = _ref.line,
          column = _ref.column,
          index = _ref.index;
        var count = line - this._buf.getCurrentLine();
        if (count > 0 && this._noLineTerminator) {
          return;
        }
        for (var i = 0; i < count; i++) {
          this._newline();
        }
        var spacesCount = count > 0 ? column : column - this._buf.getCurrentColumn();
        if (spacesCount > 0) {
          var spaces = this._originalCode ? this._originalCode.slice(index - spacesCount, index).replace(/(?:[\0-\x08\n\r-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, " ") : " ".repeat(spacesCount);
          this._append(spaces, false);
        }
      }
    }, {
      key: "_getIndent",
      value: function _getIndent() {
        return this._indentRepeat * this._indent;
      }
    }, {
      key: "printTerminatorless",
      value: function printTerminatorless(node) {
        this._noLineTerminator = true;
        this.print(node);
      }
    }, {
      key: "print",
      value: function print(node, noLineTerminatorAfter, trailingCommentsLineOffset) {
        var _node$extra, _node$leadingComments, _node$leadingComments2;
        if (!node) return;
        this._endsWithInnerRaw = false;
        var nodeType = node.type;
        var format = this.format;
        var oldConcise = format.concise;
        if (node._compact) {
          format.concise = true;
        }
        var printMethod = this[nodeType];
        if (printMethod === undefined) {
          throw new ReferenceError("unknown node of type ".concat(JSON.stringify(nodeType), " with constructor ").concat(JSON.stringify(node.constructor.name)));
        }
        var parent = this._currentNode;
        this._currentNode = node;
        if (this.tokenMap) {
          this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode;
        }
        var oldInAux = this._insideAux;
        this._insideAux = node.loc == null;
        this._maybeAddAuxComment(this._insideAux && !oldInAux);
        var parenthesized = (_node$extra = node.extra) == null ? void 0 : _node$extra.parenthesized;
        var shouldPrintParens = parenthesized && format.preserveFormat || parenthesized && format.retainFunctionParens && nodeType === "FunctionExpression" || needsParens(node, parent, this.tokenContext, this.inForStatementInit, format.preserveFormat ? this._boundGetRawIdentifier : undefined);
        if (!shouldPrintParens && parenthesized && (_node$leadingComments = node.leadingComments) != null && _node$leadingComments.length && node.leadingComments[0].type === "CommentBlock") {
          var parentType = parent == null ? void 0 : parent.type;
          switch (parentType) {
            case "ExpressionStatement":
            case "VariableDeclarator":
            case "AssignmentExpression":
            case "ReturnStatement":
              break;
            case "CallExpression":
            case "OptionalCallExpression":
            case "NewExpression":
              if (parent.callee !== node) break;
            default:
              shouldPrintParens = true;
          }
        }
        var indentParenthesized = false;
        if (!shouldPrintParens && this._noLineTerminator && ((_node$leadingComments2 = node.leadingComments) != null && _node$leadingComments2.some(commentIsNewline) || this.format.retainLines && node.loc && node.loc.start.line > this._buf.getCurrentLine())) {
          shouldPrintParens = true;
          indentParenthesized = true;
        }
        var oldNoLineTerminatorAfterNode;
        var oldInForStatementInitWasTrue;
        if (!shouldPrintParens) {
          noLineTerminatorAfter || (noLineTerminatorAfter = parent && this._noLineTerminatorAfterNode === parent && n.isLastChild(parent, node));
          if (noLineTerminatorAfter) {
            var _node$trailingComment;
            if ((_node$trailingComment = node.trailingComments) != null && _node$trailingComment.some(commentIsNewline)) {
              if (isExpression(node)) shouldPrintParens = true;
            } else {
              oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
              this._noLineTerminatorAfterNode = node;
            }
          }
        }
        if (shouldPrintParens) {
          this.tokenChar(40);
          if (indentParenthesized) this.indent();
          this._endsWithInnerRaw = false;
          if (this.inForStatementInit) {
            oldInForStatementInitWasTrue = true;
            this.inForStatementInit = false;
          }
          oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
          this._noLineTerminatorAfterNode = null;
        }
        this._lastCommentLine = 0;
        this._printLeadingComments(node, parent);
        var loc = nodeType === "Program" || nodeType === "File" ? null : node.loc;
        this.exactSource(loc, printMethod.bind(this, node, parent));
        if (shouldPrintParens) {
          this._printTrailingComments(node, parent);
          if (indentParenthesized) {
            this.dedent();
            this.newline();
          }
          this.tokenChar(41);
          this._noLineTerminator = noLineTerminatorAfter;
          if (oldInForStatementInitWasTrue) this.inForStatementInit = true;
        } else if (noLineTerminatorAfter && !this._noLineTerminator) {
          this._noLineTerminator = true;
          this._printTrailingComments(node, parent);
        } else {
          this._printTrailingComments(node, parent, trailingCommentsLineOffset);
        }
        this._currentNode = parent;
        format.concise = oldConcise;
        this._insideAux = oldInAux;
        if (oldNoLineTerminatorAfterNode !== undefined) {
          this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;
        }
        this._endsWithInnerRaw = false;
      }
    }, {
      key: "_maybeAddAuxComment",
      value: function _maybeAddAuxComment(enteredPositionlessNode) {
        if (enteredPositionlessNode) this._printAuxBeforeComment();
        if (!this._insideAux) this._printAuxAfterComment();
      }
    }, {
      key: "_printAuxBeforeComment",
      value: function _printAuxBeforeComment() {
        if (this._printAuxAfterOnNextUserNode) return;
        this._printAuxAfterOnNextUserNode = true;
        var comment = this.format.auxiliaryCommentBefore;
        if (comment) {
          this._printComment({
            type: "CommentBlock",
            value: comment
          }, 0);
        }
      }
    }, {
      key: "_printAuxAfterComment",
      value: function _printAuxAfterComment() {
        if (!this._printAuxAfterOnNextUserNode) return;
        this._printAuxAfterOnNextUserNode = false;
        var comment = this.format.auxiliaryCommentAfter;
        if (comment) {
          this._printComment({
            type: "CommentBlock",
            value: comment
          }, 0);
        }
      }
    }, {
      key: "getPossibleRaw",
      value: function getPossibleRaw(node) {
        var extra = node.extra;
        if ((extra == null ? void 0 : extra.raw) != null && extra.rawValue != null && node.value === extra.rawValue) {
          return extra.raw;
        }
      }
    }, {
      key: "printJoin",
      value: function printJoin(nodes, statement, indent, separator, printTrailingSeparator, addNewlines, iterator, trailingCommentsLineOffset) {
        if (!(nodes != null && nodes.length)) return;
        if (indent == null && this.format.retainLines) {
          var _nodes$0$loc;
          var startLine = (_nodes$0$loc = nodes[0].loc) == null ? void 0 : _nodes$0$loc.start.line;
          if (startLine != null && startLine !== this._buf.getCurrentLine()) {
            indent = true;
          }
        }
        if (indent) this.indent();
        var newlineOpts = {
          addNewlines: addNewlines,
          nextNodeStartLine: 0
        };
        var boundSeparator = separator == null ? void 0 : separator.bind(this);
        var len = nodes.length;
        for (var i = 0; i < len; i++) {
          var node = nodes[i];
          if (!node) continue;
          if (statement) this._printNewline(i === 0, newlineOpts);
          this.print(node, undefined, trailingCommentsLineOffset || 0);
          iterator == null || iterator(node, i);
          if (boundSeparator != null) {
            if (i < len - 1) boundSeparator(i, false);else if (printTrailingSeparator) boundSeparator(i, true);
          }
          if (statement) {
            var _node$trailingComment2;
            if (!((_node$trailingComment2 = node.trailingComments) != null && _node$trailingComment2.length)) {
              this._lastCommentLine = 0;
            }
            if (i + 1 === len) {
              this.newline(1);
            } else {
              var _nextNode$loc;
              var nextNode = nodes[i + 1];
              newlineOpts.nextNodeStartLine = ((_nextNode$loc = nextNode.loc) == null ? void 0 : _nextNode$loc.start.line) || 0;
              this._printNewline(true, newlineOpts);
            }
          }
        }
        if (indent) this.dedent();
      }
    }, {
      key: "printAndIndentOnComments",
      value: function printAndIndentOnComments(node) {
        var indent = node.leadingComments && node.leadingComments.length > 0;
        if (indent) this.indent();
        this.print(node);
        if (indent) this.dedent();
      }
    }, {
      key: "printBlock",
      value: function printBlock(parent) {
        var node = parent.body;
        if (node.type !== "EmptyStatement") {
          this.space();
        }
        this.print(node);
      }
    }, {
      key: "_printTrailingComments",
      value: function _printTrailingComments(node, parent, lineOffset) {
        var innerComments = node.innerComments,
          trailingComments = node.trailingComments;
        if (innerComments != null && innerComments.length) {
          this._printComments(2, innerComments, node, parent, lineOffset);
        }
        if (trailingComments != null && trailingComments.length) {
          this._printComments(2, trailingComments, node, parent, lineOffset);
        }
      }
    }, {
      key: "_printLeadingComments",
      value: function _printLeadingComments(node, parent) {
        var comments = node.leadingComments;
        if (!(comments != null && comments.length)) return;
        this._printComments(0, comments, node, parent);
      }
    }, {
      key: "_maybePrintInnerComments",
      value: function _maybePrintInnerComments(nextTokenStr, nextTokenOccurrenceCount) {
        if (this._endsWithInnerRaw) {
          var _this$tokenMap;
          this.printInnerComments((_this$tokenMap = this.tokenMap) == null ? void 0 : _this$tokenMap.findMatching(this._currentNode, nextTokenStr, nextTokenOccurrenceCount));
        }
        this._endsWithInnerRaw = true;
        this._indentInnerComments = true;
      }
    }, {
      key: "printInnerComments",
      value: function printInnerComments(nextToken) {
        var node = this._currentNode;
        var comments = node.innerComments;
        if (!(comments != null && comments.length)) return;
        var hasSpace = this.endsWith(32);
        var indent = this._indentInnerComments;
        var printedCommentsCount = this._printedComments.size;
        if (indent) this.indent();
        this._printComments(1, comments, node, undefined, undefined, nextToken);
        if (hasSpace && printedCommentsCount !== this._printedComments.size) {
          this.space();
        }
        if (indent) this.dedent();
      }
    }, {
      key: "noIndentInnerCommentsHere",
      value: function noIndentInnerCommentsHere() {
        this._indentInnerComments = false;
      }
    }, {
      key: "printSequence",
      value: function printSequence(nodes, indent, trailingCommentsLineOffset, addNewlines) {
        this.printJoin(nodes, true, indent != null ? indent : false, undefined, undefined, addNewlines, undefined, trailingCommentsLineOffset);
      }
    }, {
      key: "printList",
      value: function printList(items, printTrailingSeparator, statement, indent, separator, iterator) {
        this.printJoin(items, statement, indent, separator != null ? separator : commaSeparator, printTrailingSeparator, undefined, iterator);
      }
    }, {
      key: "shouldPrintTrailingComma",
      value: function shouldPrintTrailingComma(listEnd) {
        var _this3 = this;
        if (!this.tokenMap) return null;
        var listEndIndex = this.tokenMap.findLastIndex(this._currentNode, function (token) {
          return _this3.tokenMap.matchesOriginal(token, listEnd);
        });
        if (listEndIndex <= 0) return null;
        return this.tokenMap.matchesOriginal(this._tokens[listEndIndex - 1], ",");
      }
    }, {
      key: "_printNewline",
      value: function _printNewline(newLine, opts) {
        var format = this.format;
        if (format.retainLines || format.compact) return;
        if (format.concise) {
          this.space();
          return;
        }
        if (!newLine) {
          return;
        }
        var startLine = opts.nextNodeStartLine;
        var lastCommentLine = this._lastCommentLine;
        if (startLine > 0 && lastCommentLine > 0) {
          var offset = startLine - lastCommentLine;
          if (offset >= 0) {
            this.newline(offset || 1);
            return;
          }
        }
        if (this._buf.hasContent()) {
          this.newline(1);
        }
      }
    }, {
      key: "_shouldPrintComment",
      value: function _shouldPrintComment(comment, nextToken) {
        if (comment.ignore) return 0;
        if (this._printedComments.has(comment)) return 0;
        if (this._noLineTerminator && HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment.value)) {
          return 2;
        }
        if (nextToken && this.tokenMap) {
          var commentTok = this.tokenMap.find(this._currentNode, function (token) {
            return token.value === comment.value;
          });
          if (commentTok && commentTok.start > nextToken.start) {
            return 2;
          }
        }
        this._printedComments.add(comment);
        if (!this.format.shouldPrintComment(comment.value)) {
          return 0;
        }
        return 1;
      }
    }, {
      key: "_printComment",
      value: function _printComment(comment, skipNewLines) {
        var noLineTerminator = this._noLineTerminator;
        var isBlockComment = comment.type === "CommentBlock";
        var printNewLines = isBlockComment && skipNewLines !== 1 && !this._noLineTerminator;
        if (printNewLines && this._buf.hasContent() && skipNewLines !== 2) {
          this.newline(1);
        }
        var lastCharCode = this.getLastChar();
        if (lastCharCode !== 91 && lastCharCode !== 123 && lastCharCode !== 40) {
          this.space();
        }
        var val;
        if (isBlockComment) {
          val = "/*".concat(comment.value, "*/");
          if (this.format.indent.adjustMultilineComment) {
            var _comment$loc;
            var offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;
            if (offset) {
              var newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
              val = val.replace(newlineRegex, "\n");
            }
            if (this.format.concise) {
              val = val.replace(/\n(?!$)/g, "\n");
            } else {
              var indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
              if (this._shouldIndent(47) || this.format.retainLines) {
                indentSize += this._getIndent();
              }
              val = val.replace(/\n(?!$)/g, "\n".concat(" ".repeat(indentSize)));
            }
          }
        } else if (!noLineTerminator) {
          val = "//".concat(comment.value);
        } else {
          val = "/*".concat(comment.value, "*/");
        }
        if (this._endsWithDiv) this._space();
        if (this.tokenMap) {
          var _printSemicolonBeforeNextToken = this._printSemicolonBeforeNextToken,
            _printSemicolonBeforeNextNode = this._printSemicolonBeforeNextNode;
          this._printSemicolonBeforeNextToken = -1;
          this._printSemicolonBeforeNextNode = -1;
          this.source("start", comment.loc);
          this._append(val, isBlockComment);
          this._printSemicolonBeforeNextNode = _printSemicolonBeforeNextNode;
          this._printSemicolonBeforeNextToken = _printSemicolonBeforeNextToken;
        } else {
          this.source("start", comment.loc);
          this._append(val, isBlockComment);
        }
        if (!isBlockComment && !noLineTerminator) {
          this.newline(1, true);
        }
        if (printNewLines && skipNewLines !== 3) {
          this.newline(1);
        }
      }
    }, {
      key: "_printComments",
      value: function _printComments(type, comments, node, parent) {
        var lineOffset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        var nextToken = arguments.length > 5 ? arguments[5] : undefined;
        var nodeLoc = node.loc;
        var len = comments.length;
        var hasLoc = !!nodeLoc;
        var nodeStartLine = hasLoc ? nodeLoc.start.line : 0;
        var nodeEndLine = hasLoc ? nodeLoc.end.line : 0;
        var lastLine = 0;
        var leadingCommentNewline = 0;
        var maybeNewline = this._noLineTerminator ? function () {} : this.newline.bind(this);
        for (var i = 0; i < len; i++) {
          var comment = comments[i];
          var shouldPrint = this._shouldPrintComment(comment, nextToken);
          if (shouldPrint === 2) {
            hasLoc = false;
            break;
          }
          if (hasLoc && comment.loc && shouldPrint === 1) {
            var commentStartLine = comment.loc.start.line;
            var commentEndLine = comment.loc.end.line;
            if (type === 0) {
              var offset = 0;
              if (i === 0) {
                if (this._buf.hasContent() && (comment.type === "CommentLine" || commentStartLine !== commentEndLine)) {
                  offset = leadingCommentNewline = 1;
                }
              } else {
                offset = commentStartLine - lastLine;
              }
              lastLine = commentEndLine;
              maybeNewline(offset);
              this._printComment(comment, 1);
              if (i + 1 === len) {
                maybeNewline(Math.max(nodeStartLine - lastLine, leadingCommentNewline));
                lastLine = nodeStartLine;
              }
            } else if (type === 1) {
              var _offset = commentStartLine - (i === 0 ? nodeStartLine : lastLine);
              lastLine = commentEndLine;
              maybeNewline(_offset);
              this._printComment(comment, 1);
              if (i + 1 === len) {
                maybeNewline(Math.min(1, nodeEndLine - lastLine));
                lastLine = nodeEndLine;
              }
            } else {
              var _offset2 = commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);
              lastLine = commentEndLine;
              maybeNewline(_offset2);
              this._printComment(comment, 1);
            }
          } else {
            hasLoc = false;
            if (shouldPrint !== 1) {
              continue;
            }
            if (len === 1) {
              var singleLine = comment.loc ? comment.loc.start.line === comment.loc.end.line : !HAS_NEWLINE.test(comment.value);
              var shouldSkipNewline = singleLine && !isStatement(node) && !isClassBody(parent) && !isTSInterfaceBody(parent) && !isTSEnumMember(node);
              if (type === 0) {
                this._printComment(comment, shouldSkipNewline && node.type !== "ObjectExpression" || singleLine && isFunction(parent, {
                  body: node
                }) ? 1 : 0);
              } else if (shouldSkipNewline && type === 2) {
                this._printComment(comment, 1);
              } else {
                this._printComment(comment, 0);
              }
            } else if (type === 1 && !(node.type === "ObjectExpression" && node.properties.length > 1) && node.type !== "ClassBody" && node.type !== "TSInterfaceBody") {
              this._printComment(comment, i === 0 ? 2 : i === len - 1 ? 3 : 0);
            } else {
              this._printComment(comment, 0);
            }
          }
        }
        if (type === 2 && hasLoc && lastLine) {
          this._lastCommentLine = lastLine;
        }
      }
    }]);
  }();
  Object.assign(Printer.prototype, generatorFunctions);
  {
    (0, _deprecated.addDeprecatedGenerators)(Printer);
  }
  printer["default"] = Printer;
  function commaSeparator(occurrenceCount, last) {
    this.token(",", false, occurrenceCount);
    if (!last) this.space();
  }
  return printer;
}

var hasRequiredLib$3;
function requireLib$3() {
  if (hasRequiredLib$3) return lib$2;
  hasRequiredLib$3 = 1;
  Object.defineProperty(lib$2, "__esModule", {
    value: true
  });
  lib$2["default"] = generate;
  var _sourceMap = requireSourceMap();
  var _printer = requirePrinter();
  function normalizeOptions(code, opts, ast) {
    if (opts.experimental_preserveFormat) {
      if (typeof code !== "string") {
        throw new Error("`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string");
      }
      if (!opts.retainLines) {
        throw new Error("`experimental_preserveFormat` requires `retainLines` to be set to `true`");
      }
      if (opts.compact && opts.compact !== "auto") {
        throw new Error("`experimental_preserveFormat` is not compatible with the `compact` option");
      }
      if (opts.minified) {
        throw new Error("`experimental_preserveFormat` is not compatible with the `minified` option");
      }
      if (opts.jsescOption) {
        throw new Error("`experimental_preserveFormat` is not compatible with the `jsescOption` option");
      }
      if (!Array.isArray(ast.tokens)) {
        throw new Error("`experimental_preserveFormat` requires the AST to have attatched the token of the input code. Make sure to enable the `tokens: true` parser option.");
      }
    }
    var format = {
      auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
      auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
      shouldPrintComment: opts.shouldPrintComment,
      preserveFormat: opts.experimental_preserveFormat,
      retainLines: opts.retainLines,
      retainFunctionParens: opts.retainFunctionParens,
      comments: opts.comments == null || opts.comments,
      compact: opts.compact,
      minified: opts.minified,
      concise: opts.concise,
      indent: {
        adjustMultilineComment: true,
        style: "  "
      },
      jsescOption: Object.assign({
        quotes: "double",
        wrap: true,
        minimal: false
      }, opts.jsescOption),
      topicToken: opts.topicToken,
      importAttributesKeyword: opts.importAttributesKeyword
    };
    {
      var _opts$recordAndTupleS;
      format.decoratorsBeforeExport = opts.decoratorsBeforeExport;
      format.jsescOption.json = opts.jsonCompatibleStrings;
      format.recordAndTupleSyntaxType = (_opts$recordAndTupleS = opts.recordAndTupleSyntaxType) != null ? _opts$recordAndTupleS : "hash";
    }
    if (format.minified) {
      format.compact = true;
      format.shouldPrintComment = format.shouldPrintComment || function () {
        return format.comments;
      };
    } else {
      format.shouldPrintComment = format.shouldPrintComment || function (value) {
        return format.comments || value.includes("@license") || value.includes("@preserve");
      };
    }
    if (format.compact === "auto") {
      format.compact = typeof code === "string" && code.length > 500000;
      if (format.compact) {
        console.error("[BABEL] Note: The code generator has deoptimised the styling of " + "".concat(opts.filename, " as it exceeds the max of ", "500KB", "."));
      }
    }
    if (format.compact || format.preserveFormat) {
      format.indent.adjustMultilineComment = false;
    }
    var auxiliaryCommentBefore = format.auxiliaryCommentBefore,
      auxiliaryCommentAfter = format.auxiliaryCommentAfter,
      shouldPrintComment = format.shouldPrintComment;
    if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) {
      format.auxiliaryCommentBefore = undefined;
    }
    if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) {
      format.auxiliaryCommentAfter = undefined;
    }
    return format;
  }
  {
    lib$2.CodeGenerator = /*#__PURE__*/function () {
      function CodeGenerator(ast) {
        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var code = arguments.length > 2 ? arguments[2] : undefined;
        _classCallCheck(this, CodeGenerator);
        this._ast = void 0;
        this._format = void 0;
        this._map = void 0;
        this._ast = ast;
        this._format = normalizeOptions(code, opts, ast);
        this._map = opts.sourceMaps ? new _sourceMap["default"](opts, code) : null;
      }
      return _createClass(CodeGenerator, [{
        key: "generate",
        value: function generate() {
          var printer = new _printer["default"](this._format, this._map);
          return printer.generate(this._ast);
        }
      }]);
    }();
  }
  function generate(ast) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var code = arguments.length > 2 ? arguments[2] : undefined;
    var format = normalizeOptions(code, opts, ast);
    var map = opts.sourceMaps ? new _sourceMap["default"](opts, code) : null;
    var printer = new _printer["default"](format, map, ast.tokens, typeof code === "string" ? code : null);
    return printer.generate(ast);
  }
  return lib$2;
}

var ancestry = {};

var hasRequiredAncestry;
function requireAncestry() {
  if (hasRequiredAncestry) return ancestry;
  hasRequiredAncestry = 1;
  Object.defineProperty(ancestry, "__esModule", {
    value: true
  });
  ancestry.find = find;
  ancestry.findParent = findParent;
  ancestry.getAncestry = getAncestry;
  ancestry.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
  ancestry.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
  ancestry.getFunctionParent = getFunctionParent;
  ancestry.getStatementParent = getStatementParent;
  ancestry.inType = inType;
  ancestry.isAncestor = isAncestor;
  ancestry.isDescendant = isDescendant;
  var _t = requireLib$4();
  var VISITOR_KEYS = _t.VISITOR_KEYS;
  function findParent(callback) {
    var path = this;
    while (path = path.parentPath) {
      if (callback(path)) return path;
    }
    return null;
  }
  function find(callback) {
    var path = this;
    do {
      if (callback(path)) return path;
    } while (path = path.parentPath);
    return null;
  }
  function getFunctionParent() {
    return this.findParent(function (p) {
      return p.isFunction();
    });
  }
  function getStatementParent() {
    var path = this;
    do {
      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
        break;
      } else {
        path = path.parentPath;
      }
    } while (path);
    if (path && (path.isProgram() || path.isFile())) {
      throw new Error("File/Program node, we can't possibly find a statement parent to this");
    }
    return path;
  }
  function getEarliestCommonAncestorFrom(paths) {
    return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {
      var earliest;
      var keys = VISITOR_KEYS[deepest.type];
      var _iterator = _createForOfIteratorHelper(ancestries),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _ancestry = _step.value;
          var path = _ancestry[i + 1];
          if (!earliest) {
            earliest = path;
            continue;
          }
          if (path.listKey && earliest.listKey === path.listKey) {
            if (path.key < earliest.key) {
              earliest = path;
              continue;
            }
          }
          var earliestKeyIndex = keys.indexOf(earliest.parentKey);
          var currentKeyIndex = keys.indexOf(path.parentKey);
          if (earliestKeyIndex > currentKeyIndex) {
            earliest = path;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return earliest;
    });
  }
  function getDeepestCommonAncestorFrom(paths, filter) {
    var _this = this;
    if (!paths.length) {
      return this;
    }
    if (paths.length === 1) {
      return paths[0];
    }
    var minDepth = Infinity;
    var lastCommonIndex, lastCommon;
    var ancestries = paths.map(function (path) {
      var ancestry = [];
      do {
        ancestry.unshift(path);
      } while ((path = path.parentPath) && path !== _this);
      if (ancestry.length < minDepth) {
        minDepth = ancestry.length;
      }
      return ancestry;
    });
    var first = ancestries[0];
    depthLoop: for (var i = 0; i < minDepth; i++) {
      var shouldMatch = first[i];
      var _iterator2 = _createForOfIteratorHelper(ancestries),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _ancestry2 = _step2.value;
          if (_ancestry2[i] !== shouldMatch) {
            break depthLoop;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      lastCommonIndex = i;
      lastCommon = shouldMatch;
    }
    if (lastCommon) {
      if (filter) {
        return filter(lastCommon, lastCommonIndex, ancestries);
      } else {
        return lastCommon;
      }
    } else {
      throw new Error("Couldn't find intersection");
    }
  }
  function getAncestry() {
    var path = this;
    var paths = [];
    do {
      paths.push(path);
    } while (path = path.parentPath);
    return paths;
  }
  function isAncestor(maybeDescendant) {
    return maybeDescendant.isDescendant(this);
  }
  function isDescendant(maybeAncestor) {
    return !!this.findParent(function (parent) {
      return parent === maybeAncestor;
    });
  }
  function inType() {
    var path = this;
    for (var _len = arguments.length, candidateTypes = new Array(_len), _key = 0; _key < _len; _key++) {
      candidateTypes[_key] = arguments[_key];
    }
    while (path) {
      var _iterator3 = _createForOfIteratorHelper(candidateTypes),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var type = _step3.value;
          if (path.node.type === type) return true;
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      path = path.parentPath;
    }
    return false;
  }
  return ancestry;
}

var inference = {};

var inferers = {};

var infererReference = {};

var util = {};

var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  Object.defineProperty(util, "__esModule", {
    value: true
  });
  util.createUnionType = createUnionType;
  var _t = requireLib$4();
  var createFlowUnionType = _t.createFlowUnionType,
    createTSUnionType = _t.createTSUnionType,
    createUnionTypeAnnotation = _t.createUnionTypeAnnotation,
    isFlowType = _t.isFlowType,
    isTSType = _t.isTSType;
  function createUnionType(types) {
    {
      if (types.every(function (v) {
        return isFlowType(v);
      })) {
        if (createFlowUnionType) {
          return createFlowUnionType(types);
        }
        return createUnionTypeAnnotation(types);
      } else if (types.every(function (v) {
        return isTSType(v);
      })) {
        if (createTSUnionType) {
          return createTSUnionType(types);
        }
      }
    }
  }
  return util;
}

var hasRequiredInfererReference;
function requireInfererReference() {
  if (hasRequiredInfererReference) return infererReference;
  hasRequiredInfererReference = 1;
  Object.defineProperty(infererReference, "__esModule", {
    value: true
  });
  infererReference["default"] = _default;
  var _t = requireLib$4();
  var _util = requireUtil();
  var BOOLEAN_NUMBER_BINARY_OPERATORS = _t.BOOLEAN_NUMBER_BINARY_OPERATORS,
    createTypeAnnotationBasedOnTypeof = _t.createTypeAnnotationBasedOnTypeof,
    numberTypeAnnotation = _t.numberTypeAnnotation,
    voidTypeAnnotation = _t.voidTypeAnnotation;
  function _default(node) {
    if (!this.isReferenced()) return;
    var binding = this.scope.getBinding(node.name);
    if (binding) {
      if (binding.identifier.typeAnnotation) {
        return binding.identifier.typeAnnotation;
      } else {
        return getTypeAnnotationBindingConstantViolations(binding, this, node.name);
      }
    }
    if (node.name === "undefined") {
      return voidTypeAnnotation();
    } else if (node.name === "NaN" || node.name === "Infinity") {
      return numberTypeAnnotation();
    } else if (node.name === "arguments") ;
  }
  function getTypeAnnotationBindingConstantViolations(binding, path, name) {
    var types = [];
    var functionConstantViolations = [];
    var constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);
    var testType = getConditionalAnnotation(binding, path, name);
    if (testType) {
      var testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
      constantViolations = constantViolations.filter(function (path) {
        return !testConstantViolations.includes(path);
      });
      types.push(testType.typeAnnotation);
    }
    if (constantViolations.length) {
      var _constantViolations;
      (_constantViolations = constantViolations).push.apply(_constantViolations, functionConstantViolations);
      var _iterator = _createForOfIteratorHelper(constantViolations),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var violation = _step.value;
          types.push(violation.getTypeAnnotation());
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    if (!types.length) {
      return;
    }
    return (0, _util.createUnionType)(types);
  }
  function getConstantViolationsBefore(binding, path, functions) {
    var violations = binding.constantViolations.slice();
    violations.unshift(binding.path);
    return violations.filter(function (violation) {
      violation = violation.resolve();
      var status = violation._guessExecutionStatusRelativeTo(path);
      if (functions && status === "unknown") functions.push(violation);
      return status === "before";
    });
  }
  function inferAnnotationFromBinaryExpression(name, path) {
    var operator = path.node.operator;
    var right = path.get("right").resolve();
    var left = path.get("left").resolve();
    var target;
    if (left.isIdentifier({
      name: name
    })) {
      target = right;
    } else if (right.isIdentifier({
      name: name
    })) {
      target = left;
    }
    if (target) {
      if (operator === "===") {
        return target.getTypeAnnotation();
      }
      if (BOOLEAN_NUMBER_BINARY_OPERATORS.includes(operator)) {
        return numberTypeAnnotation();
      }
      return;
    }
    if (operator !== "===" && operator !== "==") return;
    var typeofPath;
    var typePath;
    if (left.isUnaryExpression({
      operator: "typeof"
    })) {
      typeofPath = left;
      typePath = right;
    } else if (right.isUnaryExpression({
      operator: "typeof"
    })) {
      typeofPath = right;
      typePath = left;
    }
    if (!typeofPath) return;
    if (!typeofPath.get("argument").isIdentifier({
      name: name
    })) return;
    typePath = typePath.resolve();
    if (!typePath.isLiteral()) return;
    var typeValue = typePath.node.value;
    if (typeof typeValue !== "string") return;
    return createTypeAnnotationBasedOnTypeof(typeValue);
  }
  function getParentConditionalPath(binding, path, name) {
    var parentPath;
    while (parentPath = path.parentPath) {
      if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
        if (path.key === "test") {
          return;
        }
        return parentPath;
      }
      if (parentPath.isFunction()) {
        if (parentPath.parentPath.scope.getBinding(name) !== binding) return;
      }
      path = parentPath;
    }
  }
  function getConditionalAnnotation(binding, path, name) {
    var ifStatement = getParentConditionalPath(binding, path, name);
    if (!ifStatement) return;
    var test = ifStatement.get("test");
    var paths = [test];
    var types = [];
    for (var i = 0; i < paths.length; i++) {
      var _path = paths[i];
      if (_path.isLogicalExpression()) {
        if (_path.node.operator === "&&") {
          paths.push(_path.get("left"));
          paths.push(_path.get("right"));
        }
      } else if (_path.isBinaryExpression()) {
        var type = inferAnnotationFromBinaryExpression(name, _path);
        if (type) types.push(type);
      }
    }
    if (types.length) {
      return {
        typeAnnotation: (0, _util.createUnionType)(types),
        ifStatement: ifStatement
      };
    }
    return getConditionalAnnotation(binding, ifStatement, name);
  }
  return infererReference;
}

var hasRequiredInferers;
function requireInferers() {
  if (hasRequiredInferers) return inferers;
  hasRequiredInferers = 1;
  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ArrayExpression = ArrayExpression;
    exports.AssignmentExpression = AssignmentExpression;
    exports.BinaryExpression = BinaryExpression;
    exports.BooleanLiteral = BooleanLiteral;
    exports.CallExpression = CallExpression;
    exports.ConditionalExpression = ConditionalExpression;
    exports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;
    Object.defineProperty(exports, "Identifier", {
      enumerable: true,
      get: function get() {
        return _infererReference["default"];
      }
    });
    exports.LogicalExpression = LogicalExpression;
    exports.NewExpression = NewExpression;
    exports.NullLiteral = NullLiteral;
    exports.NumericLiteral = NumericLiteral;
    exports.ObjectExpression = ObjectExpression;
    exports.ParenthesizedExpression = ParenthesizedExpression;
    exports.RegExpLiteral = RegExpLiteral;
    exports.RestElement = RestElement;
    exports.SequenceExpression = SequenceExpression;
    exports.StringLiteral = StringLiteral;
    exports.TSAsExpression = TSAsExpression;
    exports.TSNonNullExpression = TSNonNullExpression;
    exports.TaggedTemplateExpression = TaggedTemplateExpression;
    exports.TemplateLiteral = TemplateLiteral;
    exports.TypeCastExpression = TypeCastExpression;
    exports.UnaryExpression = UnaryExpression;
    exports.UpdateExpression = UpdateExpression;
    exports.VariableDeclarator = VariableDeclarator;
    var _t = requireLib$4();
    var _infererReference = requireInfererReference();
    var _util = requireUtil();
    var BOOLEAN_BINARY_OPERATORS = _t.BOOLEAN_BINARY_OPERATORS,
      BOOLEAN_UNARY_OPERATORS = _t.BOOLEAN_UNARY_OPERATORS,
      NUMBER_BINARY_OPERATORS = _t.NUMBER_BINARY_OPERATORS,
      NUMBER_UNARY_OPERATORS = _t.NUMBER_UNARY_OPERATORS,
      STRING_UNARY_OPERATORS = _t.STRING_UNARY_OPERATORS,
      anyTypeAnnotation = _t.anyTypeAnnotation,
      arrayTypeAnnotation = _t.arrayTypeAnnotation,
      booleanTypeAnnotation = _t.booleanTypeAnnotation,
      buildMatchMemberExpression = _t.buildMatchMemberExpression,
      genericTypeAnnotation = _t.genericTypeAnnotation,
      identifier = _t.identifier,
      nullLiteralTypeAnnotation = _t.nullLiteralTypeAnnotation,
      numberTypeAnnotation = _t.numberTypeAnnotation,
      stringTypeAnnotation = _t.stringTypeAnnotation,
      tupleTypeAnnotation = _t.tupleTypeAnnotation,
      unionTypeAnnotation = _t.unionTypeAnnotation,
      voidTypeAnnotation = _t.voidTypeAnnotation,
      isIdentifier = _t.isIdentifier;
    function VariableDeclarator() {
      if (!this.get("id").isIdentifier()) return;
      return this.get("init").getTypeAnnotation();
    }
    function TypeCastExpression(node) {
      return node.typeAnnotation;
    }
    TypeCastExpression.validParent = true;
    function TSAsExpression(node) {
      return node.typeAnnotation;
    }
    TSAsExpression.validParent = true;
    function TSNonNullExpression() {
      return this.get("expression").getTypeAnnotation();
    }
    function NewExpression(node) {
      if (node.callee.type === "Identifier") {
        return genericTypeAnnotation(node.callee);
      }
    }
    function TemplateLiteral() {
      return stringTypeAnnotation();
    }
    function UnaryExpression(node) {
      var operator = node.operator;
      if (operator === "void") {
        return voidTypeAnnotation();
      } else if (NUMBER_UNARY_OPERATORS.includes(operator)) {
        return numberTypeAnnotation();
      } else if (STRING_UNARY_OPERATORS.includes(operator)) {
        return stringTypeAnnotation();
      } else if (BOOLEAN_UNARY_OPERATORS.includes(operator)) {
        return booleanTypeAnnotation();
      }
    }
    function BinaryExpression(node) {
      var operator = node.operator;
      if (NUMBER_BINARY_OPERATORS.includes(operator)) {
        return numberTypeAnnotation();
      } else if (BOOLEAN_BINARY_OPERATORS.includes(operator)) {
        return booleanTypeAnnotation();
      } else if (operator === "+") {
        var right = this.get("right");
        var left = this.get("left");
        if (left.isBaseType("number") && right.isBaseType("number")) {
          return numberTypeAnnotation();
        } else if (left.isBaseType("string") || right.isBaseType("string")) {
          return stringTypeAnnotation();
        }
        return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);
      }
    }
    function LogicalExpression() {
      var argumentTypes = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
      return (0, _util.createUnionType)(argumentTypes);
    }
    function ConditionalExpression() {
      var argumentTypes = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
      return (0, _util.createUnionType)(argumentTypes);
    }
    function SequenceExpression() {
      return this.get("expressions").pop().getTypeAnnotation();
    }
    function ParenthesizedExpression() {
      return this.get("expression").getTypeAnnotation();
    }
    function AssignmentExpression() {
      return this.get("right").getTypeAnnotation();
    }
    function UpdateExpression(node) {
      var operator = node.operator;
      if (operator === "++" || operator === "--") {
        return numberTypeAnnotation();
      }
    }
    function StringLiteral() {
      return stringTypeAnnotation();
    }
    function NumericLiteral() {
      return numberTypeAnnotation();
    }
    function BooleanLiteral() {
      return booleanTypeAnnotation();
    }
    function NullLiteral() {
      return nullLiteralTypeAnnotation();
    }
    function RegExpLiteral() {
      return genericTypeAnnotation(identifier("RegExp"));
    }
    function ObjectExpression() {
      return genericTypeAnnotation(identifier("Object"));
    }
    function ArrayExpression() {
      return genericTypeAnnotation(identifier("Array"));
    }
    function RestElement() {
      return ArrayExpression();
    }
    RestElement.validParent = true;
    function Func() {
      return genericTypeAnnotation(identifier("Function"));
    }
    var isArrayFrom = buildMatchMemberExpression("Array.from");
    var isObjectKeys = buildMatchMemberExpression("Object.keys");
    var isObjectValues = buildMatchMemberExpression("Object.values");
    var isObjectEntries = buildMatchMemberExpression("Object.entries");
    function CallExpression() {
      var callee = this.node.callee;
      if (isObjectKeys(callee)) {
        return arrayTypeAnnotation(stringTypeAnnotation());
      } else if (isArrayFrom(callee) || isObjectValues(callee) || isIdentifier(callee, {
        name: "Array"
      })) {
        return arrayTypeAnnotation(anyTypeAnnotation());
      } else if (isObjectEntries(callee)) {
        return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));
      }
      return resolveCall(this.get("callee"));
    }
    function TaggedTemplateExpression() {
      return resolveCall(this.get("tag"));
    }
    function resolveCall(callee) {
      callee = callee.resolve();
      if (callee.isFunction()) {
        var _callee = callee,
          node = _callee.node;
        if (node.async) {
          if (node.generator) {
            return genericTypeAnnotation(identifier("AsyncIterator"));
          } else {
            return genericTypeAnnotation(identifier("Promise"));
          }
        } else {
          if (node.generator) {
            return genericTypeAnnotation(identifier("Iterator"));
          } else if (callee.node.returnType) {
            return callee.node.returnType;
          } else ;
        }
      }
    }
  })(inferers);
  return inferers;
}

var hasRequiredInference;
function requireInference() {
  if (hasRequiredInference) return inference;
  hasRequiredInference = 1;
  Object.defineProperty(inference, "__esModule", {
    value: true
  });
  inference._getTypeAnnotation = _getTypeAnnotation;
  inference.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
  inference.couldBeBaseType = couldBeBaseType;
  inference.getTypeAnnotation = getTypeAnnotation;
  inference.isBaseType = isBaseType;
  inference.isGenericType = isGenericType;
  var inferers = requireInferers();
  var _t = requireLib$4();
  var anyTypeAnnotation = _t.anyTypeAnnotation,
    isAnyTypeAnnotation = _t.isAnyTypeAnnotation,
    isArrayTypeAnnotation = _t.isArrayTypeAnnotation,
    isBooleanTypeAnnotation = _t.isBooleanTypeAnnotation,
    isEmptyTypeAnnotation = _t.isEmptyTypeAnnotation,
    isFlowBaseAnnotation = _t.isFlowBaseAnnotation,
    isGenericTypeAnnotation = _t.isGenericTypeAnnotation,
    isIdentifier = _t.isIdentifier,
    isMixedTypeAnnotation = _t.isMixedTypeAnnotation,
    isNumberTypeAnnotation = _t.isNumberTypeAnnotation,
    isStringTypeAnnotation = _t.isStringTypeAnnotation,
    isTSArrayType = _t.isTSArrayType,
    isTSTypeAnnotation = _t.isTSTypeAnnotation,
    isTSTypeReference = _t.isTSTypeReference,
    isTupleTypeAnnotation = _t.isTupleTypeAnnotation,
    isTypeAnnotation = _t.isTypeAnnotation,
    isUnionTypeAnnotation = _t.isUnionTypeAnnotation,
    isVoidTypeAnnotation = _t.isVoidTypeAnnotation,
    stringTypeAnnotation = _t.stringTypeAnnotation,
    voidTypeAnnotation = _t.voidTypeAnnotation;
  function getTypeAnnotation() {
    var type = this.getData("typeAnnotation");
    if (type != null) {
      return type;
    }
    type = _getTypeAnnotation.call(this) || anyTypeAnnotation();
    if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) {
      type = type.typeAnnotation;
    }
    this.setData("typeAnnotation", type);
    return type;
  }
  var typeAnnotationInferringNodes = new WeakSet();
  function _getTypeAnnotation() {
    var node = this.node;
    if (!node) {
      if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
        var declar = this.parentPath.parentPath;
        var declarParent = declar.parentPath;
        if (declar.key === "left" && declarParent.isForInStatement()) {
          return stringTypeAnnotation();
        }
        if (declar.key === "left" && declarParent.isForOfStatement()) {
          return anyTypeAnnotation();
        }
        return voidTypeAnnotation();
      } else {
        return;
      }
    }
    if (node.typeAnnotation) {
      return node.typeAnnotation;
    }
    if (typeAnnotationInferringNodes.has(node)) {
      return;
    }
    typeAnnotationInferringNodes.add(node);
    try {
      var _inferer;
      var inferer = inferers[node.type];
      if (inferer) {
        return inferer.call(this, node);
      }
      inferer = inferers[this.parentPath.type];
      if ((_inferer = inferer) != null && _inferer.validParent) {
        return this.parentPath.getTypeAnnotation();
      }
    } finally {
      typeAnnotationInferringNodes["delete"](node);
    }
  }
  function isBaseType(baseName, soft) {
    return _isBaseType(baseName, this.getTypeAnnotation(), soft);
  }
  function _isBaseType(baseName, type, soft) {
    if (baseName === "string") {
      return isStringTypeAnnotation(type);
    } else if (baseName === "number") {
      return isNumberTypeAnnotation(type);
    } else if (baseName === "boolean") {
      return isBooleanTypeAnnotation(type);
    } else if (baseName === "any") {
      return isAnyTypeAnnotation(type);
    } else if (baseName === "mixed") {
      return isMixedTypeAnnotation(type);
    } else if (baseName === "empty") {
      return isEmptyTypeAnnotation(type);
    } else if (baseName === "void") {
      return isVoidTypeAnnotation(type);
    } else {
      if (soft) {
        return false;
      } else {
        throw new Error("Unknown base type ".concat(baseName));
      }
    }
  }
  function couldBeBaseType(name) {
    var type = this.getTypeAnnotation();
    if (isAnyTypeAnnotation(type)) return true;
    if (isUnionTypeAnnotation(type)) {
      var _iterator = _createForOfIteratorHelper(type.types),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var type2 = _step.value;
          if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
            return true;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return false;
    } else {
      return _isBaseType(name, type, true);
    }
  }
  function baseTypeStrictlyMatches(rightArg) {
    var left = this.getTypeAnnotation();
    var right = rightArg.getTypeAnnotation();
    if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {
      return right.type === left.type;
    }
    return false;
  }
  function isGenericType(genericName) {
    var type = this.getTypeAnnotation();
    if (genericName === "Array") {
      if (isTSArrayType(type) || isArrayTypeAnnotation(type) || isTupleTypeAnnotation(type)) {
        return true;
      }
    }
    return isGenericTypeAnnotation(type) && isIdentifier(type.id, {
      name: genericName
    }) || isTSTypeReference(type) && isIdentifier(type.typeName, {
      name: genericName
    });
  }
  return inference;
}

var replacement = {};

var lib$1 = {};

var picocolors = {exports: {}};

var hasRequiredPicocolors;
function requirePicocolors() {
  if (hasRequiredPicocolors) return picocolors.exports;
  hasRequiredPicocolors = 1;
  var p = process || {},
    argv = p.argv || [],
    env = p.env || {};
  var isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
  var formatter = function formatter(open, close) {
    var replace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : open;
    return function (input) {
      var string = "" + input,
        index = string.indexOf(close, open.length);
      return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    };
  };
  var replaceClose = function replaceClose(string, close, replace, index) {
    var result = "",
      cursor = 0;
    do {
      result += string.substring(cursor, index) + replace;
      cursor = index + close.length;
      index = string.indexOf(close, cursor);
    } while (~index);
    return result + string.substring(cursor);
  };
  var createColors = function createColors() {
    var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : isColorSupported;
    var f = enabled ? formatter : function () {
      return String;
    };
    return {
      isColorSupported: enabled,
      reset: f("\x1b[0m", "\x1b[0m"),
      bold: f("\x1b[1m", "\x1b[22m", "\x1b[22m\x1b[1m"),
      dim: f("\x1b[2m", "\x1b[22m", "\x1b[22m\x1b[2m"),
      italic: f("\x1b[3m", "\x1b[23m"),
      underline: f("\x1b[4m", "\x1b[24m"),
      inverse: f("\x1b[7m", "\x1b[27m"),
      hidden: f("\x1b[8m", "\x1b[28m"),
      strikethrough: f("\x1b[9m", "\x1b[29m"),
      black: f("\x1b[30m", "\x1b[39m"),
      red: f("\x1b[31m", "\x1b[39m"),
      green: f("\x1b[32m", "\x1b[39m"),
      yellow: f("\x1b[33m", "\x1b[39m"),
      blue: f("\x1b[34m", "\x1b[39m"),
      magenta: f("\x1b[35m", "\x1b[39m"),
      cyan: f("\x1b[36m", "\x1b[39m"),
      white: f("\x1b[37m", "\x1b[39m"),
      gray: f("\x1b[90m", "\x1b[39m"),
      bgBlack: f("\x1b[40m", "\x1b[49m"),
      bgRed: f("\x1b[41m", "\x1b[49m"),
      bgGreen: f("\x1b[42m", "\x1b[49m"),
      bgYellow: f("\x1b[43m", "\x1b[49m"),
      bgBlue: f("\x1b[44m", "\x1b[49m"),
      bgMagenta: f("\x1b[45m", "\x1b[49m"),
      bgCyan: f("\x1b[46m", "\x1b[49m"),
      bgWhite: f("\x1b[47m", "\x1b[49m"),
      blackBright: f("\x1b[90m", "\x1b[39m"),
      redBright: f("\x1b[91m", "\x1b[39m"),
      greenBright: f("\x1b[92m", "\x1b[39m"),
      yellowBright: f("\x1b[93m", "\x1b[39m"),
      blueBright: f("\x1b[94m", "\x1b[39m"),
      magentaBright: f("\x1b[95m", "\x1b[39m"),
      cyanBright: f("\x1b[96m", "\x1b[39m"),
      whiteBright: f("\x1b[97m", "\x1b[39m"),
      bgBlackBright: f("\x1b[100m", "\x1b[49m"),
      bgRedBright: f("\x1b[101m", "\x1b[49m"),
      bgGreenBright: f("\x1b[102m", "\x1b[49m"),
      bgYellowBright: f("\x1b[103m", "\x1b[49m"),
      bgBlueBright: f("\x1b[104m", "\x1b[49m"),
      bgMagentaBright: f("\x1b[105m", "\x1b[49m"),
      bgCyanBright: f("\x1b[106m", "\x1b[49m"),
      bgWhiteBright: f("\x1b[107m", "\x1b[49m")
    };
  };
  picocolors.exports = createColors();
  picocolors.exports.createColors = createColors;
  return picocolors.exports;
}

var jsTokens = {};

var hasRequiredJsTokens;
function requireJsTokens() {
  if (hasRequiredJsTokens) return jsTokens;
  hasRequiredJsTokens = 1;
  // Copyright 2014, 2015, 2016, 2017, 2018 Simon Lydell
  // License: MIT. (See LICENSE.)

  Object.defineProperty(jsTokens, "__esModule", {
    value: true
  });

  // This regex comes from regex.coffee, and is inserted here by generate-index.js
  // (run `npm run build`).
  jsTokens["default"] = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
  jsTokens.matchToToken = function (match) {
    var token = {
      type: "invalid",
      value: match[0],
      closed: undefined
    };
    if (match[1]) token.type = "string", token.closed = !!(match[3] || match[4]);else if (match[5]) token.type = "comment";else if (match[6]) token.type = "comment", token.closed = !!match[7];else if (match[8]) token.type = "regex";else if (match[9]) token.type = "number";else if (match[10]) token.type = "name";else if (match[11]) token.type = "punctuator";else if (match[12]) token.type = "whitespace";
    return token;
  };
  return jsTokens;
}

var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib$1;
  hasRequiredLib$2 = 1;
  Object.defineProperty(lib$1, '__esModule', {
    value: true
  });
  var picocolors = /*@__PURE__*/requirePicocolors();
  var jsTokens = requireJsTokens();
  var helperValidatorIdentifier = requireLib$6();
  function isColorSupported() {
    return (typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? false : picocolors.isColorSupported;
  }
  var compose = function compose(f, g) {
    return function (v) {
      return f(g(v));
    };
  };
  function buildDefs(colors) {
    return {
      keyword: colors.cyan,
      capitalized: colors.yellow,
      jsxIdentifier: colors.yellow,
      punctuator: colors.yellow,
      number: colors.magenta,
      string: colors.green,
      regex: colors.magenta,
      comment: colors.gray,
      invalid: compose(compose(colors.white, colors.bgRed), colors.bold),
      gutter: colors.gray,
      marker: compose(colors.red, colors.bold),
      message: compose(colors.red, colors.bold),
      reset: colors.reset
    };
  }
  var defsOn = buildDefs(picocolors.createColors(true));
  var defsOff = buildDefs(picocolors.createColors(false));
  function getDefs(enabled) {
    return enabled ? defsOn : defsOff;
  }
  var sometimesKeywords = new Set(["as", "async", "from", "get", "of", "set"]);
  var NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;
  var BRACKET = /^[()[\]{}]$/;
  var tokenize;
  {
    var JSX_TAG = /^[a-z][\w-]*$/i;
    var getTokenType = function getTokenType(token, offset, text) {
      if (token.type === "name") {
        if (helperValidatorIdentifier.isKeyword(token.value) || helperValidatorIdentifier.isStrictReservedWord(token.value, true) || sometimesKeywords.has(token.value)) {
          return "keyword";
        }
        if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) === "</")) {
          return "jsxIdentifier";
        }
        if (token.value[0] !== token.value[0].toLowerCase()) {
          return "capitalized";
        }
      }
      if (token.type === "punctuator" && BRACKET.test(token.value)) {
        return "bracket";
      }
      if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
        return "punctuator";
      }
      return token.type;
    };
    tokenize = /*#__PURE__*/_regeneratorRuntime().mark(function tokenize(text) {
      var match, token;
      return _regeneratorRuntime().wrap(function tokenize$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (!(match = jsTokens["default"].exec(text))) {
              _context.next = 6;
              break;
            }
            token = jsTokens.matchToToken(match);
            _context.next = 4;
            return {
              type: getTokenType(token, match.index, text),
              value: token.value
            };
          case 4:
            _context.next = 0;
            break;
          case 6:
          case "end":
            return _context.stop();
        }
      }, tokenize);
    });
  }
  function highlight(text) {
    if (text === "") return "";
    var defs = getDefs(true);
    var highlighted = "";
    var _iterator = _createForOfIteratorHelper(tokenize(text)),
      _step;
    try {
      var _loop = function _loop() {
        var _step$value = _step.value,
          type = _step$value.type,
          value = _step$value.value;
        if (type in defs) {
          highlighted += value.split(NEWLINE$1).map(function (str) {
            return defs[type](str);
          }).join("\n");
        } else {
          highlighted += value;
        }
      };
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        _loop();
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return highlighted;
  }
  var deprecationWarningShown = false;
  var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
  function getMarkerLines(loc, source, opts) {
    var startLoc = Object.assign({
      column: 0,
      line: -1
    }, loc.start);
    var endLoc = Object.assign({}, startLoc, loc.end);
    var _ref = opts || {},
      _ref$linesAbove = _ref.linesAbove,
      linesAbove = _ref$linesAbove === void 0 ? 2 : _ref$linesAbove,
      _ref$linesBelow = _ref.linesBelow,
      linesBelow = _ref$linesBelow === void 0 ? 3 : _ref$linesBelow;
    var startLine = startLoc.line;
    var startColumn = startLoc.column;
    var endLine = endLoc.line;
    var endColumn = endLoc.column;
    var start = Math.max(startLine - (linesAbove + 1), 0);
    var end = Math.min(source.length, endLine + linesBelow);
    if (startLine === -1) {
      start = 0;
    }
    if (endLine === -1) {
      end = source.length;
    }
    var lineDiff = endLine - startLine;
    var markerLines = {};
    if (lineDiff) {
      for (var i = 0; i <= lineDiff; i++) {
        var lineNumber = i + startLine;
        if (!startColumn) {
          markerLines[lineNumber] = true;
        } else if (i === 0) {
          var sourceLength = source[lineNumber - 1].length;
          markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
        } else if (i === lineDiff) {
          markerLines[lineNumber] = [0, endColumn];
        } else {
          var _sourceLength = source[lineNumber - i].length;
          markerLines[lineNumber] = [0, _sourceLength];
        }
      }
    } else {
      if (startColumn === endColumn) {
        if (startColumn) {
          markerLines[startLine] = [startColumn, 0];
        } else {
          markerLines[startLine] = true;
        }
      } else {
        markerLines[startLine] = [startColumn, endColumn - startColumn];
      }
    }
    return {
      start: start,
      end: end,
      markerLines: markerLines
    };
  }
  function codeFrameColumns(rawLines, loc) {
    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var shouldHighlight = opts.forceColor || isColorSupported() && opts.highlightCode;
    var defs = getDefs(shouldHighlight);
    var lines = rawLines.split(NEWLINE);
    var _getMarkerLines = getMarkerLines(loc, lines, opts),
      start = _getMarkerLines.start,
      end = _getMarkerLines.end,
      markerLines = _getMarkerLines.markerLines;
    var hasColumns = loc.start && typeof loc.start.column === "number";
    var numberMaxWidth = String(end).length;
    var highlightedLines = shouldHighlight ? highlight(rawLines) : rawLines;
    var frame = highlightedLines.split(NEWLINE, end).slice(start, end).map(function (line, index) {
      var number = start + 1 + index;
      var paddedNumber = " ".concat(number).slice(-numberMaxWidth);
      var gutter = " ".concat(paddedNumber, " |");
      var hasMarker = markerLines[number];
      var lastMarkerLine = !markerLines[number + 1];
      if (hasMarker) {
        var markerLine = "";
        if (Array.isArray(hasMarker)) {
          var markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
          var numberOfMarkers = hasMarker[1] || 1;
          markerLine = ["\n ", defs.gutter(gutter.replace(/\d/g, " ")), " ", markerSpacing, defs.marker("^").repeat(numberOfMarkers)].join("");
          if (lastMarkerLine && opts.message) {
            markerLine += " " + defs.message(opts.message);
          }
        }
        return [defs.marker(">"), defs.gutter(gutter), line.length > 0 ? " ".concat(line) : "", markerLine].join("");
      } else {
        return " ".concat(defs.gutter(gutter)).concat(line.length > 0 ? " ".concat(line) : "");
      }
    }).join("\n");
    if (opts.message && !hasColumns) {
      frame = "".concat(" ".repeat(numberMaxWidth + 1)).concat(opts.message, "\n").concat(frame);
    }
    if (shouldHighlight) {
      return defs.reset(frame);
    } else {
      return frame;
    }
  }
  function index(rawLines, lineNumber, colNumber) {
    var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    if (!deprecationWarningShown) {
      deprecationWarningShown = true;
      var message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (process.emitWarning) {
        process.emitWarning(message, "DeprecationWarning");
      } else {
        var deprecationError = new Error(message);
        deprecationError.name = "DeprecationWarning";
        console.warn(new Error(message));
      }
    }
    colNumber = Math.max(colNumber, 0);
    var location = {
      start: {
        column: colNumber,
        line: lineNumber
      }
    };
    return codeFrameColumns(rawLines, location, opts);
  }
  lib$1.codeFrameColumns = codeFrameColumns;
  lib$1["default"] = index;
  lib$1.highlight = highlight;
  return lib$1;
}

var modification = {};

var removal = {};

var removalHooks = {};

var hasRequiredRemovalHooks;
function requireRemovalHooks() {
  if (hasRequiredRemovalHooks) return removalHooks;
  hasRequiredRemovalHooks = 1;
  Object.defineProperty(removalHooks, "__esModule", {
    value: true
  });
  removalHooks.hooks = void 0;
  removalHooks.hooks = [function (self, parent) {
    var removeParent = self.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self.key === "declaration" && parent.isExportDeclaration() || self.key === "body" && parent.isLabeledStatement() || self.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === "expression" && parent.isExpressionStatement();
    if (removeParent) {
      parent.remove();
      return true;
    }
  }, function (self, parent) {
    if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
      parent.replaceWith(parent.node.expressions[0]);
      return true;
    }
  }, function (self, parent) {
    if (parent.isBinary()) {
      if (self.key === "left") {
        parent.replaceWith(parent.node.right);
      } else {
        parent.replaceWith(parent.node.left);
      }
      return true;
    }
  }, function (self, parent) {
    if (parent.isIfStatement() && self.key === "consequent" || self.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression())) {
      self.replaceWith({
        type: "BlockStatement",
        body: []
      });
      return true;
    }
  }];
  return removalHooks;
}

var hasRequiredRemoval;
function requireRemoval() {
  if (hasRequiredRemoval) return removal;
  hasRequiredRemoval = 1;
  Object.defineProperty(removal, "__esModule", {
    value: true
  });
  removal._assertUnremoved = _assertUnremoved;
  removal._callRemovalHooks = _callRemovalHooks;
  removal._markRemoved = _markRemoved;
  removal._remove = _remove;
  removal._removeFromScope = _removeFromScope;
  removal.remove = remove;
  var _removalHooks = requireRemovalHooks();
  var _cache = requireCache();
  var _replacement = requireReplacement();
  var _index = requirePath();
  var _t = requireLib$4();
  var _modification = requireModification();
  var _context = requireContext();
  var getBindingIdentifiers = _t.getBindingIdentifiers;
  function remove() {
    var _this$opts;
    _assertUnremoved.call(this);
    _context.resync.call(this);
    if (_callRemovalHooks.call(this)) {
      _markRemoved.call(this);
      return;
    }
    if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {
      _removeFromScope.call(this);
    }
    this.shareCommentsWithSiblings();
    _remove.call(this);
    _markRemoved.call(this);
  }
  function _removeFromScope() {
    var _this = this;
    var bindings = getBindingIdentifiers(this.node, false, false, true);
    Object.keys(bindings).forEach(function (name) {
      return _this.scope.removeBinding(name);
    });
  }
  function _callRemovalHooks() {
    if (this.parentPath) {
      var _iterator = _createForOfIteratorHelper(_removalHooks.hooks),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var fn = _step.value;
          if (fn(this, this.parentPath)) return true;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }
  function _remove() {
    if (Array.isArray(this.container)) {
      this.container.splice(this.key, 1);
      _modification.updateSiblingKeys.call(this, this.key, -1);
    } else {
      _replacement._replaceWith.call(this, null);
    }
  }
  function _markRemoved() {
    this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;
    if (this.parent) {
      (0, _cache.getCachedPaths)(this.hub, this.parent)["delete"](this.node);
    }
    this.node = null;
  }
  function _assertUnremoved() {
    if (this.removed) {
      throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
    }
  }
  return removal;
}

var hoister = {};

var hasRequiredHoister;
function requireHoister() {
  if (hasRequiredHoister) return hoister;
  hasRequiredHoister = 1;
  Object.defineProperty(hoister, "__esModule", {
    value: true
  });
  hoister["default"] = void 0;
  var _t = requireLib$4();
  var _t2 = _t;
  var react = _t.react;
  var cloneNode = _t2.cloneNode,
    jsxExpressionContainer = _t2.jsxExpressionContainer,
    variableDeclaration = _t2.variableDeclaration,
    variableDeclarator = _t2.variableDeclarator;
  var referenceVisitor = {
    ReferencedIdentifier: function ReferencedIdentifier(path, state) {
      if (path.isJSXIdentifier() && react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {
        return;
      }
      if (path.node.name === "this") {
        var scope = path.scope;
        do {
          if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
            break;
          }
        } while (scope = scope.parent);
        if (scope) state.breakOnScopePaths.push(scope.path);
      }
      var binding = path.scope.getBinding(path.node.name);
      if (!binding) return;
      var _iterator = _createForOfIteratorHelper(binding.constantViolations),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var violation = _step.value;
          if (violation.scope !== binding.path.scope) {
            state.mutableBinding = true;
            path.stop();
            return;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      if (binding !== state.scope.getBinding(path.node.name)) return;
      state.bindings[path.node.name] = binding;
    }
  };
  var PathHoister = /*#__PURE__*/function () {
    function PathHoister(path, scope) {
      _classCallCheck(this, PathHoister);
      this.breakOnScopePaths = void 0;
      this.bindings = void 0;
      this.mutableBinding = void 0;
      this.scopes = void 0;
      this.scope = void 0;
      this.path = void 0;
      this.attachAfter = void 0;
      this.breakOnScopePaths = [];
      this.bindings = {};
      this.mutableBinding = false;
      this.scopes = [];
      this.scope = scope;
      this.path = path;
      this.attachAfter = false;
    }
    return _createClass(PathHoister, [{
      key: "isCompatibleScope",
      value: function isCompatibleScope(scope) {
        for (var _i = 0, _Object$keys = Object.keys(this.bindings); _i < _Object$keys.length; _i++) {
          var key = _Object$keys[_i];
          var binding = this.bindings[key];
          if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
            return false;
          }
        }
        return true;
      }
    }, {
      key: "getCompatibleScopes",
      value: function getCompatibleScopes() {
        var scope = this.path.scope;
        do {
          if (this.isCompatibleScope(scope)) {
            this.scopes.push(scope);
          } else {
            break;
          }
          if (this.breakOnScopePaths.includes(scope.path)) {
            break;
          }
        } while (scope = scope.parent);
      }
    }, {
      key: "getAttachmentPath",
      value: function getAttachmentPath() {
        var path = this._getAttachmentPath();
        if (!path) return;
        var targetScope = path.scope;
        if (targetScope.path === path) {
          targetScope = path.scope.parent;
        }
        if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
          for (var _i2 = 0, _Object$keys2 = Object.keys(this.bindings); _i2 < _Object$keys2.length; _i2++) {
            var name = _Object$keys2[_i2];
            if (!targetScope.hasOwnBinding(name)) continue;
            var binding = this.bindings[name];
            if (binding.kind === "param" || binding.path.parentKey === "params") {
              continue;
            }
            var bindingParentPath = this.getAttachmentParentForPath(binding.path);
            if (bindingParentPath.key >= path.key) {
              this.attachAfter = true;
              path = binding.path;
              var _iterator2 = _createForOfIteratorHelper(binding.constantViolations),
                _step2;
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var violationPath = _step2.value;
                  if (this.getAttachmentParentForPath(violationPath).key > path.key) {
                    path = violationPath;
                  }
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            }
          }
        }
        return path;
      }
    }, {
      key: "_getAttachmentPath",
      value: function _getAttachmentPath() {
        var scopes = this.scopes;
        var scope = scopes.pop();
        if (!scope) return;
        if (scope.path.isFunction()) {
          if (this.hasOwnParamBindings(scope)) {
            if (this.scope === scope) return;
            var bodies = scope.path.get("body").get("body");
            for (var i = 0; i < bodies.length; i++) {
              if (bodies[i].node._blockHoist) continue;
              return bodies[i];
            }
          } else {
            return this.getNextScopeAttachmentParent();
          }
        } else if (scope.path.isProgram()) {
          return this.getNextScopeAttachmentParent();
        }
      }
    }, {
      key: "getNextScopeAttachmentParent",
      value: function getNextScopeAttachmentParent() {
        var scope = this.scopes.pop();
        if (scope) return this.getAttachmentParentForPath(scope.path);
      }
    }, {
      key: "getAttachmentParentForPath",
      value: function getAttachmentParentForPath(path) {
        do {
          if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
            return path;
          }
        } while (path = path.parentPath);
      }
    }, {
      key: "hasOwnParamBindings",
      value: function hasOwnParamBindings(scope) {
        for (var _i3 = 0, _Object$keys3 = Object.keys(this.bindings); _i3 < _Object$keys3.length; _i3++) {
          var name = _Object$keys3[_i3];
          if (!scope.hasOwnBinding(name)) continue;
          var binding = this.bindings[name];
          if (binding.kind === "param" && binding.constant) return true;
        }
        return false;
      }
    }, {
      key: "run",
      value: function run() {
        this.path.traverse(referenceVisitor, this);
        if (this.mutableBinding) return;
        this.getCompatibleScopes();
        var attachTo = this.getAttachmentPath();
        if (!attachTo) return;
        if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;
        var uid = attachTo.scope.generateUidIdentifier("ref");
        var declarator = variableDeclarator(uid, this.path.node);
        var insertFn = this.attachAfter ? "insertAfter" : "insertBefore";
        var _attachTo$insertFn = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration("var", [declarator])]),
          _attachTo$insertFn2 = _slicedToArray(_attachTo$insertFn, 1),
          attached = _attachTo$insertFn2[0];
        var parent = this.path.parentPath;
        if (parent.isJSXElement() && this.path.container === parent.node.children) {
          uid = jsxExpressionContainer(uid);
        }
        this.path.replaceWith(cloneNode(uid));
        return attachTo.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
      }
    }]);
  }();
  hoister["default"] = PathHoister;
  return hoister;
}

var hasRequiredModification;
function requireModification() {
  if (hasRequiredModification) return modification;
  hasRequiredModification = 1;
  Object.defineProperty(modification, "__esModule", {
    value: true
  });
  modification._containerInsert = _containerInsert;
  modification._containerInsertAfter = _containerInsertAfter;
  modification._containerInsertBefore = _containerInsertBefore;
  modification._verifyNodeList = _verifyNodeList;
  modification.insertAfter = insertAfter;
  modification.insertBefore = insertBefore;
  modification.pushContainer = pushContainer;
  modification.unshiftContainer = unshiftContainer;
  modification.updateSiblingKeys = updateSiblingKeys;
  var _cache = requireCache();
  var _index = requirePath();
  var _context = requireContext();
  var _removal = requireRemoval();
  var _t = requireLib$4();
  var _hoister = requireHoister();
  var arrowFunctionExpression = _t.arrowFunctionExpression,
    assertExpression = _t.assertExpression,
    assignmentExpression = _t.assignmentExpression,
    blockStatement = _t.blockStatement,
    callExpression = _t.callExpression,
    cloneNode = _t.cloneNode,
    expressionStatement = _t.expressionStatement,
    isAssignmentExpression = _t.isAssignmentExpression,
    isCallExpression = _t.isCallExpression,
    isExportNamedDeclaration = _t.isExportNamedDeclaration,
    isExpression = _t.isExpression,
    isIdentifier = _t.isIdentifier,
    isSequenceExpression = _t.isSequenceExpression,
    isSuper = _t.isSuper,
    thisExpression = _t.thisExpression;
  function insertBefore(nodes_) {
    _removal._assertUnremoved.call(this);
    var nodes = _verifyNodeList.call(this, nodes_);
    var parentPath = this.parentPath,
      parent = this.parent;
    if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
      return parentPath.insertBefore(nodes);
    } else if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
      if (this.node) nodes.push(this.node);
      return this.replaceExpressionWithStatements(nodes);
    } else if (Array.isArray(this.container)) {
      return _containerInsertBefore.call(this, nodes);
    } else if (this.isStatementOrBlock()) {
      var node = this.node;
      var shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
      this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));
      return this.unshiftContainer("body", nodes);
    } else {
      throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
    }
  }
  function _containerInsert(from, nodes) {
    var _this$container;
    updateSiblingKeys.call(this, from, nodes.length);
    var paths = [];
    (_this$container = this.container).splice.apply(_this$container, [from, 0].concat(_toConsumableArray(nodes)));
    for (var i = 0; i < nodes.length; i++) {
      var _this$context;
      var to = from + i;
      var path = this.getSibling(to);
      paths.push(path);
      if ((_this$context = this.context) != null && _this$context.queue) {
        _context.pushContext.call(path, this.context);
      }
    }
    var contexts = _context._getQueueContexts.call(this);
    for (var _i = 0, _paths = paths; _i < _paths.length; _i++) {
      var _path = _paths[_i];
      _context.setScope.call(_path);
      _path.debug("Inserted.");
      var _iterator = _createForOfIteratorHelper(contexts),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var context = _step.value;
          context.maybeQueue(_path, true);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    return paths;
  }
  function _containerInsertBefore(nodes) {
    return _containerInsert.call(this, this.key, nodes);
  }
  function _containerInsertAfter(nodes) {
    return _containerInsert.call(this, this.key + 1, nodes);
  }
  var last = function last(arr) {
    return arr[arr.length - 1];
  };
  function isHiddenInSequenceExpression(path) {
    return isSequenceExpression(path.parent) && (last(path.parent.expressions) !== path.node || isHiddenInSequenceExpression(path.parentPath));
  }
  function isAlmostConstantAssignment(node, scope) {
    if (!isAssignmentExpression(node) || !isIdentifier(node.left)) {
      return false;
    }
    var blockScope = scope.getBlockParent();
    return blockScope.hasOwnBinding(node.left.name) && blockScope.getOwnBinding(node.left.name).constantViolations.length <= 1;
  }
  function insertAfter(nodes_) {
    _removal._assertUnremoved.call(this);
    if (this.isSequenceExpression()) {
      return last(this.get("expressions")).insertAfter(nodes_);
    }
    var nodes = _verifyNodeList.call(this, nodes_);
    var parentPath = this.parentPath,
      parent = this.parent;
    if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
      return parentPath.insertAfter(nodes.map(function (node) {
        return isExpression(node) ? expressionStatement(node) : node;
      }));
    } else if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
      var self = this;
      if (self.node) {
        var node = self.node;
        var scope = this.scope;
        if (scope.path.isPattern()) {
          assertExpression(node);
          self.replaceWith(callExpression(arrowFunctionExpression([], node), []));
          self.get("callee.body").insertAfter(nodes);
          return [self];
        }
        if (isHiddenInSequenceExpression(self)) {
          nodes.unshift(node);
        } else if (isCallExpression(node) && isSuper(node.callee)) {
          nodes.unshift(node);
          nodes.push(thisExpression());
        } else if (isAlmostConstantAssignment(node, scope)) {
          nodes.unshift(node);
          nodes.push(cloneNode(node.left));
        } else if (scope.isPure(node, true)) {
          nodes.push(node);
        } else {
          if (parentPath.isMethod({
            computed: true,
            key: node
          })) {
            scope = scope.parent;
          }
          var temp = scope.generateDeclaredUidIdentifier();
          nodes.unshift(expressionStatement(assignmentExpression("=", cloneNode(temp), node)));
          nodes.push(expressionStatement(cloneNode(temp)));
        }
      }
      return this.replaceExpressionWithStatements(nodes);
    } else if (Array.isArray(this.container)) {
      return _containerInsertAfter.call(this, nodes);
    } else if (this.isStatementOrBlock()) {
      var _node = this.node;
      var shouldInsertCurrentNode = _node && (!this.isExpressionStatement() || _node.expression != null);
      this.replaceWith(blockStatement(shouldInsertCurrentNode ? [_node] : []));
      return this.pushContainer("body", nodes);
    } else {
      throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
    }
  }
  function updateSiblingKeys(fromIndex, incrementBy) {
    if (!this.parent) return;
    var paths = (0, _cache.getCachedPaths)(this.hub, this.parent) || [];
    var _iterator2 = _createForOfIteratorHelper(paths),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _step2$value = _slicedToArray(_step2.value, 2),
          path = _step2$value[1];
        if (typeof path.key === "number" && path.container === this.container && path.key >= fromIndex) {
          path.key += incrementBy;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  function _verifyNodeList(nodes) {
    if (!nodes) {
      return [];
    }
    if (!Array.isArray(nodes)) {
      nodes = [nodes];
    }
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      var msg = void 0;
      if (!node) {
        msg = "has falsy node";
      } else if (_typeof(node) !== "object") {
        msg = "contains a non-object node";
      } else if (!node.type) {
        msg = "without a type";
      } else if (node instanceof _index["default"]) {
        msg = "has a NodePath when it expected a raw object";
      }
      if (msg) {
        var type = Array.isArray(node) ? "array" : _typeof(node);
        throw new Error("Node list ".concat(msg, " with the index of ").concat(i, " and type of ").concat(type));
      }
    }
    return nodes;
  }
  function unshiftContainer(listKey, nodes) {
    _removal._assertUnremoved.call(this);
    nodes = _verifyNodeList.call(this, nodes);
    var path = _index["default"].get({
      parentPath: this,
      parent: this.node,
      container: this.node[listKey],
      listKey: listKey,
      key: 0
    }).setContext(this.context);
    return _containerInsertBefore.call(path, nodes);
  }
  function pushContainer(listKey, nodes) {
    _removal._assertUnremoved.call(this);
    var verifiedNodes = _verifyNodeList.call(this, nodes);
    var container = this.node[listKey];
    var path = _index["default"].get({
      parentPath: this,
      parent: this.node,
      container: container,
      listKey: listKey,
      key: container.length
    }).setContext(this.context);
    return path.replaceWithMultiple(verifiedNodes);
  }
  {
    modification.hoist = function hoist() {
      var scope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.scope;
      var hoister = new _hoister["default"](this, scope);
      return hoister.run();
    };
  }
  return modification;
}

var hasRequiredReplacement;
function requireReplacement() {
  if (hasRequiredReplacement) return replacement;
  hasRequiredReplacement = 1;
  Object.defineProperty(replacement, "__esModule", {
    value: true
  });
  replacement._replaceWith = _replaceWith;
  replacement.replaceExpressionWithStatements = replaceExpressionWithStatements;
  replacement.replaceInline = replaceInline;
  replacement.replaceWith = replaceWith;
  replacement.replaceWithMultiple = replaceWithMultiple;
  replacement.replaceWithSourceString = replaceWithSourceString;
  var _codeFrame = requireLib$2();
  var _index = requireLib();
  var _index2 = requirePath();
  var _cache = requireCache();
  var _modification = requireModification();
  var _parser = requireLib$7();
  var _t = requireLib$4();
  var _context = requireContext();
  var FUNCTION_TYPES = _t.FUNCTION_TYPES,
    arrowFunctionExpression = _t.arrowFunctionExpression,
    assignmentExpression = _t.assignmentExpression,
    awaitExpression = _t.awaitExpression,
    blockStatement = _t.blockStatement,
    buildUndefinedNode = _t.buildUndefinedNode,
    callExpression = _t.callExpression,
    cloneNode = _t.cloneNode,
    conditionalExpression = _t.conditionalExpression,
    expressionStatement = _t.expressionStatement,
    getBindingIdentifiers = _t.getBindingIdentifiers,
    identifier = _t.identifier,
    inheritLeadingComments = _t.inheritLeadingComments,
    inheritTrailingComments = _t.inheritTrailingComments,
    inheritsComments = _t.inheritsComments,
    isBlockStatement = _t.isBlockStatement,
    isEmptyStatement = _t.isEmptyStatement,
    isExpression = _t.isExpression,
    isExpressionStatement = _t.isExpressionStatement,
    isIfStatement = _t.isIfStatement,
    isProgram = _t.isProgram,
    isStatement = _t.isStatement,
    isVariableDeclaration = _t.isVariableDeclaration,
    removeComments = _t.removeComments,
    returnStatement = _t.returnStatement,
    sequenceExpression = _t.sequenceExpression,
    validate = _t.validate,
    yieldExpression = _t.yieldExpression;
  function replaceWithMultiple(nodes) {
    var _getCachedPaths;
    _context.resync.call(this);
    nodes = _modification._verifyNodeList.call(this, nodes);
    inheritLeadingComments(nodes[0], this.node);
    inheritTrailingComments(nodes[nodes.length - 1], this.node);
    (_getCachedPaths = (0, _cache.getCachedPaths)(this.hub, this.parent)) == null || _getCachedPaths["delete"](this.node);
    this.node = this.container[this.key] = null;
    var paths = this.insertAfter(nodes);
    if (this.node) {
      this.requeue();
    } else {
      this.remove();
    }
    return paths;
  }
  function replaceWithSourceString(replacement) {
    _context.resync.call(this);
    var ast;
    try {
      replacement = "(".concat(replacement, ")");
      ast = (0, _parser.parse)(replacement);
    } catch (err) {
      var loc = err.loc;
      if (loc) {
        err.message += " - make sure this is an expression.\n" + (0, _codeFrame.codeFrameColumns)(replacement, {
          start: {
            line: loc.line,
            column: loc.column + 1
          }
        });
        err.code = "BABEL_REPLACE_SOURCE_ERROR";
      }
      throw err;
    }
    var expressionAST = ast.program.body[0].expression;
    _index["default"].removeProperties(expressionAST);
    return this.replaceWith(expressionAST);
  }
  function replaceWith(replacementPath) {
    _context.resync.call(this);
    if (this.removed) {
      throw new Error("You can't replace this node, we've already removed it");
    }
    var replacement = replacementPath instanceof _index2["default"] ? replacementPath.node : replacementPath;
    if (!replacement) {
      throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    }
    if (this.node === replacement) {
      return [this];
    }
    if (this.isProgram() && !isProgram(replacement)) {
      throw new Error("You can only replace a Program root node with another Program node");
    }
    if (Array.isArray(replacement)) {
      throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    }
    if (typeof replacement === "string") {
      throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    }
    var nodePath = "";
    if (this.isNodeType("Statement") && isExpression(replacement)) {
      if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {
        replacement = expressionStatement(replacement);
        nodePath = "expression";
      }
    }
    if (this.isNodeType("Expression") && isStatement(replacement)) {
      if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
        return this.replaceExpressionWithStatements([replacement]);
      }
    }
    var oldNode = this.node;
    if (oldNode) {
      inheritsComments(replacement, oldNode);
      removeComments(oldNode);
    }
    _replaceWith.call(this, replacement);
    this.type = replacement.type;
    _context.setScope.call(this);
    this.requeue();
    return [nodePath ? this.get(nodePath) : this];
  }
  function _replaceWith(node) {
    var _getCachedPaths2;
    if (!this.container) {
      throw new ReferenceError("Container is falsy");
    }
    if (this.inList) {
      validate(this.parent, this.key, [node]);
    } else {
      validate(this.parent, this.key, node);
    }
    this.debug("Replace with ".concat(node == null ? void 0 : node.type));
    (_getCachedPaths2 = (0, _cache.getCachedPaths)(this.hub, this.parent)) == null || _getCachedPaths2.set(node, this)["delete"](this.node);
    this.node = this.container[this.key] = node;
  }
  function replaceExpressionWithStatements(nodes) {
    var _this = this;
    _context.resync.call(this);
    var declars = [];
    var nodesAsSingleExpression = gatherSequenceExpressions(nodes, declars);
    if (nodesAsSingleExpression) {
      var _iterator = _createForOfIteratorHelper(declars),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var id = _step.value;
          this.scope.push({
            id: id
          });
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return this.replaceWith(nodesAsSingleExpression)[0].get("expressions");
    }
    var functionParent = this.getFunctionParent();
    var isParentAsync = functionParent == null ? void 0 : functionParent.node.async;
    var isParentGenerator = functionParent == null ? void 0 : functionParent.node.generator;
    var container = arrowFunctionExpression([], blockStatement(nodes));
    this.replaceWith(callExpression(container, []));
    var callee = this.get("callee");
    callee.get("body").scope.hoistVariables(function (id) {
      return _this.scope.push({
        id: id
      });
    });
    var completionRecords = callee.getCompletionRecords();
    var _iterator2 = _createForOfIteratorHelper(completionRecords),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var path = _step2.value;
        if (!path.isExpressionStatement()) continue;
        var loop = path.findParent(function (path) {
          return path.isLoop();
        });
        if (loop) {
          var uid = loop.getData("expressionReplacementReturnUid");
          if (!uid) {
            uid = callee.scope.generateDeclaredUidIdentifier("ret");
            callee.get("body").pushContainer("body", returnStatement(cloneNode(uid)));
            loop.setData("expressionReplacementReturnUid", uid);
          } else {
            uid = identifier(uid.name);
          }
          path.get("expression").replaceWith(assignmentExpression("=", cloneNode(uid), path.node.expression));
        } else {
          path.replaceWith(returnStatement(path.node.expression));
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    callee.arrowFunctionToExpression();
    var newCallee = callee;
    var needToAwaitFunction = isParentAsync && _index["default"].hasType(this.get("callee.body").node, "AwaitExpression", FUNCTION_TYPES);
    var needToYieldFunction = isParentGenerator && _index["default"].hasType(this.get("callee.body").node, "YieldExpression", FUNCTION_TYPES);
    if (needToAwaitFunction) {
      newCallee.set("async", true);
      if (!needToYieldFunction) {
        this.replaceWith(awaitExpression(this.node));
      }
    }
    if (needToYieldFunction) {
      newCallee.set("generator", true);
      this.replaceWith(yieldExpression(this.node, true));
    }
    return newCallee.get("body.body");
  }
  function gatherSequenceExpressions(nodes, declars) {
    var exprs = [];
    var ensureLastUndefined = true;
    var _iterator3 = _createForOfIteratorHelper(nodes),
      _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var node = _step3.value;
        if (!isEmptyStatement(node)) {
          ensureLastUndefined = false;
        }
        if (isExpression(node)) {
          exprs.push(node);
        } else if (isExpressionStatement(node)) {
          exprs.push(node.expression);
        } else if (isVariableDeclaration(node)) {
          if (node.kind !== "var") return;
          var _iterator4 = _createForOfIteratorHelper(node.declarations),
            _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var declar = _step4.value;
              var bindings = getBindingIdentifiers(declar);
              for (var _i = 0, _Object$keys = Object.keys(bindings); _i < _Object$keys.length; _i++) {
                var key = _Object$keys[_i];
                declars.push(cloneNode(bindings[key]));
              }
              if (declar.init) {
                exprs.push(assignmentExpression("=", declar.id, declar.init));
              }
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
          ensureLastUndefined = true;
        } else if (isIfStatement(node)) {
          var consequent = node.consequent ? gatherSequenceExpressions([node.consequent], declars) : buildUndefinedNode();
          var alternate = node.alternate ? gatherSequenceExpressions([node.alternate], declars) : buildUndefinedNode();
          if (!consequent || !alternate) return;
          exprs.push(conditionalExpression(node.test, consequent, alternate));
        } else if (isBlockStatement(node)) {
          var body = gatherSequenceExpressions(node.body, declars);
          if (!body) return;
          exprs.push(body);
        } else if (isEmptyStatement(node)) {
          if (nodes.indexOf(node) === 0) {
            ensureLastUndefined = true;
          }
        } else {
          return;
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
    if (ensureLastUndefined) exprs.push(buildUndefinedNode());
    if (exprs.length === 1) {
      return exprs[0];
    } else {
      return sequenceExpression(exprs);
    }
  }
  function replaceInline(nodes) {
    _context.resync.call(this);
    if (Array.isArray(nodes)) {
      if (Array.isArray(this.container)) {
        nodes = _modification._verifyNodeList.call(this, nodes);
        var paths = _modification._containerInsertAfter.call(this, nodes);
        this.remove();
        return paths;
      } else {
        return this.replaceWithMultiple(nodes);
      }
    } else {
      return this.replaceWith(nodes);
    }
  }
  return replacement;
}

var evaluation = {};

var hasRequiredEvaluation;
function requireEvaluation() {
  if (hasRequiredEvaluation) return evaluation;
  hasRequiredEvaluation = 1;
  Object.defineProperty(evaluation, "__esModule", {
    value: true
  });
  evaluation.evaluate = evaluate;
  evaluation.evaluateTruthy = evaluateTruthy;
  var VALID_OBJECT_CALLEES = ["Number", "String", "Math"];
  var VALID_IDENTIFIER_CALLEES = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", null, null];
  var INVALID_METHODS = ["random"];
  function isValidObjectCallee(val) {
    return VALID_OBJECT_CALLEES.includes(val);
  }
  function isValidIdentifierCallee(val) {
    return VALID_IDENTIFIER_CALLEES.includes(val);
  }
  function isInvalidMethod(val) {
    return INVALID_METHODS.includes(val);
  }
  function evaluateTruthy() {
    var res = this.evaluate();
    if (res.confident) return !!res.value;
  }
  function deopt(path, state) {
    if (!state.confident) return;
    state.deoptPath = path;
    state.confident = false;
  }
  var Globals = new Map([["undefined", undefined], ["Infinity", Infinity], ["NaN", NaN]]);
  function evaluateCached(path, state) {
    var node = path.node;
    var seen = state.seen;
    if (seen.has(node)) {
      var existing = seen.get(node);
      if (existing.resolved) {
        return existing.value;
      } else {
        deopt(path, state);
        return;
      }
    } else {
      var item = {
        resolved: false
      };
      seen.set(node, item);
      var val = _evaluate(path, state);
      if (state.confident) {
        item.resolved = true;
        item.value = val;
      }
      return val;
    }
  }
  function _evaluate(path, state) {
    if (!state.confident) return;
    if (path.isSequenceExpression()) {
      var exprs = path.get("expressions");
      return evaluateCached(exprs[exprs.length - 1], state);
    }
    if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
      return path.node.value;
    }
    if (path.isNullLiteral()) {
      return null;
    }
    if (path.isTemplateLiteral()) {
      return evaluateQuasis(path, path.node.quasis, state);
    }
    if (path.isTaggedTemplateExpression() && path.get("tag").isMemberExpression()) {
      var object = path.get("tag.object");
      var name = object.node.name;
      var property = path.get("tag.property");
      if (object.isIdentifier() && name === "String" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === "raw") {
        return evaluateQuasis(path, path.node.quasi.quasis, state, true);
      }
    }
    if (path.isConditionalExpression()) {
      var testResult = evaluateCached(path.get("test"), state);
      if (!state.confident) return;
      if (testResult) {
        return evaluateCached(path.get("consequent"), state);
      } else {
        return evaluateCached(path.get("alternate"), state);
      }
    }
    if (path.isExpressionWrapper()) {
      return evaluateCached(path.get("expression"), state);
    }
    if (path.isMemberExpression() && !path.parentPath.isCallExpression({
      callee: path.node
    })) {
      var _property = path.get("property");
      var _object = path.get("object");
      if (_object.isLiteral()) {
        var value = _object.node.value;
        var type = _typeof(value);
        var key = null;
        if (path.node.computed) {
          key = evaluateCached(_property, state);
          if (!state.confident) return;
        } else if (_property.isIdentifier()) {
          key = _property.node.name;
        }
        if ((type === "number" || type === "string") && key != null && (typeof key === "number" || typeof key === "string")) {
          return value[key];
        }
      }
    }
    if (path.isReferencedIdentifier()) {
      var binding = path.scope.getBinding(path.node.name);
      if (binding) {
        if (binding.constantViolations.length > 0 || path.node.start < binding.path.node.end) {
          deopt(binding.path, state);
          return;
        }
        if (binding.hasValue) {
          return binding.value;
        }
      }
      var _name = path.node.name;
      if (Globals.has(_name)) {
        if (!binding) {
          return Globals.get(_name);
        }
        deopt(binding.path, state);
        return;
      }
      var resolved = path.resolve();
      if (resolved === path) {
        deopt(path, state);
        return;
      } else {
        return evaluateCached(resolved, state);
      }
    }
    if (path.isUnaryExpression({
      prefix: true
    })) {
      if (path.node.operator === "void") {
        return undefined;
      }
      var argument = path.get("argument");
      if (path.node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
        return "function";
      }
      var arg = evaluateCached(argument, state);
      if (!state.confident) return;
      switch (path.node.operator) {
        case "!":
          return !arg;
        case "+":
          return +arg;
        case "-":
          return -arg;
        case "~":
          return ~arg;
        case "typeof":
          return _typeof(arg);
      }
    }
    if (path.isArrayExpression()) {
      var arr = [];
      var elems = path.get("elements");
      var _iterator = _createForOfIteratorHelper(elems),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var elem = _step.value;
          var elemValue = elem.evaluate();
          if (elemValue.confident) {
            arr.push(elemValue.value);
          } else {
            deopt(elemValue.deopt, state);
            return;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return arr;
    }
    if (path.isObjectExpression()) {
      var obj = {};
      var props = path.get("properties");
      var _iterator2 = _createForOfIteratorHelper(props),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var prop = _step2.value;
          if (prop.isObjectMethod() || prop.isSpreadElement()) {
            deopt(prop, state);
            return;
          }
          var keyPath = prop.get("key");
          var _key = void 0;
          if (prop.node.computed) {
            _key = keyPath.evaluate();
            if (!_key.confident) {
              deopt(_key.deopt, state);
              return;
            }
            _key = _key.value;
          } else if (keyPath.isIdentifier()) {
            _key = keyPath.node.name;
          } else {
            _key = keyPath.node.value;
          }
          var valuePath = prop.get("value");
          var _value = valuePath.evaluate();
          if (!_value.confident) {
            deopt(_value.deopt, state);
            return;
          }
          _value = _value.value;
          obj[_key] = _value;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      return obj;
    }
    if (path.isLogicalExpression()) {
      var wasConfident = state.confident;
      var left = evaluateCached(path.get("left"), state);
      var leftConfident = state.confident;
      state.confident = wasConfident;
      var right = evaluateCached(path.get("right"), state);
      var rightConfident = state.confident;
      switch (path.node.operator) {
        case "||":
          state.confident = leftConfident && (!!left || rightConfident);
          if (!state.confident) return;
          return left || right;
        case "&&":
          state.confident = leftConfident && (!left || rightConfident);
          if (!state.confident) return;
          return left && right;
        case "??":
          state.confident = leftConfident && (left != null || rightConfident);
          if (!state.confident) return;
          return left != null ? left : right;
      }
    }
    if (path.isBinaryExpression()) {
      var _left = evaluateCached(path.get("left"), state);
      if (!state.confident) return;
      var _right = evaluateCached(path.get("right"), state);
      if (!state.confident) return;
      switch (path.node.operator) {
        case "-":
          return _left - _right;
        case "+":
          return _left + _right;
        case "/":
          return _left / _right;
        case "*":
          return _left * _right;
        case "%":
          return _left % _right;
        case "**":
          return Math.pow(_left, _right);
        case "<":
          return _left < _right;
        case ">":
          return _left > _right;
        case "<=":
          return _left <= _right;
        case ">=":
          return _left >= _right;
        case "==":
          return _left == _right;
        case "!=":
          return _left != _right;
        case "===":
          return _left === _right;
        case "!==":
          return _left !== _right;
        case "|":
          return _left | _right;
        case "&":
          return _left & _right;
        case "^":
          return _left ^ _right;
        case "<<":
          return _left << _right;
        case ">>":
          return _left >> _right;
        case ">>>":
          return _left >>> _right;
      }
    }
    if (path.isCallExpression()) {
      var callee = path.get("callee");
      var context;
      var func;
      if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && (isValidObjectCallee(callee.node.name) || isValidIdentifierCallee(callee.node.name))) {
        func = commonjsGlobal[callee.node.name];
      }
      if (callee.isMemberExpression()) {
        var _object2 = callee.get("object");
        var _property2 = callee.get("property");
        if (_object2.isIdentifier() && _property2.isIdentifier() && isValidObjectCallee(_object2.node.name) && !isInvalidMethod(_property2.node.name)) {
          context = commonjsGlobal[_object2.node.name];
          var _key2 = _property2.node.name;
          if (hasOwnProperty.call(context, _key2)) {
            func = context[_key2];
          }
        }
        if (_object2.isLiteral() && _property2.isIdentifier()) {
          var _type = _typeof(_object2.node.value);
          if (_type === "string" || _type === "number") {
            context = _object2.node.value;
            func = context[_property2.node.name];
          }
        }
      }
      if (func) {
        var args = path.get("arguments").map(function (arg) {
          return evaluateCached(arg, state);
        });
        if (!state.confident) return;
        return func.apply(context, args);
      }
    }
    deopt(path, state);
  }
  function evaluateQuasis(path, quasis, state) {
    var raw = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var str = "";
    var i = 0;
    var exprs = path.isTemplateLiteral() ? path.get("expressions") : path.get("quasi.expressions");
    var _iterator3 = _createForOfIteratorHelper(quasis),
      _step3;
    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var elem = _step3.value;
        if (!state.confident) break;
        str += raw ? elem.value.raw : elem.value.cooked;
        var expr = exprs[i++];
        if (expr) str += String(evaluateCached(expr, state));
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
    if (!state.confident) return;
    return str;
  }
  function evaluate() {
    var state = {
      confident: true,
      deoptPath: null,
      seen: new Map()
    };
    var value = evaluateCached(this, state);
    if (!state.confident) value = undefined;
    return {
      confident: state.confident,
      deopt: state.deoptPath,
      value: value
    };
  }
  return evaluation;
}

var conversion = {};

var lib = {};

var formatters = {};

var hasRequiredFormatters;
function requireFormatters() {
  if (hasRequiredFormatters) return formatters;
  hasRequiredFormatters = 1;
  Object.defineProperty(formatters, "__esModule", {
    value: true
  });
  formatters.statements = formatters.statement = formatters.smart = formatters.program = formatters.expression = void 0;
  var _t = requireLib$4();
  var assertExpressionStatement = _t.assertExpressionStatement;
  function makeStatementFormatter(fn) {
    return {
      code: function code(str) {
        return "/* @babel/template */;\n".concat(str);
      },
      validate: function validate() {},
      unwrap: function unwrap(ast) {
        return fn(ast.program.body.slice(1));
      }
    };
  }
  formatters.smart = makeStatementFormatter(function (body) {
    if (body.length > 1) {
      return body;
    } else {
      return body[0];
    }
  });
  formatters.statements = makeStatementFormatter(function (body) {
    return body;
  });
  formatters.statement = makeStatementFormatter(function (body) {
    if (body.length === 0) {
      throw new Error("Found nothing to return.");
    }
    if (body.length > 1) {
      throw new Error("Found multiple statements but wanted one");
    }
    return body[0];
  });
  var expression = formatters.expression = {
    code: function code(str) {
      return "(\n".concat(str, "\n)");
    },
    validate: function validate(ast) {
      if (ast.program.body.length > 1) {
        throw new Error("Found multiple statements but wanted one");
      }
      if (expression.unwrap(ast).start === 0) {
        throw new Error("Parse result included parens.");
      }
    },
    unwrap: function unwrap(_ref) {
      var program = _ref.program;
      var _program$body = _slicedToArray(program.body, 1),
        stmt = _program$body[0];
      assertExpressionStatement(stmt);
      return stmt.expression;
    }
  };
  formatters.program = {
    code: function code(str) {
      return str;
    },
    validate: function validate() {},
    unwrap: function unwrap(ast) {
      return ast.program;
    }
  };
  return formatters;
}

var builder = {};

var options = {};

var hasRequiredOptions;
function requireOptions() {
  if (hasRequiredOptions) return options;
  hasRequiredOptions = 1;
  Object.defineProperty(options, "__esModule", {
    value: true
  });
  options.merge = merge;
  options.normalizeReplacements = normalizeReplacements;
  options.validate = validate;
  var _excluded = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
  function _objectWithoutPropertiesLoose(r, e) {
    if (null == r) return {};
    var t = {};
    for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
      if (e.includes(n)) continue;
      t[n] = r[n];
    }
    return t;
  }
  function merge(a, b) {
    var _b$placeholderWhiteli = b.placeholderWhitelist,
      placeholderWhitelist = _b$placeholderWhiteli === void 0 ? a.placeholderWhitelist : _b$placeholderWhiteli,
      _b$placeholderPattern = b.placeholderPattern,
      placeholderPattern = _b$placeholderPattern === void 0 ? a.placeholderPattern : _b$placeholderPattern,
      _b$preserveComments = b.preserveComments,
      preserveComments = _b$preserveComments === void 0 ? a.preserveComments : _b$preserveComments,
      _b$syntacticPlacehold = b.syntacticPlaceholders,
      syntacticPlaceholders = _b$syntacticPlacehold === void 0 ? a.syntacticPlaceholders : _b$syntacticPlacehold;
    return {
      parser: Object.assign({}, a.parser, b.parser),
      placeholderWhitelist: placeholderWhitelist,
      placeholderPattern: placeholderPattern,
      preserveComments: preserveComments,
      syntacticPlaceholders: syntacticPlaceholders
    };
  }
  function validate(opts) {
    if (opts != null && _typeof(opts) !== "object") {
      throw new Error("Unknown template options.");
    }
    var _ref = opts || {},
      placeholderWhitelist = _ref.placeholderWhitelist,
      placeholderPattern = _ref.placeholderPattern,
      preserveComments = _ref.preserveComments,
      syntacticPlaceholders = _ref.syntacticPlaceholders,
      parser = _objectWithoutPropertiesLoose(_ref, _excluded);
    if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
      throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
    }
    if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {
      throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
    }
    if (preserveComments != null && typeof preserveComments !== "boolean") {
      throw new Error("'.preserveComments' must be a boolean, null, or undefined");
    }
    if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== "boolean") {
      throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
    }
    if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
    }
    return {
      parser: parser,
      placeholderWhitelist: placeholderWhitelist || undefined,
      placeholderPattern: placeholderPattern == null ? undefined : placeholderPattern,
      preserveComments: preserveComments == null ? undefined : preserveComments,
      syntacticPlaceholders: syntacticPlaceholders == null ? undefined : syntacticPlaceholders
    };
  }
  function normalizeReplacements(replacements) {
    if (Array.isArray(replacements)) {
      return replacements.reduce(function (acc, replacement, i) {
        acc["$" + i] = replacement;
        return acc;
      }, {});
    } else if (_typeof(replacements) === "object" || replacements == null) {
      return replacements || undefined;
    }
    throw new Error("Template replacements must be an array, object, null, or undefined");
  }
  return options;
}

var string = {};

var parse = {};

var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse;
  hasRequiredParse = 1;
  Object.defineProperty(parse, "__esModule", {
    value: true
  });
  parse["default"] = parseAndBuildMetadata;
  var _t = requireLib$4();
  var _parser = requireLib$7();
  var _codeFrame = requireLib$2();
  var isCallExpression = _t.isCallExpression,
    isExpressionStatement = _t.isExpressionStatement,
    isFunction = _t.isFunction,
    isIdentifier = _t.isIdentifier,
    isJSXIdentifier = _t.isJSXIdentifier,
    isNewExpression = _t.isNewExpression,
    isPlaceholder = _t.isPlaceholder,
    isStatement = _t.isStatement,
    isStringLiteral = _t.isStringLiteral,
    removePropertiesDeep = _t.removePropertiesDeep,
    traverse = _t.traverse;
  var PATTERN = /^[_$A-Z0-9]+$/;
  function parseAndBuildMetadata(formatter, code, opts) {
    var placeholderWhitelist = opts.placeholderWhitelist,
      placeholderPattern = opts.placeholderPattern,
      preserveComments = opts.preserveComments,
      syntacticPlaceholders = opts.syntacticPlaceholders;
    var ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);
    removePropertiesDeep(ast, {
      preserveComments: preserveComments
    });
    formatter.validate(ast);
    var state = {
      syntactic: {
        placeholders: [],
        placeholderNames: new Set()
      },
      legacy: {
        placeholders: [],
        placeholderNames: new Set()
      },
      placeholderWhitelist: placeholderWhitelist,
      placeholderPattern: placeholderPattern,
      syntacticPlaceholders: syntacticPlaceholders
    };
    traverse(ast, placeholderVisitorHandler, state);
    return Object.assign({
      ast: ast
    }, state.syntactic.placeholders.length ? state.syntactic : state.legacy);
  }
  function placeholderVisitorHandler(node, ancestors, state) {
    var _state$placeholderWhi;
    var name;
    var hasSyntacticPlaceholders = state.syntactic.placeholders.length > 0;
    if (isPlaceholder(node)) {
      if (state.syntacticPlaceholders === false) {
        throw new Error("%%foo%%-style placeholders can't be used when " + "'.syntacticPlaceholders' is false.");
      }
      name = node.name.name;
      hasSyntacticPlaceholders = true;
    } else if (hasSyntacticPlaceholders || state.syntacticPlaceholders) {
      return;
    } else if (isIdentifier(node) || isJSXIdentifier(node)) {
      name = node.name;
    } else if (isStringLiteral(node)) {
      name = node.value;
    } else {
      return;
    }
    if (hasSyntacticPlaceholders && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
    }
    if (!hasSyntacticPlaceholders && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) {
      return;
    }
    ancestors = ancestors.slice();
    var _ancestors = ancestors[ancestors.length - 1],
      parent = _ancestors.node,
      key = _ancestors.key;
    var type;
    if (isStringLiteral(node) || isPlaceholder(node, {
      expectedNode: "StringLiteral"
    })) {
      type = "string";
    } else if (isNewExpression(parent) && key === "arguments" || isCallExpression(parent) && key === "arguments" || isFunction(parent) && key === "params") {
      type = "param";
    } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {
      type = "statement";
      ancestors = ancestors.slice(0, -1);
    } else if (isStatement(node) && isPlaceholder(node)) {
      type = "statement";
    } else {
      type = "other";
    }
    var _ref = !hasSyntacticPlaceholders ? state.legacy : state.syntactic,
      placeholders = _ref.placeholders,
      placeholderNames = _ref.placeholderNames;
    placeholders.push({
      name: name,
      type: type,
      resolve: function resolve(ast) {
        return resolveAncestors(ast, ancestors);
      },
      isDuplicate: placeholderNames.has(name)
    });
    placeholderNames.add(name);
  }
  function resolveAncestors(ast, ancestors) {
    var parent = ast;
    for (var i = 0; i < ancestors.length - 1; i++) {
      var _ancestors$i = ancestors[i],
        _key = _ancestors$i.key,
        _index = _ancestors$i.index;
      if (_index === undefined) {
        parent = parent[_key];
      } else {
        parent = parent[_key][_index];
      }
    }
    var _ancestors2 = ancestors[ancestors.length - 1],
      key = _ancestors2.key,
      index = _ancestors2.index;
    return {
      parent: parent,
      key: key,
      index: index
    };
  }
  function parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {
    var plugins = (parserOpts.plugins || []).slice();
    if (syntacticPlaceholders !== false) {
      plugins.push("placeholders");
    }
    parserOpts = Object.assign({
      allowReturnOutsideFunction: true,
      allowSuperOutsideMethod: true,
      sourceType: "module"
    }, parserOpts, {
      plugins: plugins
    });
    try {
      return (0, _parser.parse)(code, parserOpts);
    } catch (err) {
      var loc = err.loc;
      if (loc) {
        err.message += "\n" + (0, _codeFrame.codeFrameColumns)(code, {
          start: loc
        });
        err.code = "BABEL_TEMPLATE_PARSE_ERROR";
      }
      throw err;
    }
  }
  return parse;
}

var populate = {};

var hasRequiredPopulate;
function requirePopulate() {
  if (hasRequiredPopulate) return populate;
  hasRequiredPopulate = 1;
  Object.defineProperty(populate, "__esModule", {
    value: true
  });
  populate["default"] = populatePlaceholders;
  var _t = requireLib$4();
  var blockStatement = _t.blockStatement,
    cloneNode = _t.cloneNode,
    emptyStatement = _t.emptyStatement,
    expressionStatement = _t.expressionStatement,
    identifier = _t.identifier,
    isStatement = _t.isStatement,
    isStringLiteral = _t.isStringLiteral,
    stringLiteral = _t.stringLiteral,
    validate = _t.validate;
  function populatePlaceholders(metadata, replacements) {
    var ast = cloneNode(metadata.ast);
    if (replacements) {
      metadata.placeholders.forEach(function (placeholder) {
        if (!hasOwnProperty.call(replacements, placeholder.name)) {
          var placeholderName = placeholder.name;
          throw new Error("Error: No substitution given for \"".concat(placeholderName, "\". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['").concat(placeholderName, "'])}\n            - { placeholderPattern: /^").concat(placeholderName, "$/ }"));
        }
      });
      Object.keys(replacements).forEach(function (key) {
        if (!metadata.placeholderNames.has(key)) {
          throw new Error("Unknown substitution \"".concat(key, "\" given"));
        }
      });
    }
    metadata.placeholders.slice().reverse().forEach(function (placeholder) {
      try {
        applyReplacement(placeholder, ast, replacements && replacements[placeholder.name] || null);
      } catch (e) {
        e.message = "@babel/template placeholder \"".concat(placeholder.name, "\": ").concat(e.message);
        throw e;
      }
    });
    return ast;
  }
  function applyReplacement(placeholder, ast, replacement) {
    if (placeholder.isDuplicate) {
      if (Array.isArray(replacement)) {
        replacement = replacement.map(function (node) {
          return cloneNode(node);
        });
      } else if (_typeof(replacement) === "object") {
        replacement = cloneNode(replacement);
      }
    }
    var _placeholder$resolve = placeholder.resolve(ast),
      parent = _placeholder$resolve.parent,
      key = _placeholder$resolve.key,
      index = _placeholder$resolve.index;
    if (placeholder.type === "string") {
      if (typeof replacement === "string") {
        replacement = stringLiteral(replacement);
      }
      if (!replacement || !isStringLiteral(replacement)) {
        throw new Error("Expected string substitution");
      }
    } else if (placeholder.type === "statement") {
      if (index === undefined) {
        if (!replacement) {
          replacement = emptyStatement();
        } else if (Array.isArray(replacement)) {
          replacement = blockStatement(replacement);
        } else if (typeof replacement === "string") {
          replacement = expressionStatement(identifier(replacement));
        } else if (!isStatement(replacement)) {
          replacement = expressionStatement(replacement);
        }
      } else {
        if (replacement && !Array.isArray(replacement)) {
          if (typeof replacement === "string") {
            replacement = identifier(replacement);
          }
          if (!isStatement(replacement)) {
            replacement = expressionStatement(replacement);
          }
        }
      }
    } else if (placeholder.type === "param") {
      if (typeof replacement === "string") {
        replacement = identifier(replacement);
      }
      if (index === undefined) throw new Error("Assertion failure.");
    } else {
      if (typeof replacement === "string") {
        replacement = identifier(replacement);
      }
      if (Array.isArray(replacement)) {
        throw new Error("Cannot replace single expression with an array.");
      }
    }
    function set(parent, key, value) {
      var node = parent[key];
      parent[key] = value;
      if (node.type === "Identifier" || node.type === "Placeholder") {
        if (node.typeAnnotation) {
          value.typeAnnotation = node.typeAnnotation;
        }
        if (node.optional) {
          value.optional = node.optional;
        }
        if (node.decorators) {
          value.decorators = node.decorators;
        }
      }
    }
    if (index === undefined) {
      validate(parent, key, replacement);
      set(parent, key, replacement);
    } else {
      var items = parent[key].slice();
      if (placeholder.type === "statement" || placeholder.type === "param") {
        if (replacement == null) {
          items.splice(index, 1);
        } else if (Array.isArray(replacement)) {
          items.splice.apply(items, [index, 1].concat(_toConsumableArray(replacement)));
        } else {
          set(items, index, replacement);
        }
      } else {
        set(items, index, replacement);
      }
      validate(parent, key, items);
      parent[key] = items;
    }
  }
  return populate;
}

var hasRequiredString;
function requireString() {
  if (hasRequiredString) return string;
  hasRequiredString = 1;
  Object.defineProperty(string, "__esModule", {
    value: true
  });
  string["default"] = stringTemplate;
  var _options = requireOptions();
  var _parse = requireParse();
  var _populate = requirePopulate();
  function stringTemplate(formatter, code, opts) {
    code = formatter.code(code);
    var metadata;
    return function (arg) {
      var replacements = (0, _options.normalizeReplacements)(arg);
      if (!metadata) metadata = (0, _parse["default"])(formatter, code, opts);
      return formatter.unwrap((0, _populate["default"])(metadata, replacements));
    };
  }
  return string;
}

var literal = {};

var hasRequiredLiteral;
function requireLiteral() {
  if (hasRequiredLiteral) return literal;
  hasRequiredLiteral = 1;
  Object.defineProperty(literal, "__esModule", {
    value: true
  });
  literal["default"] = literalTemplate;
  var _options = requireOptions();
  var _parse = requireParse();
  var _populate = requirePopulate();
  function literalTemplate(formatter, tpl, opts) {
    var _buildLiteralData = buildLiteralData(formatter, tpl, opts),
      metadata = _buildLiteralData.metadata,
      names = _buildLiteralData.names;
    return function (arg) {
      var defaultReplacements = {};
      arg.forEach(function (replacement, i) {
        defaultReplacements[names[i]] = replacement;
      });
      return function (arg) {
        var replacements = (0, _options.normalizeReplacements)(arg);
        if (replacements) {
          Object.keys(replacements).forEach(function (key) {
            if (hasOwnProperty.call(defaultReplacements, key)) {
              throw new Error("Unexpected replacement overlap.");
            }
          });
        }
        return formatter.unwrap((0, _populate["default"])(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
      };
    };
  }
  function buildLiteralData(formatter, tpl, opts) {
    var prefix = "BABEL_TPL$";
    var raw = tpl.join("");
    do {
      prefix = "$$" + prefix;
    } while (raw.includes(prefix));
    var _buildTemplateCode = buildTemplateCode(tpl, prefix),
      names = _buildTemplateCode.names,
      code = _buildTemplateCode.code;
    var metadata = (0, _parse["default"])(formatter, formatter.code(code), {
      parser: opts.parser,
      placeholderWhitelist: new Set(names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
      placeholderPattern: opts.placeholderPattern,
      preserveComments: opts.preserveComments,
      syntacticPlaceholders: opts.syntacticPlaceholders
    });
    return {
      metadata: metadata,
      names: names
    };
  }
  function buildTemplateCode(tpl, prefix) {
    var names = [];
    var code = tpl[0];
    for (var i = 1; i < tpl.length; i++) {
      var value = "".concat(prefix).concat(i - 1);
      names.push(value);
      code += value + tpl[i];
    }
    return {
      names: names,
      code: code
    };
  }
  return literal;
}

var hasRequiredBuilder;
function requireBuilder() {
  if (hasRequiredBuilder) return builder;
  hasRequiredBuilder = 1;
  Object.defineProperty(builder, "__esModule", {
    value: true
  });
  builder["default"] = createTemplateBuilder;
  var _options = requireOptions();
  var _string = requireString();
  var _literal = requireLiteral();
  var NO_PLACEHOLDER = (0, _options.validate)({
    placeholderPattern: false
  });
  function createTemplateBuilder(formatter, defaultOpts) {
    var templateFnCache = new WeakMap();
    var templateAstCache = new WeakMap();
    var cachedOpts = defaultOpts || (0, _options.validate)(null);
    return Object.assign(function (tpl) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (typeof tpl === "string") {
        if (args.length > 1) throw new Error("Unexpected extra params.");
        return extendedTrace((0, _string["default"])(formatter, tpl, (0, _options.merge)(cachedOpts, (0, _options.validate)(args[0]))));
      } else if (Array.isArray(tpl)) {
        var _builder = templateFnCache.get(tpl);
        if (!_builder) {
          _builder = (0, _literal["default"])(formatter, tpl, cachedOpts);
          templateFnCache.set(tpl, _builder);
        }
        return extendedTrace(_builder(args));
      } else if (_typeof(tpl) === "object" && tpl) {
        if (args.length > 0) throw new Error("Unexpected extra params.");
        return createTemplateBuilder(formatter, (0, _options.merge)(cachedOpts, (0, _options.validate)(tpl)));
      }
      throw new Error("Unexpected template param ".concat(_typeof(tpl)));
    }, {
      ast: function ast(tpl) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        if (typeof tpl === "string") {
          if (args.length > 1) throw new Error("Unexpected extra params.");
          return (0, _string["default"])(formatter, tpl, (0, _options.merge)((0, _options.merge)(cachedOpts, (0, _options.validate)(args[0])), NO_PLACEHOLDER))();
        } else if (Array.isArray(tpl)) {
          var _builder2 = templateAstCache.get(tpl);
          if (!_builder2) {
            _builder2 = (0, _literal["default"])(formatter, tpl, (0, _options.merge)(cachedOpts, NO_PLACEHOLDER));
            templateAstCache.set(tpl, _builder2);
          }
          return _builder2(args)();
        }
        throw new Error("Unexpected template param ".concat(_typeof(tpl)));
      }
    });
  }
  function extendedTrace(fn) {
    var rootStack = "";
    try {
      throw new Error();
    } catch (error) {
      if (error.stack) {
        rootStack = error.stack.split("\n").slice(3).join("\n");
      }
    }
    return function (arg) {
      try {
        return fn(arg);
      } catch (err) {
        err.stack += "\n    =============\n".concat(rootStack);
        throw err;
      }
    };
  }
  return builder;
}

var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib;
  hasRequiredLib$1 = 1;
  Object.defineProperty(lib, "__esModule", {
    value: true
  });
  lib.statements = lib.statement = lib.smart = lib.program = lib.expression = lib["default"] = void 0;
  var formatters = requireFormatters();
  var _builder = requireBuilder();
  var smart = lib.smart = (0, _builder["default"])(formatters.smart);
  var statement = lib.statement = (0, _builder["default"])(formatters.statement);
  var statements = lib.statements = (0, _builder["default"])(formatters.statements);
  var expression = lib.expression = (0, _builder["default"])(formatters.expression);
  var program = lib.program = (0, _builder["default"])(formatters.program);
  lib["default"] = Object.assign(smart.bind(undefined), {
    smart: smart,
    statement: statement,
    statements: statements,
    expression: expression,
    program: program,
    ast: smart.ast
  });
  return lib;
}

var _templateObject;
var hasRequiredConversion;
function requireConversion() {
  if (hasRequiredConversion) return conversion;
  hasRequiredConversion = 1;
  Object.defineProperty(conversion, "__esModule", {
    value: true
  });
  conversion.arrowFunctionToExpression = arrowFunctionToExpression;
  conversion.ensureBlock = ensureBlock;
  conversion.ensureFunctionName = ensureFunctionName;
  conversion.splitExportDeclaration = splitExportDeclaration;
  conversion.toComputedKey = toComputedKey;
  conversion.unwrapFunctionEnvironment = unwrapFunctionEnvironment;
  var _t = requireLib$4();
  var _template = requireLib$1();
  var _visitors = requireVisitors();
  var _context = requireContext();
  var arrowFunctionExpression = _t.arrowFunctionExpression,
    assignmentExpression = _t.assignmentExpression,
    binaryExpression = _t.binaryExpression,
    blockStatement = _t.blockStatement,
    callExpression = _t.callExpression,
    conditionalExpression = _t.conditionalExpression,
    expressionStatement = _t.expressionStatement,
    identifier = _t.identifier,
    isIdentifier = _t.isIdentifier,
    jsxIdentifier = _t.jsxIdentifier,
    logicalExpression = _t.logicalExpression,
    LOGICAL_OPERATORS = _t.LOGICAL_OPERATORS,
    memberExpression = _t.memberExpression,
    metaProperty = _t.metaProperty,
    numericLiteral = _t.numericLiteral,
    objectExpression = _t.objectExpression,
    restElement = _t.restElement,
    returnStatement = _t.returnStatement,
    sequenceExpression = _t.sequenceExpression,
    spreadElement = _t.spreadElement,
    stringLiteral = _t.stringLiteral,
    _super = _t["super"],
    thisExpression = _t.thisExpression,
    toExpression = _t.toExpression,
    unaryExpression = _t.unaryExpression,
    toBindingIdentifierName = _t.toBindingIdentifierName,
    isFunction = _t.isFunction,
    isAssignmentPattern = _t.isAssignmentPattern,
    isRestElement = _t.isRestElement,
    getFunctionName = _t.getFunctionName,
    cloneNode = _t.cloneNode,
    variableDeclaration = _t.variableDeclaration,
    variableDeclarator = _t.variableDeclarator,
    exportNamedDeclaration = _t.exportNamedDeclaration,
    exportSpecifier = _t.exportSpecifier,
    inherits = _t.inherits;
  function toComputedKey() {
    var key;
    if (this.isMemberExpression()) {
      key = this.node.property;
    } else if (this.isProperty() || this.isMethod()) {
      key = this.node.key;
    } else {
      throw new ReferenceError("todo");
    }
    if (!this.node.computed) {
      if (isIdentifier(key)) key = stringLiteral(key.name);
    }
    return key;
  }
  function ensureBlock() {
    var body = this.get("body");
    var bodyNode = body.node;
    if (Array.isArray(body)) {
      throw new Error("Can't convert array path to a block statement");
    }
    if (!bodyNode) {
      throw new Error("Can't convert node without a body");
    }
    if (body.isBlockStatement()) {
      return bodyNode;
    }
    var statements = [];
    var stringPath = "body";
    var key;
    var listKey;
    if (body.isStatement()) {
      listKey = "body";
      key = 0;
      statements.push(body.node);
    } else {
      stringPath += ".body.0";
      if (this.isFunction()) {
        key = "argument";
        statements.push(returnStatement(body.node));
      } else {
        key = "expression";
        statements.push(expressionStatement(body.node));
      }
    }
    this.node.body = blockStatement(statements);
    var parentPath = this.get(stringPath);
    _context.setup.call(body, parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);
    return this.node;
  }
  {
    conversion.arrowFunctionToShadowed = function () {
      if (!this.isArrowFunctionExpression()) return;
      this.arrowFunctionToExpression();
    };
  }
  function unwrapFunctionEnvironment() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
      throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
    }
    hoistFunctionEnvironment(this);
  }
  function setType(path, type) {
    path.node.type = type;
  }
  function arrowFunctionToExpression() {
    var _arguments = arguments;
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$allowInsertArrow = _ref.allowInsertArrow,
      allowInsertArrow = _ref$allowInsertArrow === void 0 ? true : _ref$allowInsertArrow,
      _ref$allowInsertArrow2 = _ref.allowInsertArrowWithRest,
      allowInsertArrowWithRest = _ref$allowInsertArrow2 === void 0 ? allowInsertArrow : _ref$allowInsertArrow2,
      _ref$noNewArrows = _ref.noNewArrows,
      noNewArrows = _ref$noNewArrows === void 0 ? !function (_arguments$) {
        return (_arguments$ = _arguments[0]) == null ? void 0 : _arguments$.specCompliant;
      }() : _ref$noNewArrows;
    if (!this.isArrowFunctionExpression()) {
      throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
    }
    var self = this;
    if (!noNewArrows) {
      var _self$ensureFunctionN;
      self = (_self$ensureFunctionN = self.ensureFunctionName(false)) != null ? _self$ensureFunctionN : self;
    }
    var _hoistFunctionEnviron = hoistFunctionEnvironment(self, noNewArrows, allowInsertArrow, allowInsertArrowWithRest),
      thisBinding = _hoistFunctionEnviron.thisBinding,
      fn = _hoistFunctionEnviron.fnPath;
    fn.ensureBlock();
    setType(fn, "FunctionExpression");
    if (!noNewArrows) {
      var checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier("arrowCheckId");
      if (checkBinding) {
        fn.parentPath.scope.push({
          id: checkBinding,
          init: objectExpression([])
        });
      }
      fn.get("body").unshiftContainer("body", expressionStatement(callExpression(this.hub.addHelper("newArrowCheck"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));
      fn.replaceWith(callExpression(memberExpression(fn.node, identifier("bind")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));
      return fn.get("callee.object");
    }
    return fn;
  }
  var getSuperCallsVisitor = (0, _visitors.environmentVisitor)({
    CallExpression: function CallExpression(child, _ref2) {
      var allSuperCalls = _ref2.allSuperCalls;
      if (!child.get("callee").isSuper()) return;
      allSuperCalls.push(child);
    }
  });
  function hoistFunctionEnvironment(fnPath) {
    var noNewArrows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var allowInsertArrow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    var allowInsertArrowWithRest = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    var arrowParent;
    var thisEnvFn = fnPath.findParent(function (p) {
      if (p.isArrowFunctionExpression()) {
        var _arrowParent;
        (_arrowParent = arrowParent) != null ? _arrowParent : arrowParent = p;
        return false;
      }
      return p.isFunction() || p.isProgram() || p.isClassProperty({
        "static": false
      }) || p.isClassPrivateProperty({
        "static": false
      });
    });
    var inConstructor = thisEnvFn.isClassMethod({
      kind: "constructor"
    });
    if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {
      if (arrowParent) {
        thisEnvFn = arrowParent;
      } else if (allowInsertArrow) {
        fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), []));
        thisEnvFn = fnPath.get("callee");
        fnPath = thisEnvFn.get("body");
      } else {
        throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
      }
    }
    var _getScopeInformation = getScopeInformation(fnPath),
      thisPaths = _getScopeInformation.thisPaths,
      argumentsPaths = _getScopeInformation.argumentsPaths,
      newTargetPaths = _getScopeInformation.newTargetPaths,
      superProps = _getScopeInformation.superProps,
      superCalls = _getScopeInformation.superCalls;
    if (inConstructor && superCalls.length > 0) {
      if (!allowInsertArrow) {
        throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', " + "it's not possible to compile `super()` in an arrow function without compiling classes.\n" + "Please add '@babel/plugin-transform-classes' to your Babel configuration.");
      }
      if (!allowInsertArrowWithRest) {
        throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', " + "it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\n" + "Please add '@babel/plugin-transform-classes' to your Babel configuration.");
      }
      var allSuperCalls = [];
      thisEnvFn.traverse(getSuperCallsVisitor, {
        allSuperCalls: allSuperCalls
      });
      var superBinding = getSuperBinding(thisEnvFn);
      allSuperCalls.forEach(function (superCall) {
        var callee = identifier(superBinding);
        callee.loc = superCall.node.callee.loc;
        superCall.get("callee").replaceWith(callee);
      });
    }
    if (argumentsPaths.length > 0) {
      var argumentsBinding = getBinding(thisEnvFn, "arguments", function () {
        var args = function args() {
          return identifier("arguments");
        };
        if (thisEnvFn.scope.path.isProgram()) {
          return conditionalExpression(binaryExpression("===", unaryExpression("typeof", args()), stringLiteral("undefined")), thisEnvFn.scope.buildUndefinedNode(), args());
        } else {
          return args();
        }
      });
      argumentsPaths.forEach(function (argumentsChild) {
        var argsRef = identifier(argumentsBinding);
        argsRef.loc = argumentsChild.node.loc;
        argumentsChild.replaceWith(argsRef);
      });
    }
    if (newTargetPaths.length > 0) {
      var newTargetBinding = getBinding(thisEnvFn, "newtarget", function () {
        return metaProperty(identifier("new"), identifier("target"));
      });
      newTargetPaths.forEach(function (targetChild) {
        var targetRef = identifier(newTargetBinding);
        targetRef.loc = targetChild.node.loc;
        targetChild.replaceWith(targetRef);
      });
    }
    if (superProps.length > 0) {
      if (!allowInsertArrow) {
        throw superProps[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', " + "it's not possible to compile `super.prop` in an arrow function without compiling classes.\n" + "Please add '@babel/plugin-transform-classes' to your Babel configuration.");
      }
      var flatSuperProps = superProps.reduce(function (acc, superProp) {
        return acc.concat(standardizeSuperProperty(superProp));
      }, []);
      flatSuperProps.forEach(function (superProp) {
        var key = superProp.node.computed ? "" : superProp.get("property").node.name;
        var superParentPath = superProp.parentPath;
        var isAssignment = superParentPath.isAssignmentExpression({
          left: superProp.node
        });
        var isCall = superParentPath.isCallExpression({
          callee: superProp.node
        });
        var isTaggedTemplate = superParentPath.isTaggedTemplateExpression({
          tag: superProp.node
        });
        var superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
        var args = [];
        if (superProp.node.computed) {
          args.push(superProp.get("property").node);
        }
        if (isAssignment) {
          var value = superParentPath.node.right;
          args.push(value);
        }
        var call = callExpression(identifier(superBinding), args);
        if (isCall) {
          superParentPath.unshiftContainer("arguments", thisExpression());
          superProp.replaceWith(memberExpression(call, identifier("call")));
          thisPaths.push(superParentPath.get("arguments.0"));
        } else if (isAssignment) {
          superParentPath.replaceWith(call);
        } else if (isTaggedTemplate) {
          superProp.replaceWith(callExpression(memberExpression(call, identifier("bind"), false), [thisExpression()]));
          thisPaths.push(superProp.get("arguments.0"));
        } else {
          superProp.replaceWith(call);
        }
      });
    }
    var thisBinding;
    if (thisPaths.length > 0 || !noNewArrows) {
      thisBinding = getThisBinding(thisEnvFn, inConstructor);
      if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {
        thisPaths.forEach(function (thisChild) {
          var thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);
          thisRef.loc = thisChild.node.loc;
          thisChild.replaceWith(thisRef);
        });
        if (!noNewArrows) thisBinding = null;
      }
    }
    return {
      thisBinding: thisBinding,
      fnPath: fnPath
    };
  }
  function isLogicalOp(op) {
    return LOGICAL_OPERATORS.includes(op);
  }
  function standardizeSuperProperty(superProp) {
    if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") {
      var assignmentPath = superProp.parentPath;
      var op = assignmentPath.node.operator.slice(0, -1);
      var value = assignmentPath.node.right;
      var isLogicalAssignment = isLogicalOp(op);
      if (superProp.node.computed) {
        var tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
        var object = superProp.node.object;
        var property = superProp.node.property;
        assignmentPath.get("left").replaceWith(memberExpression(object, assignmentExpression("=", tmp, property), true));
        assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier(tmp.name), true), value));
      } else {
        var _object = superProp.node.object;
        var _property = superProp.node.property;
        assignmentPath.get("left").replaceWith(memberExpression(_object, _property));
        assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(_object, identifier(_property.name)), value));
      }
      if (isLogicalAssignment) {
        assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right));
      } else {
        assignmentPath.node.operator = "=";
      }
      return [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
    } else if (superProp.parentPath.isUpdateExpression()) {
      var updateExpr = superProp.parentPath;
      var _tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
      var computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null;
      var parts = [assignmentExpression("=", _tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression("=", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier(_tmp.name), numericLiteral(1)))];
      if (!superProp.parentPath.node.prefix) {
        parts.push(identifier(_tmp.name));
      }
      updateExpr.replaceWith(sequenceExpression(parts));
      var left = updateExpr.get("expressions.0.right");
      var right = updateExpr.get("expressions.1.left");
      return [left, right];
    }
    return [superProp];
    function rightExpression(op, left, right) {
      if (op === "=") {
        return assignmentExpression("=", left, right);
      } else {
        return binaryExpression(op, left, right);
      }
    }
  }
  function hasSuperClass(thisEnvFn) {
    return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
  }
  var assignSuperThisVisitor = (0, _visitors.environmentVisitor)({
    CallExpression: function CallExpression(child, _ref3) {
      var supers = _ref3.supers,
        thisBinding = _ref3.thisBinding;
      if (!child.get("callee").isSuper()) return;
      if (supers.has(child.node)) return;
      supers.add(child.node);
      child.replaceWithMultiple([child.node, assignmentExpression("=", identifier(thisBinding), identifier("this"))]);
    }
  });
  function getThisBinding(thisEnvFn, inConstructor) {
    return getBinding(thisEnvFn, "this", function (thisBinding) {
      if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();
      thisEnvFn.traverse(assignSuperThisVisitor, {
        supers: new WeakSet(),
        thisBinding: thisBinding
      });
    });
  }
  function getSuperBinding(thisEnvFn) {
    return getBinding(thisEnvFn, "supercall", function () {
      var argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
      return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));
    });
  }
  function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
    var op = isAssignment ? "set" : "get";
    return getBinding(thisEnvFn, "superprop_".concat(op, ":").concat(propName || ""), function () {
      var argsList = [];
      var fnBody;
      if (propName) {
        fnBody = memberExpression(_super(), identifier(propName));
      } else {
        var method = thisEnvFn.scope.generateUidIdentifier("prop");
        argsList.unshift(method);
        fnBody = memberExpression(_super(), identifier(method.name), true);
      }
      if (isAssignment) {
        var valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
        argsList.push(valueIdent);
        fnBody = assignmentExpression("=", fnBody, identifier(valueIdent.name));
      }
      return arrowFunctionExpression(argsList, fnBody);
    });
  }
  function getBinding(thisEnvFn, key, init) {
    var cacheKey = "binding:" + key;
    var data = thisEnvFn.getData(cacheKey);
    if (!data) {
      var id = thisEnvFn.scope.generateUidIdentifier(key);
      data = id.name;
      thisEnvFn.setData(cacheKey, data);
      thisEnvFn.scope.push({
        id: id,
        init: init(data)
      });
    }
    return data;
  }
  var getScopeInformationVisitor = (0, _visitors.environmentVisitor)({
    ThisExpression: function ThisExpression(child, _ref4) {
      var thisPaths = _ref4.thisPaths;
      thisPaths.push(child);
    },
    JSXIdentifier: function JSXIdentifier(child, _ref5) {
      var thisPaths = _ref5.thisPaths;
      if (child.node.name !== "this") return;
      if (!child.parentPath.isJSXMemberExpression({
        object: child.node
      }) && !child.parentPath.isJSXOpeningElement({
        name: child.node
      })) {
        return;
      }
      thisPaths.push(child);
    },
    CallExpression: function CallExpression(child, _ref6) {
      var superCalls = _ref6.superCalls;
      if (child.get("callee").isSuper()) superCalls.push(child);
    },
    MemberExpression: function MemberExpression(child, _ref7) {
      var superProps = _ref7.superProps;
      if (child.get("object").isSuper()) superProps.push(child);
    },
    Identifier: function Identifier(child, _ref8) {
      var argumentsPaths = _ref8.argumentsPaths;
      if (!child.isReferencedIdentifier({
        name: "arguments"
      })) return;
      var curr = child.scope;
      do {
        if (curr.hasOwnBinding("arguments")) {
          curr.rename("arguments");
          return;
        }
        if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {
          break;
        }
      } while (curr = curr.parent);
      argumentsPaths.push(child);
    },
    MetaProperty: function MetaProperty(child, _ref9) {
      var newTargetPaths = _ref9.newTargetPaths;
      if (!child.get("meta").isIdentifier({
        name: "new"
      })) return;
      if (!child.get("property").isIdentifier({
        name: "target"
      })) return;
      newTargetPaths.push(child);
    }
  });
  function getScopeInformation(fnPath) {
    var thisPaths = [];
    var argumentsPaths = [];
    var newTargetPaths = [];
    var superProps = [];
    var superCalls = [];
    fnPath.traverse(getScopeInformationVisitor, {
      thisPaths: thisPaths,
      argumentsPaths: argumentsPaths,
      newTargetPaths: newTargetPaths,
      superProps: superProps,
      superCalls: superCalls
    });
    return {
      thisPaths: thisPaths,
      argumentsPaths: argumentsPaths,
      newTargetPaths: newTargetPaths,
      superProps: superProps,
      superCalls: superCalls
    };
  }
  function splitExportDeclaration() {
    if (!this.isExportDeclaration() || this.isExportAllDeclaration()) {
      throw new Error("Only default and named export declarations can be split.");
    }
    if (this.isExportNamedDeclaration() && this.get("specifiers").length > 0) {
      throw new Error("It doesn't make sense to split exported specifiers.");
    }
    var declaration = this.get("declaration");
    if (this.isExportDefaultDeclaration()) {
      var standaloneDeclaration = declaration.isFunctionDeclaration() || declaration.isClassDeclaration();
      var exportExpr = declaration.isFunctionExpression() || declaration.isClassExpression();
      var scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;
      var id = declaration.node.id;
      var needBindingRegistration = false;
      if (!id) {
        needBindingRegistration = true;
        id = scope.generateUidIdentifier("default");
        if (standaloneDeclaration || exportExpr) {
          declaration.node.id = cloneNode(id);
        }
      } else if (exportExpr && scope.hasBinding(id.name)) {
        needBindingRegistration = true;
        id = scope.generateUidIdentifier(id.name);
      }
      var updatedDeclaration = standaloneDeclaration ? declaration.node : variableDeclaration("var", [variableDeclarator(cloneNode(id), declaration.node)]);
      var updatedExportDeclaration = exportNamedDeclaration(null, [exportSpecifier(cloneNode(id), identifier("default"))]);
      this.insertAfter(updatedExportDeclaration);
      this.replaceWith(updatedDeclaration);
      if (needBindingRegistration) {
        scope.registerDeclaration(this);
      }
      return this;
    } else if (this.get("specifiers").length > 0) {
      throw new Error("It doesn't make sense to split exported specifiers.");
    }
    var bindingIdentifiers = declaration.getOuterBindingIdentifiers();
    var specifiers = Object.keys(bindingIdentifiers).map(function (name) {
      return exportSpecifier(identifier(name), identifier(name));
    });
    var aliasDeclar = exportNamedDeclaration(null, specifiers);
    this.insertAfter(aliasDeclar);
    this.replaceWith(declaration.node);
    return this;
  }
  var refersOuterBindingVisitor = {
    "ReferencedIdentifier|BindingIdentifier": function ReferencedIdentifierBindingIdentifier(path, state) {
      if (path.node.name !== state.name) return;
      state.needsRename = true;
      path.stop();
    },
    Scope: function Scope(path, state) {
      if (path.scope.hasOwnBinding(state.name)) {
        path.skip();
      }
    }
  };
  function ensureFunctionName(supportUnicodeId) {
    if (this.node.id) return this;
    var res = getFunctionName(this.node, this.parent);
    if (res == null) return this;
    var name = res.name;
    if (!supportUnicodeId && /[\uD800-\uDFFF]/.test(name)) {
      return null;
    }
    if (name.startsWith("get ") || name.startsWith("set ")) {
      return null;
    }
    name = toBindingIdentifierName(name.replace(/[/ ]/g, "_"));
    var id = identifier(name);
    inherits(id, res.originalNode);
    var state = {
      needsRename: false,
      name: name
    };
    var scope = this.scope;
    var binding = scope.getOwnBinding(name);
    if (binding) {
      if (binding.kind === "param") {
        state.needsRename = true;
      }
    } else if (scope.parent.hasBinding(name) || scope.hasGlobal(name)) {
      this.traverse(refersOuterBindingVisitor, state);
    }
    if (!state.needsRename) {
      this.node.id = id;
      scope.getProgramParent().references[id.name] = true;
      return this;
    }
    if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {
      scope.rename(id.name);
      this.node.id = id;
      scope.getProgramParent().references[id.name] = true;
      return this;
    }
    if (!isFunction(this.node)) return null;
    var key = scope.generateUidIdentifier(id.name);
    var params = [];
    for (var i = 0, len = getFunctionArity(this.node); i < len; i++) {
      params.push(scope.generateUidIdentifier("x"));
    }
    var call = _template["default"].expression.ast(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n    (function (", ") {\n      function ", "(", ") {\n        return ", ".apply(this, arguments);\n      }\n\n      ", ".toString = function () {\n        return ", ".toString();\n      }\n\n      return ", ";\n    })(", ")\n  "])), key, id, params, cloneNode(key), cloneNode(id), cloneNode(key), cloneNode(id), toExpression(this.node));
    return this.replaceWith(call)[0].get("arguments.0");
  }
  function getFunctionArity(node) {
    var count = node.params.findIndex(function (param) {
      return isAssignmentPattern(param) || isRestElement(param);
    });
    return count === -1 ? node.params.length : count;
  }
  return conversion;
}

var introspection = {};

var hasRequiredIntrospection;
function requireIntrospection() {
  if (hasRequiredIntrospection) return introspection;
  hasRequiredIntrospection = 1;
  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
    exports._resolve = _resolve;
    exports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
    exports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
    exports.getSource = getSource;
    exports.isCompletionRecord = isCompletionRecord;
    exports.isConstantExpression = isConstantExpression;
    exports.isInStrictMode = isInStrictMode;
    exports.isNodeType = isNodeType;
    exports.isStatementOrBlock = isStatementOrBlock;
    exports.isStatic = isStatic;
    exports.matchesPattern = matchesPattern;
    exports.referencesImport = referencesImport;
    exports.resolve = resolve;
    exports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
    var _t = requireLib$4();
    var STATEMENT_OR_BLOCK_KEYS = _t.STATEMENT_OR_BLOCK_KEYS,
      VISITOR_KEYS = _t.VISITOR_KEYS,
      isBlockStatement = _t.isBlockStatement,
      isExpression = _t.isExpression,
      isIdentifier = _t.isIdentifier,
      isLiteral = _t.isLiteral,
      isStringLiteral = _t.isStringLiteral,
      isType = _t.isType,
      _matchesPattern = _t.matchesPattern;
    function matchesPattern(pattern, allowPartial) {
      return _matchesPattern(this.node, pattern, allowPartial);
    }
    {
      exports.has = function has(key) {
        var _this$node;
        var val = (_this$node = this.node) == null ? void 0 : _this$node[key];
        if (val && Array.isArray(val)) {
          return !!val.length;
        } else {
          return !!val;
        }
      };
    }
    function isStatic() {
      return this.scope.isStatic(this.node);
    }
    {
      exports.is = exports.has;
      exports.isnt = function isnt(key) {
        return !this.has(key);
      };
      exports.equals = function equals(key, value) {
        return this.node[key] === value;
      };
    }
    function isNodeType(type) {
      return isType(this.type, type);
    }
    function canHaveVariableDeclarationOrExpression() {
      return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
    }
    function canSwapBetweenExpressionAndStatement(replacement) {
      if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
        return false;
      }
      if (this.isExpression()) {
        return isBlockStatement(replacement);
      } else if (this.isBlockStatement()) {
        return isExpression(replacement);
      }
      return false;
    }
    function isCompletionRecord(allowInsideFunction) {
      var path = this;
      var first = true;
      do {
        var _path = path,
          type = _path.type,
          container = _path.container;
        if (!first && (path.isFunction() || type === "StaticBlock")) {
          return !!allowInsideFunction;
        }
        first = false;
        if (Array.isArray(container) && path.key !== container.length - 1) {
          return false;
        }
      } while ((path = path.parentPath) && !path.isProgram() && !path.isDoExpression());
      return true;
    }
    function isStatementOrBlock() {
      if (this.parentPath.isLabeledStatement() || isBlockStatement(this.container)) {
        return false;
      } else {
        return STATEMENT_OR_BLOCK_KEYS.includes(this.key);
      }
    }
    function referencesImport(moduleSource, importName) {
      if (!this.isReferencedIdentifier()) {
        if (this.isJSXMemberExpression() && this.node.property.name === importName || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral(this.node.property, {
          value: importName
        }) : this.node.property.name === importName)) {
          var object = this.get("object");
          return object.isReferencedIdentifier() && object.referencesImport(moduleSource, "*");
        }
        return false;
      }
      var binding = this.scope.getBinding(this.node.name);
      if (!binding || binding.kind !== "module") return false;
      var path = binding.path;
      var parent = path.parentPath;
      if (!parent.isImportDeclaration()) return false;
      if (parent.node.source.value === moduleSource) {
        if (!importName) return true;
      } else {
        return false;
      }
      if (path.isImportDefaultSpecifier() && importName === "default") {
        return true;
      }
      if (path.isImportNamespaceSpecifier() && importName === "*") {
        return true;
      }
      if (path.isImportSpecifier() && isIdentifier(path.node.imported, {
        name: importName
      })) {
        return true;
      }
      return false;
    }
    function getSource() {
      var node = this.node;
      if (node.end) {
        var code = this.hub.getCode();
        if (code) return code.slice(node.start, node.end);
      }
      return "";
    }
    function willIMaybeExecuteBefore(target) {
      return this._guessExecutionStatusRelativeTo(target) !== "after";
    }
    function getOuterFunction(path) {
      return path.isProgram() ? path : (path.parentPath.scope.getFunctionParent() || path.parentPath.scope.getProgramParent()).path;
    }
    function isExecutionUncertain(type, key) {
      switch (type) {
        case "LogicalExpression":
          return key === "right";
        case "ConditionalExpression":
        case "IfStatement":
          return key === "consequent" || key === "alternate";
        case "WhileStatement":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForOfStatement":
          return key === "body";
        case "ForStatement":
          return key === "body" || key === "update";
        case "SwitchStatement":
          return key === "cases";
        case "TryStatement":
          return key === "handler";
        case "AssignmentPattern":
          return key === "right";
        case "OptionalMemberExpression":
          return key === "property";
        case "OptionalCallExpression":
          return key === "arguments";
        default:
          return false;
      }
    }
    function isExecutionUncertainInList(paths, maxIndex) {
      for (var i = 0; i < maxIndex; i++) {
        var path = paths[i];
        if (isExecutionUncertain(path.parent.type, path.parentKey)) {
          return true;
        }
      }
      return false;
    }
    var SYMBOL_CHECKING = Symbol();
    function _guessExecutionStatusRelativeTo(target) {
      return _guessExecutionStatusRelativeToCached(this, target, new Map());
    }
    function _guessExecutionStatusRelativeToCached(base, target, cache) {
      var funcParent = {
        "this": getOuterFunction(base),
        target: getOuterFunction(target)
      };
      if (funcParent.target.node !== funcParent["this"].node) {
        return _guessExecutionStatusRelativeToDifferentFunctionsCached(base, funcParent.target, cache);
      }
      var paths = {
        target: target.getAncestry(),
        "this": base.getAncestry()
      };
      if (paths.target.includes(base)) return "after";
      if (paths["this"].includes(target)) return "before";
      var commonPath;
      var commonIndex = {
        target: 0,
        "this": 0
      };
      while (!commonPath && commonIndex["this"] < paths["this"].length) {
        var path = paths["this"][commonIndex["this"]];
        commonIndex.target = paths.target.indexOf(path);
        if (commonIndex.target >= 0) {
          commonPath = path;
        } else {
          commonIndex["this"]++;
        }
      }
      if (!commonPath) {
        throw new Error("Internal Babel error - The two compared nodes" + " don't appear to belong to the same program.");
      }
      if (isExecutionUncertainInList(paths["this"], commonIndex["this"] - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {
        return "unknown";
      }
      var divergence = {
        "this": paths["this"][commonIndex["this"] - 1],
        target: paths.target[commonIndex.target - 1]
      };
      if (divergence.target.listKey && divergence["this"].listKey && divergence.target.container === divergence["this"].container) {
        return divergence.target.key > divergence["this"].key ? "before" : "after";
      }
      var keys = VISITOR_KEYS[commonPath.type];
      var keyPosition = {
        "this": keys.indexOf(divergence["this"].parentKey),
        target: keys.indexOf(divergence.target.parentKey)
      };
      return keyPosition.target > keyPosition["this"] ? "before" : "after";
    }
    function _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache) {
      if (!target.isFunctionDeclaration()) {
        if (_guessExecutionStatusRelativeToCached(base, target, cache) === "before") {
          return "before";
        }
        return "unknown";
      } else if (target.parentPath.isExportDeclaration()) {
        return "unknown";
      }
      var binding = target.scope.getBinding(target.node.id.name);
      if (!binding.references) return "before";
      var referencePaths = binding.referencePaths;
      var allStatus;
      var _iterator = _createForOfIteratorHelper(referencePaths),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var path = _step.value;
          var childOfFunction = !!path.find(function (path) {
            return path.node === target.node;
          });
          if (childOfFunction) continue;
          if (path.key !== "callee" || !path.parentPath.isCallExpression()) {
            return "unknown";
          }
          var status = _guessExecutionStatusRelativeToCached(base, path, cache);
          if (allStatus && allStatus !== status) {
            return "unknown";
          } else {
            allStatus = status;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return allStatus;
    }
    function _guessExecutionStatusRelativeToDifferentFunctionsCached(base, target, cache) {
      var nodeMap = cache.get(base.node);
      var cached;
      if (!nodeMap) {
        cache.set(base.node, nodeMap = new Map());
      } else if (cached = nodeMap.get(target.node)) {
        if (cached === SYMBOL_CHECKING) {
          return "unknown";
        }
        return cached;
      }
      nodeMap.set(target.node, SYMBOL_CHECKING);
      var result = _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache);
      nodeMap.set(target.node, result);
      return result;
    }
    function resolve(dangerous, resolved) {
      return _resolve.call(this, dangerous, resolved) || this;
    }
    function _resolve(dangerous, resolved) {
      var _resolved;
      if ((_resolved = resolved) != null && _resolved.includes(this)) return;
      resolved = resolved || [];
      resolved.push(this);
      if (this.isVariableDeclarator()) {
        if (this.get("id").isIdentifier()) {
          return this.get("init").resolve(dangerous, resolved);
        }
      } else if (this.isReferencedIdentifier()) {
        var binding = this.scope.getBinding(this.node.name);
        if (!binding) return;
        if (!binding.constant) return;
        if (binding.kind === "module") return;
        if (binding.path !== this) {
          var ret = binding.path.resolve(dangerous, resolved);
          if (this.find(function (parent) {
            return parent.node === ret.node;
          })) return;
          return ret;
        }
      } else if (this.isTypeCastExpression()) {
        return this.get("expression").resolve(dangerous, resolved);
      } else if (dangerous && this.isMemberExpression()) {
        var targetKey = this.toComputedKey();
        if (!isLiteral(targetKey)) return;
        var targetName = targetKey.value;
        var target = this.get("object").resolve(dangerous, resolved);
        if (target.isObjectExpression()) {
          var props = target.get("properties");
          var _iterator2 = _createForOfIteratorHelper(props),
            _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var prop = _step2.value;
              if (!prop.isProperty()) continue;
              var key = prop.get("key");
              var match = prop.isnt("computed") && key.isIdentifier({
                name: targetName
              });
              match = match || key.isLiteral({
                value: targetName
              });
              if (match) return prop.get("value").resolve(dangerous, resolved);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        } else if (target.isArrayExpression() && !isNaN(+targetName)) {
          var elems = target.get("elements");
          var elem = elems[targetName];
          if (elem) return elem.resolve(dangerous, resolved);
        }
      }
    }
    function isConstantExpression() {
      if (this.isIdentifier()) {
        var binding = this.scope.getBinding(this.node.name);
        if (!binding) return false;
        return binding.constant;
      }
      if (this.isLiteral()) {
        if (this.isRegExpLiteral()) {
          return false;
        }
        if (this.isTemplateLiteral()) {
          return this.get("expressions").every(function (expression) {
            return expression.isConstantExpression();
          });
        }
        return true;
      }
      if (this.isUnaryExpression()) {
        if (this.node.operator !== "void") {
          return false;
        }
        return this.get("argument").isConstantExpression();
      }
      if (this.isBinaryExpression()) {
        var operator = this.node.operator;
        return operator !== "in" && operator !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
      }
      if (this.isMemberExpression()) {
        return !this.node.computed && this.get("object").isIdentifier({
          name: "Symbol"
        }) && !this.scope.hasBinding("Symbol", {
          noGlobals: true
        });
      }
      if (this.isCallExpression()) {
        return this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding("Symbol", {
          noGlobals: true
        }) && this.get("arguments")[0].isStringLiteral();
      }
      return false;
    }
    function isInStrictMode() {
      var start = this.isProgram() ? this : this.parentPath;
      var strictParent = start.find(function (path) {
        if (path.isProgram({
          sourceType: "module"
        })) return true;
        if (path.isClass()) return true;
        if (path.isArrowFunctionExpression() && !path.get("body").isBlockStatement()) {
          return false;
        }
        var body;
        if (path.isFunction()) {
          body = path.node.body;
        } else if (path.isProgram()) {
          body = path.node;
        } else {
          return false;
        }
        var _iterator3 = _createForOfIteratorHelper(body.directives),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var directive = _step3.value;
            if (directive.value.value === "use strict") {
              return true;
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      });
      return !!strictParent;
    }
  })(introspection);
  return introspection;
}

var family = {};

var hasRequiredFamily;
function requireFamily() {
  if (hasRequiredFamily) return family;
  hasRequiredFamily = 1;
  Object.defineProperty(family, "__esModule", {
    value: true
  });
  family._getKey = _getKey;
  family._getPattern = _getPattern;
  family.get = get;
  family.getAllNextSiblings = getAllNextSiblings;
  family.getAllPrevSiblings = getAllPrevSiblings;
  family.getAssignmentIdentifiers = getAssignmentIdentifiers;
  family.getBindingIdentifierPaths = getBindingIdentifierPaths;
  family.getBindingIdentifiers = getBindingIdentifiers;
  family.getCompletionRecords = getCompletionRecords;
  family.getNextSibling = getNextSibling;
  family.getOpposite = getOpposite;
  family.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;
  family.getOuterBindingIdentifiers = getOuterBindingIdentifiers;
  family.getPrevSibling = getPrevSibling;
  family.getSibling = getSibling;
  var _index = requirePath();
  var _t = requireLib$4();
  var _getAssignmentIdentifiers = _t.getAssignmentIdentifiers,
    _getBindingIdentifiers = _t.getBindingIdentifiers,
    _getOuterBindingIdentifiers = _t.getOuterBindingIdentifiers,
    numericLiteral = _t.numericLiteral,
    unaryExpression = _t.unaryExpression;
  var NORMAL_COMPLETION = 0;
  var BREAK_COMPLETION = 1;
  function NormalCompletion(path) {
    return {
      type: NORMAL_COMPLETION,
      path: path
    };
  }
  function BreakCompletion(path) {
    return {
      type: BREAK_COMPLETION,
      path: path
    };
  }
  function getOpposite() {
    if (this.key === "left") {
      return this.getSibling("right");
    } else if (this.key === "right") {
      return this.getSibling("left");
    }
    return null;
  }
  function addCompletionRecords(path, records, context) {
    if (path) {
      records.push.apply(records, _toConsumableArray(_getCompletionRecords(path, context)));
    }
    return records;
  }
  function completionRecordForSwitch(cases, records, context) {
    var lastNormalCompletions = [];
    for (var i = 0; i < cases.length; i++) {
      var casePath = cases[i];
      var caseCompletions = _getCompletionRecords(casePath, context);
      var normalCompletions = [];
      var breakCompletions = [];
      var _iterator = _createForOfIteratorHelper(caseCompletions),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var c = _step.value;
          if (c.type === NORMAL_COMPLETION) {
            normalCompletions.push(c);
          }
          if (c.type === BREAK_COMPLETION) {
            breakCompletions.push(c);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      if (normalCompletions.length) {
        lastNormalCompletions = normalCompletions;
      }
      records.push.apply(records, breakCompletions);
    }
    records.push.apply(records, _toConsumableArray(lastNormalCompletions));
    return records;
  }
  function normalCompletionToBreak(completions) {
    completions.forEach(function (c) {
      c.type = BREAK_COMPLETION;
    });
  }
  function replaceBreakStatementInBreakCompletion(completions, reachable) {
    completions.forEach(function (c) {
      if (c.path.isBreakStatement({
        label: null
      })) {
        if (reachable) {
          c.path.replaceWith(unaryExpression("void", numericLiteral(0)));
        } else {
          c.path.remove();
        }
      }
    });
  }
  function getStatementListCompletion(paths, context) {
    var completions = [];
    if (context.canHaveBreak) {
      var lastNormalCompletions = [];
      for (var i = 0; i < paths.length; i++) {
        var path = paths[i];
        var newContext = Object.assign({}, context, {
          inCaseClause: false
        });
        if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {
          newContext.shouldPopulateBreak = true;
        } else {
          newContext.shouldPopulateBreak = false;
        }
        var statementCompletions = _getCompletionRecords(path, newContext);
        if (statementCompletions.length > 0 && statementCompletions.every(function (c) {
          return c.type === BREAK_COMPLETION;
        })) {
          if (lastNormalCompletions.length > 0 && statementCompletions.every(function (c) {
            return c.path.isBreakStatement({
              label: null
            });
          })) {
            normalCompletionToBreak(lastNormalCompletions);
            completions.push.apply(completions, _toConsumableArray(lastNormalCompletions));
            if (lastNormalCompletions.some(function (c) {
              return c.path.isDeclaration();
            })) {
              completions.push.apply(completions, _toConsumableArray(statementCompletions));
              replaceBreakStatementInBreakCompletion(statementCompletions, true);
            }
            replaceBreakStatementInBreakCompletion(statementCompletions, false);
          } else {
            completions.push.apply(completions, _toConsumableArray(statementCompletions));
            if (!context.shouldPopulateBreak) {
              replaceBreakStatementInBreakCompletion(statementCompletions, true);
            }
          }
          break;
        }
        if (i === paths.length - 1) {
          completions.push.apply(completions, _toConsumableArray(statementCompletions));
        } else {
          lastNormalCompletions = [];
          for (var _i = 0; _i < statementCompletions.length; _i++) {
            var c = statementCompletions[_i];
            if (c.type === BREAK_COMPLETION) {
              completions.push(c);
            }
            if (c.type === NORMAL_COMPLETION) {
              lastNormalCompletions.push(c);
            }
          }
        }
      }
    } else if (paths.length) {
      for (var _i2 = paths.length - 1; _i2 >= 0; _i2--) {
        var pathCompletions = _getCompletionRecords(paths[_i2], context);
        if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration()) {
          completions.push.apply(completions, _toConsumableArray(pathCompletions));
          break;
        }
      }
    }
    return completions;
  }
  function _getCompletionRecords(path, context) {
    var records = [];
    if (path.isIfStatement()) {
      records = addCompletionRecords(path.get("consequent"), records, context);
      records = addCompletionRecords(path.get("alternate"), records, context);
    } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {
      return addCompletionRecords(path.get("body"), records, context);
    } else if (path.isProgram() || path.isBlockStatement()) {
      return getStatementListCompletion(path.get("body"), context);
    } else if (path.isFunction()) {
      return _getCompletionRecords(path.get("body"), context);
    } else if (path.isTryStatement()) {
      records = addCompletionRecords(path.get("block"), records, context);
      records = addCompletionRecords(path.get("handler"), records, context);
    } else if (path.isCatchClause()) {
      return addCompletionRecords(path.get("body"), records, context);
    } else if (path.isSwitchStatement()) {
      return completionRecordForSwitch(path.get("cases"), records, context);
    } else if (path.isSwitchCase()) {
      return getStatementListCompletion(path.get("consequent"), {
        canHaveBreak: true,
        shouldPopulateBreak: false,
        inCaseClause: true
      });
    } else if (path.isBreakStatement()) {
      records.push(BreakCompletion(path));
    } else {
      records.push(NormalCompletion(path));
    }
    return records;
  }
  function getCompletionRecords() {
    var records = _getCompletionRecords(this, {
      canHaveBreak: false,
      shouldPopulateBreak: false,
      inCaseClause: false
    });
    return records.map(function (r) {
      return r.path;
    });
  }
  function getSibling(key) {
    return _index["default"].get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key: key
    }).setContext(this.context);
  }
  function getPrevSibling() {
    return this.getSibling(this.key - 1);
  }
  function getNextSibling() {
    return this.getSibling(this.key + 1);
  }
  function getAllNextSiblings() {
    var _key = this.key;
    var sibling = this.getSibling(++_key);
    var siblings = [];
    while (sibling.node) {
      siblings.push(sibling);
      sibling = this.getSibling(++_key);
    }
    return siblings;
  }
  function getAllPrevSiblings() {
    var _key = this.key;
    var sibling = this.getSibling(--_key);
    var siblings = [];
    while (sibling.node) {
      siblings.push(sibling);
      sibling = this.getSibling(--_key);
    }
    return siblings;
  }
  function get(key) {
    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    if (context === true) context = this.context;
    var parts = key.split(".");
    if (parts.length === 1) {
      return _getKey.call(this, key, context);
    } else {
      return _getPattern.call(this, parts, context);
    }
  }
  function _getKey(key, context) {
    var _this = this;
    var node = this.node;
    var container = node[key];
    if (Array.isArray(container)) {
      return container.map(function (_, i) {
        return _index["default"].get({
          listKey: key,
          parentPath: _this,
          parent: node,
          container: container,
          key: i
        }).setContext(context);
      });
    } else {
      return _index["default"].get({
        parentPath: this,
        parent: node,
        container: node,
        key: key
      }).setContext(context);
    }
  }
  function _getPattern(parts, context) {
    var path = this;
    var _iterator2 = _createForOfIteratorHelper(parts),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var part = _step2.value;
        if (part === ".") {
          path = path.parentPath;
        } else {
          if (Array.isArray(path)) {
            path = path[part];
          } else {
            path = path.get(part, context);
          }
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return path;
  }
  function getAssignmentIdentifiers() {
    return _getAssignmentIdentifiers(this.node);
  }
  function getBindingIdentifiers(duplicates) {
    return _getBindingIdentifiers(this.node, duplicates);
  }
  function getOuterBindingIdentifiers(duplicates) {
    return _getOuterBindingIdentifiers(this.node, duplicates);
  }
  function getBindingIdentifierPaths() {
    var duplicates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var outerOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var path = this;
    var search = [path];
    var ids = Object.create(null);
    while (search.length) {
      var id = search.shift();
      if (!id) continue;
      if (!id.node) continue;
      var keys = _getBindingIdentifiers.keys[id.node.type];
      if (id.isIdentifier()) {
        if (duplicates) {
          var _ids = ids[id.node.name] = ids[id.node.name] || [];
          _ids.push(id);
        } else {
          ids[id.node.name] = id;
        }
        continue;
      }
      if (id.isExportDeclaration()) {
        var declaration = id.get("declaration");
        if (declaration.isDeclaration()) {
          search.push(declaration);
        }
        continue;
      }
      if (outerOnly) {
        if (id.isFunctionDeclaration()) {
          search.push(id.get("id"));
          continue;
        }
        if (id.isFunctionExpression()) {
          continue;
        }
      }
      if (keys) {
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var child = id.get(key);
          if (Array.isArray(child)) {
            search.push.apply(search, _toConsumableArray(child));
          } else if (child.node) {
            search.push(child);
          }
        }
      }
    }
    return ids;
  }
  function getOuterBindingIdentifierPaths() {
    var duplicates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return this.getBindingIdentifierPaths(duplicates, true);
  }
  return family;
}

var comments = {};

var hasRequiredComments;
function requireComments() {
  if (hasRequiredComments) return comments;
  hasRequiredComments = 1;
  Object.defineProperty(comments, "__esModule", {
    value: true
  });
  comments.addComment = addComment;
  comments.addComments = addComments;
  comments.shareCommentsWithSiblings = shareCommentsWithSiblings;
  var _t = requireLib$4();
  var _addComment = _t.addComment,
    _addComments = _t.addComments;
  function shareCommentsWithSiblings() {
    if (typeof this.key === "string") return;
    var node = this.node;
    if (!node) return;
    var trailing = node.trailingComments;
    var leading = node.leadingComments;
    if (!trailing && !leading) return;
    var prev = this.getSibling(this.key - 1);
    var next = this.getSibling(this.key + 1);
    var hasPrev = Boolean(prev.node);
    var hasNext = Boolean(next.node);
    if (hasPrev) {
      if (leading) {
        prev.addComments("trailing", removeIfExisting(leading, prev.node.trailingComments));
      }
      if (trailing && !hasNext) prev.addComments("trailing", trailing);
    }
    if (hasNext) {
      if (trailing) {
        next.addComments("leading", removeIfExisting(trailing, next.node.leadingComments));
      }
      if (leading && !hasPrev) next.addComments("leading", leading);
    }
  }
  function removeIfExisting(list, toRemove) {
    if (!(toRemove != null && toRemove.length)) return list;
    var set = new Set(toRemove);
    return list.filter(function (el) {
      return !set.has(el);
    });
  }
  function addComment(type, content, line) {
    _addComment(this.node, type, content, line);
  }
  function addComments(type, comments) {
    _addComments(this.node, type, comments);
  }
  return comments;
}

var hasRequiredPath;
function requirePath() {
  if (hasRequiredPath) return path;
  hasRequiredPath = 1;
  Object.defineProperty(path, "__esModule", {
    value: true
  });
  path["default"] = path.SHOULD_STOP = path.SHOULD_SKIP = path.REMOVED = void 0;
  var virtualTypes = requireVirtualTypes();
  var _debug = requireSrc();
  var _index = requireLib();
  var _index2 = requireScope();
  var _t = requireLib$4();
  var t = _t;
  var cache = requireCache();
  var _generator = requireLib$3();
  var NodePath_ancestry = requireAncestry();
  var NodePath_inference = requireInference();
  var NodePath_replacement = requireReplacement();
  var NodePath_evaluation = requireEvaluation();
  var NodePath_conversion = requireConversion();
  var NodePath_introspection = requireIntrospection();
  var _context = requireContext();
  var NodePath_context = _context;
  var NodePath_removal = requireRemoval();
  var NodePath_modification = requireModification();
  var NodePath_family = requireFamily();
  var NodePath_comments = requireComments();
  var NodePath_virtual_types_validator = requireVirtualTypesValidator();
  var validate = _t.validate;
  var _debug2 = _debug("babel");
  path.REMOVED = 1 << 0;
  path.SHOULD_STOP = 1 << 1;
  path.SHOULD_SKIP = 1 << 2;
  var NodePath_Final = path["default"] = /*#__PURE__*/function () {
    function NodePath(hub, parent) {
      _classCallCheck(this, NodePath);
      this.contexts = [];
      this.state = null;
      this.opts = null;
      this._traverseFlags = 0;
      this.skipKeys = null;
      this.parentPath = null;
      this.container = null;
      this.listKey = null;
      this.key = null;
      this.node = null;
      this.type = null;
      this.parent = parent;
      this.hub = hub;
      this.data = null;
      this.context = null;
      this.scope = null;
    }
    return _createClass(NodePath, [{
      key: "removed",
      get: function get() {
        return (this._traverseFlags & 1) > 0;
      },
      set: function set(v) {
        if (v) this._traverseFlags |= 1;else this._traverseFlags &= -2;
      }
    }, {
      key: "shouldStop",
      get: function get() {
        return (this._traverseFlags & 2) > 0;
      },
      set: function set(v) {
        if (v) this._traverseFlags |= 2;else this._traverseFlags &= -3;
      }
    }, {
      key: "shouldSkip",
      get: function get() {
        return (this._traverseFlags & 4) > 0;
      },
      set: function set(v) {
        if (v) this._traverseFlags |= 4;else this._traverseFlags &= -5;
      }
    }, {
      key: "getScope",
      value: function getScope(scope) {
        return this.isScope() ? new _index2["default"](this) : scope;
      }
    }, {
      key: "setData",
      value: function setData(key, val) {
        if (this.data == null) {
          this.data = Object.create(null);
        }
        return this.data[key] = val;
      }
    }, {
      key: "getData",
      value: function getData(key, def) {
        if (this.data == null) {
          this.data = Object.create(null);
        }
        var val = this.data[key];
        if (val === undefined && def !== undefined) val = this.data[key] = def;
        return val;
      }
    }, {
      key: "hasNode",
      value: function hasNode() {
        return this.node != null;
      }
    }, {
      key: "buildCodeFrameError",
      value: function buildCodeFrameError(msg) {
        var Error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SyntaxError;
        return this.hub.buildError(this.node, msg, Error);
      }
    }, {
      key: "traverse",
      value: function traverse(visitor, state) {
        (0, _index["default"])(this.node, visitor, this.scope, state, this);
      }
    }, {
      key: "set",
      value: function set(key, node) {
        validate(this.node, key, node);
        this.node[key] = node;
      }
    }, {
      key: "getPathLocation",
      value: function getPathLocation() {
        var parts = [];
        var path = this;
        do {
          var key = path.key;
          if (path.inList) key = "".concat(path.listKey, "[").concat(key, "]");
          parts.unshift(key);
        } while (path = path.parentPath);
        return parts.join(".");
      }
    }, {
      key: "debug",
      value: function debug(message) {
        if (!_debug2.enabled) return;
        _debug2("".concat(this.getPathLocation(), " ").concat(this.type, ": ").concat(message));
      }
    }, {
      key: "toString",
      value: function toString() {
        return (0, _generator["default"])(this.node).code;
      }
    }, {
      key: "inList",
      get: function get() {
        return !!this.listKey;
      },
      set: function set(inList) {
        if (!inList) {
          this.listKey = null;
        }
      }
    }, {
      key: "parentKey",
      get: function get() {
        return this.listKey || this.key;
      }
    }], [{
      key: "get",
      value: function get(_ref) {
        var hub = _ref.hub,
          parentPath = _ref.parentPath,
          parent = _ref.parent,
          container = _ref.container,
          listKey = _ref.listKey,
          key = _ref.key;
        if (!hub && parentPath) {
          hub = parentPath.hub;
        }
        if (!parent) {
          throw new Error("To get a node path the parent needs to exist");
        }
        var targetNode = container[key];
        var paths = cache.getOrCreateCachedPaths(hub, parent);
        var path = paths.get(targetNode);
        if (!path) {
          path = new NodePath(hub, parent);
          if (targetNode) paths.set(targetNode, path);
        }
        _context.setup.call(path, parentPath, container, listKey, key);
        return path;
      }
    }]);
  }();
  var methods = {
    findParent: NodePath_ancestry.findParent,
    find: NodePath_ancestry.find,
    getFunctionParent: NodePath_ancestry.getFunctionParent,
    getStatementParent: NodePath_ancestry.getStatementParent,
    getEarliestCommonAncestorFrom: NodePath_ancestry.getEarliestCommonAncestorFrom,
    getDeepestCommonAncestorFrom: NodePath_ancestry.getDeepestCommonAncestorFrom,
    getAncestry: NodePath_ancestry.getAncestry,
    isAncestor: NodePath_ancestry.isAncestor,
    isDescendant: NodePath_ancestry.isDescendant,
    inType: NodePath_ancestry.inType,
    getTypeAnnotation: NodePath_inference.getTypeAnnotation,
    isBaseType: NodePath_inference.isBaseType,
    couldBeBaseType: NodePath_inference.couldBeBaseType,
    baseTypeStrictlyMatches: NodePath_inference.baseTypeStrictlyMatches,
    isGenericType: NodePath_inference.isGenericType,
    replaceWithMultiple: NodePath_replacement.replaceWithMultiple,
    replaceWithSourceString: NodePath_replacement.replaceWithSourceString,
    replaceWith: NodePath_replacement.replaceWith,
    replaceExpressionWithStatements: NodePath_replacement.replaceExpressionWithStatements,
    replaceInline: NodePath_replacement.replaceInline,
    evaluateTruthy: NodePath_evaluation.evaluateTruthy,
    evaluate: NodePath_evaluation.evaluate,
    toComputedKey: NodePath_conversion.toComputedKey,
    ensureBlock: NodePath_conversion.ensureBlock,
    unwrapFunctionEnvironment: NodePath_conversion.unwrapFunctionEnvironment,
    arrowFunctionToExpression: NodePath_conversion.arrowFunctionToExpression,
    splitExportDeclaration: NodePath_conversion.splitExportDeclaration,
    ensureFunctionName: NodePath_conversion.ensureFunctionName,
    matchesPattern: NodePath_introspection.matchesPattern,
    isStatic: NodePath_introspection.isStatic,
    isNodeType: NodePath_introspection.isNodeType,
    canHaveVariableDeclarationOrExpression: NodePath_introspection.canHaveVariableDeclarationOrExpression,
    canSwapBetweenExpressionAndStatement: NodePath_introspection.canSwapBetweenExpressionAndStatement,
    isCompletionRecord: NodePath_introspection.isCompletionRecord,
    isStatementOrBlock: NodePath_introspection.isStatementOrBlock,
    referencesImport: NodePath_introspection.referencesImport,
    getSource: NodePath_introspection.getSource,
    willIMaybeExecuteBefore: NodePath_introspection.willIMaybeExecuteBefore,
    _guessExecutionStatusRelativeTo: NodePath_introspection._guessExecutionStatusRelativeTo,
    resolve: NodePath_introspection.resolve,
    isConstantExpression: NodePath_introspection.isConstantExpression,
    isInStrictMode: NodePath_introspection.isInStrictMode,
    isDenylisted: NodePath_context.isDenylisted,
    visit: NodePath_context.visit,
    skip: NodePath_context.skip,
    skipKey: NodePath_context.skipKey,
    stop: NodePath_context.stop,
    setContext: NodePath_context.setContext,
    requeue: NodePath_context.requeue,
    requeueComputedKeyAndDecorators: NodePath_context.requeueComputedKeyAndDecorators,
    remove: NodePath_removal.remove,
    insertBefore: NodePath_modification.insertBefore,
    insertAfter: NodePath_modification.insertAfter,
    unshiftContainer: NodePath_modification.unshiftContainer,
    pushContainer: NodePath_modification.pushContainer,
    getOpposite: NodePath_family.getOpposite,
    getCompletionRecords: NodePath_family.getCompletionRecords,
    getSibling: NodePath_family.getSibling,
    getPrevSibling: NodePath_family.getPrevSibling,
    getNextSibling: NodePath_family.getNextSibling,
    getAllNextSiblings: NodePath_family.getAllNextSiblings,
    getAllPrevSiblings: NodePath_family.getAllPrevSiblings,
    get: NodePath_family.get,
    getAssignmentIdentifiers: NodePath_family.getAssignmentIdentifiers,
    getBindingIdentifiers: NodePath_family.getBindingIdentifiers,
    getOuterBindingIdentifiers: NodePath_family.getOuterBindingIdentifiers,
    getBindingIdentifierPaths: NodePath_family.getBindingIdentifierPaths,
    getOuterBindingIdentifierPaths: NodePath_family.getOuterBindingIdentifierPaths,
    shareCommentsWithSiblings: NodePath_comments.shareCommentsWithSiblings,
    addComment: NodePath_comments.addComment,
    addComments: NodePath_comments.addComments
  };
  Object.assign(NodePath_Final.prototype, methods);
  {
    NodePath_Final.prototype.arrowFunctionToShadowed = NodePath_conversion[String("arrowFunctionToShadowed")];
    Object.assign(NodePath_Final.prototype, {
      has: NodePath_introspection[String("has")],
      is: NodePath_introspection[String("is")],
      isnt: NodePath_introspection[String("isnt")],
      equals: NodePath_introspection[String("equals")],
      hoist: NodePath_modification[String("hoist")],
      updateSiblingKeys: NodePath_modification.updateSiblingKeys,
      call: NodePath_context.call,
      isBlacklisted: NodePath_context[String("isBlacklisted")],
      setScope: NodePath_context.setScope,
      resync: NodePath_context.resync,
      popContext: NodePath_context.popContext,
      pushContext: NodePath_context.pushContext,
      setup: NodePath_context.setup,
      setKey: NodePath_context.setKey
    });
  }
  {
    NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;
    NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;
    Object.assign(NodePath_Final.prototype, {
      _getTypeAnnotation: NodePath_inference._getTypeAnnotation,
      _replaceWith: NodePath_replacement._replaceWith,
      _resolve: NodePath_introspection._resolve,
      _call: NodePath_context._call,
      _resyncParent: NodePath_context._resyncParent,
      _resyncKey: NodePath_context._resyncKey,
      _resyncList: NodePath_context._resyncList,
      _resyncRemoved: NodePath_context._resyncRemoved,
      _getQueueContexts: NodePath_context._getQueueContexts,
      _removeFromScope: NodePath_removal._removeFromScope,
      _callRemovalHooks: NodePath_removal._callRemovalHooks,
      _remove: NodePath_removal._remove,
      _markRemoved: NodePath_removal._markRemoved,
      _assertUnremoved: NodePath_removal._assertUnremoved,
      _containerInsert: NodePath_modification._containerInsert,
      _containerInsertBefore: NodePath_modification._containerInsertBefore,
      _containerInsertAfter: NodePath_modification._containerInsertAfter,
      _verifyNodeList: NodePath_modification._verifyNodeList,
      _getKey: NodePath_family._getKey,
      _getPattern: NodePath_family._getPattern
    });
  }
  var _iterator = _createForOfIteratorHelper(t.TYPES),
    _step;
  try {
    var _loop = function _loop() {
      var type = _step.value;
      var typeKey = "is".concat(type);
      var fn = t[typeKey];
      NodePath_Final.prototype[typeKey] = function (opts) {
        return fn(this.node, opts);
      };
      NodePath_Final.prototype["assert".concat(type)] = function (opts) {
        if (!fn(this.node, opts)) {
          throw new TypeError("Expected node path of type ".concat(type));
        }
      };
    };
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  Object.assign(NodePath_Final.prototype, NodePath_virtual_types_validator);
  for (var _i = 0, _Object$keys = Object.keys(virtualTypes); _i < _Object$keys.length; _i++) {
    var type = _Object$keys[_i];
    if (type[0] === "_") continue;
    if (!t.TYPES.includes(type)) t.TYPES.push(type);
  }
  return path;
}

var hasRequiredContext$1;
function requireContext$1() {
  if (hasRequiredContext$1) return context;
  hasRequiredContext$1 = 1;
  Object.defineProperty(context, "__esModule", {
    value: true
  });
  context["default"] = void 0;
  var _index = requirePath();
  var _t = requireLib$4();
  var _context = requireContext();
  var VISITOR_KEYS = _t.VISITOR_KEYS;
  var TraversalContext = /*#__PURE__*/function () {
    function TraversalContext(scope, opts, state, parentPath) {
      _classCallCheck(this, TraversalContext);
      this.queue = null;
      this.priorityQueue = null;
      this.parentPath = parentPath;
      this.scope = scope;
      this.state = state;
      this.opts = opts;
    }
    return _createClass(TraversalContext, [{
      key: "shouldVisit",
      value: function shouldVisit(node) {
        var opts = this.opts;
        if (opts.enter || opts.exit) return true;
        if (opts[node.type]) return true;
        var keys = VISITOR_KEYS[node.type];
        if (!(keys != null && keys.length)) return false;
        var _iterator = _createForOfIteratorHelper(keys),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var key = _step.value;
            if (node[key]) {
              return true;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return false;
      }
    }, {
      key: "create",
      value: function create(node, container, key, listKey) {
        return _index["default"].get({
          parentPath: this.parentPath,
          parent: node,
          container: container,
          key: key,
          listKey: listKey
        });
      }
    }, {
      key: "maybeQueue",
      value: function maybeQueue(path, notPriority) {
        if (this.queue) {
          if (notPriority) {
            this.queue.push(path);
          } else {
            this.priorityQueue.push(path);
          }
        }
      }
    }, {
      key: "visitMultiple",
      value: function visitMultiple(container, parent, listKey) {
        if (container.length === 0) return false;
        var queue = [];
        for (var key = 0; key < container.length; key++) {
          var node = container[key];
          if (node && this.shouldVisit(node)) {
            queue.push(this.create(parent, container, key, listKey));
          }
        }
        return this.visitQueue(queue);
      }
    }, {
      key: "visitSingle",
      value: function visitSingle(node, key) {
        if (this.shouldVisit(node[key])) {
          return this.visitQueue([this.create(node, node, key)]);
        } else {
          return false;
        }
      }
    }, {
      key: "visitQueue",
      value: function visitQueue(queue) {
        this.queue = queue;
        this.priorityQueue = [];
        var visited = new WeakSet();
        var stop = false;
        var visitIndex = 0;
        for (; visitIndex < queue.length;) {
          var path = queue[visitIndex];
          visitIndex++;
          _context.resync.call(path);
          if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {
            _context.pushContext.call(path, this);
          }
          if (path.key === null) continue;
          var node = path.node;
          if (visited.has(node)) continue;
          if (node) visited.add(node);
          if (path.visit()) {
            stop = true;
            break;
          }
          if (this.priorityQueue.length) {
            stop = this.visitQueue(this.priorityQueue);
            this.priorityQueue = [];
            this.queue = queue;
            if (stop) break;
          }
        }
        for (var i = 0; i < visitIndex; i++) {
          _context.popContext.call(queue[i]);
        }
        this.queue = null;
        return stop;
      }
    }, {
      key: "visit",
      value: function visit(node, key) {
        var nodes = node[key];
        if (!nodes) return false;
        if (Array.isArray(nodes)) {
          return this.visitMultiple(nodes, node, key);
        } else {
          return this.visitSingle(node, key);
        }
      }
    }]);
  }();
  context["default"] = TraversalContext;
  return context;
}

var hasRequiredTraverseNode;
function requireTraverseNode() {
  if (hasRequiredTraverseNode) return traverseNode;
  hasRequiredTraverseNode = 1;
  Object.defineProperty(traverseNode, "__esModule", {
    value: true
  });
  traverseNode.traverseNode = traverseNode$1;
  var _context = requireContext$1();
  var _t = requireLib$4();
  var VISITOR_KEYS = _t.VISITOR_KEYS;
  function traverseNode$1(node, opts, scope, state, path, skipKeys, visitSelf) {
    var keys = VISITOR_KEYS[node.type];
    if (!keys) return false;
    var context = new _context["default"](scope, opts, state, path);
    if (visitSelf) {
      if (skipKeys != null && skipKeys[path.parentKey]) return false;
      return context.visitQueue([path]);
    }
    var _iterator = _createForOfIteratorHelper(keys),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var key = _step.value;
        if (skipKeys != null && skipKeys[key]) continue;
        if (context.visit(node, key)) {
          return true;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return false;
  }
  return traverseNode;
}

var hasRequiredContext;
function requireContext() {
  if (hasRequiredContext) return context$1;
  hasRequiredContext = 1;
  Object.defineProperty(context$1, "__esModule", {
    value: true
  });
  context$1._call = _call;
  context$1._getQueueContexts = _getQueueContexts;
  context$1._resyncKey = _resyncKey;
  context$1._resyncList = _resyncList;
  context$1._resyncParent = _resyncParent;
  context$1._resyncRemoved = _resyncRemoved;
  context$1.call = call;
  context$1.isDenylisted = isDenylisted;
  context$1.popContext = popContext;
  context$1.pushContext = pushContext;
  context$1.requeue = requeue;
  context$1.requeueComputedKeyAndDecorators = requeueComputedKeyAndDecorators;
  context$1.resync = resync;
  context$1.setContext = setContext;
  context$1.setKey = setKey;
  context$1.setScope = setScope;
  context$1.setup = setup;
  context$1.skip = skip;
  context$1.skipKey = skipKey;
  context$1.stop = stop;
  context$1.visit = visit;
  var _traverseNode = requireTraverseNode();
  var _index = requirePath();
  var _removal = requireRemoval();
  var t = requireLib$4();
  function call(key) {
    var opts = this.opts;
    this.debug(key);
    if (this.node) {
      if (_call.call(this, opts[key])) return true;
    }
    if (this.node) {
      var _opts$this$node$type;
      return _call.call(this, (_opts$this$node$type = opts[this.node.type]) == null ? void 0 : _opts$this$node$type[key]);
    }
    return false;
  }
  function _call(fns) {
    if (!fns) return false;
    var _iterator = _createForOfIteratorHelper(fns),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var fn = _step.value;
        if (!fn) continue;
        var node = this.node;
        if (!node) return true;
        var ret = fn.call(this.state, this, this.state);
        if (ret && _typeof(ret) === "object" && typeof ret.then === "function") {
          throw new Error("You appear to be using a plugin with an async traversal visitor, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");
        }
        if (ret) {
          throw new Error("Unexpected return value from visitor method ".concat(fn));
        }
        if (this.node !== node) return true;
        if (this._traverseFlags > 0) return true;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return false;
  }
  function isDenylisted() {
    var _this$opts$denylist;
    var denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;
    return denylist == null ? void 0 : denylist.includes(this.node.type);
  }
  {
    context$1.isBlacklisted = isDenylisted;
  }
  function restoreContext(path, context) {
    if (path.context !== context) {
      path.context = context;
      path.state = context.state;
      path.opts = context.opts;
    }
  }
  function visit() {
    var _this$opts$shouldSkip, _this$opts;
    if (!this.node) {
      return false;
    }
    if (this.isDenylisted()) {
      return false;
    }
    if ((_this$opts$shouldSkip = (_this$opts = this.opts).shouldSkip) != null && _this$opts$shouldSkip.call(_this$opts, this)) {
      return false;
    }
    var currentContext = this.context;
    if (this.shouldSkip || call.call(this, "enter")) {
      this.debug("Skip...");
      return this.shouldStop;
    }
    restoreContext(this, currentContext);
    this.debug("Recursing into...");
    this.shouldStop = (0, _traverseNode.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys);
    restoreContext(this, currentContext);
    call.call(this, "exit");
    return this.shouldStop;
  }
  function skip() {
    this.shouldSkip = true;
  }
  function skipKey(key) {
    if (this.skipKeys == null) {
      this.skipKeys = {};
    }
    this.skipKeys[key] = true;
  }
  function stop() {
    this._traverseFlags |= _index.SHOULD_SKIP | _index.SHOULD_STOP;
  }
  function setScope() {
    var _this$opts2, _this$scope;
    if ((_this$opts2 = this.opts) != null && _this$opts2.noScope) return;
    var path = this.parentPath;
    if ((this.key === "key" || this.listKey === "decorators") && path.isMethod() || this.key === "discriminant" && path.isSwitchStatement()) {
      path = path.parentPath;
    }
    var target;
    while (path && !target) {
      var _path$opts;
      if ((_path$opts = path.opts) != null && _path$opts.noScope) return;
      target = path.scope;
      path = path.parentPath;
    }
    this.scope = this.getScope(target);
    (_this$scope = this.scope) == null || _this$scope.init();
  }
  function setContext(context) {
    if (this.skipKeys != null) {
      this.skipKeys = {};
    }
    this._traverseFlags = 0;
    if (context) {
      this.context = context;
      this.state = context.state;
      this.opts = context.opts;
    }
    setScope.call(this);
    return this;
  }
  function resync() {
    if (this.removed) return;
    _resyncParent.call(this);
    _resyncList.call(this);
    _resyncKey.call(this);
  }
  function _resyncParent() {
    if (this.parentPath) {
      this.parent = this.parentPath.node;
    }
  }
  function _resyncKey() {
    if (!this.container) return;
    if (this.node === this.container[this.key]) {
      return;
    }
    if (Array.isArray(this.container)) {
      for (var i = 0; i < this.container.length; i++) {
        if (this.container[i] === this.node) {
          setKey.call(this, i);
          return;
        }
      }
    } else {
      for (var _i = 0, _Object$keys = Object.keys(this.container); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        if (this.container[key] === this.node) {
          setKey.call(this, key);
          return;
        }
      }
    }
    this.key = null;
  }
  function _resyncList() {
    if (!this.parent || !this.inList) return;
    var newContainer = this.parent[this.listKey];
    if (this.container === newContainer) return;
    this.container = newContainer || null;
  }
  function _resyncRemoved() {
    if (this.key == null || !this.container || this.container[this.key] !== this.node) {
      _removal._markRemoved.call(this);
    }
  }
  function popContext() {
    this.contexts.pop();
    if (this.contexts.length > 0) {
      this.setContext(this.contexts[this.contexts.length - 1]);
    } else {
      this.setContext(undefined);
    }
  }
  function pushContext(context) {
    this.contexts.push(context);
    this.setContext(context);
  }
  function setup(parentPath, container, listKey, key) {
    this.listKey = listKey;
    this.container = container;
    this.parentPath = parentPath || this.parentPath;
    setKey.call(this, key);
  }
  function setKey(key) {
    var _this$node;
    this.key = key;
    this.node = this.container[this.key];
    this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;
  }
  function requeue() {
    var pathToQueue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;
    if (pathToQueue.removed) return;
    var contexts = this.contexts;
    var _iterator2 = _createForOfIteratorHelper(contexts),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _context = _step2.value;
        _context.maybeQueue(pathToQueue);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  function requeueComputedKeyAndDecorators() {
    var context = this.context,
      node = this.node;
    if (!t.isPrivate(node) && node.computed) {
      context.maybeQueue(this.get("key"));
    }
    if (node.decorators) {
      var _iterator3 = _createForOfIteratorHelper(this.get("decorators")),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var decorator = _step3.value;
          context.maybeQueue(decorator);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  }
  function _getQueueContexts() {
    var path = this;
    var contexts = this.contexts;
    while (!contexts.length) {
      path = path.parentPath;
      if (!path) break;
      contexts = path.contexts;
    }
    return contexts;
  }
  return context$1;
}

var hub = {};

var hasRequiredHub;
function requireHub() {
  if (hasRequiredHub) return hub;
  hasRequiredHub = 1;
  Object.defineProperty(hub, "__esModule", {
    value: true
  });
  hub["default"] = void 0;
  var Hub = /*#__PURE__*/function () {
    function Hub() {
      _classCallCheck(this, Hub);
    }
    return _createClass(Hub, [{
      key: "getCode",
      value: function getCode() {}
    }, {
      key: "getScope",
      value: function getScope() {}
    }, {
      key: "addHelper",
      value: function addHelper() {
        throw new Error("Helpers are not supported by the default hub.");
      }
    }, {
      key: "buildError",
      value: function buildError(node, msg) {
        var Error = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TypeError;
        return new Error(msg);
      }
    }]);
  }();
  hub["default"] = Hub;
  return hub;
}

var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib$6;
  hasRequiredLib = 1;
  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "Hub", {
      enumerable: true,
      get: function get() {
        return _hub["default"];
      }
    });
    Object.defineProperty(exports, "NodePath", {
      enumerable: true,
      get: function get() {
        return _index["default"];
      }
    });
    Object.defineProperty(exports, "Scope", {
      enumerable: true,
      get: function get() {
        return _index2["default"];
      }
    });
    exports.visitors = exports["default"] = void 0;
    requireContext();
    var visitors = requireVisitors();
    exports.visitors = visitors;
    var _t = requireLib$4();
    var cache = requireCache();
    var _traverseNode = requireTraverseNode();
    var _index = requirePath();
    var _index2 = requireScope();
    var _hub = requireHub();
    var VISITOR_KEYS = _t.VISITOR_KEYS,
      removeProperties = _t.removeProperties,
      traverseFast = _t.traverseFast;
    function traverse(parent) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var scope = arguments.length > 2 ? arguments[2] : undefined;
      var state = arguments.length > 3 ? arguments[3] : undefined;
      var parentPath = arguments.length > 4 ? arguments[4] : undefined;
      var visitSelf = arguments.length > 5 ? arguments[5] : undefined;
      if (!parent) return;
      if (!opts.noScope && !scope) {
        if (parent.type !== "Program" && parent.type !== "File") {
          throw new Error("You must pass a scope and parentPath unless traversing a Program/File. " + "Instead of that you tried to traverse a ".concat(parent.type, " node without ") + "passing scope and parentPath.");
        }
      }
      if (!parentPath && visitSelf) {
        throw new Error("visitSelf can only be used when providing a NodePath.");
      }
      if (!VISITOR_KEYS[parent.type]) {
        return;
      }
      visitors.explode(opts);
      (0, _traverseNode.traverseNode)(parent, opts, scope, state, parentPath, null, visitSelf);
    }
    exports["default"] = traverse;
    traverse.visitors = visitors;
    traverse.verify = visitors.verify;
    traverse.explode = visitors.explode;
    traverse.cheap = function (node, enter) {
      traverseFast(node, enter);
      return;
    };
    traverse.node = function (node, opts, scope, state, path, skipKeys) {
      (0, _traverseNode.traverseNode)(node, opts, scope, state, path, skipKeys);
    };
    traverse.clearNode = function (node, opts) {
      removeProperties(node, opts);
    };
    traverse.removeProperties = function (tree, opts) {
      traverseFast(tree, traverse.clearNode, opts);
      return tree;
    };
    function hasDenylistedType(path, state) {
      if (path.node.type === state.type) {
        state.has = true;
        path.stop();
      }
    }
    traverse.hasType = function (tree, type, denylistTypes) {
      if (denylistTypes != null && denylistTypes.includes(tree.type)) return false;
      if (tree.type === type) return true;
      var state = {
        has: false,
        type: type
      };
      traverse(tree, {
        noScope: true,
        denylist: denylistTypes,
        enter: hasDenylistedType
      }, null, state);
      return state.has;
    };
    traverse.cache = cache;
  })(lib$6);
  return lib$6;
}

var libExports$2 = requireLib();
var traverse = /*@__PURE__*/getDefaultExportFromCjs(libExports$2);

var libExports$1 = requireLib$3();
var generate = /*@__PURE__*/getDefaultExportFromCjs(libExports$1);

var libExports = requireLib$4();

var _isconstant = function isconstant(expression) {
  if (libExports.isStringLiteral(expression) || libExports.isNumericLiteral(expression) || libExports.isBooleanLiteral(expression) || libExports.isNullLiteral(expression)) {
    return true;
  }
  if (libExports.isObjectExpression(expression)) {
    return expression.properties.every(function (prop) {
      if (libExports.isObjectProperty(prop)) {
        return libExports.isAssignmentPattern(prop.value) ? false : libExports.isExpression(prop.value) || libExports.isSpreadElement(prop.value) ? _isconstant(prop.value) : false;
      }
      if (libExports.isSpreadElement(prop)) {
        return _isconstant(prop.argument);
      }
      return false;
    });
  }
  if (libExports.isArrayExpression(expression)) {
    return expression.elements.every(function (elem) {
      return _isconstant(elem);
    });
  }
  return false;
};
var lazify = function lazify(expression) {
  return libExports.arrowFunctionExpression([], expression);
};
var lazifyifnotconstant = function lazifyifnotconstant(e) {
  return _isconstant(e) ? e : lazify(e);
};
function _transform(code, filename) {
  var ast = libExports$3.parse(code, {
    sourceType: "module",
    sourceFilename: filename
  });
  traverse(ast, {
    CallExpression: function CallExpression(path) {
      if (path.node.callee.name != "jsx") return;
      var args = path.node.arguments;
      if (libExports.isIdentifier(args[0]) && args[0].name == "jsxf") {
        console.log("fragmento");
        var cn = libExports.arrayExpression(args.slice(2));
        path.replaceWith(libExports.objectExpression([libExports.objectProperty(libExports.identifier("cn"), lazifyifnotconstant(cn))]));
      } else {
        var tag = args[0];
        if (libExports.isStringLiteral(tag)) tag.value = tag.value.toUpperCase();
        var tagProperty = libExports.objectProperty(libExports.identifier("tag"), tag);
        var propsProperty;
        var props = args[1];
        var nopros = libExports.isNullLiteral(props);
        if (props && !nopros) {
          props = lazifyifnotconstant(props);
          propsProperty = libExports.objectProperty(libExports.identifier("p"), props);
        }
        var childrenProperty;
        var cna = args.slice(2);
        if (cna.length) {
          var _cn = libExports.arrayExpression(cna);
          childrenProperty = libExports.objectProperty(libExports.identifier("cn"), lazifyifnotconstant(_cn));
        }
        path.replaceWith(libExports.objectExpression([tagProperty, propsProperty, childrenProperty].filter(function (x) {
          return !!x;
        })));
      }
    }
  });
  return generate(ast, {
    sourceMaps: true
  }, code);
}
var vitePluginJmx = (function (options) {
  console.log("create vite jmx plugin", JSON.stringify(options));
  return {
    name: "vite-plugin-jmx",
    transform: function transform(raw, filename) {
      if (filename.endsWith(".tsx")) {
        var r = _transform(raw, filename);
        if (options !== null && options !== void 0 && options.debug) {
          fs.writeFileSync(filename + ".orig.ts", "" + raw);
          fs.writeFileSync(filename + ".result.tsx", "" + r.code);
        }
        return r;
      } else return null;
    }
  };
});

export { vitePluginJmx as default };
//# sourceMappingURL=vite-plugin-jmx.js.map
